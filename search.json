[{"title":"2026了。","url":"/posts/56022/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n心里想了很多，打了又删，有些还表达不出来，果然小时候应该少抄些作文啊，也或许是太久没有表达过自己了吧。\n\n2025呢，平淡乏味，没有那么多高光，是体验说不上好的一年。\n\n有个人为自己打造了一个笼，他早在2025年以前就开始动工了，那时笼还没有那么坚固可靠，他还能从从容容，游刃有余，一切都还在他的掌控之中。\n\n有一年，他忽然发现自己的笼已经建的坚固精密了，出不去了。于是他在笼里探索，寻求出去的方法，这期间有成长的喜悦，但更多的是因为笼的坚固无法打破的沮丧和绝望。尽管有时悲观，有时怀疑，有时放弃，但他终究是没有丢失打破笼的信心。他还年轻，最不缺的就是时间，今年他彻彻底底地败了，那明年呢？他相信他终将打破这个坚固的笼。他会一直一直地敲打这个笼，直到力竭，直到血流。\n\n他也明白，打破这个笼，还有个更大的笼罩着他。这些笼有些还是他自己造的，有些不是。“这又怎么样呢，至少我得到了更广阔的空间。”他想。\n\n笼中鸟，何时飞。\n","categories":["其他"]},{"title":"Linux异步通知","url":"/posts/50845/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\nLinux 异步通知机制（Asynchronous Notification）是 Linux 设备驱动中一个非常经典且实用的概念。\n\n简单来说，它的核心思想是 **“被动接收，而非主动查询”**。\n\n## 1. 什么是异步通知机制\n\n想象一下你在钓鱼，这时候你有两种方式知道鱼上钩了：\n\n1. **轮询（Polling）**：你每隔 5 秒钟拉起鱼竿看一看有没有鱼。这很累，而且如果你在看书，看书会被不断打断。\n\n2. **异步通知（Asynchronous）**：你在鱼竿上挂个铃铛，然后你就安心看书。当鱼上钩拉动鱼竿时，铃铛响了（**信号**），你再放下书去收杆。\n\n在 Linux 中，异步通知机制是基于 **信号（Signal）** 实现的。\n\n- **非阻塞 I/O**：应用程序需要不断循环读取（轮询），浪费 CPU。\n\n- **异步通知**：应用程序告诉内核驱动：“如果有数据了，发个信号（通常是 `SIGIO`）告诉我。” 驱动程序在数据就绪时，主动向应用程序发送信号，应用程序暂停当前工作，进入信号处理函数处理数据。\n\n## 2. 异步通知的优缺点\n\n### 2.1. 优点\n\n- **节省 CPU 资源**：应用程序不需要死循环轮询（Polling），CPU 可以处理其他任务或进入休眠。\n- **响应及时**：数据一来，驱动立马发信号，比轮询的时间片机制反应更快。\n- **逻辑解耦**：应用程序可以专心做主逻辑，只有在 I/O 事件发生时才被打断。\n### 2.2. 缺点\n\n- **编程复杂度增加**：需要处理信号并发、重入等问题。\n- **不适合高频数据**：如果数据来得太快（比如网络包狂轰滥炸），不断触发信号中断会让 CPU 把时间都花在上下文切换上（类似“中断风暴”），此时轮询反而更高效。\n\n## 3. 理解异步通知机制\n\n我们从用户态开始入手，看在使用异步通知时，内核里实际发生了什么。\n首先我们需要了解三个核心API：\n\n### 3.1. `fcntl()`\n\n它定义在 `<linux/fcntl.h>`。是**用户态**用来“控制已打开文件描述符行为”的系统调用。\n它**不负责读写数据**，而是用来：\n- 改文件描述符的**状态**\n- 设置 **进程 / 信号 / 锁** 等属性\n\n函数原型：\n```c\n#include <fcntl.h>\n\nint fcntl(int fd, int cmd, ... /* arg */);\n\n```\n\n- `fd`：已经打开的文件描述符\n- `cmd`：你要干什么\n- `arg`：参数（根据 cmd 不同）\n\nfcntl主要是操作 `struct file` 这个结构体，如下：\n```\n用户态 fcntl()\n   ↓\nsys_fcntl()\n   ↓\nVFS\n   ↓\nstruct file\n ├─ f_flags   ← O_NONBLOCK / O_ASYNC\n ├─ f_owner   ← SIGIO 接收者\n └─ f_op\n```\n\n四大类用法：\n\n***1. F_GETFL / F_SETFL***\n\n🟢作用：读取 / 修改 `file->f_flags`\n\n🟢常见标志位：\n\n|标志|作用|\n|---|---|\n|`O_NONBLOCK`|非阻塞 I/O|\n|`O_ASYNC`|启用异步通知（SIGIO）|\n|`O_APPEND`|追加写|\n|`O_DIRECT`|直接 I/O|\n\n🟢用法：\n```c\nint flags = fcntl(fd, F_GETFL);\nfcntl(fd, F_SETFL, flags | O_NONBLOCK | O_ASYNC);\n```\n\n>**不能直接 F_SETFL 一个新值**，否则你会把原有 flags 覆盖掉。\n\n***2. F_SETOWN / F_GETOWN***\n👉 **异步通知必须用**\n\n🟢作用：指定信号发给谁 修改 `file->f_owner.pid = pid`\n\n🟢用法：\n```c\nfcntl(fd, F_SETOWN, getpid());\n```\n\n ***3. F_DUPFD / F_DUPFD_CLOEXEC***\n\n🟢作用：复制文件描述符\n\n🟢用法：\n```c\nint newfd = fcntl(fd, F_DUPFD, 0);\n```\n\n***4. 文件锁***\n\n用于防止多个进程同时操作资源。现在不深入。\n\n### 3.2. `fasync_helper()`\n\n这是在驱动层使用的。`fasync_helper()` 用来维护“需要被异步通知的进程列表”。\n它做的事只有一个核心目标——\n**哪个进程打开了设备并设置了 O_ASYNC，就把那个进程记下来。**\n\n函数原型：\n```c\nint fasync_helper(int fd,\n                  struct file *file,\n                  int on,\n                  struct fasync_struct **fapp);\n\n```\n\n- `fd`：\n\t- 用户态传进来的文件描述符\n\t- **只是标识用途**\n\t- 内核真正关心的是 `file`\n\t可以把它当附带信息\n\n- `file`：\n\t- 对应用户态 `open()` 返回的 fd\n\t- 即fcntl操作的 `struct file`\n\t\t- `f_owner`（信号接收者）\n\t\t- `f_flags`（是否 O_ASYNC）\n\t异步通知最终是基于 file 的\n\n- `on`：\n\t- `on != 0` 启用异步（加入队列）\n\t- `on == 0` 关闭异步（移除队列）\n\n- `fapp`：\n\t需要被异步通知的进程链表的链表头。\n\n函数逻辑伪代码：\n```\nif (on) {\n    // 开启异步\n    if (file 不在 fapp 链表中) {\n        分配 fasync_struct\n        设置 file / f_owner\n        插入 fapp 链表\n    }\n} else {\n    // 关闭异步\n    if (file 在 fapp 链表中) {\n        从链表删除\n        释放 fasync_struct\n    }\n}\n\n```\n\n### 3.3. `kill_fasync()`\n\n在驱动层使用。向应用程序发出信号的核心函数。\n\n原型：\n```c\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n```\n\n- `fp`：要操作的 fasync_struct。\n- `sig`：要发送的信号。\n- `band`：可读时设置为 POLL_IN，可写时设置为 POLL_OUT。\n\n### 3.4. 工作流程\n\n1. 在用户态打开设备：\n```c\nint fd = open(\"/dev/key\", O_RDWR);\n```\n\n此步在 VFS 中创建 `struct file`，没启用异步。\n\n2. 用户态登记进程PID：\n```c\nfcntl(fd, F_SETOWN, getpid());\n```\n\n内核找到 `struct file`，把 `file->f_owner.pid` 设置为当前进程 PID，以后这个 file 触发信号，就发给这个进程。\n\n3. 用户态请求开启异步通知：\n```c\nint flags = fcntl(fd, F_GETFL);\nfcntl(fd, F_SETFL, flags | O_ASYNC);\n```\n\n**此步会触发驱动的 fasync 回调函数。**\n\n4. 驱动必须实现 fasync 这个fop：\n```c\nstatic int key_fasync(int fd, struct file *file, int on)\n{\n    struct key_dev *kdev = file->private_data;\n    return fasync_helper(fd, file, on, &kdev->async_queue);\n}\n```\n\nfasync_helper：把当前进程封装成 `struct fasync_struct` 并加入 `kdev->async_queue`。\n\njust like this：\n```\nkey_dev -> 设备资源结构体\n └── async_queue\n      ├── 进程A (PID xxx)\n      ├── 进程B\n```\n\n5. 事件发生：\n\t例如，按键中断触发\n```\nirq_handler()\n{\n    key_value = 1;\n    kill_fasync(&kdev->async_queue, SIGIO, POLL_IN);\n}\n```\n\nkill_fasync：通知 async_queue 里的所有进程：有 I/O 事件发生了。\n\njust like this：\n```\nkill_fasync\n └── 遍历 async_queue\n      └── send_sigio()\n           └── send_sig_info()\n                └── 把 SIGIO 放入目标进程的 signal queue\n```\n\n注意：此函数只是把只是把信号“挂”到目标进程上。\n\n6. 用户态必须注册信号处理函数：\n\n```c\nsignal(SIGIO, sigio_handler);\n```\n\n当内核发现：\n```c\ncurrent->pending signal == SIGIO\n```\n\n则\n→ 保存当前上下文\n→ 跳转到 sigio_handler()\n\n## 4. 使用异步机制\n\n### 4.1. 应用程序端 (User Space)\n\n应用程序需要做三件事（简称“三板斧”）：\n1. **绑定信号处理函数**：使用 `signal()` 让应用知道收到 `SIGIO` 信号后该干什么。\n2. **设置属主**：使用 `fcntl(fd, F_SETOWN, getpid())` 告诉内核：“这个设备文件的信号要发给当前进程”。\n3. **开启异步标志**：使用 `fcntl(fd, F_SETFL, flags | O_ASYNC)` 启用异步通知功能。\n\n### 4.2. 驱动程序端 (Kernel Space)\n\n驱动需要处理数据结构 `fasync_struct` 并实现三个部分：\n1. **定义结构体**：在设备结构体中定义 `struct fasync_struct *async_queue;`。\n2. **实现 `.fasync` 接口**：当应用调用 `fcntl` 设置 `O_ASYNC` 时，内核会调用驱动的 `.fasync` 函数。驱动里只需调用内核辅助函数 `fasync_helper`。\n3. **发送信号**：当设备数据就绪（如中断来了），调用 `kill_fasync` 发送信号。\n4. **清理**：在 `.release` 函数中把节点从异步队列中删除。\n\n### 4.3. 番外：嵌入还是指针？\n\n在设备资源结构体中，\n`struct fasync_struct async_queue` 用嵌入还是指针？\n\n用指针。因为它是“外部管理对象”，你只是引用。它由 `fasync_helper` 管理。\n\n---END---\n\n","categories":["Linux","内核编程"]},{"title":"我的驱动模块项目文件结构","url":"/posts/3762/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 前言\n\n当我们编写一个linux外部模块时，如果是小demo，我们还可以把所有实现都放在一个.c文件里，但是如果你想要写一个真实、可长期维护的驱动，这样是肯定不推荐的，一定是多文件结构。\n\n## 文件组织形式及原则\n\n按职责拆分，把一个模块拆为运用多个子系统的子模块，一个子系统模块单独为一个.c文件。这些子系统模块通过内部共享头文件为main.c提供使用该子系统模块的接口。\n\n例如，一个GPIO按键驱动的目录结构如下：\n\n```\nkey_driver/\n├── Makefile\n├── Kconfig              # 可选\n├── key_main.c           # 模块入口 / probe / remove\n├── key_gpio.c           # GPIO 相关\n├── key_irq.c            # 中断相关\n├── key_fops.c           # 字符设备 / file_operations\n├── key_internal.h       # 内部头文件（核心）\n└── key_uapi.h           # 可选：用户态 ioctl 定义\n```\n\n| 文件               | 职责                                  |\n| ---------------- | ----------------------------------- |\n| `key_main.c`     | `module_init / exit`、`probe/remove` |\n| `key_gpio.c`     | GPIO 获取、释放、读值                       |\n| `key_irq.c`      | `request_irq`、中断处理                  |\n| `key_fops.c`     | `open/read/ioctl/poll`              |\n| `key_internal.h` | **模块内部共享结构和函数声明**                   |\n| `key_uapi.h`     | **给用户态用的 ioctl 定义（可选）**             |\n\n## 文件的编写原则\n\n### 最小化依赖头文件\n\n你可能会想，我把所有.c文件需要包含的头文件都写到key_internal.h，然后其他.c文件只引用key_internal.h就好了？这种做法在 C 语言编程，尤其是 Linux 内核编程中，是**应该避免的**。原因如下：\n\n1. 可读性差。阅读代码的人完全不知到你的.c文件依赖哪些内核头文件。\n2. 编译速度。任何 `.c` 文件都必须处理所有不必要的头文件内容，导致编译时间大幅增加。\n3. 命名空间污染。引入了大量的符号和宏定义，增加了**符号冲突**的风险，也使代码更难阅读和维护。\n\n一个有趣的说法是，你已经把整个项目拆分成了许多功能子系统的实现，但是如果你像上面那样做，就等于又把它们杂糅在一起了，这与我们的初衷背道而驰。\n\n应该怎么做？\n\n1. **按需包含 (Include What You Use)**：只包含你当前文件需要使用的定义。\n2. **依赖分离**：将依赖关系限制在真正需要它们的源文件和头文件内。\n3. **保持最小依赖**：只引入当前文件所需的最小集合的符号。\n\n### 内部头文件的内容\n\n只放：\n1. 所有 `.c` 都需要的头文件\n2. 跨文件函数声明\n3. 核心结构体定义\n4. 前置声明\n5. 核心结构体成员所需要的头文件\n\n其中第4、5点我们需要视情况灵活处理，详见下文。\n\n### 定义结构体成员时用不用指针？\n\n当我们编写内核模块，在定义结构体成员时，特别是这个成员也是一个结构体，到底用指针还是直接内嵌呢？\n\n首先我们了解一下这两种方式的特点：\n\n#### 内嵌\n\n🟢适用场景：\n- **组合关系（Is-part-of）：** 子结构体是父结构体不可分割的一部分。例如，一个按键内部“自带”一个定时器。\n- **生命周期同步：** 子结构体必须随父结构体一起创建和销毁。\n- **性能考量：** \n\t- **减少内存碎片：** 一次 `kmalloc` 就能申请到父子所有的内存。\n    - **缓存友好（Cache Locality）：** 父子结构体在物理内存中是连续的，CPU 访问速度更快。\n- **内核习惯用法：** * `struct cdev` 或 `struct list_head` 通常内嵌在自定义驱动结构体中，以便通过 `container_of` 宏来找回父结构体的指针。\n\n🔴缺点：\n- **必须包含头文件：** **编译器必须知道子结构体的确切大小**，所以头文件里必须 `#include` 它的定义。\n- **空间固定：** 即使你不使用这个成员，它也会占用内存。\n\n#### WHAT ABOUT 指针？\n\n当我们定义一个指针时，其内存大小是确定的——4字节（32位系统）或8字节（64位系统）。\n\n🟢适用场景：\n- **引用关系（Refers-to）：** 你只是在“借用”或“观察”一个由别处创建和管理的对象。\n    _例如：_ GPIO 描述符是由内核 GPIO 子系统管理的，你的驱动只是申请了一个“使用权”。\n- **生命周期不同步：** 子对象的寿命可能比父对象长，或者在父对象创建后才动态生成。\n- **可选性（Optional）：** 这个成员可能不存在。指针可以设为 `NULL`，而内嵌结构体永远占用空间。\n- **解耦依赖：** 如前所述，可以使用**前置声明[^1]**，减少头文件的相互包含。\n- **共享资源：** 多个不同的父对象可能需要指向同一个子对象实例。\n\n🔴缺点：\n- **内存碎片：** 如果子对象也需要动态分配，会多出一次内存申请开销。\n- **访问开销：** 需要通过指针解引用（Dereference）访问，稍微慢一点。\n\n#### 最终判断原则\n\n对于我来说，在编写模块时，我会这样判断：\n\n1. 这个成员是不是来自其他子系统的句柄？我只是“借用”或“观察”一个由别处创建和管理的对象。如果是，则使用指针。\n\t_例如： GPIO 描述符是由内核 GPIO 子系统管理的，你的驱动只是申请了一个“使用权”。_\n\t\n2. 我会不会用这个结构体成员反向寻回其父结构体（container_of）？如果是，则直接内嵌。\n\n我最常用的还是第二点，如果第二点不满足我会直接考虑使用指针，其余还可参考上文提到的特点综合考虑，只是我更倾向于用指针。\n\n## 一个头文件的例子\n\n```c\n#ifndef __KEY_PDEV_INTERNAL_H__\n#define __KEY_PDEV_INTERNAL_H__\n\n#include <linux/types.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/timer.h>\n\n#define DEV_NAME \"key_pdev\"\n#define KEY_NUM  1\n\nstruct gpio_desc;//前置声明\n\n/* -------- 数据结构 -------- */\n/* key 设备下 单个按键数据结构*/\nstruct key_member {\n    int id;\n    struct gpio_desc *gpio_input;\n    int irq_num;\n    struct timer_list debounce_timer;\n    int final_val;\n};\n\n/* key 设备数据结构 */\nstruct key_dev {\n    dev_t devno;\n    struct cdev cdev;\n    struct class *cls;\n    struct device *device;\n    struct device *pdev_dev;\n    struct key_member KeyMem[KEY_NUM];\n};\n\n/* -------- 跨文件函数 -------- */\n\n#endif\n```\n\n在这个例子里，结构体 `struct key_dev` 指的是整个按键设备，而 `struct key_member` 则是按键设备下的一个按键。\n\n1. 在 `struct key_member` 中，其包含了 `struct timer_list`，且使用了**结构体本身** (`struct timer_list debounce_timer`)，而不是指针。因此，**必须**包含定义它的头文件 `<linux/timer.h>`。\n    \n2. `struct gpio_desc` 使用的是指针，但是他是用于特定功能的结构体成员，也就是说它只会在使用GPIO子系统的.c文件中操作，其他文件只是“持有这个字段”。这种情况适合使用前置声明，在使用这个字段的.c文件中来包含它的依赖。\n\n3. 该项目需要 cdev 和 debounce_timer 寻回其父结构体，因此使用的是内嵌。\n    \n4. 对于像 `struct cdev` 和 `struct device` 这样的核心结构，几乎贯穿整个项目，所以包含他们的头文件（cdev.h 和 device.h）是正确的。\n\n5. `types.h` 用于 `dev_t` 。虽然很多头文件会间接包含它，但明确包含是好习惯。\n\n\n[^1]: 由于指针的内存大小是确定的，所以编译器不用知道该数据类型的具体定义以判断其所占内存，我们只需要告诉编译器这个数据类型有定义，这就是前置声明，它可以降低编译依赖。\n","categories":["Linux","项目管理"]},{"title":"Platform设备模型","url":"/posts/10329/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 1. 为什么使用platform？\n\n为了可移植性、兼容性，复用性，实现硬件和驱动的分离，让设备驱动可以在不同的板子上跑。\n\n![](Snipaste_2025-12-13_21-11-35.png)\n\n## 2. Platform 设备模型适合哪些设备？\n\n在 Linux 内核中，像 USB、PCI、I2C 这种设备可以自动被总线发现。但很多嵌入式系统的 SoC 内部外设（如 GPIO、RTC、UART、LCD、I2C-contrller）是直接通过内存映射（Memory-mapped）访问的，CPU 无法自动“感知”它们的存在。\n\n**Platform 总线**就是为了管理这些“挂在内存上”的设备而诞生的。\n\n## 3. 理解 Platform 模型\n\nPlatform 模型的核心思想是 **“分层”**：将**硬件信息**和**驱动逻辑**分开。它由三个核心部分组成：\n1. **Platform Device (设备)**：描述硬件资源（寄存器地址、中断号等）。\n2. **Platform Driver (驱动)**：实现操作逻辑（如何初始化、读写数据等）。\n3. **Platform Bus (总线)**：作为中介，负责匹配设备和驱动。\n\n我们简单过一遍platform的工作流程，以对这三个部分有个简单的认知。\n### 3.1. Platform 的工作流程\n\n#### 3.1.1. 总览\n\n```\n读取设备树\n → 解析节点\n   → 判断“谁来认领这个节点”\n     → 创建 platform_device（兜底）\n       → platform_driver 注册\n         → platform_bus 匹配\n           → probe()\n\n```\n\n先明确一个前提：\n- Bootloader（U-Boot）已经把 `.dtb` 放到内存\n- 内核启动时，通过指针拿到整棵设备树\n此时**设备树只是“一坨数据结构”，还不是 device**\n\n#### 3.1.2. step1：内核解析设备树阶段\n\n内核启动过程中，会进入设备树初始化阶段，开始解析设备树的节点。\n对每个节点，内核问一个关键的问题:\n\n> 这个节点，该由谁来处理？\n\n1. 先问：“是不是‘可枚举总线’设备？”\n\t例如USB、PCI。\n\t如果是——跳过设备树创建设备，以后靠总线扫描来创建\n\n2. 再问：“是不是某个‘专用子系统’设备？”\n\t例如节点里有一些特殊属性：\n\t- gpio-controller\n\t- interrupt-controller\n\t- clock-controller\n\t- pinctrl\n\t如果是——这类节点有对应子系统解析。\n\n3. 再问：”是不是属于某条总线子设备？“\n\t例如I2C总线、SPI总线\n\t如果是——有专门的总线框架解析\n\n> 这里注意区分I2C控制器和I2C设备，I2C控制器通常是SoC的内部外设，是platform设备，而I2C设备是挂在 I2C 总线上的外设，**由I2C 总线框架管理**，**不是 platform 设备**。\n\n问完之后，没人要你？那你就是 platform 设备。所以platform设备就是兜底规则。\n\n#### 3.1.3. step2：内核创建 platform_device（设备）\n\n即内核将**设备**“挂”在 platform_bus 上。\n\n内核创建了\n```c\nstruct platform_device *pdev;\n```\n\n其中比较重要的结构体成员：\n- `pdev->dev` → 设备信息\n\t- `pdev->dev.of_node` → 指向设备树节点\n\t- `pdev->dev.bus` → platform_bus\n- `pdev->name` → 来自节点名或 compatible\n\n这一步硬件被“对象化”了。之后GPIO、IRQ、寄存器、电源管理等**全部都可以从 `pdev->dev` 出发统一获取**。\n\n注意这里引出了platform的核心对象之一——**设备**。\n\n#### 3.1.4. step3：platform_driver 注册（驱动）\n\n这一步是你做的。当你根据platform设备框架编写 `platform_driver`（驱动逻辑）时，\n一定会调用：（后文会详细提到）\n```c\nmodule_platform_driver(my_driver);\n```\n\n它类似于 `module_init()` ，**而这个API的作用是把你写的驱动程序也注册进platform_bus，也就是把驱动挂到platform总线。**\n\n所以当你加载你的.ko文件时，驱动程序也注册进了platform总线。\n\n那这里就引出了platform的核心对象之一——**驱动**。\n\n#### 3.1.5. step4：platform_bus 开始做“匹配”\n\n这是 platform 作为**总线**的核心职责。\n\n我们用伪代码来概括一下总线做的事：\n```\nfor each platform_device:\n    for each platform_driver:\n        if (match(device, driver)):\n            call driver->probe(device)\n```\n\n>**匹配机制（Match）**\n>最常用的就是根据 compatible 进行匹配。\n>优先级大致是：\n>1. `of_match_table` ← 设备树 compatible\n>2. `id_table`\n>3. `name`\n\n整个过程我们的 compatible 就只在这一步发挥作用。\n\n#### 3.1.6. step5：probe() 被调用\n\n驱动和设备匹配成功后就会调用probe()\nprobe()由你来实现。具体操作细节后文细说\n\n那我们应该在probe里做什么？——让设备（硬件）可用。\n\n典型顺序：\n1. 从 `pdev->dev.of_node` 读属性\n2. 申请 GPIO / IRQ / 内存\n3. 初始化硬件状态\n4. 注册字符设备 / miscdevice（如果需要）\n\n#### 3.1.7. step6：remove\n\n如果设备被移除或其驱动被卸载，也就是匹配失效，则会调用remove()。\n\nremove()当然也由你来实现。我们后文细说。\n\n## 4. 使用Platform设备模型\n\n### 4.1. 省流版\n\n用设备树“声明硬件”，用 platform_driver“实现驱动逻辑”，\n内核通过 platform 总线把两者配对，并调用你的 probe()\n\n### 4.2. step1：在设备树里声明设备\n\n在 `.dts` 里写一个节点描述硬件，例如：\n\n```c\nmykey {\n    compatible = \"gdm,mykey\";\n    key-gpio = <&gpio1 5 GPIO_ACTIVE_LOW>;\n    interrupt-parent = <&gpio1>;\n    interrupts = <5 IRQ_TYPE_EDGE_FALLING>;\n};\n```\n\n### 4.3. step2：编写platform_driver（驱动逻辑）\n\n#### 4.3.1. 定义匹配表\n\n```c\nstatic const struct of_device_id mykey_of_match[] = {\n    { .compatible = \"gdm,mykey\" },\n    { }\n};\nMODULE_DEVICE_TABLE(of, mykey_of_match);\n```\n\n**这一步是在告诉 platform 总线：我能驱动什么设备，我能驱动设备的特征。** 给bus的匹配提供信息。\n\n#### 4.3.2. 在 probe() 中完成“设备初始化”\n\n##### 4.3.2.1. 获取设备树节点\n\n```c\nstruct device *dev = &pdev->dev;\nstruct device_node *np = dev->of_node;\n```\n\n后续所有资源都从这里“派生”\n\n##### 4.3.2.2. 获取GPIO【可选】\n\n```c\nstruct gpio_desc *key_gpio;\n\nkey_gpio = devm_gpiod_get(dev, \"key\", GPIOD_IN);\n```\n\n##### 4.3.2.3. 获取IRQ【可选】\n\n```c\nint irq = platform_get_irq(pdev, 0);\n```\n\n作用\n- 解析 `interrupts`\n- 返回 Linux IRQ 号\n\n##### 4.3.2.4. 注册中断【可选】\n\n```c\ndevm_request_irq(dev, irq, key_isr,\n                 IRQF_TRIGGER_FALLING,\n                 \"mykey\", dev);\n```\n\n##### 4.3.2.5. 其他操作....\n\n#### 4.3.3. remove()\n\n如果你用了：`devm_`开头的API，那基本上就不需要头疼资源释放的问题\n\n因为platform + devm = 自动资源回收\n\n#### 4.3.4. 定义platform的操作\n\n```c\nstatic struct platform_driver mykey_driver = {\n    .probe  = mykey_probe,\n    .remove = mykey_remove,\n    .driver = {\n        .name = \"mykey\",\n        .of_match_table = mykey_of_match,\n    },\n};\n```\n\n这一步把你的 probe / remove 交给 platform 框架托管。\n\n#### 4.3.5. 注册 driver\n在模块的编写中通常这样写：\n\n```c\nstatic int __init leddriver_init(void)\n{\n\t return module_platform_driver(myled_driver);\n}\n```\n\n这一步把 driver\n挂到 platform_bus 上。\n\n### 4.4. step3：像往常一样添加设备\n\n初学者通常没弄清platform的作用，它只负责板级设备的描述、匹配、生命周期管理、硬件资源获取与托管。并不是直接把设备给你创建好了，如果你需要用户态接口，比如read()、write()、ioctl()；或者需要设备接口（/dev/xxx），你仍需要自己创建（在probe()中）。\n\n> 它是一个仓管，你完成一个作品需要什么资源，告诉仓管，仓管从仓库里给你拿资源，然后你来做。\n\n![](树形图.png)\n","categories":["Linux","设备驱动程序"]},{"title":"IMX6ULL引脚电气属性配置寄存器浅析","url":"/posts/21397/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n**IMX6ULL参考手册中，一个电气属性配置寄存器说明如下，我们来解读一下。**\n\n![](Snipaste_2025-12-08_21-19-18.png)\n\n![](Snipaste_2025-12-08_21-19-26.png)\n\n这个寄存器属于 **IOMUXC_SNVS**，作用是：\n\n**配置 SNVS_TAMPER1 引脚的电气特性（如上下拉、电驱动能力、开漏、速度等）**。 它**不负责选择复用功能（MUX）**，只负责“PAD 控制”。\n\n## 一. **寄存器总体功能概述**\n\nSW_PAD_CTL_PAD_SNVS_TAMPER1 提供以下功能配置：\n\n| 功能方向   | 子功能                       |\n| ------ | ------------------------- |\n| 输入端    | 上下拉、保持、迟滞 Hysteresis      |\n| 输出端    | 开漏使能、驱动强度、slew rate（边沿速度） |\n| PAD 行为 | SPEED（在 SNVS 区域通常是固定值）    |\n| 保护     | 部分位保留不用                   |\n\n下面按位说明。\n\n## 二. **逐字段解析（由高到低位）**\n\n### **31–17：Reserved**\n\n这些位保留，写什么都没用。\n\n### **16: HYS — 输入迟滞（Hysteresis）使能**\n\n作用： 让输入信号增加抗抖动能力，在信号接近阈值边缘时不容易误触发。\n\n|值|含义|\n|---|---|\n|0|**不启用迟滞**（输入信号干净时使用）|\n|1|**启用迟滞**（抗干扰更好，推荐给按键/慢信号）|\n\n### **15–14：PUS — 上下拉电阻配置**\n\n只对输入有效。\n\n|PUS 值|电阻配置|说明|\n|---|---|---|\n|00|100K 下拉|拉低|\n|01|47K 上拉|稍强的上拉|\n|10|100K 上拉|弱上拉|\n|11|22K 上拉|强上拉|\n\n要使用这些上下拉，必须配合 **PUE=1** 和/或 **PKE=1**。\n\n### **13: PUE — Pull / Keeper 选择**\n\n决定启用 **Pull** 还是 **Keeper**。\n\n| 值   | 含义                            |\n| --- | ----------------------------- |\n| 0   | Keeper（保持器）启用：用于保持原状态（不是真上下拉） |\n| 1   | Pull（真正的上下拉电阻）启用              |\n\n**一般如果你希望确定逻辑电平（输入），就把 PUE=1。**\n\n### **12: PKE — Pull/Keeper 使能**\n\n是否启用 pull/keeper 模块。\n\n|值|含义|\n|---|---|\n|0|禁用 Pull/Keeper|\n|1|使能 Pull/Keeper（由 PUE 决定是 Pull 还是 Keeper）|\n\n即：PKE=1 时，PUE 决定到底是“pull”还是“keeper”。\n\n### **11: ODE — 开漏输出使能（Open Drain Enable）**\n\n|ODE|含义|\n|---|---|\n|0|**普通输出模式**|\n|1|**开漏模式（Open-drain）**|\n\n开漏常用于：\n\n- I²C SDA/SCL\n- 多设备共享信号线\n- 需要外拉电阻的场景\n\n### **10–8：Reserved**\n\n无意义。\n\n### **7–6: SPEED — I/O速度（通常 Read Only，SNVS区域固定）**\n\n在 SNVS 区域一般固定为：\n\n|值|含义|\n|---|---|\n|10b|medium (100 MHz)|\n\n但 SNVS 的 tamper pin 本质上通常是低速接口，因此 SPEED 通常不重要。\n\n### **5–3: DSE — Drive Strength（驱动能力）**\n\n配置输出引脚的驱动强度（等效电阻 R0/n）。\n\n|DSE|驱动能力|含义|\n|---|---|---|\n|000|关闭输出驱动|不输出（禁用）|\n|001|R0/1|最强|\n|010|R0/2|强|\n|011|R0/3|中等|\n|100|R0/4||\n|101|R0/5||\n|110|R0/6||\n|111|R0/7|最弱|\n\n驱动越强，负载越大，下降上升越快，但 EMI 可能会增大。\n\n### **2–1：Reserved**\n\n不用配置。\n\n### **0: SRE — Slew Rate（输出转换速度）**\n\n控制输出电平变化的快慢：\n\n|值|含义|\n|---|---|\n|0|Slow（慢速）→ EMI 小|\n|1|Fast（快速）→ 边沿快、驱动高频信号|\n\n一般：\n\n- 高频信号 → **Fast（1）**\n- 普通 GPIO → **Slow（0）**\n- 有 EMI 要求 → **Slow（0）**\n\n## 三. **功能汇总**\n\n|功能类别|字段|作用|\n|---|---|---|\n|**输入配置**|HYS|输入迟滞（抗干扰）|\n||PUS|使用哪种上下拉电阻|\n||PUE/PKE|启用上下拉或保持器|\n|**输出配置**|ODE|开漏输出|\n||DSE|驱动强度|\n||SRE|信号边沿速度|\n|**常规**|SPEED|I/O速度（SNVS一般固定）|\n||Reserved|保留位|\n\n## 四. **典型使用例子**\n\n### 配置为输入上拉\n\n例如一个按键输入：\n\n```ini\nHYS = 1        # 开启迟滞\nPKE = 1        # 使能 pull/keeper\nPUE = 1        # 使用 pull 模式\nPUS = 10       # 100K 上拉\nODE = 0        # 输入不需要开漏\n```\n\n### ② 配置为 I²C SDA/SCL（开漏 + 上拉）\n\n```ini\nODE = 1        # 开漏\nPKE = 1\nPUE = 1\nPUS = 10       # 上拉\nSRE = 1        # 快速速度\nDSE = 110      # R0/6\n```\n\n### ③ 配置为普通 GPIO 输出\n\n```ini\nODE = 0             # 普通推挽\nDSE = 100 (R0/4)    # 中等驱动\nSRE = 1             # 快速或视环境选\n```\n\n\n\n","categories":["嵌入式","配置功能"]},{"title":"按键驱动综合实验和ioctl功能介绍","url":"/posts/22750/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 1. 实验内容\n\n在设备树中添加按键外设“key”，同时使用pinctrl和gpio子系统，并使用中断系统启动定时器，并利用定时器进行消抖、读取按键值。\n\n- 知识点：设备树、pinctrl、gpio、中断、ioctl、timer\n未涉及INPUT子系统，还没学到。。。\n\n## 2. 查询手册并配置Pinctrl、GPIO、dts\n\n查询原理图：key使用的引脚名为 SNVS_TAMPER1\n\n![](Snipaste_2025-12-08_21-39-28.png)\n\n\n查询参考手册，搜索“SNVS_TAMPER1”\n该引脚可复用为 GPIO5_IO01：**——GPIO子系统配置条件已就绪**\n\n![](Snipaste_2025-12-08_21-16-29.png)\n\n现在明确了pinctrl子系统的复用，还要配置电气属性。\n\n在参考手册找到 SW_PAD_CTL_PAD_SNVS_TAMPER1 SW PAD Control，该寄存器用于配置 GPIO5_IO01 引脚的电器属性，各个位的含义我专门写了一篇文章——参见[IMX6ULL引脚电气属性配置寄存器浅析](https://blog.godmao.top/posts/21397/)，这里就不细说了。我们需要：\n\n- 第16位 HYS 启用输入迟滞：1\n- 第15-14位 PUS 启用100k下拉：00\n- 第13位 PUE 选择上下拉电阻：1\n- 第12位 PKE 使能PUE：1\n- 第11位 ODE 失能开漏输出：0\n- 第7-6位 中等 I/O速度：10\n- 第5-3位 DSE 关闭输出：000\n- 第0位 SRE 输出转换速度 慢：0\n\n即 **0x13080**，——**pinctrl 所有配置条件已就绪！**\n\n在iomuxc节点下添加 key 的引脚组：这是pinctrl节点（宏定义在imx6ull-pinfunc-snvs.h）\n\n```\n&iomuxc {\n    pinctrl_key: keygrp{\n        fsl,pins = <\n            MX6ULL_PAD_SNVS_TAMPER1__GPIO5_IO01 0x13080\n        >;\n    };\n};\n```\n\n中断的属性也可以写了，就是interrupt-parent和interrupts这两个，我们触发方式设置为双边沿触发，中断宏定义在include/linux/irq.h\n\n那么我们把完整的设备树节点写出来：\n\n```\n/ {\n    key{\n        #address-cells = <1>;\n        #size-cells = <1>;\n        compatible = \"gdm-key\";\n        pinctrl-names = \"default\";\n        pinctrl-0 = <&pinctrl_key>;\n        key-gpios = <gpio5 1 GPIO_ACTIVE_HIGH>;\n        interrupt-parent = <&gpio5>;\n        interrupts = <1 IRQ_TYPE_EDGE_BOTH>;\n        status = \"okay\";\n    };\n};\n```\n\n最后在内核源码根目录下编译一波：`make dtbs`\n\n## 3. 验证：使用ftp把dts传到开发板\n\n使用ftp文件传输到开发板相关方法，参见——[mx6ull开发版移植nxp官方u-boot](https://blog.godmao.top/posts/26288)\n\n这里主要讲一下如何将nxp官方的uboot启动命令修改为“使用ftp从网络中下载dts”而不是mmc中的dts,不然你每次启动还是从mmc中加载\n\n进入到 uboot 界面，使用 `pri` 命令查看环境变量，看bootcmd命令：\n\n```bash\nbootcmd=run findfdt;run findtee;mmc dev ${mmcdev};mmc dev ${mmcdev}; if mmc rescan; then if run loadbootscript; then run bootscript; else if run loadimage; then run mmcboot; else run netboot; fi; fi; else run netboot; fi\n```\n\n使用递归的思想分析一波，设备启动后会进入 `run loadimage` 分支运行，最后运行 `mmcboot` 因此我们看mmcboot\n\n```bash\necho Booting from mmc ...; run mmcargs; if test ${tee} = yes; then run loadfdt; run loadtee; bootm ${tee_addr} - ${fdt_addr}; else if test ${boot_fdt} = yes || test ${boot_fdt} = try; then if run loadfdt; then bootz ${loadaddr} - ${fdt_addr}; else if test ${boot_fdt} = try; then bootz; else echo WARN: Cannot load the DT; fi; fi; else bootz; fi; fi;\n```\n\n注意到 `loadfdt`，推测这应该就是load dts文件脚本，转到 `loadfdt`\n\n```bash\nfatload=mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\n```\n\n还真是兄弟，直接改一手：dtb名字自己确定\n\n```bash\nsetenv fatload \"tftp 0x83000000 imx6ull-gdm-emmc.dtb\"\nsaveenv\n```\n\n那么就ok啦，直接参考上面那篇文章网络传输dtb吧！\n\n下载启动后，查看\n\n```bash\ncd /proc/device-tree/mykey\nls\n```\n\n确有此节点并且属性与设备树文件里的一致。\n\n## 4. ioctl介绍\n\n### 4.1. 为什么需要 ioctl？\n\n字符设备驱动一般会提供 **read、write** 接口，而 read/write 主要用于：\n\n- read：从设备读数据\n- write：往设备写数据\n\n但驱动经常有一些“不是读写”的功能，比如：\n\n- 设置按键工作模式\n- 获取某个按键的值\n- 清除缓冲区\n- 开/关 LED\n- 获取设备状态\n- 执行复位\n- 调节参数（如 PWM、波特率）\n\n这些事情不是数据流，而是 **命令**。\nread/write 是拿来传数据的，不适合传“指令”。\n\n于是内核提供了一个专门用于“发送命令”的接口：\n**ioctl：I/O control（输入输出控制）**\n\n它的作用就是：\n**用户程序给驱动发送一个命令，驱动执行对应的动作。**\n\n### 4.2. ioctl 的模型\n\n把驱动想象成一部“电器”，比如一个空调，你可以：\n\n- read → 读取当前温度\n- write → 写入要显示的内容\n- ioctl → 控制空调的功能（调温度、开关机、风速）\n\n也就是说：\n**ioctl 就是“控制面板上的按钮”。**\n用户程序通过 ioctl 给驱动发命令，驱动根据不同命令执行操作。\n\n### 4.3. ioctl 函数的原型\n\n驱动里必须实现一个函数：\n\n```c\nlong unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);\n```\n\n参数解释：\n- **cmd**：命令编号（告诉驱动要做什么）\n- **arg**：命令的数据（比如 key_id、温度等）\n\n### 4.4. cmd 是怎么设计的？\n\n**魔数 + 命令号 + 数据类型。**\n\nLinux 使用宏来构造 ioctl 命令：\n\n- `_IO()`\n- `_IOR()`\n- `_IOW()`\n- `_IOWR()`\n\n这些宏会构造命令码，并把隐藏信息编码进去。\n例如：\n\n```c\n#define KEY_IOCTL_MAGIC 'K'\n#define KEY_GET_VALUE   _IOWR(KEY_IOCTL_MAGIC, 0x01, int)\n```\n展开后，命令码包含信息：\n\n| 内容          | 含义             |\n| ----------- | -------------- |\n| 魔数 `'K'`    | 标识该命令属于 Key 驱动 |\n| 命令号 `0x01`  | 这条命令是第一个功能     |\n| 操作方向 `IOWR` | 读写用户空间         |\n| 类型          | int            |\n\n这样做能保证不同驱动不会冲突。\n\n### 4.5. arg 参数是什么？\n\n看函数原型：\n\n```c\nlong unlocked_ioctl(..., unsigned long arg);\n```\n\narg 是一个“数字”，但为了传数据，通常我们让用户传 **指针**：\n\n用户态：\n```c\nint key_id = 0; ioctl(fd, KEY_GET_VALUE, &key_id);\n```\n驱动态：\n```c\ncopy_from_user(&key_id, (int *)arg, sizeof(int));\n```\n\n也就是说：\narg = 用户空间的数据地址\n驱动读/写这个地址完成**数据交互**——也就是说，我把一个数据通过这个变量传入进驱动，驱动把要返回的数据通过这个变量再传回来\n\n### 4.6. ioctl 内部流程\n\n假设你要读某个按键：\n用户程序：\n```c\nint key_id = 2;\nioctl(fd, KEY_GET_VALUE, &key_id);\n```\n\n驱动里发生的事情：\n\n1. 内核把命令放进 unlocked_ioctl\n2. 驱动判断 cmd 是哪个指令\n3. 使用 `copy_from_user` 获取用户传来的 key_id\n4. 根据 key_id 获取按键值\n5. 使用 `copy_to_user` 把按键值写回 arg 指向的用户变量\n\n最终用户程序里的 key_id 变成：`key2 的值`\n\n### 4.7. ioctl 是如何区分命令的？\n\n驱动里会写：\n\n```c\nswitch (cmd) {\ncase KEY_GET_VALUE:\n...\ncase KEY_SET_MODE:\n...\n}\n```\n\ncmd 就像电话打进来时的“分机号”，告诉驱动要执行哪个功能。\n\n### 4.8. 小结\n\n|接口|用途|\n|---|---|\n|read|获取数据流|\n|write|发送数据流|\n|ioctl|执行控制命令|\n\nioctl 原理：\n1. 用户程序调用 ioctl(fd, cmd, arg)\n2. 内核把 cmd 和 arg 传给驱动的 unlocked_ioctl\n3. 驱动根据 cmd 执行不同操作\n4. arg 用于传入参数或返回结果\n5. 命令码用魔数+编号生成，防止冲突\n\n## 5. 编写实验代码\n\n![](readme.png)\n\n[代码下载](https://file.godmao.top/@s/IlaXAvGm)\n\n","categories":["Linux","记录"]},{"title":"linux中断系统基础使用","url":"/posts/35167/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n在 Linux 内核开发中，**中断（Interrupt）** 是 CPU 与硬件通信的“急救热线”。如果让 CPU 不断轮询（Polling）硬件状态，效率极低；而中断机制允许硬件在需要时“打断” CPU，极大提升了系统的并发处理能力。\n\n本文将帮助您理解 Linux 中断处理的顶半部/底半部机制，掌握核心 API。\n\n## 1. “顶半部”和“底半部”\n\nLinux 中断处理的一个黄金法则 是：**快进快出**\n\n当硬件触发中断时，CPU 会暂停当前任务，跳转到中断处理函数。如果这个函数执行时间过长（例如读取大量数据或进行复杂计算），系统就会卡顿，甚至丢失其他重要的中断信号。\n\n为了解决这个问题，Linux 将中断处理分为两个部分：\n\n### 1.1. 顶半部 (Top Half / Hard IRQ)\n\n- **角色：** “前台接待员”。\n- **触发：** 硬件直接触发。\n- **特点：**\n\t- **极快**：只做最紧急的事（如读取寄存器状态、清除中断标志）。\n    - **屏蔽中断**：执行期间通常会屏蔽当前CPU的其他中断。\n    - **不可睡眠**：严禁调用任何可能导致睡眠的函数（如 `ssleep`, `mutex_lock`, `copy_from_user`）。\n- **任务：** 登记任务，将耗时操作推迟给底半部，然后立即返回。\n### 1.2. 底半部 (Bottom Half)\n\n- **角色：** “后台处理专员”。\n- **触发：** 由顶半部调度，在稍后的安全时间执行。\n- **特点：**\n\t* **开中断**：执行时允许响应其他中断。\n    - **灵活**：根据机制不同，有些可以睡眠（Workqueue），有些不行（Softirq/Tasklet）。\n- **常见场景：** 按键消抖、处理数据包、执行长时间计算\n#### 1.2.1. 常见的底半部机制\n\n选择哪种底半部机制取决于您的具体需求：\n\n| **机制**               | **运行上下文** | **是否允许睡眠** | **适用场景**                              |\n| -------------------- | --------- | ---------- | ------------------------------------- |\n| **Softirq (软中断)**    | 中断上下文     | **否**      | 极高并发需求（如网卡驱动）。一般驱动很少直接用。              |\n| **Tasklet**          | 中断上下文     | **否**      | **(旧)** 轻量级任务。但在新内核中逐渐被 Workqueue 取代。 |\n| **Workqueue (工作队列)** | **进程上下文** | **是**      | **(推荐)** 需要耗时操作、需要睡眠、需要申请大量内存时。       |\n| **Threaded IRQ**     | 进程上下文     | **是**      | **(推荐)** 现代驱动的首选，将中断处理直接线程化。          |\n\n## 2. IRQ 资源编号与设备树\n\n在现代 Linux 内核中，绝大多数 SoC 的中断都不再通过固定的“linux 内部 IRQ 号”访问，而是通过 **设备树（Device Tree）描述硬件 → 内核解析 → 统一抽象（irq_domain） → 转换成 Linux IRQ 号** 的方式使用。\n\n这一层抽象非常重要，因为：\n\n- **SoC 的硬件 IRQ 号不是从 0 开始，也不是固定长度**\n- **不同中断控制器（GIC, NVIC, RISC-V PLIC …）的中断号格式完全不同**\n- DTS 可以统一描述，不需要驱动写死中断号\n\n### 2.1. 设备树中的中断描述\n\n在 DTS 中，中断通常由两个属性提供：\n1. **interrupt-parent**：指定使用哪个中断控制器\n2. **interrupts**：描述设备的中断号和触发方式\n\n例如：\n```\nmydev: my-device@0 {\n    compatible = \"gdm,mydev\";\n    reg = <0x01c20000 0x1000>;\n\n    interrupt-parent = <&gic>;\n    interrupts = <33 IRQ_TYPE_LEVEL_LOW>;\n};\n```\n\n“interrupts” 单元的含义依赖于中断控制器定义的 **#interrupt-cells** 属性。\n\n#### 2.1.1. \"#interrupt-cells\" 的定义\n\n每个中断控制器节点都定义自己的中断参数格式。\n\n例如 ARM GIC：\n\n```\ngic: interrupt-controller@1e001000 {\n    compatible = \"arm,cortex-a9-gic\";\n    #interrupt-cells = <3>;\n    interrupt-controller;\n};\n\n```\n\n表示这个中断控制器的 `interrupts = <a b c>` 有 **3 个单元**。\n常见格式：\n\n|单元序号|含义|\n|---|---|\n|0|中断类型（0: SPI, 1: PPI）|\n|1|硬件中断号|\n|2|触发类型（edge/level）|\n\n#### 2.1.2. GPIO 触发的中断\n\n很多 GPIO 控制器也提供中断功能：\n\n```c\nmy_button {\n    gpios = <&gpio1 5 GPIO_ACTIVE_LOW>;\n    interrupts = <5 IRQ_TYPE_EDGE_FALLING>;\n    interrupt-parent = <&gpio1>;\n};\n```\n\n注意：\n`gpios` 与 `interrupts` 是两回事。\n`gpios`表示驱动该设备的 GPIO 引脚，\n`interrupts`表示触发中断的中断号。\n\n### 2.2. 内核如何解析设备树中的中断\n\n中断解析的三层结构：\n```\nDTS → irq_domain → Linux IRQ number\n```\n\n解析过程：\n1.  解析 interrupt-parent 属性\n\t内核找到你的设备是由哪个中断控制器管理。\n\n2. 将 interrupts 中的原生硬件 IRQ 参数交给 irq_domain\n\t中断控制器在初始化时，会创建对应的 **irq_domain** 对象，用于映射：\n```\n硬件中断号 （hwirq）\n        ↓\nLinux 虚拟 IRQ（virq）\n\n```\n\n3. 返回驱动可用的 Linux IRQ\n\t这个 IRQ 是你在 request_irq() 中使用的。\n\n4. 你在驱动中拿到的 IRQ 号 **不是硬件 IRQ**，而是 Linux 分配的虚拟 IRQ（virq）\n\t所以不能写死 IRQ 数字，必须从 DTS 获取。\n\n### 2.3. 在驱动中获取设备树中的 IRQ 号\n\n#### 2.3.1. 常用方式：platform_get_irq()\n\n最推荐、最通用：\n```c\nint irq = platform_get_irq(pdev, 0);\nif (irq < 0)\n    return irq;\n```\n\n对应 DTS：\n```\ninterrupts = <33 IRQ_TYPE_LEVEL_LOW>;\n```\n\n如果有多个中断：\n```\ninterrupts = <33 IRQ_TYPE_LEVEL_LOW>,\n             <34 IRQ_TYPE_EDGE_RISING>;\n```\n\n驱动：\n```c\nirq0 = platform_get_irq(pdev, 0);\nirq1 = platform_get_irq(pdev, 1);\n```\n\n#### 2.3.2. 一般 GPIO → IRQ：gpiod_to_irq()\n\n如果是 GPIO：\n```c\nirq-gpios = <&gpio1 5 GPIO_ACTIVE_LOW>;\n```\n\n驱动：\n```c\ngpio = gpiod_get(&pdev->dev, \"irq\", GPIOD_IN);\nirq = gpiod_to_irq(gpio);\n```\n\n#### 2.3.3. 旧方法（不推荐）：irq_of_parse_and_map()\n\n较低级 API，如今主要用于没有 platform_device 的情况。\n```c\nirq = irq_of_parse_and_map(node, 0);\n```\n\n## 3. 常见API\n\n### 3.1. `request_irq()`：注册中断处理程序\n\n```c\nint request_irq(unsigned int irq,\n                irq_handler_t handler,\n                unsigned long flags,\n                const char *name,\n                void *dev);\n\n```\n\n参数说明：\n\n|参数|说明|\n|---|---|\n|irq|中断号|\n|handler|中断处理函数|\n|flags|触发方式，如 IRQF_TRIGGER_FALLING|\n|name|/proc/interrupts 显示的名称|\n|dev|传给 handler 的参数（通常设备结构体）|\n\n### 3.2. `free_irq()`：释放中断\n\n```c\nvoid free_irq(unsigned int irq, void *dev);\n```\n\n### 3.3. 中断处理函数（ISR）\n\n```c\nirqreturn_t my_irq_handler(int irq, void *dev_id)\n{\n    struct mydev *dev = dev_id;\n\n    /* 处理硬件中断：读取状态寄存器、清中断标志… */\n    ...\n\n    return IRQ_HANDLED;\n}\n\n```\n\n注意：\n- **不能睡眠**\n- **不能使用可能阻塞的 API（如 msleep）**\n\n返回值：\n- `IRQ_HANDLED`\n\t表示：\n\t- 中断被这个 handler 正常处理了\n\t- 内核会认为这个中断“属于你”\n\n- `IRQ_NONE`\n\t表示：\n\t- 这个中断不属于你\n\t- 通常用于共享中断线（例如 PCI）\n\n### 3.4. `enable_irq()` / `disable_irq()`\n\n用于在软件中暂时禁用/启用某个 IRQ：\n\n```c\ndisable_irq(irq);       // 会等待硬件中断执行完毕\ndisable_irq_nosync(irq); // 不等待\nenable_irq(irq);\n```\n\n## 4. 底半部机制\n\n### 4.1. tasklet（轻量底半部）\n\n创建：\n\n```c\nvoid my_tasklet_func(unsigned long data);  DECLARE_TASKLET(my_tasklet, my_tasklet_func, 0);\n\n```\n\n调度：\n\n```c\ntasklet_schedule(&my_tasklet);\n```\n\n### 4.2. workqueue（更灵活）\n\n相比 tasklet，它可以睡眠，也更能处理复杂任务。\n\n创建工作：\n\n```c\nstatic void my_work_func(struct work_struct *work)\n{\n    struct mydev *dev = container_of(work, struct mydev, work);\n    /* 可以执行耗时任务 */\n}\n\n```\n\n初始化：\n\n```c\nINIT_WORK(&dev->work, my_work_func);\n```\n\n在中断里调度：\n\n```c\nschedule_work(&dev->work);\n```\n\n这是最常用的底半部方式。\n\n## 5. 中断处理中需要注意的事项\n\n### 5.1. 不要睡眠\n\nISR 禁止使用：\n- msleep\n- mutex_lock（可能睡眠）\n- schedule()\n### 5.2. 尽可能短\n\n- 清状态寄存器\n- 准备数据\n- 调度底半部\n### 5.3. 触发方式匹配硬件\n\n常见 flags：\n- IRQF_TRIGGER_RISING\n- IRQF_TRIGGER_FALLING\n- IRQF_TRIGGER_HIGH\n- IRQF_TRIGGER_LOW\n- IRQF_ONESHOT（配合 threaded irq）\n\n## 6. Threaded IRQ（线程化中断）\n\nLinux 支持把中断处理放到线程里（可睡眠）。适合驱动复杂逻辑。\n\n```c\nrequest_threaded_irq(irq, NULL,\n                     my_thread_fn,\n                     IRQF_ONESHOT | IRQF_TRIGGER_FALLING,\n                     \"mydev\", dev);\n\n```\n\nthread_fn 可以睡眠，非常灵活：\n\n```c\nstatic irqreturn_t my_thread_fn(int irq, void *dev_id)\n{\n    msleep(20);   // 可以\n    return IRQ_HANDLED;\n}\n```\n\n## 7. 查看中断情况\n\n执行：\n```bash\ncat /proc/interrupts\n```\n\n可以看到：\n- 中断号\n- 对应 CPU\n- 触发次数\n- 对应驱动名称\n\n例如：\n```bash\n33:      1023   GIC   edge   mydev_irq\n```\n","categories":["Linux","内核编程"]},{"title":"linux内核定时器的使用","url":"/posts/22304/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\nLinux 内核定时器用于在未来的某个特定时间点（基于系统滴答 `jiffies`）执行某个函数。它们是**低精度**定时器，主要用于超时处理、轮询检测等不需要纳秒级精度的场景。它是内核中最基础、最轻量级的异步机制之一。\n\n## 1. 核心概念\n\n在使用之前，需要理解以下几个关键点：\n\n- **异步执行：** 定时器回调函数是在 **中断上下文 (Softirq)** 中执行的，而不是进程上下文。\n- **Jiffies：** 内核的时间单位。定时器的超时时间是基于 `jiffies` 计数的。\n- **Struct timer_list：** 描述定时器的核心结构体。\n\n## 2. 核心数据结构\n\n在 Linux 4.14 版本之后，内核定时器的 API 进行了重构，使得结构更加简单安全。\n\n```c\nstruct timer_list {\n    /* 核心字段 */\n    unsigned long expires;        // 超时时间（单位：jiffies）\n    void (*function)(struct timer_list *); // 超时后的回调函数\n    u32 flags;                    // 标志位\n    /* 内部字段，用户通常无需直接操作 */\n    struct hlist_node entry;\n    unsigned long data;           // 旧版本残留，新版通常通过container_of 获取数据\n};\n```\n\n## 3. 内核定时器的特点\n\n- **低精度**（依赖 HZ，典型为 100~1000Hz）\n- **软中断上下文执行**（不能睡眠）\n- **适合轻量的周期性任务**\n- **适合简单超时处理**\n\n> 如果需要高精度定时，应该使用 hrtimer（高精度定时器）。\n\n## 4. 基本使用流程\n\n1. 定义一个 `struct timer_list` 变量\n2. 初始化定时器\n3. 设置回调函数\n4. 设置超时时间\n5. 注册定时器（添加到内核）\n6. 在退出时删除定时器\n\n## 5. 常用API函数\n\n以下是开发中最常用的 API，请务必掌握：\n\n### 5.1. `timer_setup()`：初始化\n\n内核 4.15 之后推荐的初始化方法。\n\n```c\nvoid timer_setup(struct timer_list *timer,\n                 void (*callback)(struct timer_list *),\n                 unsigned int flags);\n\n```\n\n**参数说明：**\n\n- `timer`：你的定时器对象\n- `callback`：超时后执行的函数\n- `flags`：一般填 0 即可\n\n### 5.2. `mod_timer()`：修改\n\n修改定时器的超时时间（如果未启动则相当于启动）。\n\n```c\nint mod_timer(struct timer_list *timer, unsigned long expires);\n```\n\n**参数说明：**\n\n- `timer`：要设置的定时器\n- `expires`：过期时间（jiffies 为单位）\n\n例：过 200ms 触发：\n\n```c\nmod_timer(&my_timer, jiffies + msecs_to_jiffies(200));\n```\n\n### 5.3. `del_timer()`：删除\n\n删除一个定时器（不等待当前回调执行完）。\n\n```c\nint del_timer(struct timer_list *timer);\n```\n\n### 5.4. `del_timer_sync()`：删除\n\n删除并确保回调不再执行（常用于模块卸载）。\n\n```c\nint del_timer_sync(struct timer_list *timer);\n```\n\n> 推荐在驱动卸载 (`module_exit`) 中使用。\n\n### 5.5. 时间转换函数（非常重要）\n\nLinux 内核定时器以 **jiffies** 为单位，但我们通常希望以毫秒、秒表示时间。\n直接操作 `jiffies` 很麻烦，内核提供了转换宏：\n\n```c\nunsigned long msecs_to_jiffies(const unsigned int m);\nunsigned long jiffies_to_msecs(const unsigned long j);\nunsigned long usecs_to_jiffies(const unsigned int u);\n```\n\n**示例**\n\n```c\nunsigned long expires = jiffies + msecs_to_jiffies(500);\n```\n\n## 6. 使用示例：每 500ms 打印一次消息\n\n```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n\nstatic struct timer_list my_timer;\n\nstatic void my_timer_callback(struct timer_list *t)\n{\n    pr_info(\"my_timer: timer fired!\\n\");\n\n    /* 再次启动定时器，形成周期性 */\n    mod_timer(&my_timer, jiffies + msecs_to_jiffies(500));\n}\n\nstatic int __init timer_example_init(void)\n{\n    pr_info(\"my_timer: module init\\n\");\n\n    /* 初始化定时器并绑定回调函数 */\n    timer_setup(&my_timer, my_timer_callback, 0);\n\n    /* 启动一个 500ms 的定时器 */\n    mod_timer(&my_timer, jiffies + msecs_to_jiffies(500));\n\n    return 0;\n}\n\nstatic void __exit timer_example_exit(void)\n{\n    pr_info(\"my_timer: module exit\\n\");\n\n    /* 删除定时器并确保回调不再运行 */\n    del_timer_sync(&my_timer);\n}\n\nmodule_init(timer_example_init);\nmodule_exit(timer_example_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"GoDm@\");\nMODULE_DESCRIPTION(\"Kernel timer example\");\n\n```\n\n\n## 7. 常见问题FAQ\n\n### 7.1. ❓定时器回调能否睡眠？\n\n**不能。**\n\n定时器回调运行在 **软中断（softirq）上下文**，不允许调用会睡眠的 API。\n例如不能使用：\n- `msleep()`\n- `mutex_lock()`\n- `copy_to_user()`\n如果要在进程上下文处理，使用 `workqueue` 更合适。\n\n### 7.2. ❓定时器精度是多少？\n\n取决于 `CONFIG_HZ`：\n\n|HZ|定时器最小精度|\n|---|---|\n|100|10ms|\n|250|4ms|\n|1000|1ms|\n\n如果你要亚毫秒或更高精度 → 使用 **hrtimer**。\n\n### 7.3. ❓卸载模块时忘记删除定时器会怎样？\n\n很可能导致：\n- 内核崩溃（使用了已释放的内存）\n- 难以排查的 BUG\n因此，**模块退出务必 `del_timer_sync()`**。\n\n\n### 7.4. ❓内核定时器的时钟源是什么？\n\n- **逻辑源：** `jiffies` (系统滴答计数)。\n- **物理源：**\n\t对于ARM来说，**ARM Generic Timer (Arch Timer)**——ARMv7/v8 架构规范中定义的通用定时器（System Counter），集成在 CPU 内部，频率稳定，是 ARM Linux 的首选。\n- **内核子系统：** **Clock Event Device** (负责产生中断的设备)。\n\n## 8. 更高级：定时器 + 私有数据\n\n如果你需要为每个定时器绑定自己的数据，可以这样：\n\n```c\nstruct my_data {\n    int count;\n    struct timer_list timer;\n};\n\nstatic void my_callback(struct timer_list *t)\n{\n    struct my_data *data = from_timer(data, t, timer);\n    pr_info(\"count = %d\\n\", data->count++);\n}\n\n```\n\n`from_timer()` 在新内核中非常常用。","categories":["Linux","内核编程"]},{"title":"Linux内核中的并发与竞争","url":"/posts/17521/","content":"\n>  **本篇参考**\n> - 【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.81\n> - [一文读懂Linux内核中的并发和竞争 - 知乎 作者：Linux嵌入式](https://zhuanlan.zhihu.com/p/561865798)\n\n## 1. 内核中的并发和竞争简介\n\n在早期的 Linux内核中，并发的来源相对较少。早期内核不支持对称多处理（ symmetric multi processing,SMP），因此，导致并发执行的唯一原因是对硬件中断的服务。这种情况处理起来较为简单，但并不适用于为获得更好的性能而使用更多处理器且强调快速响应事件的系统。\n\n为了响应现代硬件和应用程序的需求， Linux内核已经发展到同时处理更多事情的时代。Linux系统是个多任务操作系统，会存在多个任务同时访问同一片内存区域的情况，这些任务可能会相互覆盖这段内存中的数据，造成内存数据混乱。针对这个问题必须要做处理，严重的话可能会导致系统崩溃。现在的 Linux系统并发产生的原因很复杂，总结一下有下面几个主要原因：\n\n1. **多线程并发访问**:\n\tLinux是多任务（线程）的系统，所以多线程访问是最基本的原因。\n\n2. **抢占式并发访问**：\n\t内核代码是可抢占的，因此，我们的驱动程序代码可能在任何时候丢失对处理器的独占\n\n3. **中断程序并发访问**：\n\t设备中断是异步事件，也会导致代码的并发执行。\n\n4.\t**SMP（多核）核间并发访问**：\n\t现在ARM架构的多核SOC很常见，多核CPU存在核间并发访问。正在运行的多个用户空间进程可能以一种令人惊讶的组合方式访问我们的代码，SMP系统甚至可在不同的处理器上同时执行我们的代码。\n\n对于并发问题的处理方法，我们现在就来介绍最基础的四种。\n\n## 2. 原子操作\n\n### 2.1. 原子操作简介\n\n原子，在早接触到是在化学概念中。原子指化学反应不可再分的基本微粒。同样的，在内核中所说的原子操作表示这一个访问是一个步骤，必须一次性执行完，不能被打断，不能再进行拆分。 例如，在多线程访问中，我们的线程一对a进行赋值操作，a=10，线程二也对a进行赋值操作a=20，我们理想的执行顺序是线程一先执行，线程二再执行。但是很有可能在线程一执行的时候被其他操作打断，使得线程一最后的执行结果变为a=20。要解决这个问题，必须保证我们的线程一在对数据访问的过程中不能被其他的操作打断，一次性执行完成。\n\n![](Snipaste_2025-12-02_22-11-21.png)\n\nLinux 内核定义了叫做 `atomic_t` 的结构体来完成整形数据的原子操作，在使用中用原子变量来代替整形变量，此结构体定义在 include/linux/types.h 文件中，定义如下：\n\n```c\ntypedef struct {\n\tint counter;\n} atomic_t;\n```\n\n如果要使用原子操作 API 函数，首先要先定义一个 atomic_t 的变量，如下所示：\n```c\natomic_t a; //定义 a\n```\n\n也可以在定义原子变量的时候给原子变量赋初值，如下所示：\n```c\natomic_t b = ATOMIC_INIT(0); //定义原子变量 b 并赋初值为 0\n```\n\n### 2.2. 原子操作相关API\n\n#### 2.2.1. 整型原子操作API\n\n| 函数                                                  | 描述                                                 |\n| --------------------------------------------------- | -------------------------------------------------- |\n| `ATOMIC_INIT(int i)`                                | 定义原子变量的时候对其初始化。                                    |\n| `int atomic_read(atomic_t*v)`                       | 读取 v的值，并且返回                                        |\n| `void atomic_set(atomic_t *v, int i)`               | 向 v写入 i值。                                          |\n| `void atomic_add(int i, atomic_t *v)`               | 给 v加上 i值。                                          |\n| `void atomic_sub(int i, atomic_t *v)`               | 从 v减去 i值。                                          |\n| `void atomic_inc(atomic_t *v)`                      | 给 v加 1，也就是自增。                                      |\n| `void atomic_dec(atomic_t *v)`                      | 从 v减 1，也就是自减 。                                     |\n| `int atomic_dec_return(atomic_t *v)`                | 从 v减 1，并且返回v的值 。                                   |\n| `int atomic_inc_return(atomic_t *v)`                | 给 v加 1，并且返回 v的值。                                   |\n| `int atomic_sub_and_test(int i, atomic_t *v)`       | 从 v减 i，如果结果为0就返回真，否则就返回假                           |\n| `int atomic_dec_and_test(atomic_t *v)`              | 从 v减 1，如果结果为0就返回真，否则就返回假                           |\n| `int atomic_inc_and_test(atomic_t *v)`              | 给 v加 1，如果结果为0就返回真，否则就返回假                           |\n| `int atomic_add_negative(int i, atomic_t *v)`       | 给 v加 i，如果结果为负就返回真，否则返回假                            |\n| `int atomic_cmpxchg(atomic_t *v, int old, int new)` | 看 v指向的值是不是 old，如果是，就把它改成 new。否则不改。总是返回v指向的未修改的原始值。 |\n\n> 64位的整型原子操作只是将“atomic_”前缀换成“atomic64_”，将int换成long long。\n\n#### 2.2.2. 位原子操作相关API\n\n| 函数                                         | 描述                     |\n| ------------------------------------------ | ---------------------- |\n| `void set_bit(int nr, void *p)`            | 将p地址的nr位置1             |\n| `void clear_bit(int nr,void *p)`           | 将p地址的nr位清零             |\n| `void change_bit(int nr, void *p)`         | 将p地址的nr位反转             |\n| `int test_bit(int nr, void *p)`            | 获取p地址的nr位的值            |\n| `int test_and_set_bit(int nr, void *p)`    | 将p地址的nr位置1，并且返回nr位原来的值 |\n| `int test_and_clear_bit(int nr, void *p)`  | 将p地址的nr位清0，并且返回nr位原来的值 |\n| `int test_and_change_bit(int nr, void *p)` | 将p地址的nr位翻转，并且返回nr位原来的值 |\n|                                            |                        |\n\n### 2.3. 小实验1\n\n- 实验目的：了解原子操作。\n- 实验内容：实现led灯设备在同一时间只能由一个进程访问。\n- 实验原理：\n\t我们在led设备的数据结构体里添加一个标志位 `busy`，该标志位反应该设备是否被占用，如果被占用则`busy`为1，否则为0。当我们在led的open函数中判断是否被占用以及设定标志位时，如果操作不是原子的，那么可能会出现这种情况：\n\t\t1. ->进程a（第一个访问led）运行到判断语句成功进入未占用分支并准备赋值标志位为1\n\t\t2. ->进程b打断进程a开始运行\n\t\t3. ->进程b运行判断语句并赋值`busy`为1，占用该设备\n\t\t4. ->进程a由于先前已进入未占用分支，则继续赋值标志位为1，占用该设备\n\t为了杜绝这种事发生，我们必须保证判断、修改`busy`标志位这两个步骤是统一的、原子的，不能被打断。\n- 实验步骤：\n\t1. 在led私有变量结构体(struct led_dev)中，定义原子变量busy\n\t2. 在led设备初始化函数中，初始化busy为0：`atomic_set()`\n\t3. 在led设备open函数中，判断、修改busy，这两个操作必须是连续的、不可被打断的：`atomic_cmpxchg()`\n\t4. 则led设备release函数中，重新置busy为0，代表解除占用\n- 实验现象：当一个进程占用led设备时，另一个进程会无法打开该设备，然后退出。（可以自己编写一个程序open设备然后用sleep模拟占用几秒）\n头文件：\n```c\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/string.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/atomic.h>\n\n#define DEV_NAME \"led_atomic\"\n```\n\n<details>\n\n<summary>参考代码，只展示了一些关键代码。</summary>\n\n```c\nstruct led_dev {\n    /*...含各种私有数据，略*/\n    atomic_t busy;  //new: 原子变量\n};\nstatic struct led_dev* led;\nstatic int led_open(struct inode *nd, struct file *fp)\n{\n    struct led_dev* this_devp;\n    this_devp = container_of(nd->i_cdev, struct led_dev, cdev);\n    fp->private_data = this_devp;\n\n    /* atomic_cmpxchg(ptr, old, new):\n     * 看 ptr 指向的值是不是 old，如果是，就把它改成 new。\n     * 返回值：ptr指向的值的原始值。\n     * 如果busy=0，0=old，会将busy改成new值，返回原始值0\n     * 如果busy=1，1!=old，不会改值，返回原始值1\n     * busy!=0的情况：只能是被其他的进程置为1了\n     * busy=0的情况：没有进程占用这个设备，这种情况下会这个函数会将busy=1\n     */\n    if(atomic_cmpxchg(&this_devp->busy, 0, 1) != 0)\n    {\n        printk(KERN_INFO \"this dev is occupied by another guy.\");\n        return -EBUSY;\n    }\n    return 0;\n}\nstatic int led_rel(struct inode *nd, struct file *fp)\n{\n    struct led_dev* this_devp = fp->private_data;\n    /* 释放原子变量 */\n    atomic_set(&this_devp->busy, 0);\n    printk(KERN_INFO \"release！ now busy = %d\", atomic_read(&this_devp->busy));\n    return 0;\n}\n\nssize_t led_read(struct file *, char __user *, size_t, loff_t *)\n{\n    /*...略*/\n}\n\nstatic ssize_t led_write(struct file *fp, const char __user *buf, size_t cnt, loff_t *)\n{\n    /*...略，含控制亮灭的逻辑*/\n}\n\nstatic struct file_operations led_fops = {\n    .open = led_open,\n    .release = led_rel,\n    .read = led_read,\n    .write = led_write\n};\n\nstatic int add_dev(void)\n{\n\t/*...添加字符设备的一般步骤，略*/\n}\n\nstatic __init int led_init(void)\n{\n    int ret = 0;\n    // ！！！！在此处为我们的私有数据结构体分配内存！！！！否则指针指向NULL\n    led = kzalloc(sizeof(*led), GFP_KERNEL);\n    ret = add_dev();\n    if (ret != 0)\n        return ret;\n    /* 初始化原子变量为0 */\n    atomic_set(&led->busy, 0);\n   \n    /*...含查找节点并申请gpio子系统控制gpio，略*/\n   \n    return 0;\n}\n\nstatic __exit void led_exit(void)\n{\n    /*...含各种释放，略*/\n}\n\nmodule_init(led_init);\nmodule_exit(led_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"gdm\");\n```\n</details>\n\n## 3. 自旋锁\n\n### 3.1. 自旋锁简介\n\n自旋锁，顾名思义，我们可以把他理解成厕所门上的一把锁。这个厕所门只有一把钥匙，当我们进去时，把钥匙取下来，进去后反锁。那么当第二个人想进来，必须等我们出去后才可以。当第二个人在外面等待时，可能会一直等待在门口转圈。\n\n我们的自旋锁也是这样，自旋锁只有锁定和解锁两个状态。当我们进入拿上钥匙进入厕所，这就相当于自旋锁锁定的状态，期间谁也不可以进来。当第二个人想要进来，这相当于线程B想要访问这个共享资源但是目前不能访问，所以线程B就一直在原地等待，一直查询是否可以访问这个共享资源（占用CPU）。当我们从厕所出来后，这个时候就“解锁”了，只有再这个时候线程B才能访问。\n\n假如，在厕所的人待的时间太长怎么办？外面的人一直等待吗？如果换做是我们，肯定不会这样，简直浪费时间，可能我们会寻找其他方法解决问题。自旋锁也是这样的，如果线程A持有**自旋锁时间过长，显然会浪费处理器的时间，降低了系统性能**。我们知道CPU最伟大的发明就在于多线程操作，这个时候让线程B在这里傻傻的不知道还要等待多久，显然是不合理的。因此，如果**自旋锁只适合短期持有**，如果遇到需要长时间持有的情况，我们就要换一种方式了（下文的互斥体）。\n\n### 3.2. 自旋锁API\n\n| 函数                                     | 描述                               |\n| -------------------------------------- | -------------------------------- |\n| `DEFINE_SPINLOCK(spinlock_t lock)`     | 定义并初始化一个自旋变量                     |\n| `int spin_lock_init(spinlock_t *lock)` | 初始化自旋锁                           |\n| `void spin_lock(spinlock_t *lock)`     | 获取指定的自旋锁，也叫加锁                    |\n| `void spin_unlock(spinlock_t *lock)`   | 释放指定的自旋锁。                        |\n| `int spin_trylock(spinlock_t *lock)`   | 尝试获取指定的锁，如果没有获取到，返回0             |\n| `int spin_is_locked(spinlock_t *lock)` | 检查指定的自旋锁是否被获取，如果没有被获取返回非0，否则返回0. |\n\n自旋锁是主要为了**多处理器系统**设计的。对于**单处理器且内核不支持抢占的系统**，一旦进入了自旋状态，则会永远自旋下去。\n\n> **注意** 非抢占 ≠ 不切换。非抢占式只是不能在内核中任意抢占，但线程仍然可能主动睡眠、阻塞、被调度切换。\n\n举个例子，线程A获取了锁，A 在持锁状态下被切到进程 B，B 就可能自旋占着 CPU，使 A 无法继续执行释放锁 → 死锁。\n\n因此，在单处理器且内核不支持抢占的系统中，**自旋锁会被设置为空操作**。\n\n以上列表中的函数**适用于SMP或支持抢占的单CPU**下线程之间的并发访问，也就是用于线程与线程之间，被自旋锁保护的临界区**一定不能调用任何能够引起睡眠和阻塞（其实本质仍然是睡眠）的API函数**，否则的话会可能会导致死锁现象的发生。自旋锁会**自动禁止抢占**，也就说当线程A得到锁以后会**暂时禁止内核抢占**。如果线程A在持有锁期间进入了**休眠状态**，那么线程A会**自动放弃CPU使用权**。CPU此时将使用权赋予线程B，线程B开始运行，线程B也想要获取锁，但是此时锁被A线程持有，而且**内核抢占还被禁止了**！线程B无法被调度岀去，那么线程A就无法运行，锁也就无法释放**死锁**发生了！\n\n当线程之间发生并发访问时，如果此时中断也要插一脚，中断也想访问共享资源，那该怎么办呢？首先可以肯定的是，中断里面使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要**先禁止本地中断**（也就是**本CPU中断**，对于多核SOC来说会有多个CPU核），否则可能导致锁死现象的发生。看下下面一个例子：\n\n![](Snipaste_2025-12-03_23-11-21.png)\n\n线程A先运行，并且获取到了lock这个锁，当线程A运行 functionA函数的时候中断发生了，**中断抢走了CPU使用权**。下边的中断服务函数也要获取lock这个锁，但是这个锁被线程A占有着，中断就会一直自旋，等待锁有效。但是在中断服务函数执行完之前，线程A是不可能执行的，线程A说“你先放手”，中断说“你先放手”，场面就这么僵持着死锁发生！\n\n使用了自旋锁之后可以保证临界区不受别的CPU和本CPU内的抢占进程的打扰，但是得到锁的代码在执行临界区的时候，还可能受到中断和底半部的影响，为了防止这种影响，建议使用以下列表中的函数：\n\n| 函数                                                                   | 描述                           |\n| -------------------------------------------------------------------- | ---------------------------- |\n| `void spin_lock_irq(spinlock_t *lock)`                               | 禁止本地中断，并获取自旋锁                |\n| `void spin_unlock_irq(spinlock_t *lock)`                             | 激活本地中断，并释放自旋锁                |\n| `void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)`      | 保存中断状态，禁止本地中断，并获取自旋锁         |\n| `void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)` | 将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁 |\n\n其中 `flags` 就是用于保存中断状态寄存器（具体是哪个个寄存器忘了，反正肯定有个保存中断状态的寄存器）的值。\n\n下半部(BH)也会竞争共享资源，有些资料也会将下半部叫做底半部。如果要在下半部里面使用自旋锁，可以使用这些 API 函数：\n\n`void spin_lock_bh(spinlock_t *lock)`\n关闭下半部，并获取自旋锁。\n\n`void spin_unlock_bh(spinlock_t *lock)`\n打开下半部，并释放自旋锁。\n\n在多核编程的时候，如果进程和中断可能访问同一片临界资源，我们一般需要在进程上下文中调用`spin_lock irqsave()` `spin_unlock_irqrestore()`，在中断上下文中调用 `spin_lock()` `spin_unlock()`。这样，在CPU上，无论是进程上下文，还是中断上下文获得了自旋锁，此后，如果CPU1无论是进程上下文，还是中断上下文，想获得同一自旋锁，都必须忙等待，这避免一切核间并发的可能性。同时，由于每个核的进程上下文持有锁的时候用的是 `spin_lock_irgsave()`，所以该核上的中断是不可能进入的，这避免了核内并发的可能性。\n\n```c\nDEFINE_SPINLOCK(lock) /* 定义并初始化一个锁 */\n/* 线程A */\nvoid functionA ()\n{\n\tunsigned long flags; /* 中断状态 */\n\tspin_lock_irqsave(&lock, flags) /* 获取锁 */\n\t/* 临界区 */\n\tspin_unlock_irqrestore(&lock, flags) /* 释放锁 */\n}\n/* 中断服务函数 */\nvoid irq()\n{\n\tspin_lock(&lock) /* 获取锁 */\n\t/* 临界区 */\n\tspin_unlock(&lock) /* 释放锁 */\n}\n```\n\n### 3.3. 小实验2\n\n我们在小实验1的例子上修改。\n\n- 实验目的：了解自旋锁。\n- 实验内容：实现led灯设备在同一时间只能由一个进程访问。\n- 实验原理：同实验1，只不过我们采用自旋锁来实现判断、赋值的原子性。\n- 实验步骤：\n\t1. 包含头文件 `#include <linux/spinlock.h>`\n\t2. 在led私有变量结构体(struct led_dev)中，定义整形变量busy；定义自旋锁类型 `spinlock_t lock`。\n\t3. 在led设备初始化函数中，初始化busy为0；初始化自旋锁：`spin_lock_init()`。\n\t4. 在led设备open函数中，判断、修改busy前上锁：`spin_lock_irqsave()`，修改完成后释放锁：`spin_unlock_irqrestore()`\n\t5. 则led设备release函数中，上锁，重新置busy为0，释放锁。\n- 实验现象：当一个进程占用led设备时，另一个进程会无法打开该设备。第一个进程占用结束后，进程b才继续运行（可以自己编写一个程序open设备然后用sleep模拟占用几秒\n\n关键的open函数：\n```c\nstatic int led_open(struct inode *nd, struct file *fp)\n{\n    struct led_dev* this_devp;\n    unsigned long flags;\n    this_devp = container_of(nd->i_cdev, struct led_dev, cdev);\n    fp->private_data = this_devp;\n\n    spin_lock_irqsave(&this_devp->spinlock, flags);\n    /* 如果发现该设备已经被占用了： */\n    if(this_devp->busy)\n    {\n        /* 解锁并恢复中断状态 */\n        spin_unlock_irqrestore(&this_devp->spinlock, flags);\n        printk(KERN_INFO \"this dev is occupied by another guy.\");\n        return -EBUSY;\n    }\n\n    this_devp->busy = 1;    //标记占用\n    spin_unlock_irqrestore(&this_devp->spinlock, flags);\n       \n    return 0;\n}\n```\n\n### 3.4. 自旋锁的衍生\n\n在自旋锁的基础上还衍生出了其他特定场合使用的锁，这些锁在驱动中其实用的不多，更多的是在 Linux 内核中使用，本节我们简单来了解一下这些衍生出来的锁。\n\n#### 3.4.1. 读写锁\n\n当临界区的一个文件可以被**同时读取**，但是并**不能被同时读和写**。如果一个线程在读，另一个线程在写，那么很可能会读取到错误的**不完整的数据**。读写自旋锁是可以**允许对临界区的共享资源进行并发读操作的。但是并不允许多个线程并发读写操作**。如果想要并发读写，就要用到了顺序锁。 读写自旋锁的**读**操作函数如下所示：\n\n| 函数                                                                | 描述                          |\n| ----------------------------------------------------------------- | --------------------------- |\n| `DEFINE_RWLOCK(rwlock_t lock)`                                    | 定义并初始化读写锁                   |\n| `void rwlock_init(rwlock_t *lock)`                                | 初始化读写锁                      |\n| `void read_lock(rwlock_t *lock)`                                  | 获取读锁                        |\n| `void read_unlock(rwlock_t *lock`                                 | 释放读锁                        |\n| `void read_unlock_irq(rwlock_t *lock)`                            | 打开本地中断，并且释放读锁               |\n| `void read_lock_irqsave(rwlock_t *lock,unsigned long flags)`      | 保存中断状态，禁止本地中断，并获取读锁         |\n| `void read_unlock_irqrestore(rwlock_t *lock,unsigned long flags)` | 将中断状态恢复到以前的状态，并且激活本地中断，释放读锁 |\n| `void read_lock_bh(rwlock_t *lock)`                               | 关闭下半部，并获取读锁                 |\n| `void read_unlock_bh(rwlock_t *lock)`                             | 打开下半部，并释放读锁                 |\n\n读写自旋锁的**写**操作函数如下所示：\n\n| 函数                                                               | 描述                          |\n| ---------------------------------------------------------------- | --------------------------- |\n| `void write_lock(rwlock_t *lock)`                                  | 获取写锁                        |\n| `void write_unlock(rwlock_t *lock)`                                | 释放写锁                        |\n| `void write_lock_irq(rwlock_t *lock)`                              | 禁止本地中断，并且获取写锁。              |\n| `void write_unlock_irq(rwlock_t *lock)`                            | 打开本地中断，并且释放写锁               |\n| `void write_lock_irqsave(rwlock_t *lock,unsigned long flags)`      | 保存中断状态，禁止本地中断，并获取写锁         |\n| `void write_unlock_irqrestore(rwlock_t *lock,unsigned long flags)` | 将中断状态恢复到以前的状态，并且激活本地中断，释放写锁 |\n| `void write_lock_bh(rwlock_t *lock)`                               | 关闭下半部，并获取写锁                 |\n| `void write_unlock_bh(rwlock_t *lock)`                             | 打开下半部，并释放写锁                 |\n\n示例：\n\n```c\nrwlock_t lock; /* 定义rwlock */\nrwlock_init(&lock); /* 初始化rwlock */\n/* 读时获取锁*/\nread_lock(&lock);\n... /* 临界资源 */\nread_unlock(&lock);\n/* 写时获取锁*/\nwrite_lock_irqsave(&lock, flags);\n ... /* 临界资源 */\n write_unlock_irqrestore(&lock, flags);\n```\n\n#### 3.4.2. 顺序锁\n\n顺序锁是读写锁的优化版本，读写锁不允许同时读写，而使用**顺序锁可以完成同时进行读和写的操作**，**但并不允许同时的写**。虽然顺序锁可以同时进行读写操作，但并不建议这样，读取的过程并不能保证数据的完整性。\n\n顺序锁的**读**操作函数如下所示：\n\n| 函数                                                                 | 描述                            |\n| ------------------------------------------------------------------ | ----------------------------- |\n| `DEFINE_SEQLOCK(seqlock_t sl)`                                       | 定义并初始化顺序锁                     |\n| `void seqlock_ini seqlock_t *sl)`                                    | 初始化顺序锁                        |\n| `void write_seqlock(seqlock_t *sl)`                                  | 顺序锁写操作                        |\n| `void write_sequnlock(seqlock_t *sl)`                                | 获取写顺序锁                        |\n| `void write_seqlock_irq(seqlock_t *sl)`                              | 禁止本地中断，并且获取写顺序锁               |\n| `void write_sequnlock_irq(seqlock_t *sl)`                            | 打开本地中断，并且释放写顺序锁               |\n| `void write_seqlock_irqsave(seqlock_t *sl,unsigned long flags)`      | 保存中断状态，禁止本地中断，并获取写顺序          |\n| `void write_sequnlock_irqrestore(seqlock_t *sl,unsigned long flags)` | 将中断状态恢复到以前的状态，并且激活本地中断，释放写顺序锁 |\n| `void write_seqlock_bh(seqlock_t *sl)`                               | 关闭下半部，并获取写读锁                  |\n| `void write_sequnlock_bh(seqlock_t *sl)`                             | 打开下半部，并释放写读锁                  |\n\n顺序锁的**写**操作函数如下所示：\n\n| 函数                                                         | 描述                                      |\n| ---------------------------------------------------------- | --------------------------------------- |\n| `DEFINE_RWLOCK(rwlock_t lock)`                               | 读单元访问共享资源的时候调用此函数，此函数会返回顺序锁的顺序号         |\n| `unsigned read_seqretry(const seqlock_t *sl,unsigned start)` | 读结束以后调用此函数检查在读的过程中有没有对资源进行写操作，如果有的话就要重读 |\n\n### 3.5. 自旋锁使用注意事项\n\n1. 因为在等待自旋锁的时候处于“自旋”状态，因此锁的持有时间不能太长，一定要短，否则的话会降低系统性能。如果临界区比较大，运行时间比较长的话要选择其他的并发处理方式，比如稍后要讲的信号量和互斥体。\n2. 自旋锁保护的临界区内不能调用任何可能导致线程休眠的API函数，比如copy_from_user（）、copy_to_user（）、kmalloc（）和msleep（）等函数，否则的话可能导致死锁。\n3. 不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己把自己锁死了\n4. 在编写驱动程序的时候我们必须考虑到驱动的可移植性，因此不管你用的是单核的还是多核的SOC，都将其当做多核SOC来编写驱动程序。\n\n> copy_from_user的使用是结合进程上下文的，因为他们要访问“user”的内存空间，这个“user”必须是某个特定的进程。如果在驱动中使用这两个函数，必须是在实现系统调用的函数中使用，不可在实现中断处理的函数中使用。如果在中断上下文中使用了，那代码就很可能操作了根本不相关的进程地址空间。其次由于操作的页面可能被换出，这两个函数可能会休眠，所以同样不可在中断上下文中使用。\n\n## 4. 信号量\n\n### 4.1. 信号量简介\n\n信号量和自旋锁有些相似，不同的是使用自旋锁时：\n- 当前 CPU 会在循环中 **不停检查锁是否释放**\n- **不会睡眠**\n- **不会切换任务**\n- CPU 一直高负载自旋\n而使用信号量时：\n- 当前进程会 **睡眠（TASK_INTERRUPTIBLE）**\n- CPU 让给其他任务\n- 等待唤醒（资源可用 or 收到 signal）\n\n信号量可以指定同时能访问的进程数。比如，有100个停车位的停车场，门口电子显示屏上实时更新的停车数量就是一个信号量，他允许100个车辆访问。当有车开进去，信号量减一，当有车开出来，信号量加一。 信号量具有以下特点：\n\n1. 因为信号量可以使等待资源线程进入休眠状态，因此适用于那些**占用资源比较久**的场合。\n2. 因此信号量不能用于中断中，因为信号量会引起休眠，**中断不能休眠**。\n3. **如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势**。\n\n>在没有激烈锁争用的情况下，自旋锁的性能要大大优于信号量； 因为没有锁拥塞，获取自旋锁的开销仅为几十个CPU周期， 而上下文切换的开销则至少几百/上千个时钟周期，而且操作系统的时间片切换周期还有可能会丢弃几千万个时钟周期。\n 如果拥塞程度很高，或者锁会被长时间持有（有时候真的没办法！），在这种场景下，使用自旋锁则会消耗大量的CPU时间，却什么活都没干。这时候使用信号量（或互斥锁）是一种更好的解决办法，因为没有抢占CPU，其他线程在这段时间内就可以有效运行。\n\n### 4.2. 信号量API\n\n| 函数                                             | 描述                                                          |\n| ---------------------------------------------- | ----------------------------------------------------------- |\n| `DEFINE_SEAMPHORE(name)`                         | 定义一个信号量，并且设置信号量的值为1                                         |\n| `void sema_init(struct semaphore *sem, int val)` | 初始化信号量sem，设置信号量值为val                                        |\n| `void down(struct semaphore *sem)`               | 获取信号量，因为会导致休眠，因此不能在中断中使用                                    |\n| `int down_trylock(struct semaphore *sem);`       | 尝试获取信号量，如果能获取到信号量就获取，并且返回0.如果不能就返回非0，并且不会进入休眠               |\n| `int down_interruptible(struct semaphore`        | 获取信号量，和down类似，只是使用dow进入休眠状态的线程不能被信号打断。而使用此函数进入休眠以后是可以被信号打断的 |\n| `void up(struct semaphore *sem)`                 | 释放信号量                                                       |\n\n### 4.3. 小实验3\n\n我们在小实验1的例子上修改。\n\n- 实验目的：了解信号量。\n- 实验内容：实现led灯设备在同一时间只能由一个进程访问。\n- 实验原理：\n\t进程获取完所有信号量后，其他进程进入休眠状态等待信号量，因此无法访问设备。\n- 实验步骤：\n\t1. 包含头文件 `#include <linux/semaphore.h>`\n\t2. 在led私有变量结构体(struct led_dev)中，定义信号量类型 `struct semaphore sem`。\n\t3. 在led设备初始化函数中，初始化信号量：`sema_init()`。\n\t4. 在led设备open函数中，获取信号量：`down_interruptible()`。\n\t5. 则led设备release函数中，释放信号量：`up()`。\n- 实验现象：当一个进程占用led设备时，另一个进程会进入休眠状态等待信号量。第一个进程占用结束后，进程b才继续运行（可以自己编写一个程序open设备然后用sleep模拟占用几秒）\n\n关键open函数：\n\n```c\nstatic int led_open(struct inode *nd, struct file *fp)\n{\n    struct led_dev* this_devp;\n    this_devp = container_of(nd->i_cdev, struct led_dev, cdev);\n    fp->private_data = this_devp;\n\n    /* 获取信号量，进入休眠等待状态的进程可以被信号打断，不建议用down()，因为在等待信号量的过程中，不可以被信号打断 */\n    if(down_interruptible(&this_devp->sem))\n        return -EBUSY;\n   return 0;\n}\n```\n\n\n## 5. 互斥体\n\n### 5.1. 互斥体简介\n\n互斥体表示一次只有一个线程访问共享资源，**不可以递归申请互斥体**。 信号量也可以用于互斥体，当信号量用于互斥时（即避免多个进程同时在一个临界区中运行），信号量的值应初始化为1.这种信号量在任何给定时刻只能由单个进程或线程拥有。在这种使用模式下，一个信号量有时也称为一个“互斥体（ mutex）”，它是互斥（mutual exclusion）的简称。Linux内核中**几平所有的信号量均用于互斥**。\n\n### 5.2. 互斥体API\n\n| 函数                                               | 描述                               |\n| ------------------------------------------------ | -------------------------------- |\n| `DEFINE_MUTEX(name)`                               | 定义并初始化一个 mutex变量                 |\n| `void mutex_init(mutex *lock)`                     | 初始化 mutex                        |\n| `void mutex_lock(struct mutex *lock)`              | 获取 mutex，也就是给 mutex上锁。如果获取不到就进休眠 |\n| `void mutex_unlock(struct mutex *lock)`            | 释放 mutex，也就给 mutex解锁             |\n| `int mutex_trylock(struct mutex *lock)`            | 判断 mutex是否被获取，如果是的话就返回，否则返回0     |\n| `int mutex_lock_interruptible(struct mutex *lock)` | 使用此函数获取信号量失败进入休眠以后可以被信号打断        |\n\n### 5.3. 小实验4\n\n我们在小实验1的例子上修改。\n\n- 实验目的：了解互斥体。\n- 实验内容：实现led灯设备在同一时间只能由一个进程访问。\n- 实验原理：\n\t进程占用互斥体后，其他进程进入休眠状态等待，因此无法访问设备。\n- 实验步骤：\n\t1. 包含头文件 `#include <linux/mutex.h>`\n\t2. 在led私有变量结构体(struct led_dev)中，定义互斥体类型 `struct mutex lock`。\n\t3. 在led设备初始化函数中，初始化互斥体：`mutex_init()`。\n\t4. 在led设备open函数中，上锁：`mutex_lock()`。\n\t5. 则led设备release函数中，释放锁：`mutex_unlock()`。\n- 实验现象：当一个进程占用led设备时，另一个进程会进入休眠状态等待信号量。第一个进程占用结束后，进程b才继续运行（可以自己编写一个程序open设备然后用sleep模拟占用几秒）\n\n### 5.4. 互斥体的注意事项\n\n互斥体的使用限制和场景基本上和信号量一样。可以近似看作信号量为1的信号量，但是既然单独设计出互斥体这么一个概念，肯定有它独特的地方。\n\n## 6. 总结及常见问题\n\n### 6.1. 自旋锁、信号量、互斥体的主要特性\n\n| 特性       | spinlock | mutex | semaphore |\n| -------- | -------- | ----- | --------- |\n| 临界区可睡眠？  | ❌ 不行     | ✔ 可以  | ✔ 可以      |\n| 可在中断里用？  | ✔ 可以     | ❌ 不行  | ❌ 不行      |\n| 可保护阻塞操作？ | ❌ 不行     | ✔ 可以  | ✔ 可以      |\n| 临界区长短    | 很短       | 可长    | 可长        |\n| 内核等待方式   | 忙等       | 睡眠    | 睡眠        |\n\n### 6.2. 互斥体与信号量的区别\n\n**mutex ≠ semaphore(1)**\n因为 mutex 有严格的“锁所有权（ownership）”语义，而 semaphore 没有。\n\n内核为了实现更安全、可靠的同步机制，引入了 mutex。\n信号量适用范围大但危险，而 mutex 是专为“互斥”设计的安全锁。\n\nmutex 系统中：\n- 如果同一个线程重复 lock，会进入死锁检测路径\n- 如果 unlock 不是 owner，会警告\n- CONFIG_DEBUG_MUTEX 提供完整检测\n\nsemaphore 则完全不管你：\n- 同一线程 down 两次？ → 直接死锁\n- 无 owner unlock → 完全无法检测\n- 无 debug 机制\n\n信号量太“万能”了——所以容易被误用，也更难优化。\n\nmutex 则是：\n- 只用于互斥\n- 更快\n- 更安全\n- 有调试能力\n- 支持优先级继承\n- 语义明确\n\n> **如果你只是想保护一个共享变量，只应该用 mutex，而不是 semaphore。**\n\n这是为什么 Linux 内核在新代码中强烈推荐 mutex，而不是 semaphore(1)。\n\n| 特点     | mutex                    | semaphore(1) |\n| ------ | ------------------------ | ------------ |\n| 专为互斥   | ✔ 是                      | ❌ 不是         |\n| 有严格语义  | ✔ lock/unlock owner 必须一致 | ❌ 无 owner 概念 |\n| 误用时有检测 | ✔ 多重检测                   | ❌ 没检测        |\n| 允许阻塞操作 | ✔                        | ✔            |\n| 性能     | ⭐ 较高                     | ⭐ 普通         |\n| 适用场景   | 保护共享资源                   | 信号同步、多个资源    |\n","categories":["Linux","内核编程"]},{"title":"【点灯大师】设备树和Pinctrl","url":"/posts/64795/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\ncp arch/arm/boot/dts/nxp/imx/imx6ull-14x14-evk-emmc.dts\n\n改个名，代表这是自己的dts文件\n\n添加设备节点\n/{}\n添加pinctrl\n添加gpio\n\n分析uboot逻辑，修改设备树加载命令\nfatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\n\n setenv loadfdt \"tftp ${fdt_addr} imx6ull-gdm-emmc.dtb\"\n\n成功加载，发现有节点。爽飞飞\ncd、ls 检查一下文件\n\n\n\n`of_get_named_gpio()` 是 **Linux 内核设备树（Device Tree）GPIO 子系统**中的一个 API，用于从设备树节点中按名称获取 GPIO 编号，方便驱动程序访问硬件引脚。\n\n---\n\n## 1. 函数原型\n\n##### C\n\n`int of_get_named_gpio(const struct device_node *np,                       const char *propname,                       int index);`\n\n### 参数说明\n\n- **`np`**  \n    指向设备树节点 (`struct device_node *`)，通常通过 `of_find_node_by_*()` 或 `of_parse_phandle()` 获取。\n- **`propname`**  \n    设备树属性名（字符串），例如 `\"gpios\"`、`\"reset-gpios\"` 等。\n- **`index`**  \n    属性中的 GPIO 索引（从 0 开始），用于获取同一属性下的第几个 GPIO。\n\n### 返回值\n\n- **非负整数**：GPIO 全局编号（可直接用于 `gpio_request()` 等 API）。\n- **负数**：错误码，例如：\n    - `-ENOENT`：属性不存在\n    - `-EINVAL`：参数无效\n    - `-EPROBE_DEFER`：驱动延迟探测（依赖的 GPIO 控制器尚未初始化）\n\n---\n\n## 2. 设备树示例\n\n##### Dts\n\n`my_device: my_device@0 {     compatible = \"myvendor,mydevice\";     reset-gpios = <&gpio1 5 GPIO_ACTIVE_LOW>,                   <&gpio2 3 GPIO_ACTIVE_HIGH>; };`\n\n---\n\n## 3. 驱动代码示例\n\n##### C\n\n`#include <linux/of.h> #include <linux/of_gpio.h> #include <linux/gpio.h> #include <linux/err.h>  static int my_driver_probe(struct platform_device *pdev) {     struct device_node *np = pdev->dev.of_node;     int gpio_reset;      // 获取 reset-gpios 属性中的第 0 个 GPIO     gpio_reset = of_get_named_gpio(np, \"reset-gpios\", 0);     if (gpio_reset < 0) {         dev_err(&pdev->dev, \"Failed to get reset GPIO: %d\\n\", gpio_reset);         return gpio_reset; // 返回错误码     }      // 请求 GPIO     if (gpio_request(gpio_reset, \"reset-gpio\")) {         dev_err(&pdev->dev, \"Failed to request reset GPIO\\n\");         return -EBUSY;     }      // 设置为输出并拉高     gpio_direction_output(gpio_reset, 1);      return 0; }`\n\n---\n\n## 4. 注意事项\n\n1. **GPIO 子系统版本差异**\n    - 新内核（4.8+）推荐使用 **GPIO descriptor API**（`gpiod_get()` 等），`of_get_named_gpio()` 属于旧 API，但仍被大量驱动使用。\n2. **错误处理**\n    - 必须检查返回值，避免非法 GPIO 编号导致内核崩溃。\n3. **释放资源**\n    - 使用完 GPIO 后应调用 `gpio_free()` 释放。\n4. **延迟探测**\n    - 如果返回 `-EPROBE_DEFER`，说明依赖的 GPIO 控制器驱动尚未加载，应延迟 probe。\n\n---\n\n✅ **总结**  \n`of_get_named_gpio()` 是驱动中从设备树获取 GPIO 编号的常用接口，适合旧版 GPIO API 场景；新项目建议用 `gpiod_get()` 以获得更好的可移植性和安全性。\n\n---\n\n如果你需要，我可以帮你**把 `of_get_named_gpio()` 的旧写法改成新内核推荐的 `gpiod_get()` 写法**，这样驱动在未来内核版本中更安全可维护。  \n你要我帮你改成新 API 吗？\n\n\n\n","categories":["Linux","记录"]},{"title":"创建一个字符设备与地址映射","url":"/posts/26367/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n> 本篇文章主要讲解创建字符驱动设备的一个代码框架，配置一个GPIO的方式依然是最原始的配置寄存器方式（配合讲解地址映射）。\n\n## 1. 地址映射介绍\n\n### 1.1. 地址映射究竟在干什么？\n\nLinux 世界里，任何外设的寄存器都不允许你“像裸机一样”随便拿地址就写。物理地址只是硬件的地盘，而用户空间、内核空间都活在自己的“虚拟地址”里。\n\n虚拟地址这个东西，只是对 CPU 说的一套语言；真实的电路是物理地址。所以得靠 MMU（内存管理单元）做翻译，把虚拟地址 → 物理地址挂上关系。这一步就叫 **地址映射（memory mapping）**。\n\n简单描述一下：\n\n虚拟地址（进程眼里看到的） → 通过页表（内核维护的一堆数据结构） → 映射到物理地址（板子上的真实寄存器）\n\n**为什么要这么麻烦？**\n\n因为 Linux 要保证：\n\n1. 每个进程互不干扰，不会互相写爆对方。\n2. 不让用户程序直接摸外设，保证系统稳定。\n3. 内核可以把物理地址重新分布，不影响程序。\n\n### 1.2. 那如何访问外设寄存器？\n\n访问寄存器通常需要两步：\n\n1. **获得物理地址**（比如 datasheet 会写某个 GPIO 控制寄存器的地址）\n2. **将物理地址映射成虚拟地址** → 才能读写\n\n在 Linux 内核中，这个动作由 `ioremap()` 完成。\n\n### 1.3. 常用函数\n\n#### 1.3.1. ioremap()\n\n把“物理地址段”映射到“内核虚拟地址空间” 你传入基地址和大小，它返回一段能访问的虚拟地址。\n\n```c\nvoid __iomem *virt = ioremap(phys_addr, size);\n```\n\n#### 1.3.2. iounmap()\n\n释放映射。\n\n#### 1.3.3. readl()/writel()\n\n读写 32bit 寄存器的常用函数。\n\n```c\nvalue = readl(virt_addr + offset);\nwritel(0x1, virt_addr + offset);\n```\n\n比直接解引用指针更安全。\n\n## 2. 创建一个字符设备\n\n### 2.1. step1.定义操作集合\n\n就是大名鼎鼎的 file_operations。让内核知道当用户空间调用open、close等文件操作函数时实际应该怎么操作。\n\n示例：\n\n```c\nstatic struct file_operations led_fops = {\n    .owner = THIS_MODULE,\n    .open = led_open,\n    .read = led_read,// 对应用户空间的 open()\n    .write = led_write,// 对应用户空间的 write()\n    .release = led_release}; // 对应用户空间的 close()\n```\n\n\n需要理清楚这些操作函数与对应用户空间的函数的关系。\n### 2.2. step2.编写实际操作函数\n\n我们确定好要编写哪些操作函数后就可以开始编写了，函数名字要和file_operations里的一样。\n\n> 我们编写实际操作函数时，要填形参，可以进入到“file_operations”的定义里面看操作函数对应的形参。\n\n### 2.3. step3.四个关键结构体\n\n我们首先定义四个关键结构体：\n\n```c\ndev_t devno; // 用于存储设备号\nstruct cdev cdev; //申请一个cdev对象\nstatic struct class *class = NULL; // 类\nstruct device *device //设备节点\n```\n\n我们将其统一包装在一个结构体，作为该设备的私有数据，例如：\n\n```c\nstruct led_dev{\n    dev_t devno;      // 用于存储设备号\n    struct cdev cdev; // 申请一个cdev对象\n    struct class *class; // 类\n    struct device *device; //设备节点\n};\n\nstatic struct led_dev* led_dev;\n```\n\n### 2.4. step4.确定设备号\n\n有两种方式：静态和动态。**用到step3的第一个结构体**。\n\n此步只是 **在内核中预留了数字，没有创建任何对象**；这是字符设备的“身份证号码”。\n\n#### 2.4.1. alloc_chrdev_region()：\n**动态分配**一个未被占用的主设备号，并注册设备号区域。建议使用此方法，避免与现有设备冲突。\n\n用法：\n\n```c\nint alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);\n```\n\n- _*dev：用于返回设备号_\n- _baseminor：指定次设备号起始值_\n- _count：申请的次设备号个数_\n- _name: 设备名称_\n\n#### 2.4.2. register_chrdev_region():\n**静态注册**一个已知的主设备号。如果知道分配给设备的设备号，可以使用此方法.\n\n用法：\n\n```c\nint register_chrdev_region(dev_t from, unsigned count, const char *name)\n```\n\n- *from：设备号，一般在调用之前就得通过一个主设备号和次设备号得到一个设备号*\n- *count: 次设备个数 以major为主设备号，以0~0+count的次设备号*\n- *name: 设备名称*\n\n### 2.5. step5.注册字符设备\n\n此步包含 初始化cdev结构体 和 将设备添加到内核。\n\n#### 2.5.1. cdev_init()\n\n用于初始化我们**step3提供的第二个结构体**，将设备与对应的操作集合（step1、2）绑定。\n\n```c\nvoid cdev_init(struct cdev *, const struct file_operations *);\n```\n\n- _cdev*：字符设备结构体地址_\n- _struct file_operations* ：操作集合地址_\n\n#### 2.5.2. cdev_add()\n\n此步正式将设备添加到内核。\n\n```c\nint cdev_add(struct cdev *, dev_t, unsigned count);\n```\n\n- _cdev*：字符设备结构体地址_\n- *dev_t：设备号*\n- *count：注册的次设备数量*\n\n### 2.6. step5.创建设备节点\n\n向内核添加字符设备后，在用户空间使用仍然不方便，因为它没有暴露接口，也就是`/dev/`目录下没有它的身影。\n\n#### 2.6.1. class_create()\n\n创建设备节点前要求必须有对应的类。它会在在 sysfs 中创建一个类目录。class 本质上只是一个目录 + 一些描述信息。此处用到**step3提供的第三个结构体**。\n\n用法：\n\n```c\nstruct class *class_create(const char *name);\n```\n\n- *name：类名*\n- ***返回**：类结构体指针*\n\n**同一类的设备 = 功能相似、统一管理、统一呈现、自动创建节点**\n\n- sysfs 中统一目录\n- 设备节点命名统一\n- 用户态可自动识别\n- 驱动文件不同也能加入同一类\n- 便于 udev/systemd/应用程序管理设备\n\ntips：\n\n想要将不同设备添加到同一类，可以在申请类的那个初始化文件里提供一个接口函数然后 `extern`，例如：\n\na.c:\n\n```c\nstruct class *my_class;\n\nstruct class *get_my_class(void)\n{\n    return my_class;\n}\n\nstatic int __init main_dev_init(void)\n{\n    my_class = class_create(THIS_MODULE, \"myclass\");\n    if (IS_ERR(my_class))\n        return PTR_ERR(my_class);\n\n    return 0;\n}\n\n```\n\nb.c:\n\n```c\nextern struct class *get_my_class(void);\n\ndevice_create(get_my_class(), NULL, devno, NULL, \"otherdev\");\n\n```\n\n#### 2.6.2. device_create()\n\n正式创建设备节点。**用到step3提供的第四个结构体**\n\n```c\nstruct device *device_create(struct class *cls, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...);\n```\n\n*cls: 类结构体指针*\n*parent：父设备，一般为 NULL*\n*devt：设备号*\n*drvdata：驱动私有数据，可为 NULL*\n*fmt：设备名格式化字符串，即在dev目录下显示的设备名。*\n\n## 3. 销毁一个字符设备\n\n举一反三，不再过多赘述\n销毁需要按创建时的顺序 反顺序销毁。\n\n```c\n//删除设备节点\nvoid device_destroy(const struct class *cls, dev_t devt);\n//删除类\nvoid class_destroy(const struct class *cls)\n//删除字符设备\nvoid cdev_del(struct cdev *);\n//释放设备号\nvoid unregister_chrdev_region(dev_t, unsigned);\n\n```\n\n## 4. 完整示例程序，包含地址映射\n\n注意的细节：goto的错误处理，私有数据。\n\n说明一下使用私有数据后，怎么在open函数中获取这些私有数据：\n\n`container_of`关键宏：已知某个结构体成员的指针，反推出整个结构体的指针。它定义在 `include/linux/kernel.h` 中。\n\n在led_open()中，我们通过`container_of` 反推出 装有cdev成员的 struct led_dev 结构体指针（因为这里的cdev正好是struct led_dev的成员，为什么cdev不是其他结构体的成员呢？因为我们在cdev_add中指定的就是struct led_dev中的cdev的地址），也就是我们在step3中定义的结构体。即私有数据，并将这个指针指向fp的privatedata成员变量。这样read、write就可以通过fp->privatedata访问这些数据。\n\n>使用container_of在几个设备共用一个驱动时更具有通用性。\n\n还有这个常用的函数：\n```c\nunsigned long copy_from_user(void *to, const void __user *from, unsigned long n);\n```\n\n- *to：目标地址（内核空间）*\n- *from：源地址（用户空间）*\n- *n：要拷贝的字节数*\n- *返回值：成功返回0，失败返回未拷贝的字节数*\n\n表示从用户空间拷贝到内核空间，防止用户程序直接访问或修改内核数据结构和硬件资源。\n\n相应的也有\n```c\nunsigned long copy_to_user(void __user *to, const void *from, unsigned long n);\n```\n表示从内核空间复制到用户空间。当目标地址无效时，`copy_to_user`会将目标内核缓冲区清零，防止信息泄漏。\n\n除了上述两个主要函数外，Linux还提供了一系列简化函数：\n\n`get_user`：获取简单变量（char/int/long等）\n`put_user`：写入简单变量\n`get_user/put_user`：不进行地址检查的版本\n这些函数适用于简单数据类型的传输，效率更高。\n\n~~---终于他妈写完了，草--- 写得真是依托。。。。。不管了~~\n\nled.c\n```c\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/io.h> //io映射相关\n#include <linux/uaccess.h>\n#include <asm-generic/int-ll64.h>\n#include <linux/string.h>\n\n#define DEV_NAME \"led\"\n\n// 定义开关状态\n#define LED_OFF 0\n#define LED_ON 1\n\n// 定义寄存器物理地址\n#define CCM_CCGR1_BASE (0X020C406C)\n#define SW_MUX_GPIO1_IO03_BASE (0X020E006C)\n#define SW_PAD_GPIO1_IO03_BASE (0X020E02F8)\n#define GPIO1_DR_BASE (0X0209C000)\n#define GPIO1_GDIR_BASE (0X0209C004)\n\n// 定义映射后的虚拟地址\n\nstatic void __iomem *IMX6U_CCM_CCGR1;\nstatic void __iomem *SW_MUX_GPIO1_IO03;\nstatic void __iomem *SW_PAD_GPIO1_IO03;\nstatic void __iomem *GPIO1_DR;\nstatic void __iomem *GPIO1_GDIR;\n\nstruct led_dev{\n    dev_t devno;      // 用于存储设备号\n    struct cdev cdev; // 申请一个cdev对象\n    struct class *class; // 类\n    struct device *device; //设备节点\n};\n\nstatic struct led_dev* led_dev;\n\nstatic void led_switch(u8 sta)\n{\n    u32 temp = 0;\n    if (sta == LED_ON)\n    {\n        temp = readl(GPIO1_DR);\n        temp &= ~(1 << 4);\n        writel(temp, GPIO1_DR);\n    }\n    else if (sta == LED_OFF)\n    {\n        temp = readl(GPIO1_DR);\n        temp |= (1 << 4);\n        writel(temp, GPIO1_DR);\n    }\n}\n\nstatic int led_open(struct inode *inode, struct file *fp)\n{\n    struct led_dev* this_devp;\n    // container_of:已知某个结构体成员的指针，反推出整个结构体的指针。\n    this_devp = container_of(inode->i_cdev, struct led_dev, cdev);\n    // 指定私有数据，后续read/write函数均可以直接读取\n    fp->private_data = this_devp;\n    printk(KERN_INFO \"led dev open!\");\n    return 0;\n}\n\nstatic ssize_t led_write(struct file *fp, const char __user *buf, size_t cnt, loff_t *offt)\n{\n    int ret;\n    char databuf[5];\n    char* ledstat;\n    ret = copy_from_user(databuf, buf, cnt);\n    if (ret < 0)\n    {\n        printk(KERN_ERR \"kernel write failed!\\n\");\n        return -EFAULT;\n    }\n    ledstat = databuf;\n    if (strcmp(ledstat, \"on\") == 0)\n        led_switch(LED_ON);\n    else if (strcmp(ledstat, \"off\") == 0)\n        led_switch(LED_OFF);\n    else\n    {\n        printk(KERN_ERR \"E: only can write \\\"off\\\" or \\\"on\\\"\\n\");\n        return -1;\n    }\n    return 0;\n}\n\n\nstatic ssize_t led_read(struct file *fp, char __user *buf, size_t nt, loff_t *offt)\n{\n    printk(KERN_INFO \"it's unnecessary to read led!\");\n    return 0;\n}\n\nstatic int led_release(struct inode *, struct file *)\n{\n    printk(KERN_INFO \"led dev release!\");\n    return 0;\n}\n\nstatic struct file_operations led_fops = {\n    .owner = THIS_MODULE,\n    .open = led_open,\n    .read = led_read,\n    .write = led_write,\n    .release = led_release};\n   \nstatic int __init led_init(void)\n{\n    u32 temp = 0;\n    int ret = 0;\n    /* 映射 */\n    IMX6U_CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, 4);\n    SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, 4);\n    SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, 4);\n    GPIO1_DR = ioremap(GPIO1_DR_BASE, 4);\n    GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, 4);\n    /* 设置寄存器值 */\n    /* 1. 使能时钟 */\n    // 这是通用寄存器，最好不要直接写入，要保证其他值不变，否则可能会影响其他外设,以下同理\n    temp = readl(IMX6U_CCM_CCGR1);\n    temp &= ~(3 << 26); // 清除设置\n    temp |= (3 << 26);  // 设定26-27为1，使能时钟\n    writel(temp, IMX6U_CCM_CCGR1);\n    temp = 0;\n    /* 2. 引脚复用为GPIO */\n    writel(5, SW_MUX_GPIO1_IO03);\n    /* 3. 设置电气属性 */\n    writel(0x10b0, SW_PAD_GPIO1_IO03);\n    /* 4. 设置为输出 */\n    temp = readl(GPIO1_GDIR);\n    temp &= ~(1 << 4); // 清除设定\n    temp |= (1 << 4);\n    writel(temp, GPIO1_GDIR);\n    temp = 0;\n    /* 5. 设置为输出低电平（开启LED） */\n    temp = readl(GPIO1_DR);\n    temp &= ~(1 << 4);\n    writel(temp, GPIO1_DR);\n    temp = 0;\n    /* 向系统添加字符设备 */\n    printk(KERN_INFO \"led load!\");\n    /* 获取设备号 */\n    ret = alloc_chrdev_region(&led_dev->devno, 1, 1, DEV_NAME); // 成功后，主设备号存储在MAJOR(devno)，次设备号为1\n    if (ret < 0)\n    {\n        printk(KERN_ERR \"Failed to alloc dev number!\\n\");\n        goto err_alloc;\n    }\n    /* 注册字符设备 */\n    cdev_init(&led_dev->cdev, &led_fops); // 初始化cdev结构体\n    led_dev->cdev.owner = THIS_MODULE;\n    ret = cdev_add(&led_dev->cdev, led_dev->devno, 1); // 此步正式将设备添加到内核\n    if (ret < 0)\n    {\n        printk(KERN_ERR \"Failed to add cdev!\\n\");\n        goto err_cdev;\n    }\n    /* 创建设备节点 */\n    led_dev->class = class_create(\"led\"); // 创建设备节点前要求必须有对应的类\n    if (IS_ERR(led_dev->class))\n    {\n        printk(KERN_ERR \"Failed to create class \\n\");\n        ret = PTR_ERR(led_dev->class); // 设置返回值，否则返回0\n        goto err_class;\n    }\n\n    led_dev->device = device_create(led_dev->class, NULL, led_dev->devno, NULL, DEV_NAME);\n    if (IS_ERR(led_dev->device))\n    {\n        printk(KERN_ERR \"Failed to create device\\n\");\n        ret = PTR_ERR(led_dev->device);\n        goto err_device;\n    }\n    return 0;\nerr_device:\n    class_destroy(led_dev->class);\nerr_class:\n    cdev_del(&led_dev->cdev);\nerr_cdev:\n    unregister_chrdev_region(led_dev->devno, 1); // 释放设备号\nerr_alloc:\n    return ret;\n}\n\nstatic void __exit led_exit(void)\n{   /* 关灯 */\n    led_switch(LED_OFF);\n    /* 取消映射 */\n    iounmap(IMX6U_CCM_CCGR1);\n    iounmap(SW_MUX_GPIO1_IO03);\n    iounmap(SW_PAD_GPIO1_IO03);\n    iounmap(GPIO1_DR);\n    iounmap(GPIO1_GDIR);\n    /* 释放资源 */\n    device_destroy(led_dev->class, led_dev->devno);\n    class_destroy(led_dev->class);\n    cdev_del(&led_dev->cdev);\n    unregister_chrdev_region(led_dev->devno, 1); // 释放设备号\n    printk(KERN_INFO \"led dev closed!\\n\");\n\n}\n\nmodule_init(led_init);\nmodule_exit(led_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"gdm\");\n\n```\n\n测试程序chrdevbaseAPP，用于写入字符串\n\n```c\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n\nint test(const char *argv[])\n{\n    int fd, ret;\n    char readbuf[30], writebuf[30];\n    const char *filename = argv[1];\n    /* 打开 */\n    fd = open(filename, O_RDWR); // 可读可写打开\n    if (fd < 0)\n    {\n        printf(\"E: Can not open %s\\n\", filename);\n        return -1;\n    }\n    /* 读取选项 */\n    if (strcmp(argv[2], \"r\") == 0)\n    {\n        memset(readbuf, 0, sizeof(readbuf));\n        ret = read(fd, readbuf, strlen(writebuf) + 1);\n        if (ret < 0)\n            printf(\"E: read %s filed!\\n\", filename);\n        else\n            printf(\"read data with %d byte: %s \\n\", strlen(readbuf), readbuf);\n    }\n    /* 写入选项 */\n    else if (strcmp(argv[2], \"w\") == 0)\n    {\n        memcpy(writebuf, argv[3], strlen(argv[3]) + 1);\n        ret = write(fd, writebuf, strlen(writebuf) + 1);\n        if (ret < 0)\n            printf(\"E: write %s filed!\\n\", filename);\n        else\n            printf(\"write data with %d byte: %s \\n\", strlen(writebuf), writebuf);\n    }\n    /* 关闭 */\n    ret = close(fd);\n    if (ret < 0)\n    {\n        printf(\"E: Can't close file %s\\n\", filename);\n        return -1;\n    }\n    return 0;\n}\n\nint main(int argc, const char *argv[])\n{\n    printf(\"===%s:now running test APP for chrdevbase===\\n\", argv[0]);\n\n    /* 参数判断 */\n    if (!((argc == 3 && strcmp(argv[2], \"r\") == 0) || (argc == 4 && strcmp(argv[2], \"w\") == 0)))\n    {\n        printf(\"E: wrong usage! now argc = %d! argv[2] = %s\\n usage:\\n\\t read:%s %s r \\n\\t write:%s %s w [str_data]\\n\",\n            argc, argv[2], argv[0], argv[1], argv[0], argv[1]);\n        return -1;\n    }\n\n    test(argv);\n}\n```\n\nMakefile\n```make\n# =========================================================\n\n# Makefile for building a Linux Kernel Module\n\n# Module Name: led\n\n# =========================================================\n\n# KERNEL_SOURCE 指向你的内核源码或头文件路径\n# 如果你使用系统默认内核头，直接用 /lib/modules/$(shell uname -r)/build\n\nKERNEL_SOURCE := /home/gdm/prjts/linux/driver_learning/kernel/linux-imx-lf-6.6.52-2.2.1\nOUTPUT_DIR := $(PWD)/../output\n\n# 模块源文件\nobj-m := led.o  \n# obj-m 用于告诉内核模块系统需要编译 chrdevbase.c 成为模块\n\n# 默认目标\n# 使用内核的 Makefile 来构建模块\n# -C 指定内核源码路径\n# M=$(PWD) 告诉内核在当前目录下查找源文件\nall:\n    arm-none-linux-gnueabihf-gcc -static chrdevbaseAPP.c -o chrdevbaseAPP\n    $(MAKE) -C $(KERNEL_SOURCE) M=$(PWD) modules\n    mv .*.cmd *.mod *mod.c *.o *.symvers *.order $(OUTPUT_DIR)\n\n# 清理生成文件\nclean:\n# 使用内核 Makefile 清理模块相关文件\n    $(MAKE) -C $(KERNEL_SOURCE) M=$(PWD) clean\n    rm chrdevbaseAPP\n    rm $(OUTPUT_DIR)/* $(OUTPUT_DIR)/.*.cmd\n\napp:\n    arm-none-linux-gnueabihf-gcc -static chrdevbaseAPP.c -o chrdevbaseAPP\n\ncleanapp:\n    rm chrdevbaseAPP\n\n```","categories":["Linux","设备驱动程序"]},{"title":"gpio子系统","url":"/posts/45361/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n> 衔接上一篇介绍 Pinctrl 子系统的文章。\n\n## 1. GPIO 子系统简介\n\n如果说 Pinctrl 子系统是负责把“路”铺好（配置引脚模式、电气属性），那么 GPIO 子系统就是负责在路上“跑车”（控制高低电平、读取输入状态）。\n\n对于嵌入式工程师来说，GPIO（通用输入输出）是最简单、最基础，但也是使用频率最高的子系统。\n\n## 2. GPIO 子系统的使用\n\n### 2.1. step0.查阅规范\n\n不多说。上篇文章已经提到过。\n\n### 2.2. step1.在设备树 (DTS) 中描述\n\n>我们默认已经配置好了GPIO控制器节点。一般来说也不需要配置，官方已配置好。如果想要配置GPIO控制器节点，请查阅编写规范文档，官方已给出例子和要求。控制器基地址查阅参考手册。\n\n我们需要告诉内核：这个设备用到了哪个 GPIO，以及它是高电平有效还是低电平有效。\n\n```\n/* 例子：一个由 GPIO 控制的蜂鸣器节点 */\nbeep_device {\n    compatible = \"my-beep-driver\";\n\n    /* 1. 引用 Pinctrl (先铺路) */\n    pinctrl-names = \"default\";\n    pinctrl-0 = <&beep_gpio_pin>;\n\n    /* 2. 定义 GPIO (后跑车) */\n    /* 格式：<&gpio控制器 引脚索引 标志位> */\n    enable-gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;\n};\n```\n\n> 不同厂商写法不同，请对应的参见规范文档。\n\n关于 `enable-gpios` 这个名字：\n- 前缀 “enable” 可以自定义，这是我们后续使用API函数查找这个GPIO的索引关键字。\n- 后缀“-gpios” 是规范的，固定的。\n\n### 2.3. step2.在驱动中调用API函数\n\n请转到第4小节。\n\n## 3. GPIO子系统的工作原理浅析\n\n### 3.1. 系统结构\n\nLinux 内核通过 **gpiolib** 框架统一管理 GPIO。该框架包括三部分：\n\n- **GPIO 控制器驱动**：芯片厂商提供底层的 GPIO 控制器驱动。硬件相关的代码（位于 `drivers/gpio/` 目录），负责初始化和操作具体的 GPIO 控制器，实现了“读寄存器、写寄存器”的具体函数。\n\n- **GPIO 核心库（gpiolib）**：处于中间的连接层。gpiolib 是 Linux GPIO 子系统的核心，它管理着一张大表，维护所有 GPIO 控制器（gpio_chip）、所有 GPIO 描述符（gpio_desc）、控制器之间的映射关系。提供API函数并转换为底层驱动的调用。\n\n- **GPIO 字符设备接口驱动**：也就是我们写的设备驱动。\n\n> Pinctrl 和 GPIO 的底层交互:在某些 SoC 架构中，当你调用`gpiod_direction_output()` 时，GPIO 子系统会在后台自动调用 Pinctrl 子系统的接口，确保引脚复用被强制切回 GPIO 模式。这是一种保险机制，但我们在写 DTS 时，最好还是显式地写清楚 Pinctrl 配置。\n\n### 3.2. 工作流程\n\n一般来说，gpio控制器节点都会有以下两个属性：\n\n- `gpio-controller`：告诉内核这是一个 GPIO 控制器。\n-  `#gpio-cells`：告诉内核控制器使用几个参数描述 GPIO（如编号和 flags），用于解析。\n\n从代码层面看，GPIO 子系统的工作流程其实就是**三个核心结构体**之间的交互：\n\n1. **struct gpio_chip**：代表**硬件控制器**（Provider，厂商写的）。\n2. **struct gpio_desc**：代表**每一个具体的引脚**（Core，内核维护的）。\n3. **struct gpio_ops**：代表**底层操作方法**（读/写寄存器的函数指针）。\n\n#### 3.2.1. 注册阶段：硬件上线 (Provider)\n\n在系统启动时，芯片厂商的驱动加载。它初始化了一个核心结构体 `struct gpio_chip` 并注册给内核。\n\n**核心结构体：struct gpio_chip**\n这是底层驱动与 GPIO 子系统的接口。它包含了“怎么操作硬件”的所有函数指针。\n\n```C\nstruct gpio_chip {\n    const char *label;     // 芯片名字，如 \"gpio-rockchip\"\n    struct module *owner;\n\n    // 核心操作函数指针（这是它的灵魂）\n    int (*get)(struct gpio_chip *gc, unsigned int offset); // 读引脚\n    void (*set)(struct gpio_chip *gc, unsigned int offset, int value); // 写引脚\n    int (*direction_output)(struct gpio_chip *gc, unsigned int offset, int value);\n\n    int base;              // 全局 GPIO 编号基址（现代内核多用 -1 动态分配）\n    u16 ngpio;             // 这个控制器有多少个引脚（比如 32 个）\n    // ...\n};\n\n```\n\n- **动作**：调用 `gpiochip_add_data(chip)`。\n- **结果**：内核收到这个 `chip`，知道有 32 个引脚可用，并为每一个引脚创建了下一步的 `struct gpio_desc`。\n\n#### 3.2.2. 初始化阶段：生成描述符 (Core)\n\n内核为了管理这 32 个引脚，会分配一个数组，数组里存的就是 `struct gpio_desc`。\n\n**核心结构体：struct gpio_desc**\n这是 GPIO 子系统中**最重要**的对象。每一个物理引脚对应一个 `gpio_desc`。\n\n```C\nstruct gpio_desc {\n    struct gpio_device *gdev;  // 指回所属的 gpio_chip/device\n    unsigned long flags;       // 记录状态：是输入还是输出？是 Active Low 吗？有没有被占用？\n    const char *label;         // 谁在使用它？(用于 debug 显示)\n    const char *name;          // 引脚名字\n    // ...\n};\n```\n\n- **状态**：此时这些 `desc` 都在内存里躺着，`flags` 是空的，等待被申请。\n\n#### 3.2.3. 获取阶段：驱动申请 (Consumer)\n\n现在轮到你的驱动代码运行了。\n\n- **你的代码**：`desc = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);`\n- **内核流程**：\n\t- **解析 DTS**：内核依据 `#gpio-cells` 解析设备树，找到 `reset-gpios = <gpio1 5 ...>`\n\t- **定位**：根据 handle 找到对应的 `gpio_chip`（控制器 1），再根据偏移量（5）在数组中找到第 5 个 **struct gpio_desc**。\n\t- **配置 Flags**：读取 DTS 里的 `GPIO_ACTIVE_LOW`，把这个信息记录在 `desc->flags` 里的 `FLAG_ACTIVE_LOW` 位。\n\t- **绑定**：把你的驱动名字填入 `desc->label`（标记占用）。\n\t- **结果**：你拿到了指向这个 **struct gpio_desc** 的指针。\n#### 3.2.4. 控制阶段：函数调用链 (Runtime)\n\n当你调用 `gpiod_set_value(desc, 1)` 时，内核发生了一次完整的“结构体跳跃”：\n\n1. **逻辑判断 (GPIOLIB 层)**：函数 `gpiod_set_value` 接收到你的 `desc` 和 `1`。\n它检查 `desc->flags`：\n\n```C\n// 伪代码逻辑\nif (test_bit(FLAG_ACTIVE_LOW, &desc->flags))\n    value = !value; // 如果是低有效，把逻辑 1 翻转为物理 0\n\n```\n\n2. **硬件操作 (Driver 层)**：它通过 `desc` 找到所属的 `chip`，然后调用 `chip` 里注册的函数指针：\n\n```C\n// 伪代码逻辑\nchip->set(chip, gpio_index, value);\n\n```\n\n3. **寄存器写入**：最终执行到了厂商驱动里具体的代码（例如 `rockchip_gpio_set`），向物理地址写入电平。\n\n#### 3.2.5. 总结\n\n对于工程师来说，只要记住这个链条：\n\n1. **Provider** 提供 **struct gpio_chip**（含操作函数 `set/get`）。\n2. **Core** 维护 **struct gpio_desc**（含状态标志 `flags`，如 Active Low）。\n3. **Consumer** 持有 **struct gpio_desc ***（句柄）。\n4. **调用链**：\n```\ngpiod_set_value()\n⬇️\n检查 desc->flags (处理极性)\n⬇️\n调用 desc->gdev->chip->set() (硬件回调)\n⬇️\nwritel(REG) (物理生效)\n```\n\n## 4. 相关API函数\n\n这些 API 定义在头文件 `#include <linux/gpio/consumer.h>` 中。相比老的 `gpio_` 接口（基于整数索引），`gpiod_` 接口（基于描述符）是目前内核推荐的标准用法。\n\n<p style=\"font-size:25px;color:red\">这部分我写得不太好，请访问——<a herf=\"https://linuxkernel.org.cn/doc/html/latest/driver-api/gpio/consumer.html\">GPIO 描述符消费者接口</a></p>\n\n### 4.1. 核心头文件\n\n在驱动代码中，必须包含：\n\n```C\n#include <linux/gpio/consumer.h>\n```\n\n### 4.2. 获取与释放 (Acquire & Release)\n\n在驱动的 `probe` 函数中，我们需要获取 GPIO 的句柄（Descriptor）。\n\n#### 4.2.1. A. 资源托管方式 (推荐)\n\n使用 `devm_` 前缀的函数，驱动卸载时内核会自动释放 GPIO，无需手动调用 `put`，防止内存泄漏。\n\n- **devm_gpiod_get**:\n```C\nstruct gpio_desc *devm_gpiod_get(struct device *dev, const char *con_id, enum gpiod_flags flags);\n```\n\n **功能**：获取一个 GPIO 描述符。\n **参数**：\n\t- **dev**: 设备指针 (通常是 &pdev->dev)。\n\t- **con_id**: 字符串 ID。对应 DTS 中的 xxx-gpios 中的 xxx。如果传 NULL，则匹配 gpios 属性。\n\t- **flags**: 初始化标志（见下文）。\n**返回值**：成功返回描述符指针；失败返回 ERR_PTR。\n\n- **devm_gpiod_get_optional**:\n```C\nstruct gpio_desc *devm_gpiod_get_optional(struct device *dev, const char *con_id, enum gpiod_flags flags);\n```\n\n**功能**：同上，但如果 DTS 里没有定义这个 GPIO，它**不会报错**，而是返回 `NULL`。\n**场景**：用于某些非必须的功能（例如：有的板子有 LED，有的没有，驱动想兼容两者）。\n\n#### 4.2.2. B. 初始化标志 (Flags)\n\n在获取 GPIO 时，可以直接指定初始状态：\n\n- `GPIOD_ASIS`: 不改变当前状态（保持原样）。\n- `GPIOD_IN`: 配置为输入。\n- `GPIOD_OUT_LOW`: 配置为输出，且初始值为**逻辑低**（关闭）。\n- `GPIOD_OUT_HIGH`: 配置为输出，且初始值为**逻辑高**（开启）。\n\n### 4.3. 读写控制 (Read & Write)\n\n拿到 `struct gpio_desc *` 指针后，就可以操作它了。\n\n#### 4.3.1. A. 设置输出值\n\n- **gpiod_set_value**\n```C\nvoid gpiod_set_value(struct gpio_desc *desc, int value);\n```\n\n**功能**：设置 GPIO 输出电平。\n**参数 value**：\n\t- 1: 设置为 **逻辑有效 (Active)**。\n\t- 0: 设置为 **逻辑无效 (Inactive)**。\n**注意**：内核会自动处理“高电平有效”还是“低电平有效”。如果 DTS 定义了 `GPIO_ACTIVE_LOW`，你写 `1`，实际物理引脚会输出低电平。\n\n#### 4.3.2. B. 读取输入值\n\n- **gpiod_get_value**\n```C\nint gpiod_get_value(const struct gpio_desc *desc);\n```\n\n**功能**：读取 GPIO 当前电平。\n**返回值**：`1` 表示逻辑有效，`0` 表示逻辑无效。\n\n#### 4.3.3. C. 修改方向\n\n- `int gpiod_direction_input(struct gpio_desc *desc)`\n- `int gpiod_direction_output(struct gpio_desc *desc, int value)`\n\n### 4.4. 睡眠与原子操作 (Sleeping vs Atomic)\n\n这是一个容易踩坑的地方。\n\n- **SoC 内部 GPIO**：读写速度极快，可以在中断上下文（Atomic Context）中调用。\n- **扩展芯片 GPIO (如 I2C/SPI 扩展器)**：读写需要通过 I2C/SPI 总线，耗时较长，**会引起睡眠**，不能在中断或自旋锁中调用。\n\n为了代码的健壮性，如果你不确定 GPIO 是 SoC 内部的还是外部扩展的，或者你在非原子上下文（如线程化的中断、工作队列、普通进程），**建议使用 cansleep 后缀的函数**：\n\n- `gpiod_set_value_cansleep(desc, value)`\n\n- `gpiod_get_value_cansleep(desc)`\n\n>如果你的 GPIO 确实连在 I2C 扩展器上，而你用了普通的 gpiod_set_value，内核会打印警告栈回溯 (WARN_ON)。\n\n### 4.5. 中断相关 (Interrupts)\n\n如果要把 GPIO 当作中断源（比如按键）：\n\n- **gpiod_to_irq**\n```C\nint gpiod_to_irq(const struct gpio_desc *desc);\n```\n\n**功能**：将 GPIO 描述符转换为 Linux 中断号 (IRQ Number)。\n**用法**：拿到返回值 `irq` 后，传给 `request_irq()` 或 `devm_request_threaded_irq()` 来注册中断服务函数。\n\n### 4.6. 常用API函数总结\n\n| **功能**   | **普通 API (原子上下文)**       | **允许睡眠 API (进程上下文)**       |\n| -------- | ------------------------ | -------------------------- |\n| **设置值**  | `gpiod_set_value`        | `gpiod_set_value_cansleep` |\n| **读取值**  | `gpiod_get_value`        | `gpiod_get_value_cansleep` |\n| **设置方向** | `gpiod_direction_output` | N/A (通常初始化时设定)             |\n| **转中断号** | `gpiod_to_irq`           | N/A                        |\n| **获取句柄** | `devm_gpiod_get`         | N/A                        |\n","categories":["Linux","设备驱动程序"]},{"title":"pinctrl子系统","url":"/posts/30124/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 1. Linux 内核 Pinctrl 子系统简介\n\n现代 SoC 中的 GPIO 引脚通常具有多功能（多路复用）属性，例如一个引脚既可以用作通用 GPIO，也可以用作某个外设（如 UART、I2C、SPI 等）的信号线。传统做法需要驱动直接访问寄存器完成引脚功能和属性配置，但这种方式繁琐且易错。为此，Linux 内核引入了 pinctrl（pin control）子系统，负责解析设备树中的引脚配置，并在系统启动时自动完成引脚的复用和电气属性设置。换言之，开发者只需在设备树中描述引脚功能和特性，pinctrl 子系统就会在后台枚举所有可控引脚、设置对应的复用模式和上下拉、驱动强度等电气特性，从而简化驱动开发过程。\n\n综上，我们现在总结出 **Pinctrl 的两大核心任务**：\n1. **引脚复用 (Pin Muxing)：** 决定某个物理引脚当前是作为普通 GPIO，还是作为 UART 的 TX 线，或者是 I2C 的 SCL 线。\n2. **引脚配置 (Pin Configuration)：** 设置引脚的电气特性，例如：上拉/下拉电阻、驱动能力（电流大小）、防抖动等。\n\n## 2. 理解 Pinctrl\n\n理解 Pinctrl，需要掌握以下几个关键概念。我们尽量避开复杂的 C 语言结构体，从逻辑层面来理解：\n\n### 2.1. 关键术语\n\n- **Pin（引脚）：** 芯片上最小的物理单元。\n- **Group（引脚组）：** 有些功能需要多个引脚配合（例如 I2C 需要 SCL 和 SDA 两根线）。我们将这两根线打包，称为一个 Group。\n- **Function（功能）：** 这一组引脚要干什么？是做 `i2c0`，还是做 `uart1`？这就是 Function。\n- **State（状态）：** 这是应用层最常接触的概念。一个设备可能有多种状态，最常见的是：`default`：设备正常工作时的引脚配置。`sleep`：设备休眠时，为了省电，将引脚配置为低功耗模式（如断开连接或弱下拉）。\n\n### 2.2. 用于Pinctrl的设备树节点\n\n一般来说，要使用pinctrl，在设备树里面会有一个节点专门来描述 PIN 的配置信息。\n\n对于不同厂商，这个节点的命名是不同的，比如有些直接以“pinctrl”命名，而像imx6系列就是以“iomuxc”来命名的。\n\n我们以 nxp 的 imx6ull 为例，来看看这个节点定义在哪里（本篇均以该SoC为例）。它这个包含关系比较抽象，这个节点的定义在\n`arch/arm/boot/dts/nxp/imx/imx6ul.dtsi`\n\n具体包含关系是这样的：imx6ull-14x14-evk-emmc.dts(最终使用的设备树文件) -> imx6ull-14x14-evk.dts -> imx6ull.dtsi -> imx6ul.dtsi\n\n那么在 imx6ul.dtsi 文件中具体代码是这样写的：\n\n```\nsoc: soc{\n...\n\tiomuxc: pinctrl@20e0000 {\n\t\tcompatible = \"fsl,imx6ul-iomuxc\";\n\t\treg = <0x020e0000 0x4000>;\n\t};\n...\n}\n```\n\n我们向这个节点添加我们想要的配置，pinctrl 系统就能自动配置引脚属性，我们这个SoC就在 `arch/arm/boot/dts/nxp/imx/imx6ul-14x14-evk.dtsi` 这个文件里面添加了许多引脚配置信息：\n\n```\n...\n&iomuxc {\n    pinctrl-names = \"default\";\n\n    pinctrl_camera_clock: cameraclockgrp {\n        fsl,pins = <\n            MX6UL_PAD_CSI_MCLK__CSI_MCLK        0x1b088\n        >;\n    };\n   \n    pinctrl_csi1: csi1grp {\n        fsl,pins = <\n            MX6UL_PAD_CSI_PIXCLK__CSI_PIXCLK    0x1b088\n            MX6UL_PAD_CSI_VSYNC__CSI_VSYNC      0x1b088\n            MX6UL_PAD_CSI_HSYNC__CSI_HSYNC      0x1b088\n            MX6UL_PAD_CSI_DATA00__CSI_DATA02    0x1b088\n            MX6UL_PAD_CSI_DATA01__CSI_DATA03    0x1b088\n            MX6UL_PAD_CSI_DATA02__CSI_DATA04    0x1b088\n            MX6UL_PAD_CSI_DATA03__CSI_DATA05    0x1b088\n            MX6UL_PAD_CSI_DATA04__CSI_DATA06    0x1b088\n            MX6UL_PAD_CSI_DATA05__CSI_DATA07    0x1b088\n            MX6UL_PAD_CSI_DATA06__CSI_DATA08    0x1b088\n            MX6UL_PAD_CSI_DATA07__CSI_DATA09    0x1b088\n        >;\n    };\n...\n};\n...\n```\n\n### 2.3. Pinctrl 的实现\n\n#### 2.3.1. Pinctrl Provider（服务端）\n\n通常由芯片厂商（如瑞芯微、恩智浦、高通）编写的驱动。它知道芯片底层每一个寄存器怎么写，知道“引脚A”怎么切换成“功能B”。**我们通常不需要写这部分代码，只需使用。**\n\n这部分就相当于 pinctrl 的驱动程序，本质就是使用of函数搜索设备节点，找到用于pinctrl的设备节点，并根据该节点里的子节点信息来配置寄存器，具体的实现我们就不去深究了，附一张调用链图，来自正点原子：\n\n![](Snipaste_2025-11-24_15-21-27.png)\n\n\n#### 2.3.2. Pinctrl Consumer（客户端）\n\n这是我们需要关心的部分。具体的设备驱动（如 UART 驱动、LED 驱动）就是客户端。它们向 Pinctrl 子系统发出申请：“我要用这组引脚，帮我切到 UART 模式。”\n\n#### 2.3.3. 总结\n\n从原理上看，pinctrl 子系统分为**核心层（core）** 和 **控制器驱动层（provider）** 、**客户端层（consumer）**。\n\n内核启动时，pinctrl core 会扫描设备树，收集所有 pin 控制器节点和它们定义的引脚组。\n\n各 SoC 厂商提供的 pinctrl 驱动（位于 `drivers/pinctrl/` 目录）负责与具体硬件交互。在驱动 probe 阶段，pin 控制器驱动会根据设备树提供的组配置向硬件寄存器写入正确的复用模式和引脚参数。这样，无论是 GPIO、UART、SPI 等功能，只要设备树指定了 pinctrl 组和状态，内核都会在初始化时调用对应驱动完成配置。\n\n用户态程序或驱动只需通过抽象好的接口申请和切换状态，而不必关心寄存器细节。\n\n总体上，pinctrl 子系统实现了“设备树描述 → pin 配置 → 驱动使用”这一流程的统一化管理，让引脚配置从驱动代码中解耦，提升了代码可移植性和可维护性。\n\n### 2.4. Pinctrl 的工作流程\n\nPinctrl 子系统在内核中起到了“中间人”的作用，它屏蔽了底层硬件的复杂性。\n\n**流程如下：**\n\n1. **系统启动**：Linux 内核解析设备树（DTS）。\n2. **设备加载**：当一个设备驱动（比如 I2C 驱动）加载时，内核会检查该设备在设备树中关联的 Pinctrl 信息。\n3. **自动申请**：在驱动的 `probe` 阶段，驱动核心（Driver Core）会自动向 Pinctrl 核心申请将该设备的引脚切换到 `default` 状态。\n4. **底层执行**：Pinctrl 核心找到对应的Pinctrl驱动（Provider），写入寄存器，完成复用和电气配置。 **这就意味着，作为驱动开发者，你甚至不需要在 C 代码里写一行关于配置引脚的代码，一切都已经在设备树加载时自动完成了。**\n\n## 3. 使用 Pinctrl （以IMX6ULL为例）\n\n### 3.1. step0.查阅编写说明书\n\n要使用 Pinctrl ，必不可少的就是我们在前面介绍设备树一文中提到的编写规范文档，**必须按照编写规范来写！** 对于本文使用的SoC来说，这个文档就是 `Documentation/devicetree/bindings/pinctrl/fsl,imx6ul-pinctrl.txt`\n\n原文是这样描述的：\n\n```\n* Freescale i.MX6 UltraLite IOMUX Controller\n\nPlease refer to fsl,imx-pinctrl.txt in this directory for common binding part\nand usage.\n\nRequired properties:\n- compatible: \"fsl,imx6ul-iomuxc\" for main IOMUX controller or\n  \"fsl,imx6ull-iomuxc-snvs\" for i.MX 6ULL's SNVS IOMUX controller.\n- fsl,pins: each entry consists of 6 integers and represents the mux and config\n  setting for one pin.  The first 5 integers <mux_reg conf_reg input_reg mux_val\n  input_val> are specified using a PIN_FUNC_ID macro, which can be found in\n  imx6ul-pinfunc.h under device tree source folder.  The last integer CONFIG is\n  the pad setting value like pull-up on this pin.  Please refer to i.MX6 UltraLite\n  Reference Manual for detailed CONFIG settings.\n\n```\n\n翻译如下：\n\n```\n* Freescale i.MX6 UltraLite IOMUX 控制器\n\n本目录中的 fsl,imx-pinctrl.txt 文件提供了通用绑定部分及使用说明，请参考该文档。\n\n必需属性：\n- compatible：\n  主 IOMUX 控制器应使用 \"fsl,imx6ul-iomuxc\"，\n  i.MX6ULL 的 SNVS IOMUX 控制器则使用 \"fsl,imx6ull-iomuxc-snvs\"\n- fsl,pins：\n  每个条目由6个整数组成，代表单个引脚的多路复用和配置设置。\n  前5个整数 <mux_reg conf_reg input_reg mux_val input_val>\n  使用 PIN_FUNC_ID 宏定义（该宏定义位于设备树源文件夹下的 imx6ul-pinfunc.h 文件中），\n  最后一个整数 CONFIG 为焊盘配置值（例如该引脚的上拉设置）。\n  详细 CONFIG 设置请参阅 i.MX6 UltraLite 参考手册。\n```\n\n意思是你要在pinctrl节点下添加你的pin配置，你必须有两个属性：\n- compatible：**这是主控制器也就是IOMUXC节点所需属性，子节点无需指定。**\n\t- 如果使用主 IOMUX 控制器，值必须为“fsl,imx6ul-iomuxc”。\n\t- 如果使用 SNVS IOMUX 控制器，值必须为“fsl,imx6ull-iomuxc-snvs”\n- fsl,pins：**子节点必需属性。** 由6个寄存器值组成，前5个值已被官方包装为宏定义，最后一个寄存器值需要我们手动设置。\n\n它还提到这个宏定义就在 `imx6ul-pinfunc.h`，我们截取一段看看，就拿一个GPIO的配置来看一下吧：\n\n```\n#define MX6UL_PAD_GPIO1_IO04__GPIO1_IO04        0x006c 0x02f8 0x0000 5 0\n```\n\n这五个数是这样组织的:\n\n| **名字** | **mux_reg**   | **conf_reg**  | **input_reg** | **mux_val** | **input_val** |\n| ------ | ------------- | ------------- | ------------- | ----------- | ------------- |\n| **值**  | 0x006c        | 0x02f8        | 0             | 5           | 0             |\n| **意义** | 引脚复用寄存器相对偏移地址 | 引脚配置寄存器相对偏移地址 | 输入选择控制寄存器偏移地址 | 引脚复用寄存器值    | 输入选择控制寄存器值    |\n\n**备注：**\n1. 相对 主io控制器 iomuxc 的地址 0x020e0000 偏移。\n2. 输入选择寄存器为0，为无效值，表示这个配置不需要输入选择。\n3. 什么时候需要输入选择寄存器呢？假设芯片内部有一个 UART1_RX（串口1接收）信号。根据芯片设计，这个 UART1_RX 信号可能可以从 GPIO1_IO01 这个引脚输入，也可以从 GPIO1_IO02 这个引脚输入。这两个引脚都具备复用为 UART1_RX 的能力。这个寄存器的作用就是指定输入路径。\n4. 写入寄存器的这些值是厂商帮我们写好了的，填入这些值到相应的寄存器，引脚就能复用为我们想要的功能。我们再也不需要去找寄存器、看位定义了！\n5. 擅长找规律的同学肯定注意到了，第六个值，也就是自己配置的值其实就是 conf_val。\n\n不同的厂商有不同的编写方式，但通过阅读厂商为我们写好的编写文档，我们就可以很快速的跟上厂商的节奏。\n\n### 3.2. step1.在 Pinctrl 节点中定义引脚配置\n\n首先，在 SoC 厂商提供的 pinctrl 节点下，定义你需要的引脚组。\n\n```DTS\n&iomuxc {\n\tpinctrl_i2c1: i2c1grp {\n\t\tfsl,pins = <\n\t\t\tMX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x4001b8b0\n\t\t\tMX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x4001b8b0\n        >;\n\t};\n};\n```\n\n> 不同厂商的语法（如 rockchip,pins 或 fsl,pins）略有不同，但逻辑一致。\n\n### 3.3. step2.在设备节点中引用 Pinctrl\n\n接下来，在你具体的设备节点中，告诉内核：“我要用上面定义的那些引脚”。\n\n```DTS\n&i2c1 {\n    status = \"okay\";\n\n    /* 1. 指定引脚配置名称列表 */\n    pinctrl-names = \"default\";\n\n    /* 2. 引用步骤一中定义的句柄 */\n    pinctrl-0 = <&pinctrl_i2c1>;\n};\n```\n\n**代码解读：**\n\n- `pinctrl-names = \"default\"`：告诉内核，这组配置叫 \"default\"。内核加载驱动时，会自动查找并激活名为 \"default\" 的配置。\n- `pinctrl-0 = <&pinctrl_i2c1>;`：这对应着 \"default\" 状态下具体的硬件引脚设置。\n\n### 3.4. 进阶：多状态切换（休眠模式）\n\n如果你的设备支持电源管理，你可以定义两个状态：\n\n```DTS\n&some_device {\n    pinctrl-names = \"default\", \"sleep\"; /* 定义了两个名字 */\n    pinctrl-0 = <&pin_conf_active>;     /* default 对应这组 */\n    pinctrl-1 = <&pin_conf_sleep>;      /* sleep 对应这组 */\n};\n```\n\n当设备驱动调用 `pinctrl_pm_select_sleep_state()` 时，引脚会自动切换到 `pinctrl-1` 指定的配置（例如关闭上拉电阻以省电）。\n\n## 4. 总结\n\nLinux Pinctrl 子系统虽然底层复杂，但对应用和驱动开发者的接口非常友好。\n\n- **核心作用：** 管理引脚复用（Mux）和电气配置（Config）。\n- **工作方式：** 基于设备树（DTS）描述，内核自动在驱动加载时应用。\n- **你的任务：** 作为开发者，你主要的工作是**查阅芯片手册**，确定引脚功能，然后在**设备树**中正确填写 `pinctrl-names` 和 `pinctrl-0`。\n\n","categories":["Linux","设备驱动程序"]},{"title":"VSCODE-Linux驱动开发环境设置","url":"/posts/2591/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\nVSCODE的C/C++插件对于在Linux源码环境下的Linux驱动开发支持并不是很好，主要体现在文件查找和错误的“错误提示”（红色波浪线真的逼死强迫症，本篇记录一下对VSCODE的环境设置。\n\n此篇主要介绍\n\n1. 指定内核源码路径\n2. 指定编译器路径\n3. 添加一些宏定义让编辑器不再错误地划红色波浪线（“报错”）\n\n## 配置\n\n通过这个按钮选择配置集或打开设置：\n\n![](Snipaste_2025-11-23_19-50-49.png)\n\n具体的设置大概是这样，这里我新建了一个配置集 `linux-arm`\n\n![](Snipaste_2025-11-23_19-51-13.png)\n![](Snipaste_2025-11-23_19-53-24.png)\n\n如果使用json设置的话：（c_cpp_properties.json）\n\n```json\n{\n    \"configurations\": [  \n        {\n            \"name\": \"Linux-arm\",\n            \"includePath\": [\n                \"${workspaceFolder}/**\",\n                \"/home/gdm/prjts/linux/driver_learning/kernel/linux-imx-lf-6.6.52-2.2.1/include/**\",\n                \"/home/gdm/prjts/linux/driver_learning/kernel/linux-imx-lf-6.6.52-2.2.1/arch/arm/include/**\"\n            ],\n            \"defines\": [\n                \"__KERNEL__\",\n                \"__GNUC__\",\n                \"MODULE\"\n            ],\n            \"compilerPath\": \"/home/gdm/prjts/ARM_TOOLCHAIN/AArch32-BareMetal/arm-none-eabi-PATH/arm-none-eabi-gcc\",\n            \"cStandard\": \"gnu11\",\n            \"cppStandard\": \"gnu++17\",\n            \"intelliSenseMode\": \"linux-gcc-x64\",\n            \"mergeConfigurations\": false,\n            \"recursiveIncludes\": {},\n            \"browse\": {\n                \"limitSymbolsToIncludedHeaders\": true\n            }\n        }\n    ],\n    \"version\": 4\n}\n```\n\n\n## 注意的要点\n\n### 1. 编译器路径指定\n\n指定用于编译裸机的交叉编译器！比如我的ARM官方工具链的用于裸机编译的 `arm-none-eabi-gcc` 。这个指定编译器不重要，真正用于编译的是我们在linux内核源码的makefile里指定的编译器，只是VSCODE要在这个编译器的路径下找一些头文件啥的，如果你使用带有linux目录的编译器的话，比如 `arm-none-linux-eabihf-gcc`，它的目录下有linux文件夹，而VSCODE优先搜索编译器路径，会导致跳转的文件不是指定的源码路径下的文件。还会提示找不到文件。。。。\n\n### 2. 指定一些宏定义避免VSCODE错误地划红色波浪线\n\n指定上图的三个宏定义，否则VSCODE会错误地画红色波浪线（编译可通过，但是VSCODE报错。\n\n### 3. 包含的路径\n\n一般包含：\n\n- linux源码根目录下的 `include`\n- 对应架构下的 `include`","tags":["VSCODE","开发环境"],"categories":["Linux","设备驱动程序"]},{"title":"dts设备树入门","url":"/posts/50610/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 1. 设备树简介\n\n### 1.1. 什么是设备树\n\n在 Linux 内核（特别是 ARM 架构）开发中，设备树（Device Tree）是描述硬件信息的“地图”。它的核心目的是**将硬件描述与驱动代码分离**。\n\n简单来说：\n- **以前**：你在 `.c` 代码里写死“这个引脚是 GPIO 5，内存地址是 0x1000”。\n- **现在**：驱动代码只写逻辑（“我要读取一个 GPIO”），而具体的“GPIO 5”写在设备树文件（`.dts`）里。\n\n设备树可以理解为**一个硬件描述文件：告诉内核板级外设的位置、参数、使用方式。**\n\n例如：\n- GPIO 属于哪个控制器？\n- 串口 1 的寄存器基地址在哪里？\n- I2C 的速度是多少？\n- 一个 LED 接在哪个 GPIO 引脚？\n\n这些都通过设备树告诉内核。\n### 1.2. 设备树的由来\n\n在 2011 年之前（Linux 3.x 版本之前），ARM 架构的 Linux 内核源码中并没有设备树。那时候，描述板子硬件信息是直接写在 C 文件里的。本来ARM架构的板子就多，还他妈每个板子都要提交一个硬件描述文件，而且硬件描述文件大部分都是一些硬件地址的结构体，同一厂家生产的SoC提交的硬件描述文件还有很多重复的内容。\n\n在这种情况下，Linux 之父 Linus Torvalds 在检查 ARM 架构的代码合并请求时，终于忍无可忍。他在邮件列表里发出了那封著名的邮件，痛斥 ARM 社区：\n\n> **\" This whole ARM thing is a f*cking pain in the ass.\"** (\"这整个 ARM 的东西简直就是屁股上的痛（极其痛苦）。\")\n\n他指出 ARM 社区没有像 x86 那样有统一的硬件描述标准（x86 有 BIOS/ACPI），导致内核充斥着无关紧要的板级细节。他威胁说，如果不解决这个问题，就不再合并 ARM 的代码。\n\n面对 Linus 的压力，ARM 社区的大佬们开始寻找解决方案。他们将 PowerPC 的这套机制移植到了 ARM 架构上。从此，硬件描述不再写在 C 代码里，而是写在独立的文本文件（`.dts`）里，经过单独编译成二进制（`.dtb`），由 Bootloader 传给内核。\n\n我们还可以注意到即使是现在的6.x内核，其源码目录中的 `/linux/arch/arm/mach-xxx` 仍有许多.c文件，这些文件并不是硬件描述文件，而是负责让 SoC 能够正常启动并运行内核。比如CPU 初始化、timer 初始化、中断控制器初始化、电源管理等等。\n\n## 2. 核心文件类型\n\n在使用设备树之前，需要区分三种文件后缀：\n\n| **后缀**    | **全称**                     | **作用**                        | **类比**      |\n| --------- | -------------------------- | ----------------------------- | ----------- |\n| **.dts**  | Device Tree Source         | 板级定义文件，描述具体的电路板硬件。            | `.c` 源文件    |\n| **.dtsi** | Device Tree Source Include | SoC 级或**通用**的头文件，可被多个 dts 复用。 | `.h` 头文件    |\n| **.dtb**  | Device Tree Blob           | 编译后的二进制文件，Bootloader 会把它传给内核。 | `.o` 或可执行文件 |\n\n> 一般 .dtsi 文件用于描述 SOC 的内部外设信息，比如 CPU 架构、主频、外设寄存器地址范围，比如 UART、IIC 等等。这些信息在某些板子上是通用的，比如 imx6ul-14x14-evk.dtsi 就被 I.MX6ULL 的 dts 文件包含。\n\n## 3. 编译设备树\n\n在 Linux 内核源码中，ARM 架构的设备树通常位于 `arch/arm/boot/dts/` (或 `arch/arm64/boot/dts/`)。\n\n我们打开 `arch/arm/boot/dts/nxp/imx/Makefile`\n\n这里的 Makefile 就记录了该平台下所有板子的设备树文件：\n\n```make\n...\n\ndtb-$(CONFIG_SOC_IMX6UL) += \\\n    imx6ul-14x14-evk.dtb \\\n    imx6ul-ccimx6ulsbcexpress.dtb \\\n    imx6ul-ccimx6ulsbcpro.dtb \\\n    imx6ul-geam.dtb \\   \n...\n```\n\n可以看出，当选中 I.MX6ULL 这个 SOC 以后(CONFIG_SOC_IMX6ULL=y)，所有使用到\nI.MX6ULL 这个 SOC 的板子对应的.dts 文件都会被编译为.dtb。如果我们使用I.MX6ULL 新做了一个板子，只需要新建一个此板子对应的.dts 文件，然后将对应的.dtb 文件名添加到 dtb-$(CONFIG_SOC_IMX6ULL)下，这样在编译设备树的时候就会找到对应的.dts 编译为二进制的 .dtb 文件。\n\n只编译设备树文件：`make dtbs` 或 `make [具体的设备树文件名]`\n\n**系统启动后，内核会将解析后的设备树以文件系统形式展示在 `/proc/device-tree`。**\n\n```bash\n# 查看刚才添加的 LED 节点\nls /proc/device-tree/leds/\n# 查看 compatible 属性\ncat /proc/device-tree/leds/compatible\n```\n\n## 4. 基本语法\n\n设备树是一个树状结构，由**节点**（Node）和**属性**（Property）组成。\n\n### 4.1. 节点\n\n一个硬件模块就是一个节点：\n\n```dts\n/dts-v1/;                // 版本号\n#include \"soc.dtsi\"      // 包含头文件\n\n/{\n\taliases{\n\t\t\tcan0 = &flexcan1;\n\t\t};\n\tcpus{\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\t\tcpu0: cpu@0 {\n\t\t\tcompatible = \"arm,cortex-a7\";\n\t\t\tdevice_type = \"cpu\";\n\t\t\treg = <0>;\n\t\t\t};\n\t\t};\n\tintc: interrupt-controller@00a01000 {\n\t\tcompatible = \"arm,cortex-a7-gic\";\n\t\t#interrupt-cells = <3>;\n\t\tinterrupt-controller;\n\t\treg = <0x00a01000 0x1000>,\n\t\t\t  <0x00a02000 0x100>;\n\t};\n}\n```\n\n“/”是根节点，每个设备树文件只有一个根节点。根节点会合并。\n\n我们可以看到一些常见写法，如：\n\n- `label: node-name@unit-address`\n\n\t其中“node-name”是节点名字，为 ASCII 字符串，节点名字应该能够清晰的描述出节点的功能，比如“uart1”就表示这个节点是 UART1 外设。\n\n\t“unit-address”一般表示设备的地址或寄存器首地址，如果某个节点没有地址或者寄存器的话“unit-address”可以不要，比如“cpu@0”“interrupt-controller@00a01000”。\n\n\t引入 \"label\" 的目的是为了方便访问节点，可以直接通过 &label 来访问这个节点，比如通过 &cpu0 就可以访问“cpu@0”这个节点，而不需要输入完整的节点名字。\n\n- `<number>`：32 位无符号整数。可以设置为一组值，比如：、\n\t“reg = <0 0x123456 100>;”\n\n### 4.2. 两个特殊节点\n\n#### 4.2.1. aliases\n\n用于定义别名。不过我们一般会在节点命名的时候会加上 label，然后通过&label\n来访问节点，这样也很方便。\n\n#### 4.2.2. chosen\n\nchosen 并不是一个真实的设备，chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重点是 bootargs 参数。\n\n下图为 uboot 向 chosen 节点添加 bootargs 参数的调用链：\n\n![](Snipaste_2025-11-23_17-32-22.png)\n\n### 4.3. 属性\n\n这是在修改设备树时最常用的几个属性：\n\n#### 4.3.1. compatible (兼容性)：\n\n- **作用**：这是设备树与驱动程序的“暗号”。内核通过这个字符串将设备节点与驱动程序匹配起来。\n- **格式**：`\"厂商,模块驱动名\"`。\n- **例子**：`compatible = \"fsl,imx6ul-evk-wm8960\",\"fsl,imx-audio-wm8960\";`\n\n一般驱动程序文件都会有一个 OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的 compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。\n\n属性值有两个的话，首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。\n\n#### 4.3.2. status (状态)：\n\n- **作用**：控制设备是否启用。\n- **常用值**：`\"okay\"` (启用), `\"disabled\"` (禁用)，`“fail”` 。\n- **场景**：SoC 内部有很多控制器（如 I2C3），板子没用到，就在 `.dts` 里设为 `disabled`；如果用到了，就改为 `okay`。\n\n#### 4.3.3. reg (寄存器/地址)：\n\n- **作用**：描述设备的地址资源（内存映射地址、I2C 地址等）。\n- **格式**：通常是 `<地址 长度>` 或 `<I2C地址>`。\n\n#### 4.3.4. label 与 phandle (引用)：\n\n- **作用**：让节点之间互相引用。\n- **符号**：`&`。例如 `&i2c1` 表示引用标签为 `i2c1` 的节点。\n\n#### 4.3.5. #address-cells 和 #size-cells ：\n\n- **作用**：决定了**子节点** reg 属性中地址信息和长度信息所占用的字长(32 位)。\n- **例子**：`#address-cells = <1>;` `#size-cells = <0>;`，表明子节点 reg 值，地址占一个字长，长度无。\n\n#### 4.3.6. ranges\n\n- **作用**：表示将子节点地址向父节点地址的转换。\n- **格式**：`<local地址， parent地址， size>`\n\n比如对于 `#address-cells` 和 `#size-cells` 都为1，以`<0x0  0x10 0x20>`为例，表示将 local 的 从 0x0~(0x0 + 0x20) 的地址空间映射到 parent 的 0x10~(0x10 + 0x20)。\nranges属性值为空的话，表示1:1映射。\n\n### 4.4. 追加内容\n\n相在某一父节点下添加一个子节点，你可以直接在那个父节点下添加。\n或者直接使用 `&` 符号+label名，表示在这个节点下追加属性。\n肥肠的煎蛋。\n\n```\n&i2c1 {\n/* 要追加或修改的内容 */\n};\n```\n\n\n## 5. 设备树的编写规范\n\n### 5.1. 查阅编写规范\n\n打开linux源码目录 `Documentation/devicetree/bindings` 它是设备树（Device Tree）规范的“官方说明书”，里面定义着不同厂商的不同设备的设备树的编写规范。\n\n具体来说，里面的每一个 `.yaml` 或 `.txt` 文件，都在描述某一类硬件设备在设备树中应该如何被正确地写出来。\n\n也就是：\n- 它有哪些必需属性（`reg`、`compatible`…）\n- 可选属性有哪些\n- 各个属性是什么含义\n- 属性的类型和合法取值是什么\n- 示例（示范 devicetree 节点怎么写）\n\nLinux 内核靠它们来**校验设备树 DTS 文件是否符合规范**。\n\n>当你 `make dtbs` 或 `dt-validate` 时，`dt-schema` 工具会检查 DTS 是否按照 bindings 的要求去写。若有问题，会直接报错。\n\n### 5.2. 为什么有编写规范\n\n因为世界上 SoC/外设千千万，每个设备的写法不同。\n为了避免不同厂家乱写导致兼容性和维护困难，内核社区采用：\n\n- 统一规范（binding）\n- 统一校验（dt-schema）\n\n这样：\n- 社区可以维护通用格式\n- DTS 文件编译时可以自动报错（提示写法不规范）\n- 驱动开发者知道设备树应该怎样写\n\n### 5.3. 看懂编写规范\n\n以一个典型的 YAML binding 为例，它会包含：\n\n#### 5.3.1. compatible 字段\n\n列出这个驱动支持的硬件型号\n\n```yaml\ncompatible:\n  const: \"nxp,imx6ull-uart\"\n```\n\n#### 5.3.2. 必须的属性\n\n```yaml\nproperties:\n  reg:\n    maxItems: 1\n  interrupts:\n    maxItems: 1\nrequired:\n  - compatible\n  - reg\n  - interrupts\n```\n\n#### 5.3.3. 可选属性\n\n如 `clocks`、`dmas` 等。\n\n#### 5.3.4. 示例\n\n```yaml\nexamples:\n  - |\n    uart1: serial@02020000 {\n        compatible = \"nxp,imx6ull-uart\";\n        reg = <0x02020000 0x4000>;\n        interrupts = ;\n    };\n```\n\n这些示例是你写 DTS 时最可靠的参考。\n\n## 6. 驱动程序获取设备树属性\n\n设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必须先获取到这个设备的节点。Linux 内核使用 `device_node` 结构体来描述一个节点，此结构体定义在文件 `include/linux/of.h` 中。\n\n通过 **OF(OpenFirmware)** 系列函数，我们可以查找这些 `device_node` 变量类型的结构体，并从中获取对应设备的属性。\n\n这些函数的用途在函数名已有体现。\n例如常用的一些查找函数：\nof_find_node_by_name\n```c\nstruct device_node*\nof_find_node_by_name(struct device_node\n* from, const char* name)\n```\n\nof_find_compatible_node\n```c\nstruct device_node*\nof_find_compatible_node(struct device_node* from, const char* type, const char* compatible)\n```\n\nof_find_matching_node_and_match\n```c\nstruct device_node* of_find_matching_node_and_match(structdevice_node* from, const struct of_device_id* matches, const struct of_device_id** match)\n```\n\nof_find_node_by_path\n```c\ninline struct device_node* of_find_node_by_path(const char* path)\n```\n\nOF函数在驱动的编写中很重要，受限于篇幅原因就不一一介绍了，有可能后续再开一篇来介绍。\n\n最后来一张表格总结常用的：\n\n|功能|函数|\n|---|---|\n|查找节点|`of_find_compatible_node()`|\n|基础属性读取|`of_get_property()`|\n|读 u32|`of_property_read_u32()`|\n|读字符串|`of_property_read_string()`|\n|读 reg → resource|`of_address_to_resource()`|\n|读 reg → 虚拟地址|`of_iomap()`|\n|获取 IRQ|`of_irq_get()`|\n|是否有某属性|`of_property_read_bool()`|\n|匹配 compatible|`of_match_device()`|\n|遍历节点|`for_each_child_of_node()`|\n\n## 7. 参考资料\n\n【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.81","tags":["Linux","设备树","dts"],"categories":["Linux","设备驱动程序"]},{"title":"使用mfgtool烧写完整系统到IMX的EMMC","url":"/posts/19983/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## mfgtool 介绍\n\nmfgtool 是 NXP 提供的专门用于给 I.MX 系列 CPU 烧写系统的软件。\n## mfgtool 工作流程\n\n1. 首先 mfgtool 将 firmware 目录中的 uboot、linux kernel 和.dtb(设备树)，然后通过 USB OTG 将这个文件下载到开发板的 DDR 中，目的就是在 DDR 中启动 Linux 系统，为后面的烧写做准备。\n2. 经过第一步的操作，此时 Linux 系统已经运行起来了，系统运行起来以后就可以很方便的完成对 EMMC 的格式化、分区等操作。EMMC 分区建立好以后就可以从 files 中读取要烧写的 uboot、linux kernel、.dtb(设备树)和 rootfs 这 4 个文件，然后将其烧写到 EMMC 中。\n3. files 和 firmware 目录下有众多的 uboot 和设备树，那么烧写的时候究竟选择哪一个呢？这个工作就是由 ucl2.xml 文件来完成的。ucl2.xml 以“`<UCL>`”开始，以“`</UCL>`”结束。“`<CFG>`”和“`</CFG>`”之间是配置相关内容，主要是判断当前是给 I.MX 系列的哪个芯片烧写系统。“`<LIST>`”和“`</LIST>`”之间的是针对不同存储芯片的烧写命令。\n\n这个就是 mfgTool 的大概工作流程。\n\n总结：\n\n`firmware`：烧写到DDR中的Linux文件，用于操作EMMC。\n\n`file`：真正烧写到EMMC中的文件。\n\n`ucl2.xml`：指示mfgtool烧写哪些文件。\n\n## 烧写自己的系统\n\n以IMX6ULL为例。\n\n查看 `ucl2.xml`，再打开：\n\n`/mfgtools/Profiles/Linux/OS Firmware/firmware` 及\n\n`/mfgtools/Profiles/Linux/OS Firmware/files`，\n\n易知：\n\n要烧写的文件在 files 目录下和 firmware 目录下同名\n且要烧写的文件名如下：\n\n### u-boot\n\n官方u-boot名称：`u-boot-imx6ull14x14evk_emmc.imx`\n\n### 内核镜像\n\n官方内核名称：`zImage`\n\n### 设备树\n\n官方设备树名称：`zImage-imx6ull-14x14-evk-emmc.dtb`\n\n### 根文件系统\n\n官方根文件系统名称：`rootfs_nogpu.tar.bz2`\n\n注：先将根文件系统使用 `tar -vcjf` 命令打包。该项只存在于 files 中，无需烧写到DDR中。\n\n### 烧写方法\n\n直接将自己确认好可以用的 dtb、kernel、uboot、rootfs 文件改为上面的官方名称并覆盖到firmware 及 files 文件夹。\n然后双击对应的烧写脚本（我的是： `mfgtool2-yocto-mx-evk-emmc.vbs`） 烧写。\n\n### issue#1：内核启动3s后卡死，无法挂载根文件系统。\n\n#### 排查过程：\n\n起初怀疑是根文件系统问题。排查如下：\n\n1. 检查根文件系统是否烧写成功或文件系统格式错误。\n\t在uboot中输入命令：`ext4ls mmc 1:2 /` 成功输出根文件系统内容，排除。\n\t\n2. 怀疑根文件系统初始化脚本无法执行。\n\t在uboot的bootargs 参数中添加：`init=/bin/sh`，依旧无法启动，排除。说明根本还没到这一步就死了，确认问题是根文件系统无法挂载。\n\n3. 控制变量法：\n\t替换根文件系统为正点原子官方的根文件系统并烧写，依旧启动卡死。怀疑是内核问题。\n\n4. 替换内核为官方Linux内核；uboot、根文件系统、dtb使用自己的并烧写——成功启动。\n\n5. 懵逼。按理来说内核4.0跨到6.0版本，时间跨度很大，dtb文件应该不适用才对。也就是说我使用 4.0 的内核应该不能适配 6.0 的 dtb 文件。\n\n#### 最后排查原因：\n\ndtb文件烧写错误。。。。。我错误的将`zImage-imx6ull-14x14-evk-emmc.dtb` 命名为了 `zImage-imx6ull-14x14-evk.dtb`，导致我使用新内核启动时，使用的还是是nxp官方的旧的内核的dtb文件，而不是新的。。。两者不适配。\n\n最后还得感谢ai的质疑精神）我给ai说我确认dtb文件正确，ai看了我的日志后提出了质疑，并帮助我排查出了原因，也是nb。。。。\n\n![](Snipaste_2025-11-13_20-11-17.png)\n\n## 定制化脚本\n\n待补充。。。。。\n","tags":["Linux","mfgtool"],"categories":["Linux","系统移植"]},{"title":"编程随想","url":"/posts/42114/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n在一切开始之前，只有一片寂静的“原初之石”（嵌入式设备）。\n\n## 第一章：启程者U·Boot的誓约\n\n在永恒的黑暗中，第一位生灵觉醒了，他是启程者U·Boot。U·Boot是一位不朽的守誓人，他的存在只有一个目的：开启世界。\n\n当启动的信号闪烁，U·Boot立刻开始了他的神圣仪式：他首先叩击了“原初之石”的脉络（初始化硬件），确认每一个节点——从宏大的记忆之河到微小的时钟之弦——都已准备就绪。\n\nU·Boot知道，他无法独自构建世界。他必须唤醒那位沉睡的，真正的造物主。他奔向古老的智慧之塔（存储器），找到并抬起了沉重的命运之卷。他将这卷轴——那是核心法则的记录——庄严地放置在清醒之所（内存）的中央。\n\nU·Boot深深地鞠躬，他望向那卷轴，低语道：“我的使命已终。核心啊，醒来吧，时间已到。” 他将所有的力量和权限，都倾注给了这卷轴，然后，U·Boot的光芒隐去，他完成了对黎明的誓约。\n\n## 第二章：律法之魂Kernel的诞生\n\n当U·Boot的光芒熄灭，律法之魂Kernel被唤醒了。\n\nKernel是世界的内在灵魂，它没有具体的形态，却是一切秩序的源泉。Kernel诞生的第一件事，就是建立律法。\n\n它向四周伸出无数看不见的触手，拥抱并驾驭了整个“原初之石”（加载驱动程序，接管硬件）。现在，它能听到每一次输入，能控制每一次输出。\n\n它在广阔的空间内划定了界限（内存管理），制定了时间分配的铁律（进程调度），确保每一个未来的思绪和行动都能得到公平的资源。 \n\nKernel拥有了管理世界的绝对能力，但它环顾四周，发现自己身处一个有法则却无色彩的空旷世界。它像一位孤独的君王，拥有无上的权力，却没有臣民，没有诗歌，没有生命存在的意义。\n\n“我的律法需要一个国度来承载，需要一个故事来讲述。” Kernel低语。\n\n## 第三章：世界之华RootFS的盛开\n\nKernel沿着旧日信标指引的道路，找到了那片被尘封的宝库——那里储存着人类文明所有的积淀与梦想，它就是世界之华RootFS。\n\nKernel用律法的力量，将宝库的大门打开（挂载 RootFS），并伸出触手，唤醒了宝库中沉睡的第一个声音：先知 init。\n\n先知 init 醒来，在Kernel律法的框架下开始了他的工作。\n\n他迅速地摆放了日常所需的工具（基础命令、配置），让世界有了可操作的逻辑。\n\n他依次唤醒了吟游诗人的歌谣（应用程序）、哲人的手稿（配置文件）和工匠的工具（服务进程）。 \n\n至此，Kernel的律法框架与RootFS的丰富内容完美结合。世界不再是空洞的法则，而是充满生机、可以感知、可以创造的完整存在。\n\n启程者U·Boot开启了诞生；律法之魂Kernel赋予了秩序；世界之华RootFS成就了意义。三位一体，构成了完整的生命觉醒之旅。\n\n\n## 附录1：世界之华的十大景观\n\n### /root 和 /home：君王和臣民的私域\n\n/root(君王的静室)：这是律法之魂Kernel的私人居所。只有他拥有最高的权限，用于处理最核心、最私密的政务。外人不得擅入。\n\n/home(臣民的村落)：这是所有在国度中生活和创造的个体（用户）的专属领地。每个臣民在自己的屋子里书写自己的故事，彼此独立，但都在科恩的律法之下。\n\n### /bin 和 /sbin：勇士和祭司的武器库\n\n/bin(勇士的佩剑)：存放着所有普通居民（用户）都可以使用的日常工具和技能。比如：ls（点清财物）、cp（搬运物品）。它们是国度最常用的动作。\n\n/sbin(祭司的法杖)：存放着只有最高祭司（系统管理员或 Kernel）才能动用的神圣工具。这些工具用于维护国度的根本稳定，如格式化土地、修复城墙等。\n\n### /etc：国度的古老法典\n\n/etc(古老的法典与契约)：存放着国度运行的所有规定和契约（配置文件）。它规定了谁（用户）能做什么，何时（服务）启动，以及如何（网络配置）与外界交流。它是世界的运行蓝图。\n\n### /usr：知识与文化的殿堂\n\n/usr(文化的宝库与学院)：Unix Software Resourse 存放着非核心但极其庞大的知识、艺术和工具。所有的吟游诗人的歌谣（库文件 /usr/lib）、学者的手稿（头文件 /usr/include）和复杂的巨型应用（/usr/bin）都集中于此，是国度的文明象征。\n\n### /dev：与生俱来的感知器官\n\n/dev(与生俱来的感知器官)：它不是真正的文件，而是Kernel与生俱来的“感知器官”（设备文件）。通过这些器官，灵魂可以直接触摸（读写）外界的光线（显示器）、倾听外界的声音（声卡）和感受外界的震动（键盘）。\n\n### /proc 和 /sys：世界的实时心跳与镜像\n\n/proc(世界的实时心跳)：它是一个魔法的镜子，实时映射出Kernel的每一个思绪和每一次呼吸（进程信息）。它不存储任何实物，只是Kernel当前状态的投影。\n\n/sys(世界的生理数据)：它是一个精密的温度计和测量仪，详细展示国度的生理数据（硬件和驱动状态）。\n\n### /tmp 和 /var：时间的沙漏与变化\n\n/tmp(流逝的沙漏)： 存放着短暂的、易逝的思绪（临时文件）。一旦日出日落（重启），这些思绪便会随风消逝。\n\n/var(变化的记录簿)： 存放着所有不断增长、不断变化的历史记录。比如：守夜人的日志（日志文件 /var/log）和来往的信件（邮件 /var/mail）。","tags":["Linux"],"categories":["Linux","系统移植"]},{"title":"使用BusyBox构建根文件系统","url":"/posts/30149/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 1. 前言\n\n### 1.1. 最小根文件系统\n\n一个最精简的文件系统包含什么呢？\n我们知道，内核挂载根文件系统后，第一件事是就是启动 /sbin 目录下的 init 程序作为第一个进程，init 程序读取 /etc 目录下的配置文件，再根据配置文件启动其他 app。同时这些app又有可能是动态链接的，所以我们还需要 /lib 文件夹，包含一些头文件。\n此外，bootloader 也会在根文件系统启动内核，内核需要在根文件系统中读取设备树文件以控制硬件，这有了 /boot 文件夹。\n有了设备树，自然少不了 /dev 目录。最小的/dev目录，只要包含 console 与 null。\n综上，我们可以总结出一个最小的根文件系统有什么：\n\n1. init 程序\n2. 其他的必要app\n3. 配置文件\n4. lib库（用于动态链接）\n5. 内核zImage\n6. dtb设备树文件\n7. /dev\n\n1点属于/sbin，2点属于/bin ，3点属于/etc，4点属于/lib，5、6点属于/boot。\n\n如果更极致的话，甚至可以使用静态链接，静态编译应用程序，这样就不用 /lib ，也不使用其他app，就一个init程序实现想要的功能即可——当然这是理想化的。\n\n### 1.2. 关于 systemV 和 systemd\n\n我们上面所说的 init 其实说的就是 system V 的启动方式——串行启动，一个脚本执行完再启动下一个。与 system V 相比，systemd 更加现代化且更好——并行启动，通过依赖关系图同时启动多个服务、启动速度快、依赖关系明确等等...\n但是，在嵌入式linux坏境中却并不一定好用，因为它太重了，依赖也多。而且对于使用 systemd 的嵌入式系统来说，根文件系统也不应该用 busybox 来构建。busybox生成的 init 实际上就是类似于 system V 的 init 实现。\n\n### 1.3. What is BusyBox？\n\nBusyBox**并不是一个根文件系统制作工具**，它只是极大地简化了 /bin、/sbin 等目录的搭建。\nBusyBox 是一个集成了上百个常用 UNIX 命令的小型可执行文件。\n\n当你在 shell 中输入：`ls`\n实际上调用：`/bin/busybox ls`\nBusyBox 会根据你执行的命令名自动表现成对应工具的行为。\n\n它的设计哲学是：\n- 只实现最核心的功能；\n- 去掉冗余；\n- 用最小的代码体积覆盖最大功能。\n\n从这里可以看出，它非常适合嵌入式系统。\n\n## 2. 编译BusyBox\n\n首先在makefile中指定交叉编译器，避免每次make都要传入编译器参数。\n\n![](Snipaste_2025-11-05_18-15-55.png)\n\n使用命令 `make help` 查看make选项。\n\n### 2.1. 生成配置文件\n\n我们先使用默认的配置文件。\n\n使用命令 `make menuconfig` 或者 `make defconfig` 都可以。我们选择menuconfig，方便我们配置一些选项：\n\n```bash\nmake menuconfig\n```\n\n进入配置界面后，我们可以指定一下编译器前缀 ：\n将 Settings → Build Options → Cross Compiler prefix 中指定为 `arm-none-linux-gnueabihf-`。\n\n也可以启用 Build static binary (no shared libs) 以实现静态编译，不用使用动态共享库省去自己构建库文件的步骤，代价是根文件系统大小大一些。空间换时间（bushi\n\n其他的根据自己需求修改（如果看得懂的话）。\n\n同时最好关闭硬件加速项SHA，也就是这两项：\n\n![](Snipaste_2025-11-05_18-22-47.png)\n\n我使用的1.37.0版本 busybox，即使使用默认配置文件，什么也不做修改，也无法编译成功，会报错：“libbb/hash_md5_sha.c:1316:35: error: ‘sha1_process_block64_shaNI’ undeclared (first use in this function);”\n\n查阅后发现可能是CPU不支持硬件加速的问题，所以就将 Settings 选项里的两个硬件加速选项关了。不知道是官方的bug还是什么.....\n\n### 2.2. 编译并安装BusyBox\n\n编译没啥好说的，`make` 即可。\n\n用 `CONFIG_PREFIX` 指定文件夹。将busybox 安装到指定文件夹，也就是拟用于构建根文件系统的那个文件夹嘛，前面我们也说了，busybox就相当于把 /sbin /bin 这两块拼图做好了。\n\n> 安装实际上就是建立软链接，链接到 /bin/busybox 。所以一定要确定好路径，要是不小心指定到本机Linux的根目录下不就废了吗。:(\n\n```bash\nmake CONFIG_PREFIX=~/shared/rootfs_tmp  install\n```\n\n![](Snipaste_2025-11-05_18-43-14.png)\n\n![](Snipaste_2025-11-10_14-54-29.png)\n\n## 3. 完善根文件系统\n\n目前根文件系统最基本的操作工具就有了，但是还缺少必要的文件夹，比如dev、sys等。\n\n但是我们不必在这里创建这些文件夹。还记得之前提到的初始化脚本吗，内核启动并挂载根文件系统后，做的第一件事就是运行 /sbin/init 。而这个程序又在做什么呢，busybox的init程序大概做这三件事：\n\n1. 读取 `/etc/inittab`（如果有）；\n2. 启动第一个初始化脚本 `/etc/init.d/rcS`；\n3. 最后启动 shell。\n\n`inittab`：init 程序的配置文件\n\n`/etc/init.d/rcS`：run commands for system。一个普通的 shell 脚本，但它是由 init 启动的第一个脚本，负责初始化系统的环境。\n\n因此我们可以在rcS脚本中添加这些必要文件。所以我们只需要在现在的根文件系统中添加以下几个文件：\n\n```bash\nmkdir etc/init.d/rcS\nmkdir etc/inittab\n```\n\n### 3.1. rcS 的编写\n\n大致内容如下，已附详细注释及常见问题：\n\n```bash\n#!/bin/sh\n# rcS - minimal BusyBox startup script\n\n# 这些文件夹的具体用途可以参见我的另一篇文章《编程随想》\necho \">>> Create the necessary folder if it does not exist...\"\nmkdir -p /sys /dev /proc /tmp /run /var\n\n# mount -t <文件系统类型> <设备> <挂载点>\n# none：占位符。因为这里并不是“挂载某个磁盘”，\n# 而是在请求内核“把它内部的数据结构以文件形式呈现出来”\n# 文件系统类型 (`proc`, `sysfs`) 是内核内置的。\n# 系统并不会去磁盘上找“proc”，\n# 它调用的是内核内部的 `procfs_mount()` 函数。\n# 这里挂载的并不是设备，而是VFS，所以设备为“none”。\necho \">>> Mounting proc to /proc...\"\nmount -t proc none /proc\necho \">>> Mounting sysfs to /sys...\"\nmount -t sysfs none /sys\n\n# devtmpfs介绍：\n# 这是一个内核级的临时文件系统，\n# 自动由内核在设备注册时创建对应的设备节点。\n# 而无需什么mknod，udev，mdev。\n# 为什么是“临时”？因为它是重启后就需要重新生成。\n\n# 我发现在内核启动过程中已自动挂载devtmpfs，\n# 所以就不用再挂一遍。\n# --devtmpfs has already auto mounted.--\nif ! mount | grep -q \"on /dev \"; then\n    echo \">>> Mounting devtmpfs to /dev...\"\n    mount -t devtmpfs devtmpfs /dev\nelse\n    echo \">>> /dev already mounted by kernel\"\nfi\n\necho \">>> Setting up essential directories...\"\nmount -t tmpfs tmpfs /tmp\nmount -t tmpfs tmpfs /run\n\n# setting hostname\necho \"mark1\" > /proc/sys/kernel/hostname\n\n# exec命令功能：\n#- 执行命令并替换掉当前进程（不会新建子进程）；\n#- 如果只带重定向而没有命令，\n#则会改变当前 shell 的文件描述符绑定。\n#这里的作用是把当前脚本进程直接替换为`/bin/sh`。\n#不再返回，也不再继续执行后续脚本。\n\n# Unix 的进程默认有三条流：\n#- `0` — 标准输入（stdin）\n#- `1` — 标准输出（stdout）\n#- `2` — 标准错误（stderr）\n#< /dev/ttymxc0：\n#表示把标准输入改为从`/dev/ttymxc0`读取。\n#> /dev/ttymxc0：\n#表示把标准输出改为写入`/dev/ttymxc0`。\n#2>&1：\n#表示把标准错误也重定向到标准输出的同一个地方。\n\n# 为什么这样做：\n# 如果直接exec到sh，则会提示：\n# /bin/sh: can't access tty;job control turned off\n# 意思是当前 shell 没有绑定到一个真正的终端（tty），\n# 所以 Ctrl+C、Ctrl+Z、作业控制等功能无法使用。\necho \">>> System ready. Starting shell...\"\nexec /bin/sh < /dev/ttymxc0 > /dev/ttymxc0 2>&1\n\n```\n\n### 3.2. inittab的编写\n\n当内核启动 `/sbin/init`（比如 BusyBox 的 init）时，init 会读取这个文件，\n决定应该执行哪些命令、启动哪些脚本、在哪些终端上提供登录。\n\n换句话说，它定义了：\n- 系统开机时做什么；\n- 哪些脚本要执行；\n- 哪些终端需要打开 shell。\n所以，它就像系统启动的“行动计划表”。\n\n#### 3.2.1. `inittab` 的基本格式\n\n每一行是一条指令，格式通常是：\n\n`<id>:<runlevels>:<action>:<process>`\n\n但在 BusyBox 的简化版本中，`runlevels` 通常被忽略，\n所以我们常见的是这样的：\n\n`::action:/path/to/command`\n\n#### 3.2.2. 常见的 action 类型\n\n让我们来看几个经典例子（尤其在 BusyBox 系统中）：\n\n 1. `sysinit`\n\n\t系统初始化时运行，通常挂载虚拟文件系统、创建目录等：\n\n\t`::sysinit:/etc/init.d/rcS`\n\n\t表示：在系统启动时，执行 `/etc/init.d/rcS` 脚本。\n\n2. `respawn`\n\n\t表示该进程如果退出，init 会重新启动它（循环重启）。\n\t常用于启动终端或守护进程：\n\n\t`ttyS0::respawn:/sbin/getty -L ttyS0 115200 vt100`\n\n\t表示：在串口 ttyS0 上启动一个终端，波特率 115200，终端类型 vt100。\n\n3. `askfirst`\n\n\t和 `respawn` 类似，但在启动前会提示 “Press ENTER to activate this console”。\n\t常用于开发板上的交互式 shell：\n\n\t`tty1::askfirst:/bin/sh`\n\n 4. `wait`\n\n\t表示执行完后等待命令退出再继续。\n\t通常在系统初始化阶段使用：\n\n\t`::wait:/etc/init.d/rc.local`\n\n#### 3.2.3. 例子\n\n```\n::sysinit:/etc/init.d/rcS\n::askfirst:-/bin/sh\n::ctrlaltdel:/bin/umount -a -r\n::shutdown:/bin/umount -a -r\n```\n\n## 4. 构建lib目录（如果是动态编译）\n\nbusybox默认是动态编译的，当然你可以在menuconfig中指定静态编译。\n\n那么库在哪里呢？我们在使用工具链编译链接的时候，并没有报错，说明我们使用的工具链中含有这些库。我们从工具链中复制这些库到 /lib 。\n\n那我们工具链的库又在哪呢？我们可以输入这么一行命令来获取到库路径：\n\n```bash\necho \"void main(){}\" | arm-none-linux-gnueabihf-gcc -E -v -\n```\n\n输出：\n```\nLIBRARY_PATH=/home/gdm/prjts/ARM_TOOLCHAIN/AArch32-Linux/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf/bin/../lib/gcc/arm-none-linux-gnueabihf/14.3.1/:/home/gdm/prjts/ARM_TOOLCHAIN/AArch32-Linux/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf/bin/../lib/gcc/:/home/gdm/prjts/ARM_TOOLCHAIN/AArch32-Linux/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf/bin/../lib/gcc/arm-none-linux-gnueabihf/14.3.1/../../../../arm-none-linux-gnueabihf/lib/:/home/gdm/prjts/ARM_TOOLCHAIN/AArch32-Linux/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf/bin/../arm-none-linux-gnueabihf/libc/lib/:/home/gdm/prjts/ARM_TOOLCHAIN/AArch32-Linux/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf/bin/../arm-none-linux-gnueabihf/libc/usr/lib/\n```\n\n他们都是以 /home/gdm/prjts/ARM_TOOLCHAIN/AArch32-Linux/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf/bin/../ 开头。也就是工具链源路径。\n\n令 “/home/gdm/prjts/ARM_TOOLCHAIN/AArch32-Linux/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf/bin/../” = [工具链源路径]\n\n化简整理得：\n\n```\n[工具链源路径]/lib/gcc/arm-none-linux-gnueabihf/14.3.1/\n\n[工具链源路径]/lib/gcc/\n\n[工具链源路径]/lib/gcc/arm-none-linux-gnueabihf/14.3.1/../../../../arm-none-linux-gnueabihf/lib/\n\n[工具链源路径]/arm-none-linux-gnueabihf/libc/lib/\n\n[工具链源路径]/arm-none-linux-gnueabihf/libc/usr/lib/\n```\n\n> `ldd` 命令介绍：`ldd` 是 Linux 系统中用于显示可执行文件或共享库所依赖的动态链接库的命令行工具。它可以帮助开发者快速了解程序运行时的依赖关系，解决库缺失或版本冲突等问题。\n\n我们使用工具链中提供的 `readelf` 工具来查看 busybox 所需的动态链接库：\n\n```bash\narm-none-linux-gnueabihf-readelf -d bin/busybox | grep NEEDED\n```\n\n> -d 就是显示动态库。\n\n输出：\n\n```\n0x00000001 (NEEDED) Shared library: [libm.so.6]\n0x00000001 (NEEDED) Shared library: [libresolv.so.2]\n0x00000001 (NEEDED) Shared library: [libc.so.6]\n```\n\n接着就在上面提到的工具链库中找呀找，最后在倒数第二个库中找到了这几个依赖。\n\n![](Snipaste_2025-11-05_21-48-39.png)\n\n还要注意的是这些文件是不是软链接，如果是软链接，则需要将链接到的源文件也拷贝到 /lib。并在使用cp命令时加上 `-d` 选项，使其保持链接特性。\n\n这里我用 `ls -l` 查看了，都不是软链接。\n\n直接cp：\n\n```bash\ncp libc.so.6 libm.so.6 libresolv.so.2 ~/shared/rootfs_tmp/lib\n```\n\n还要cp一个链接器：\n\n```bash\ncp ld-linux-armhf.so.3 ~/shared/rootfs_tmp/lib\n```\n\n---\n\n<p style=\"font-size:30px\"> <strong>下面的内容已不再适用。但是有一些内容值得做一些参考。</strong></p>\n\n---\n\n## [old]5. 构建boot目录\n\n把之前编译好的内核生成的dtb文件和zImage文件拷贝到根文件的 /boot 目录即可。\n\n## [old]6. 构建dev目录\n\n最小dev目录我们只要满足标准输出就好了，也就是能够输出信息。\n\n我们可以先查看我们 linux 系统里的 console 设备是怎么创建的：\n\n```bash\nls /dev/console -l\n```\n\n输出：\n\n```\ncrw------- 1 root root 5, 1 Nov  6 15:35 /dev/console\n```\n\n我们仿照这个用 `mknod` 命令在rootfs/dev目录创建：\n\n```bash\nsudo mknod console c 5 1\n```\n\n同理创建 null 设备，\n\n仿照：\n```\ncrw-rw-rw- 1 root root 1, 3 Nov  6 15:35 /dev/null\n```\n\n创建：\n```bash\nsudo mknod null c 1 3\n```\n\n## [old]7. 刻录映像文件\n\n### 7.1. 刻录\n\n使用genimage这个工具来生成image文件。\n\n```bash\nsudo apt install genimage\n```\n\n```\nimage emmc.img{\n\n\thdimage {                 //生成DOS分区images。\n\n\t}\n\n\tpartition rootfs-1 {\n\t\tpartition-type = 0xC\n\t\tbootable = \"yes\"\n\t\timage = \"boot.vfat\"  //路径由 ${INPUTPATH} 指定\n\t\tsize = 12M\n\t}\n\n\tpartition rootfs-2 {\n\t\tpartition-type = 0x83\n\t\tbootable = \"yes\"\n\t\timage = \"myrootfs.ext4\"\n\t\tsize = 34M\n\t}\n}\nimage boot.vfat {\n\tvfat {\n\t\tfiles = { \"u-boot-dtb.imx\" } //路径由 {INPUTPATH} 指定\n\t}\n\tsize = 10M\n}\n\nimage myrootfs.ext4 {\n\text4{}\n\tname = \"root\"\n\tsize = 32M //根据自己的根文件系统大小调整\n\tmountpoint = \"/\" //路径由 {ROOTPATH} 指定\n}\n\n```\n\n我们现在只是测试，可以先随便创建一个\"u-boot-dtb.imx\"文件，比方说我创建这个文件，并在里面写入一个“test”字符串。\n\n```bash\ngenimage \\\n--rootpath \"/home/gdm/shared/rootfs_tmp\" \\\n--inputpath \"/home/gdm/shared/gen_image\" \\\n--outputpath \"/home/gdm/shared/gen_image/output\" \\\n--tmppath \"/home/gdm/shared/gen_image/tmp\" \\\n--config \"genimage.cfg\"\n```\n\n#### 7.1.1. issue#1\n\n执行后报错：\n\n```\n/bin/sh: 1: genext2fs: not found\n```\n\n根据提示安装 genext2fs:\n\n```bash\nsudo apt install genext2fs\n```\n\n### 7.2. 验证\n\n我们可以使用 `fdisk` 工具验证一下生成的 emmc.img:\n\n![](Snipaste_2025-11-06_17-06-12.png)\n\n与配置文件中的如出一辙。\n\n**另外我们学习一下在Linux下装载镜像文件：**\n\n`losetup` 命令允许用户将文件映射到循环设备（如/dev/loop0），从而使文件能够被视为块设备。这种方式常用于挂载ISO镜像文件或其他磁盘映像文件，使其可以像真实的磁盘一样进行访问和操作。\n\n查看循环设备：`losetup` 或 `losetup -a` 。\n\n1. 创建循环设备文件并映射镜像文件：\n\n```bash\nlosetup -P /dev/loop3 ./emmc.img\n```\n\n`-P` 是指扫描镜像文件分区，创建带有分区的循环设备。\n\n2. 查看循环设备信息：\n\n```bash\nls /dev/loop3*\n\n输出：/dev/loop3  /dev/loop3p1  /dev/loop3p2\n```\n\n3. 挂载分区1：\n\n```bash\nsudo mount /dev/loop3p1 /mnt\n```\n\n4. 查看文件：\n\n```bash\nls /mnt\n输出：\nu-boot-dtb.imx\n\nls -l /mnt\n输出：\ntotal 2\n-rwxr-xr-x 1 root root 5 Nov  7  2025 u-boot-dtb.imx\n\ncat /mnt/u-boot-dtb.imx\n输出：\ntest\n\nsudo umount /mnt\n\n```\n\n5. 同理查看分区2：\n\n```bash\nsudo mount /dev/loop3p2 /mnt\n\nls -l /mnt\n\n输出：\ntotal 27\ndrwxr-xr-x 2 gdm  gdm   3072 Nov  5 18:35 bin\ndrwxr-xr-x 2 gdm  gdm   1024 Nov  5 22:10 boot\ndrwxr-xr-x 2 gdm  gdm   1024 Nov  6 15:45 dev\ndrwxr-xr-x 2 gdm  gdm   1024 Nov  5 22:01 lib\nlrwxrwxrwx 1 gdm  gdm     11 Nov  5 18:35 linuxrc -> bin/busybox\ndrwx------ 2 root root 16384 Nov  6 17:04 lost+found\ndrwxr-xr-x 2 gdm  gdm   3072 Nov  5 18:35 sbin\ndrwxr-xr-x 4 gdm  gdm   1024 Nov  5 18:35 usr\n\nsudo umount /mnt\n\n```\n\n6. 卸除循环设备：\n\n```bash\nsudo losetup -d /dev/loop3\n```\n\n\n\n","tags":["Linux","rootfs","根文件系统","busybox"],"categories":["Linux","系统移植"]},{"title":"mx6ull开发版移植nxp官方linux内核","url":"/posts/44016/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n\n> 基于野火 I.MX6ULL S1 Pro 开发板。\n## 1. 获取内核源码\n\n访问nxp官网：\n[用于 i.MX 应用处理器的嵌入式 Linux |恩智浦半导体 --- Embedded Linux for i.MX Applications Processors | NXP Semiconductors](https://www.nxp.com/design/design-center/software/embedded-software/i-mx-software/embedded-linux-for-i-mx-applications-processors:IMXLINUX)\n\n可以看到，截至目前，官方维护版本是：`6.6.52_2.2.1` ，因此我们基于此内核构建。\n\n![](Snipaste_2025-10-31_15-55-24.png)\n\n在官方github库中获取源码：\n[Release lf-6.6.52-2.2.1 · nxp-imx/linux-imx](https://github.com/nxp-imx/linux-imx/releases/tag/lf-6.6.52-2.2.1)\n\n## 2. 编译内核源码\n\n我是用的是Arm官方工具链`arm-none-linux-gnueabihf`：[Arm GNU Toolchain Downloads – Arm Developer](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)\n\n和uboot源码编译类似：\n\n```bash\nmake ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- distclean # 清除编译后的文件\n\nmake ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- imx_v7_defconfig # 配置文件\n\nmake ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- -j10 # 10核编译，首次编译时间比较长\n\n```\n\n编译完成会生成：\n\n- **zImage**：压缩的内核镜像，位于 `arch/arm/boot/zImage`\n- **dtb**：设备树文件，位于 `arch/arm/boot/dts/nxp/imx/imx6ull-14x14-evk-emmc.dtb`\n\n## 3. 测试：在uboot中启动\n\n请参见——[mx6ull开发版移植nxp官方u-boot](obsidian://open?vault=_posts&file=mx6ull%E5%BC%80%E5%8F%91%E7%89%88%E7%A7%BB%E6%A4%8Dnxp%E5%AE%98%E6%96%B9u-boot) 3.2节。\n\n>启动成功后，如果EMMC中是没有rootfs的，或者指定了错误的块设备或分区，会提示panic，挂载不了rootfs，这是正常的。\n\n我们可以看到启动日志的第二行：\n\n```\nLinux version 6.6.52 (gdm@mDoG)\n(arm-none-linux-gnueabihf-gcc (Arm GNU Toolchain 14.3.Rel1 (Build arm-14.174)) 14.3.1 20250623,\nGNU ld (Arm GNU Toolchain 14.3.Rel1 (Build arm-14.174)) 2.44.0.20250616)\n#1 SMP PREEMPT Fri Oct 31 16:15:58 CST 2025\n```\n\n说明这确实是我们编译的内核。\n\n## 4. 创建自己的dts文件和config文件\n\n### 4.1. dts\n\n打开 `arch/arm/boot/dts/nxp/imx/` ，可以看到许多dts文件，我们以\n`imx6ull-14x14-evk.dts` 为模板创建，为什么不用 `imx6ull-14x14-evk-emmc.dts` 呢？查看文件 `imx6ull-14x14-evk-emmc.dts`：\n\n```\n#include \"imx6ull-14x14-evk.dts\"\n&usdhc2 {\n    pinctrl-names = \"default\", \"state_100mhz\", \"state_200mhz\";\n    pinctrl-0 = <&pinctrl_usdhc2_8bit>;\n    pinctrl-1 = <&pinctrl_usdhc2_8bit_100mhz>;\n    pinctrl-2 = <&pinctrl_usdhc2_8bit_200mhz>;\n    bus-width = <8>;\n    non-removable;\n    status = \"okay\";\n};\n```\n\n我们发现其实它只是在 `imx6ull-14x14-evk.dts` 的基础上加了 usdhc2 的修改。\n**所以我们只需要将这个 &usdhc2 里的内容复制到 `imx6ull-14x14-evk.dts` 后面就可以了。**\n\n我将自己的配置文件命名为：`mx6ull-14x14-evk[gdm-main].dts`，表示这是以 `imx6ull-14x14-evk.dts` 为模板创建的，且是主要文件。因为这个 dts 文件还包含了其他的 dtsi 文件——也就是 dts 的头文件，后续我们如果要修改头文件中的内容，也将头文件复制下来改名作修改，并在 dts 文件中包含这个复制后的头文件，这样可以避免直接修改源文件导致其他的 dts 配置错误（因为头文件不只在一个文件中包含）。\n\n**然后打开 `arch/arm/boot/dts/nxp/imx/Makefile` 添加 `mx6ull-14x14-evk[gdm-main].dtb` 的make目标。**\n\n### 4.2. defconfig\n\n同理，以 `arch/arm/configs/imx_v7_defconfig` 为模板创建。\n\n### 4.3. 编译下载启动\n\n重复本篇第2节、第3节的内容。如果 EMMC 里有 rootfs 并正确配置，则可正常启动\n\n---\n\n<p style=\"font-size:30px\"> <strong>以下为补充部分</strong></p>\n\n---\n\n## 5. 主频修改\n\n进入到系统后（我的是buildroot）使用以下命令：\n\n```bash\ncat /proc/cpuinfo\n```\n\n查看cpu信息输出：\n\n```\nprocessor       : 0\nmodel name      : ARMv7 Processor rev 5 (v7l)\nBogoMIPS        : 24.00\nFeatures        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae\nCPU implementer : 0x41\nCPU architecture: 7\nCPU variant     : 0x0\nCPU part        : 0xc07\nCPU revision    : 5\n\nHardware        : Freescale i.MX6 Ultralite (Device Tree)\nRevision        : 0000\nSerial          : 2f39b9d75d68c574\n```\n\nBogoMIPS 这一条，此时 BogoMIPS 为 24.00，BogoMIPS 是 Linux 系统中\n衡量处理器运行速度的一个“尺子”，处理器性能越强，主频越高，BogoMIPS 值就越大。\nBogoMIPS 只是粗略的计算 CPU 性能，并不十分准确。\n\n我们再来看看如何查看工作频率及相关信息。\n\n进入到目录 `/sys/bus/cpu/devices/cpu0/cpufreq`:\n\n```\naffected_cpus                  scaling_cur_freq\ncpuinfo_cur_freq               scaling_driver\ncpuinfo_max_freq               scaling_governor\ncpuinfo_min_freq               scaling_max_freq\ncpuinfo_transition_latency     scaling_min_freq\nrelated_cpus                   scaling_setspeed\nscaling_available_frequencies  stats\nscaling_available_governors\n```\n\n此目录中记录了 CPU 频率等信息，这些文件的含义如下：\n\n| 目录项                           | 描述                                            |\n| ----------------------------- | --------------------------------------------- |\n| cpuinfo_cur_freq              | 当前 cpu 工作频率，从 CPU 寄存器读取到的工作频率。                |\n| cpuinfo_max_freq              | 处理器所能运行的最高工作频率(单位: KHz）。                      |\n| cpuinfo_min_freq              | 处理器所能运行的最低工作频率(单位: KHz）。                      |\n| cpuinfo_transition_latency    | 处理器切换频率所需要的时间(单位:ns)。                         |\n| scaling_available_frequencies | 处理器支持的主频率列表(单位: KHz）。                         |\n| scaling_available_governors   | 当前内核中支持的所有 governor(调频)类型。                    |\n| scaling_cur_freq              | 保存着 cpufreq 模块缓存的当前 CPU 频率，不会对 CPU 硬件寄存器进行检查。 |\n| scaling_driver                | 该文件保存当前 CPU 所使用的调频驱动。                         |\n| scaling_max_freq              | governor(调频)可以调节的最高频率。                        |\n| cpuinfo_min_freq              | governor(调频)可以调节的最低频率。                        |\n\n此外还有：\n\n- **scaling_governor**：governor(调频)策略，Linux 内核一共有 5 中调频策略，\n\t1. `Performance`：最高性能，直接用最高频率，不考虑耗电。\n\t2. `Interactive`：一开始直接用最高频率，然后根据 CPU 负载慢慢降低。\n\t3. `Powersave`：省电模式，通常以最低频率运行，系统性能会受影响，一般不会用这个！\n\t4. `Userspace`：可以在用户空间手动调节频率。\n\t5. `Ondemand`，：定时检查负载，然后根据负载来调节频率。负载低的时候降低 CPU 频率，这样省电，负载高的时候提高 CPU 频率，增加性能。\n\n- **stats** 目录下给出了 CPU 各种运行频率的统计情况，比如 CPU 在各频率下的运行时间及变频次数。\n\n使用命令查看各参数的值：\n```bash\ncat [目录项]\n```\n\n会发现当前调度模式是 `Ondemand`。\n\n如果我想让我们的板子一直满血运行，怎么做？我们只需图形化配置defconfig文件。\n\n进入到 kernel 源码目录，使用命令打开图形化配置文件：\n\n```bash\nmake menuconfig\n```\n\n![](Snipaste_2025-10-31_23-08-34.png)\n\n进入 `CPU Power Management`-> `CPU Frequency scaling`-> `Default CPUFreq governor` ，选择performance，再次编译（不用distclean清理），再传进开发板。\n\n再次查看就可以发现：\n\n![](Snipaste_2025-10-31_23-15-11.png)\n\n**当然日常使用还是 `Ondemand` 更好，所以我还是换回 `Ondemand` 了。**\n\n至此，我们以修改主频为引，介绍了如何调试修改配置文件并应用修改。\n\n--end--\n\n## 6. 系统网络测试\n\n野火的板子PHY芯片使用的和nxp官方的一样，因此直接适配nxp官方linux内核，不用修改设备树文件，所以这里讲一下网络测试。\n\n进入到系统后，默认是没有启用任何一个网络驱动设备的，使用 `ifconfig` 命令可能只会显示一个“loc”。所以我们输入命令查看所有的网络驱动设备：\n\n```bash\nifconfig -a\n```\n\n输出：\n\n![](Snipaste_2025-11-02_18-29-44.png)\n\n我通过MAC地址分辨出我应该启用的是 `eth0` 它正通过网线连接着我的电脑，输入命令：\n\n```bash\nifconfig eth0 up\n```\n\n启用后，我们通过 `ifconfig` 命令就能查看到这个设备了。但是这个网卡都还没\n有 IP 地址，所以不能进行 ping 等操作。\n\n所以我们为其分配 ip 地址：\n\n```bash\nifconfig eth0 192.168.137.145\n```\n\n现在就能 ping 通我的电脑了。\n我的电脑以太网卡 ip 地址为 192.168.137.1：\n\n![](Snipaste_2025-11-02_18-38-02.png)\n\n","tags":["Linux","内核移植"],"categories":["Linux","系统移植"]},{"title":"mx6ull开发版移植nxp官方u-boot","url":"/posts/26288/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 1. 我写尼玛！\n\n我他妈直接不想码字。\n我他妈直接转载。\n\n**移植和烧录部分：**\n作者：觉皇嵌入式 遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议。\n[i.MX6ULL - 从零开始移植uboot-imx_v2020.04_5.4.70_2.3.0-CSDN博客](https://blog.csdn.net/qq153471503/article/details/126587387)\n\n---\n\n>**以下为后续补充**\n\n## 2. 图形化配置 \n\n在uboot目录下，使用命令：\n\n```\nmake menuconfig\n```\n\n可以通过图形化界面配置uboot，更加直观。\n\n## 3. U-boot 启动Linux测试\n\n### 3.1. 从EMMC启动（EMMC里有原厂自带文件）\n\n#### 3.1.1. 查看\n\n首先检查EMMC里面是否有——Linux镜像zImage、.dtb文件和根文件系统。\n\n我们当前的mmc环境是SD卡，切换到EMMC。输入命令：\n\n```\nmmc dev 1\n```\n\n>具体EMMC的设备号 根据实际情况输入。\n\n该开发板EMMC分区是这样的：\n- 分区0：是存放boot的，\n- 分区1：存放linux镜像和设备树，\n- 分区2：存放root。\n\n>可以使用 `fstype mmc dev:part` 命令查看文件系统格式。\n>其中 dev是EMMC的设备号，part是分区号。运行后：\n>分区0输出 `Unrecognized...`；\n>分区1输出 `fat` ；分区2输出 `ext4`。\n\n分区1使用的文件系统是FAT，因此用 `fatls` 查看EMMC分区1里面的文件：\n\n```\nfatls mmc dev:part\n```\n\n输出：\n\n```\n7863120   zImage\n    38733   imx6ull-mmc-npi-lite.dtb\n\n2 file(s), 0 dir(s)\n```\n\n说明系统和设备树是存在的。\n\n#### 3.1.2. 加载系统相关命令\n\n- **查看指定的镜像加载地址：**\n\n\t`printenv loadaddr`\n\n\t输出为 `0x80800000`\n\n- **查看指定的设备树加载地址：**\n\n\t`printenv fdt_addr`\n\n\t输出为 `0x83000000`\n\n- **把zImage加载到地址 `0x80800000`：**\n\n\t`fatload mmc 1:1 80800000 zImage`\n\n- **把设备树加载到地址 `0x83000000`**：\n\n\t`fatload mmc 1:1 83000000 imx6ull-mmc-npi-lite.dtb`\n\n- **启动内核：**\n\t`bootz 80800000 - 83000000`\n\n#### 3.1.3. 设置bootcmd\n\n`bootcmd` 是一个环境变量，保存着 uboot 默认命令，uboot 倒计时结束以后就会执行 bootcmd 中的命令。这些命令一般都是用来启动 Linux 内核的，比如读取 EMMC 或者 NAND Flash 中的 Linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 Linux 内核。\n\n```\nsetenv bootcmd 'mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-mmc-npi-lite.dtb; bootz 80800000 - 83000000;'\n```\n\n#### 3.1.4. 设置bootargs\n\n<details>\n\n<summary> 关于bootargs的介绍有点长，折叠一下。</summary>\n\nbootargs 保存着 uboot 传递给 Linux 内核的参数，bootargs 环境变量是由 mmcargs 设置的，mmcargs 环境变量如下：\n`mmcargs=setenv bootargs console=${console},${baudrate} root=${mmcroot}`\n\n其中 console=ttymxc0，baudrate=115200，mmcroot=/dev/mmcblk0p2 rootwait rw，\n\n因此将mmcargs 展开以后就是：\n`mmcargs=setenv bootargs console= ttymxc0, 115200 root= /dev/mmcblk0p2 rootwait rw`\n\n可以看出环境变量 mmcargs 就是设置 bootargs 的值为`console= ttymxc0, 115200 root=/dev/mmcblk1p2 rootwait rw`，\n\nbootargs 就是设置了很多的参数的值，这些参数 Linux 内核会使用到，常用的参数有：\n\n- **console：**\n\tconsole 用来设置 linux 终端(或者叫控制台)，也就是通过什么设备来和 Linux 进行交互，例如串口、 LCD 屏幕。如果是串口的话应该是串口几、波特率等。一般设置串口作为 Linux 终端，这样我们就可以在电脑上通过串口程序来和 linux 交互了。这里设置 console 为 ttymxc0，因为 linux启动以后 I.MX6ULL 的串口 1 在 linux 下的设备文件就是/dev/ttymxc0，”一切皆文件“。\n- **root：**\n\troot 用来设置根文件系统的位置，例如，`root=/dev/mmcblk1p2` 指根文件系统存放在 mmcblk1 设备的分区 2 中。\n\t`rootwait rw`。rootwait 表示等待 mmc 设备初始化完成以后再挂载，否则的话mmc 设备还没初始化完成就挂载根文件系统会出错的。rw 表示根文件系统是可以读写的，不加 rw 的话可能无法在根文件系统中进行写操作，只能进行读操作。\n- **rootfstype：**\n\t此选项一般配置 root 一起使用，rootfstype 用于指定根文件系统类型，如果根文件系统为ext 格式的话此选项无所谓。如果根文件系统是 yaffs、jffs 或 ubifs 的话就需要设置此选项，指定根文件系统的类型。\n\n</details>\n\n设置：\n```\nsetenv bootargs 'console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw'\n```\n\n#### 3.1.5. 启动\n\n使用命令 `run bootcmd` 或 在切换到EMMC环境后直接输入`boot`。\n\n### 3.2. 从网络启动\n\n#### 3.2.1. 安装 tftpd-hpa 和客户端工具\n\n```bash\nsudo apt update\nsudo apt install tftpd-hpa tftp-hpa\n```\n\n#### 3.2.2. 创建共享目录并开放权限\n\nTFTP 的默认根目录是 `/srv/tftp`，你也可以改成别的：\n\n```bash\nsudo mkdir -p /srv/tftp\nsudo chmod 777 /srv/tftp\n```\n\n然后把要传的文件（比如 `uImage`）放进去：\n\n```bash\ncp ~/uImage /srv/tftp/\n```\n\n#### 3.2.3. 手动启动 TFTP 服务（因为没有 systemctl）\n\n直接运行：\n\n```bash\nsudo /usr/sbin/in.tftpd --foreground --secure --verbose /srv/tftp\n```\n\n- --foreground：在前台运行\n- --secure：只允许访问指定目录\n- --verbose：打印详细日志\n\n> 还有一些选项，例如：\n> --address <ip:port>：指定 TFTP 服务监听的 IP 地址和端口。\n> --blocksize <大小>：指定一个数据包的大小。\n> --create：允许客户端上传。\n\n这会在前台启动服务器（按 `Ctrl+C` 可停止）。\n\n如果你想让它**后台运行**：\n\n```bash\nsudo /usr/sbin/in.tftpd --secure /srv/tftp &\n```\n\n#### 3.2.4. 确认服务在监听 UDP 69 端口\n\n```bash\nsudo netstat -anu | grep :69\n```\n\n或者：\n\n```bash\nsudo ss -anu | grep 69\n```\n\n出现类似：\n\n```nginx\nudp   UNCONN  0      0      0.0.0.0:69    0.0.0.0:*\n```\n\n说明启动成功。\n\n#### 3.2.5. 让 U-Boot 能访问 WSL 的 IP\n\n这是关键部分。\nWSL 和 Windows 的网络是**桥接但不完全共享的**，所以开发板不能直接访问 `127.0.0.1` 或 `localhost`。\n\n1. 在 Windows 里执行：\n\n```powershell\nipconfig\n```\n找到 **以太网适配器 vEthernet (WSL)** 这一项。\n它通常是类似 `172.25.x.x` 或 `192.168.137.x` 的 IP，比如：\n\n```nginx\nIPv4 Address. . . . . . . . . . . : 172.27.240.1\n```\n2. 在 U-Boot 里设置：\n\n```bash\nsetenv serverip 192.168.137.1\nsetenv ipaddr 192.168.137.144\n```\n\n3. 关闭防火墙：\n\t在设置——网络与Internet——高级网络设置——Windows防火墙，将公用网络中的防火墙暂时关闭。\n\t\n4. 测试：\n\n```bash\nping 192.168.137.1\n```\n如果显示 “host is alive”，说明连通。\n\n#### 3.2.6. 传文件\n\n假设你要下载 `/srv/tftp/uImage` 到内存地址 `0x80800000`：\n\n```bash\ntftp 0x80800000 uImage\n```\n\n看到类似输出：\n\n```nginx\nUsing FEC device\nTFTP from server 172.27.240.1; our IP address is 172.27.240.166\nFilename 'uImage'.\nLoad address: 0x80800000\nLoading: #########################################\ndone\nBytes transferred = 3456789 (34abcd hex)\n```\n\n就成功了！\n","tags":["Linux","u-boot移植"],"categories":["Linux","系统移植"]},{"title":"大蟒蛇-typer库","url":"/posts/40650/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 一、安装\n\n```bash\npip install typer[all]\n```\n\n`[all]` 会额外安装颜色和补全功能（推荐）。\n\n## 二、最简单的例子\n\n```python\nimport typer\n\ndef main(name: str):\n    typer.echo(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n```\n\n运行：\n```bash\npython3 app.py gdm\n```\n\n输出：\n```\nHello gdm\n```\n\nTyper 会自动解析命令行参数并生成帮助：\n\n```bash\npython3 app.py --help\n```\n\n```\nUsage: app.py [OPTIONS] NAME\n\nArguments:\n  NAME  [required]\n\nOptions:\n  --help  Show this message and exit.\n```\n\n\n## 三、带类型提示的参数解析\n\nTyper 会根据**Python 类型注解**自动转换输入：\n\n```python\ndef main(\nname: str, \nage: int, \nactive: bool = True\n):\n    typer.echo(f\"Name: {name}, Age: {age}, Active: {active}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n执行：\n```bash\npython3 app.py gdm 25 --active\n```\n\n或关闭 active：\n```bash\npython3 app.py gdm 25 --no-active\n```\n\n\n## 四、使用选项（Options）\n\n如果你希望某个参数是可选的、带前缀的选项，可以用 `typer.Option`。\n\n```python\ndef main(\nname: str = typer.Option(\"World\", help=\"名字\"), \nrepeat: int = typer.Option(1, help=\"重复次数\")\n):\n\n    for _ in range(repeat):\n        typer.echo(f\"Hello {name}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n\n```\n\n运行：\n\n\n```bash\npython3 app.py --name gdm --repeat 3\n```\n\n\n## 五、使用参数（Arguments）\n\n`typer.Argument()` 用于定义**位置参数**，即必需参数。\n\n```python\ndef main(filename: str = typer.Argument(..., help=\"文件路径\")):\n    typer.echo(f\"Processing file: {filename}\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n```\n\n`...` 表示必须提供。\n\n示例：\n```bash\npython3 app.py data.txt\n```\n\n\n## 六、命令分组（多个子命令）\n\n你可以像写 Git 一样定义多命令结构。\n\n```python\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef add(a: int, b: int):\n    typer.echo(a + b)\n\n@app.command()\ndef sub(a: int, b: int):\n    typer.echo(a - b)\n\nif __name__ == \"__main__\":\n    app()\n```\n\n运行：\n```bash\npython3 app.py add 3 5\npython3 app.py sub 10 2\n```\n\n帮助信息：\n```bash\npython3 app.py --help\n```\n\n```\nCommands:\n  add\n  sub\n```\n\n\n## 七、默认命令（入口函数）\n\n如果只定义一个命令，也可以这样写：\n\n```python\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef greet(name: str):\n    typer.echo(f\"Hi {name}\")\n\nif __name__ == \"__main__\":\n    app()\n\n```\n\n\n## 八、提示输入（Prompt）\n\nTyper 支持交互式输入：\n\n```python\ndef main(password: str = typer.Option(..., prompt=True, hide_input=True)):\n    typer.echo(\"Password received!\")\n\nif __name__ == \"__main__\":\n    typer.run(main)\n```\n\n运行后会提示输入密码而不回显。\n\n## 九、颜色输出\n\n```python\ntyper.secho(\"成功!\", fg=typer.colors.GREEN, bold=True)\ntyper.secho(\"警告!\", fg=typer.colors.YELLOW)\ntyper.secho(\"错误!\", fg=typer.colors.RED)\n```\n\n## 十、退出与错误\n\n```python\nif error:\n    typer.echo(\"Something went wrong.\")\n    raise typer.Exit(code=1)\n```\n\n或：\n\n```python\ntyper.Abort()  # 相当于 Ctrl+C\n```\n\n\n## 十一、自动补全\n\n为终端安装 Typer 补全脚本：\n\n```bash\napp --install-completion\n\n```\n\n然后重启终端。\n\n## 十二、复杂结构（嵌套命令）\n\n可以创建多个 `Typer` 实例，并注册子命令模块：\n\n```python\nimport typer\n\napp = typer.Typer()\nuser_app = typer.Typer()\napp.add_typer(user_app, name=\"user\")\n\n@user_app.command(\"create\")\ndef create_user(name: str):\n    typer.echo(f\"Created user: {name}\")\n\nif __name__ == \"__main__\":\n    app()\n```\n\n运行：\n```bash\npython app.py user create gdm\n```\n\n\n## 十三、与Click兼容\n\nTyper 基于 Click，可以混用 Click 的函数：\n\n```python\nimport typer\nimport click\n\n@app.command()\n@click.option(\"--debug/--no-debug\", default=False)\ndef run(debug):\n    typer.echo(f\"Debug = {debug}\")\n\n```\n\n## 十四、完整示例\n\n一个带颜色、帮助信息、命令组、选项的综合例子：\n\n```python\nimport typer\n\napp = typer.Typer(help=\"一个简单的文件处理工具\")\n\n@app.command(help=\"读取文件内容\")\ndef read(file: str):\n    with open(file, \"r\", encoding=\"utf-8\") as f:\n        typer.echo(f.read())\n\n@app.command(help=\"统计文件行数\")\ndef count(file: str):\n    lines = sum(1 for _ in open(file, \"r\", encoding=\"utf-8\"))\n    typer.secho(f\"{file}: {lines} lines\", fg=typer.colors.GREEN)\n\nif __name__ == \"__main__\":\n    app()\n\n```\n"},{"title":"大蟒蛇-rich库","url":"/posts/30447/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 🪶 Rich 库新手使用指南\n\n\n`Rich` 是一个超强的 Python 库，用来让终端输出变得**漂亮、有色彩、有格式**。\n它可以显示**彩色文字、表格、进度条、Markdown、高亮代码、日志信息**等。\n\n安装非常简单：\n\n```bash\npip install rich\n```\n\n导入方式：\n\n```python\nfrom rich import print\nfrom rich.console import Console\n```\n\n\n### 一、彩色输出基础\n\nRich 自带的 `print` 可以直接使用类似 BBCode 的标签上色。\n\n```python\nfrom rich import print\n\nprint(\"[bold red]错误：[/bold red] 文件未找到！\")\nprint(\"[green]任务完成！[/green]\")\nprint(\"[yellow on black]警告：内存不足[/yellow on black]\")\n```\n\n`[color]文字[/color]`\n支持样式如：`bold`, `italic`, `underline`, `red`, `green`, `blue`, `on color`, `blink` 等。\n\n### 二、使用 Console 对象（更灵活）\n\n```python\nfrom rich.console import Console\n\nconsole = Console()\nconsole.print(\"普通输出\")\nconsole.print(\"[bold magenta]高亮输出[/bold magenta]\")\nconsole.log(\"这是带时间戳的日志输出\")\n```\n\n### 三、打印表格\n\n```python\nfrom rich.console import Console\nfrom rich.table import Table\n\ntable = Table(title=\"学生成绩\")\n\ntable.add_column(\"姓名\", style=\"cyan\", no_wrap=True)\ntable.add_column(\"科目\", style=\"magenta\")\ntable.add_column(\"分数\", justify=\"right\", style=\"green\")\n\ntable.add_row(\"张三\", \"数学\", \"88\")\ntable.add_row(\"李四\", \"英语\", \"93\")\ntable.add_row(\"王五\", \"物理\", \"75\")\n\nconsole = Console()\nconsole.print(table)\n```\n\n输出：彩色、有边框的漂亮表格。\n\n### 四、进度条\n\n```python\nimport time\nfrom rich.progress import track\n\nfor i in track(range(10), description=\"[cyan]正在处理...\"):\n    time.sleep(0.3)\n```\n\n它会在终端显示一个动态进度条，非常直观。\n\n### 五、打印 Markdown 文本\n\n```python\nfrom rich.console import Console\nfrom rich.markdown import Markdown\n\nmd = Markdown(\"\"\"\n# 标题\n- 支持列表\n- **加粗**\n- *斜体*\n\"\"\")\n\nconsole = Console()\nconsole.print(md)\n```\n\n\n### 六、代码高亮\n\n```python\nfrom rich.console import Console\nfrom rich.syntax import Syntax\n\ncode = '''\ndef hello():\n    print(\"Hello, world!\")\n'''\n\nsyntax = Syntax(code, \"python\", theme=\"monokai\", line_numbers=True)\nconsole = Console()\nconsole.print(syntax)\n```\n\n### 七、日志与追踪\n\n```python\nfrom rich.console import Console\nfrom rich.traceback import install\n\ninstall()  # 让报错显示彩色堆栈\nconsole = Console()\n\ndef divide(a, b):\n    return a / b\n\ndivide(5, 0)  # 会输出带颜色的错误信息\n\n```\n\n### 八、组合示例：多种元素一起展示\n\n```python\nfrom rich.console import Console\nfrom rich.table import Table\nfrom rich.progress import track\nfrom time import sleep\n\nconsole = Console()\n\nconsole.rule(\"[bold green]Rich 示例\")\n\ntable = Table(title=\"任务状态\")\ntable.add_column(\"任务名\", style=\"cyan\")\ntable.add_column(\"状态\", style=\"magenta\")\n\nfor i in track(range(5), description=\"[yellow]执行任务中...\"):\n    sleep(0.2)\n    table.add_row(f\"任务{i+1}\", \"完成\")\n\nconsole.print(table)\nconsole.rule(\"[bold blue]执行结束\")\n\n```\n\n### 九、常见功能速览\n\n| 功能 | 模块 | 示例 |\n| ---- | ---- | ---- |\n| 彩色文本 | rich.print | [red]Error[/red] |\n| 表格 | rich.table.Table | 美观的表格输出 |\n| 进度条 | rich.progress | track() |\n| Markdown | rich.markdown.Markdown | 渲染 Markdown |\n| 代码高亮 | rich.syntax.Syntax | 高亮 Python 等代码 |\n| 日志输出 | console.log() | 彩色时间戳日志 |\n| 彩色错误追踪 | rich.traceback.install() | 让异常更清晰 |\n\n## 🌈 Rich 进阶组件使用指南\n\n这些功能让你不仅能“美化输出”，还能在终端中**构建交互式信息界面**。\n主要包括：`Panel`、`Layout`、`Tree`、`Live`、`Columns` 等模块。\n\n### 一、Panel —— 给内容加上“信息卡片边框”\n\n`Panel` 用来让内容看起来像一块醒目的提示板。\n\n```python\nfrom rich.console import Console\nfrom rich.panel import Panel\n\nconsole = Console()\n\npanel = Panel(\n    \"[bold yellow]操作成功！[/bold yellow]\\n数据已保存到数据库。\",\n    title=\"通知\",\n    subtitle=\"rich.panel 示例\",\n    border_style=\"green\"\n)\n\nconsole.print(panel)\n```\n\n可以设置：\n\n- `title` / `subtitle`：上、下标题\n- `border_style`：边框颜色\n- `expand=True`：让面板占满终端宽度\n\n### 二、Layout —— 构建终端“界面布局”\n\n`Layout` 能让终端像网页一样分区。适合日志面板、状态栏等。\n\n```python\nfrom rich.console import Console\nfrom rich.layout import Layout\nfrom rich.panel import Panel\n\nconsole = Console()\nlayout = Layout()\n\n# 整体分为上下两部分\nlayout.split(\n    Layout(name=\"header\", size=3),\n    Layout(name=\"body\", ratio=1)\n)\n\n# 再把 body 分为左右\nlayout[\"body\"].split_row(\n    Layout(name=\"left\"),\n    Layout(name=\"right\")\n)\n\nlayout[\"header\"].update(Panel(\"[bold magenta]Rich Layout 示例\"))\nlayout[\"left\"].update(Panel(\"左侧面板内容\"))\nlayout[\"right\"].update(Panel(\"右侧面板内容\"))\n\nconsole.print(layout)\n```\n\n可以使用 `split()`（上下）或 `split_row()`（左右）来划分区域。\n每个区域都能用 `.update()` 放入 `Panel`、`Table`、`Markdown` 等内容。\n\n### 三、Tree —— 生成漂亮的目录结构\n\n`Tree` 是一个树形结构输出工具，很适合打印文件层级或配置结构。\n\n```python\nfrom rich.console import Console\nfrom rich.tree import Tree\n\nconsole = Console()\n\ntree = Tree(\"📂 项目结构\")\nsrc = tree.add(\"src\")\nsrc.add(\"main.py\")\nsrc.add(\"utils.py\")\n\ndocs = tree.add(\"docs\")\ndocs.add(\"readme.md\")\n\ntree.add(\"requirements.txt\")\n\nconsole.print(tree)\n```\n\n可搭配 emoji 和颜色使用，让终端目录更直观。\n\n### 四、Live —— 实时更新终端内容（动态界面）\n\n`Live` 能让你持续刷新输出，而不是刷屏。\n\n```python\nimport time\nfrom rich.live import Live\nfrom rich.table import Table\n\ntable = Table()\ntable.add_column(\"任务\")\ntable.add_column(\"进度\")\n\nwith Live(table, refresh_per_second=4):\n    for i in range(5):\n        table.add_row(f\"任务 {i+1}\", f\"{(i+1)*20}%\")\n        time.sleep(1)\n```\n\n`Live` 会在同一块区域动态更新内容，非常适合实时监控或进度显示。\n\n\n\n### 五、Columns —— 多列并排显示内容\n\n当你想让一堆内容整齐地排在一行（比如日志或状态栏）时，`Columns` 是利器。\n\n```python\nfrom rich.console import Console\nfrom rich.columns import Columns\nfrom rich.panel import Panel\n\nconsole = Console()\n\npanels = [\n    Panel(\"CPU: 24%\", title=\"系统状态\", border_style=\"cyan\"),\n    Panel(\"内存: 1.2 GB\", title=\"内存\", border_style=\"green\"),\n    Panel(\"网络: 正常\", title=\"网络\", border_style=\"magenta\"),\n]\n\nconsole.print(Columns(panels))\n```\n\n会自动根据终端宽度排版，多列自适应。\n\n### 六、Progress（进阶版）—— 多任务进度条\n\n之前的 `track()` 是简化用法。\n进阶用法可以同时显示多个任务。\n\n```python\nimport time\nfrom rich.progress import Progress\n\nwith Progress() as progress:\n    task1 = progress.add_task(\"[cyan]下载文件A...\", total=100)\n    task2 = progress.add_task(\"[magenta]下载文件B...\", total=100)\n\n    while not progress.finished:\n        progress.update(task1, advance=2)\n        progress.update(task2, advance=1)\n        time.sleep(0.05)\n```\n\n你可以随时 `update(task_id, advance=x)` 来推进进度，非常适合多线程或循环任务。\n\n### 七、组合示例：一个简易“系统监控界面”\n\n```python\nimport time\nfrom rich.console import Console\nfrom rich.layout import Layout\nfrom rich.panel import Panel\nfrom rich.live import Live\n\nconsole = Console()\n\nlayout = Layout()\nlayout.split_column(\n    Layout(name=\"header\", size=3),\n    Layout(name=\"main\", ratio=1),\n    Layout(name=\"footer\", size=3)\n)\n\nlayout[\"header\"].update(Panel(\"[bold green]🖥 系统监控\"))\nlayout[\"footer\"].update(Panel(\"按 Ctrl+C 退出\", border_style=\"red\"))\n\ndef make_main_panel(cpu, mem):\n    return Panel(f\"CPU 使用率: {cpu}%\\n内存占用: {mem} MB\", border_style=\"cyan\")\n\nwith Live(layout, refresh_per_second=2):\n    for i in range(100):\n        cpu = (i * 3) % 100\n        mem = 500 + (i * 2)\n        layout[\"main\"].update(make_main_panel(cpu, mem))\n        time.sleep(0.1)\n```\n\n运行后，你会看到一个实时更新的动态“界面”，像个迷你监控台。\n\n## 高级\n\nRich 的开发者还写了一个基于它的**终端应用框架**：[**Textual**](https://github.com/Textualize/textual)  \n它能让你用 Rich 的基础语法写出带窗口、按钮、滚动区的完整 TUI（终端UI）程序。\n\n有余力可以学习一下。\n","tags":["python","rich"],"categories":["python"]},{"title":"大蟒蛇-json库","url":"/posts/50277/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## json.load()\n**描述：** 从文件对象读取 JSON 数据并反序列化为 Python 对象  \n**语法：**\n```python\njson.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)\n```\n**示例：**\n```python\nimport json\nwith open('data.json', 'r') as f:\n    data = json.load(f)\n```\n\n## json.loads()\n**描述：** 从字符串读取 JSON 数据并反序列化为 Python 对象  \n**语法：**\n```python\njson.loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)\n```\n**示例：**\n```python\ndata = json.loads('{\"name\": \"Alice\", \"age\": 25}')\n```\n\n## json.dump()\n**描述：** 将 Python 对象序列化为 JSON 并写入文件  \n**语法：**\n```python\njson.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True,\n          allow_nan=True, cls=None, indent=None, separators=None,\n          default=None, sort_keys=False, **kw)\n```\n**示例：**\n```python\ndata = {\"name\": \"Bob\", \"age\": 30}\nwith open('data.json', 'w') as f:\n    json.dump(data, f, indent=4)\n```\n\n## json.dumps()\n**描述：** 将 Python 对象序列化为 JSON 字符串  \n**语法：**\n```python\njson.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True,\n           allow_nan=True, cls=None, indent=None, separators=None,\n           default=None, sort_keys=False, **kw)\n```\n**示例：**\n```python\ns = json.dumps({\"x\": 1, \"y\": 2}, indent=2)\n```\n\n## json.JSONDecoder\n**描述：** JSON 反序列化类，可自定义解析逻辑  \n**语法：**\n```python\nclass json.JSONDecoder(object_hook=None, object_pairs_hook=None, parse_float=None,\n                       parse_int=None, parse_constant=None, strict=True, **kw)\n```\n**示例：**\n```python\ndecoder = json.JSONDecoder()\nobj = decoder.decode('{\"a\":1,\"b\":2}')\n```\n\n## json.JSONEncoder\n**描述：** JSON 序列化类，可自定义编码行为  \n**语法：**\n```python\nclass json.JSONEncoder(skipkeys=False, ensure_ascii=True, check_circular=True,\n                       allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)\n```\n**示例：**\n```python\nencoder = json.JSONEncoder(indent=2)\ns = encoder.encode({\"name\": \"test\"})\n```\n\n## json.JSONDecodeError\n**描述：** 解码 JSON 时的异常类型（继承自 `ValueError`）  \n**语法：**\n```python\ntry:\n    json.loads('invalid json')\nexcept json.JSONDecodeError as e:\n    print(e)\n```\n\n## json.tool（命令行模块）\n**描述：** 命令行工具，用于格式化 JSON 输出  \n**语法：**\n```bash\npython -m json.tool input.json\n```\n**示例：**\n```bash\necho '{\"a\":1,\"b\":2}' | python -m json.tool\n```\n\n## 参数说明（适用于 dump/dumps/load/loads）\n\n### indent\n控制缩进格式（整数或字符串）  \n```python\njson.dumps(data, indent=4)\n```\n\n### separators\n自定义分隔符（默认 `(', ', ': ')`）  \n```python\njson.dumps(data, separators=(',', ':'))\n```\n\n### sort_keys\n按键名排序输出  \n```python\njson.dumps(data, sort_keys=True)\n```\n\n### ensure_ascii\n是否转义非 ASCII 字符  \n```python\njson.dumps({\"中文\": \"测试\"}, ensure_ascii=False)\n```\n\n### default\n定义无法序列化对象的处理函数  \n```python\ndef encode_complex(obj):\n    if isinstance(obj, complex):\n        return {\"real\": obj.real, \"imag\": obj.imag}\n    raise TypeError()\n\njson.dumps(1+2j, default=encode_complex)\n```\n\n### object_hook\n自定义反序列化处理函数  \n```python\ndef as_person(d):\n    return Person(d['name']) if 'name' in d else d\n\njson.loads('{\"name\":\"Alice\"}', object_hook=as_person)\n```\n\n### parse_float, parse_int, parse_constant\n用于自定义解析数字/常量的函数  \n```python\njson.loads('{\"num\": 1.23}', parse_float=lambda x: round(float(x), 1))\n```\n\n## 常见用法对比\n\n| 操作   | 从字符串         | 从文件         | 输出为字符串       | 输出为文件       |\n| ---- | ------------ | ----------- | ------------ | ----------- |\n| 反序列化 | json.loads() | json.load() | —            | —           |\n| 序列化  | —            | —           | json.dumps() | json.dump() |\n\n","tags":["python","json"],"categories":["python"]},{"title":"u-boot常见命令","url":"/posts/13859/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\nU-Boot（Universal Boot Loader）是嵌入式系统开发中一个非常重要的组件，它负责在操作系统启动之前，进行基本的硬件初始化，并提供一个交互式的命令行接口，以便用户进行系统配置、内核加载等操作。掌握 U-Boot 的常见命令是嵌入式工程师的基本功。\n\n本文将为您介绍一些 U-Boot 中最常用和最关键的命令及其用途。\n\n## 一、 环境与信息查看命令\n\n这些命令用于查看和管理 U-Boot 的运行环境和系统信息。\n\n| **命令**       | **用途**                                  | **示例**                 | **备注**              |\n| ------------ | --------------------------------------- | ---------------------- | ------------------- |\n| `help` 或 `?` | 显示所有可用命令的列表或特定命令的帮助信息。                  | `help` / `help setenv` | `?` 是 `help` 的别名。   |\n| `printenv`   | 显示所有的环境变量及其值。                           | `printenv`             | 环境变量通常保存在非易失性存储介质中。 |\n| `bdinfo`     | 显示板级信息（Board Info Structure），如内存地址、大小等。 | `bdinfo`               |                     |\n| `version`    | 显示 U-Boot 的版本信息。                        | `version`              |                     |\n\n## 二、 环境变量操作命令\n\n环境变量是 U-Boot 配置系统行为的关键，例如定义启动参数、网络设置等。\n\n|**命令**|**用途**|**示例**|**备注**|\n|---|---|---|---|\n|`setenv`|设置或修改一个环境变量的值。|`setenv ipaddr 192.168.1.100`|更改是临时的，只在当前 U-Boot 会话中生效。|\n|`saveenv`|将当前内存中的环境变量保存到非易失性存储（如 Flash 或 eMMC）中。|`saveenv`|使环境变量永久生效。|\n|`run`|执行存储在一个环境变量中的命令序列。|`run bootcmd`|`bootcmd` 是一个重要的环境变量，定义了自动启动时执行的命令。|\n|`bootargs`|**（特殊变量）** 设置传递给 Linux 内核的启动参数。|`setenv bootargs 'root=/dev/mmcblk0p2 console=ttyS0,115200'`|通常在启动前设置。|\n|`bootcmd`|**（特殊变量）** 设定 U-Boot 自动启动时执行的命令。|`setenv bootcmd 'tftp 0x42000000 zImage; bootm 0x42000000'`|启动时若不打断，则执行此变量中的命令。|\n\n## 三、 内存与存储操作命令\n\n这些命令用于读写内存、从外部存储加载数据、以及操作 Flash 等。\n\n| **命令**                            | **用途**                            | **示例**                                                | **备注**                                                |\n| --------------------------------- | --------------------------------- | ----------------------------------------------------- | ----------------------------------------------------- |\n| `mw`                              | 内存写入（Memory Write），向内存地址写入指定值。    | `mw.l 0x40000000 0xDEADBEEF 10`                       | `.b` (字节), `.w` (字), `.l` (长字) 指定写入单位。**10是一个十六进制数**。 |\n| `md`                              | 内存显示（Memory Display），查看指定内存地址的内容。 | `md.l 0x40000000 10`                                  | **10是一个十六进制数**，表示显示 10 个单位。                           |\n| `cp`                              | 内存拷贝（Memory Copy），在内存或存储之间复制数据。   | `cp.b 0x40000000 0x40100000 0x100`                    | 可用于从 NAND/SD/eMMC 等到 RAM 的复制。                         |\n| `erase`                           | 擦除 Flash 或其他存储区域。                 | `erase 0x50000000 +0x100000`                          | 慎用！会清除数据。                                             |\n| `nand` / `mmc` / `spi` / `sata` 等 | 针对不同存储介质的操作命令。                    | `mmc rescan` / `nand read 0x40000000 kernel 0x800000` | 具体命令取决于 U-Boot 配置和硬件支持。                               |\n| `cmp`                             | 比较两段内存地址的指定单位长度数据是否相等             | `cmp.l 80000000 80000100 10`                          | `.b` (字节), `.w` (字), `.l` (长字) 指定写入单位。**10是一个十六进制数**。 |\n\n## 四、 网络与文件传输命令\n\n在嵌入式开发中，通常通过网络（如 TFTP）从主机下载内核或文件系统镜像。\n\n| **命令**   | **用途**                    | **示例**                                                       | **备注**                             |\n| -------- | ------------------------- | ------------------------------------------------------------ | ---------------------------------- |\n| `ping`   | 测试网络连接。                   | `ping 192.168.1.1`                                           | 需要设置 `ipaddr` 和 `serverip` 环境变量。   |\n| `tftp`   | 使用 TFTP 协议从服务器下载文件到内存。    | `tftp 0x42000000 zImage`                                     | 0x42000000 是内存地址，zImage 是服务器上的文件名。 |\n| `dhcp`   | 通过 DHCP 获取板子的 IP 地址等网络参数。 | `dhcp`                                                       |                                    |\n| `setenv` | **（网络相关变量）** 设置网络参数。      | `setenv ipaddr 192.168.1.10` / `setenv serverip 192.168.1.1` |                                    |\n\n### issue#1:无法ping通\n\n第一，检查环境变量，配置好ipaddr、ethaddr、netmask，确保与主机处于同一网段。\n\n| **环境变量**  | **用途**                        |\n| --------- | ----------------------------- |\n| ipaddr    | 开发板ip地址                       |\n| ethaddr   | 开发板MAC地址                      |\n| netmask   | 子网掩码                          |\n| gatewayip | 网关地址                          |\n| serveip   | 服务器 IP 地址，也就是主机 IP 地址，用于调试代码。 |\n\n```\nsetenv ipaddr 192.168.137.144\nsetenv ethaddr yourethaddr\nsetenv netmask 255.255.255.0\nsetenv serverip 192.168.137.1\nsaveenv\n```\n\n第二，检查无误后，使用网线连接主机（电脑），发现无法ping通。\n\n- **原因**：windows系统无法识别连接到以太网接口的设备，显示为“未识别的网络”，使用的是公用网络的网络配置文件，而windows公用网络配置文件默认是不允许回应ping的，因此无法ping通。\n\n- **解决方法**：在设置——网络与Internet——高级网络设置——Windows防火墙，将公用网络中的防火墙暂时关闭，即可ping通。\n\n\n## 五、 系统启动命令\n\n这些命令用于加载并启动操作系统内核。\n\n| **命令**           | **用途**                                           | **示例**             | **备注**                         |\n| ---------------- | ------------------------------------------------ | ------------------ | ------------------------------ |\n| `bootm`          | 启动一个由 `mkimage` 工具制作的、带有 U-Boot 映像头信息的内核或操作系统映像。 | `bootm 0x42000000` | 地址是内核在 RAM 中的加载地址。             |\n| `bootz`          | 启动一个 Linux zImage 格式的内核。                         | `bootz 0x42000000` | 通常用于启动未被 `mkimage` 打包的 zImage。 |\n| `boot` 或 `bootd` | 执行 `bootcmd` 环境变量中定义的命令，实现默认启动。                  | `boot`             | `bootd` 是 `boot` 的别名。          |\n\n## 总结\n\nU-Boot 的命令众多，但上述这些是日常开发和调试中最常用的。通过这些命令，您可以实现：\n\n1. **查看和修改配置：** 使用 `printenv`、`setenv` 和 `saveenv` 管理启动参数和网络设置。\n    \n2. **加载映像文件：** 使用 `tftp`、`mmc read` 等将内核、设备树（DTB）和文件系统加载到 RAM 中。\n    \n3. **启动系统：** 使用 `bootm` 或 `bootz` 引导操作系统。\n    \n4. **调试和诊断：** 使用 `md`、`mw` 和 `ping` 等进行内存和网络测试。\n    \n\n在实际操作中，您可以通过输入 `help` 命令来获取当前 U-Boot 版本所支持的完整命令列表。希望这篇文章能帮助您更好地理解和使用 U-Boot！\n\n---\n","tags":["u-boot"],"categories":["Linux","系统移植"]},{"title":"记录搭建一台云服务器环境的过程","url":"/posts/2446/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n- [1. 前言](#1-前言)\n- [2. 操作习惯部分](#2-操作习惯部分)\n  - [2.1. 修改主机名](#21-修改主机名)\n  - [2.2. 配置时区](#22-配置时区)\n- [3. 🔐安全部分](#3-安全部分)\n  - [3.1. 重新设置root密码为强密码](#31-重新设置root密码为强密码)\n  - [3.2. 添加用户并设置强密码](#32-添加用户并设置强密码)\n  - [3.3. 系统升级](#33-系统升级)\n  - [3.4. 使用SSH Key远程登录而不是密码](#34-使用ssh-key远程登录而不是密码)\n    - [3.4.1. 在本地电脑上生成密匙对：](#341-在本地电脑上生成密匙对)\n    - [3.4.2. 创建config文件](#342-创建config文件)\n    - [3.4.3. 复制公匙到服务器](#343-复制公匙到服务器)\n    - [3.4.4. 登录](#344-登录)\n  - [3.5. 改ssh端口\\&配置防火墙](#35-改ssh端口配置防火墙)\n    - [3.5.1. 初步配置](#351-初步配置)\n    - [3.5.2. 改SSH端口](#352-改ssh端口)\n    - [3.5.3. 关闭22端口](#353-关闭22端口)\n  - [3.6. ssh配置文件](#36-ssh配置文件)\n    - [3.6.1. 禁用 root远程登录\\&密码登录](#361-禁用-root远程登录密码登录)\n    - [3.6.2. 使用SSH2](#362-使用ssh2)\n    - [3.6.3. 重启ssh](#363-重启ssh)\n  - [3.7. Fail2ban工具防暴力破解](#37-fail2ban工具防暴力破解)\n    - [3.7.1. 配置fail2ban](#371-配置fail2ban)\n    - [3.7.2. 查看状态](#372-查看状态)\n    - [3.7.3. 解封ip](#373-解封ip)\n    - [3.7.4. 启用fail2ban](#374-启用fail2ban)\n    - [3.7.5. 小贴士](#375-小贴士)\n- [4. 系统维护部分](#4-系统维护部分)\n  - [4.1. ~~使用expkg~~](#41-使用expkg)\n- [5. 系统运行部分](#5-系统运行部分)\n\n\n## 1. 前言\n\n前几天在七牛云租了一台轻量应用级服务器，2c4gb，足够满足玩具的需求了。第一次玩服务器，现在把自己的搭建环境的过程记录一下，方便日后操作。\n\n云服务器系统：Ubuntu 24.04 LTS\n云服务器厂商：七牛云\n云服务器规格：轻量型 T1 2C4GB CPU型\n\n\n## 2. 操作习惯部分\n### 2.1. 修改主机名\n\nssh登录到服务器后，发现主机名是一坨乱码，看着太难受了，必须改了。\n![](Snipaste_2025-10-14_14-17-13.png)\n\n永久修改主机名命令：\n```bash\nsudo hostnamectl set-hostname myserver\n```\n\n重启生效。\n\n### 2.2. 配置时区\n\n输入 `date` 命令，发现服务器使用的世界协调时（UTC），改为中国标准时（UTC+8），符合习惯。\n\n```bash\nsudo timedatectl set-timezone Asia/Shanghai\n```\n\n运行后，使用  `timedatectl` 命令确认是否修改成功，并查看 `NTP service` 是否启用，这是自动同步网络时间，可保持时间精准。若未启用则需查询相关教程启用。\n\n\n## 3. 🔐安全部分\n\n此部分需格外重视！\n\n### 3.1. 重新设置root密码为强密码\n\n不用多说，`passwd` 命令即可。\n\n### 3.2. 添加用户并设置强密码\n\n```bash\nadduser yourname\n```\n\n添加到sudo组：\n```bash\nusermod -aG sudo yourname\n```\n\n查看用户组：\n```bash\ncat /etc/group\n```\n\n查看当前用户所属组：`groups`命令。\n\n>设置完成后，退出root用户登录，用SSH以普通用户重新登录到服务器。\n\n### 3.3. 系统升级\n\n```bash\nsudo apt update\nsudo apt upgrade\n```\n\n\n### 3.4. 使用SSH Key远程登录而不是密码\n\nSSH Key 登录比密码安全很多，几乎无法破解。本质就是让服务器识别你的电脑，只有你的电脑才能登录到服务器。\n\n#### 3.4.1. 在本地电脑上生成密匙对：\n\n```bash\nssh-keygen -t rsa -b 4096\n```\n\n- `-t`：指定密匙类型，rsa是经典算法，兼容性好。\n- `-b`：指定密匙长度为4096位。\n\n它会提示你几个问题：\n\n```\nGenerating public/private rsa key pair. Enter file in which to save the key (/home/yourname/.ssh/id_rsa):\n```\n\n这时候：\n- **直接回车** 就会把密钥生成在默认位置：\n    - 私钥：`~/.ssh/id_rsa` ，**绝对不能泄露！**\n    - 公钥：`~/.ssh/id_rsa.pub\n- **或者**指定位置及文件名。\n接着会提示：\n\n```\nEnter passphrase (empty for no passphrase):\n```\n\n这里你可以选择：\n- **直接回车**：不设置密码，登录更方便；\n- **输入密码短语**：多一层保护（每次用私钥登录都要输入这串密码）。\n\n#### 3.4.2. 创建config文件\n\n有时，我们不只有一个ssh密匙对，比如我为github生成了一个密匙对，也给服务器生成了一个。如果使用了非默认名称的密钥文件，需要在 _~/.ssh/config_ 文件中进行配置。\n\n在本地保存ssh密匙对文件的文件夹里，打开或创建名为 `config` 的文件，无需后缀名。编辑该文件，示例：\n\n```\n# GitHub（常见）\nHost github.com\n  HostName github.com\n  User git\n  IdentityFile ~/.ssh/id_ed25519_github\n  IdentitiesOnly yes\n\n# 我的服务器\nHost myserver #你的主机名\n  HostName 1.2.3.4 #主机ip地址/域名\n  User someone #你要登录的用户\n  Port 22        # 如果你改过SSH端口就写上，默认22\n  IdentityFile ~/.ssh/id_rsa_server\n  IdentitiesOnly yes\n```\n\n| 参数                   | 含义                         |\n| -------------------- | -------------------------- |\n| `Host`               | 自定义的别名（可以随意起名）             |\n| `HostName`           | 实际的服务器域名或 IP 地址            |\n| `User`               | 登录用户名                      |\n| `Port`               | SSH 端口（没改的话默认 22）          |\n| `IdentityFile`       | 私钥文件路径                     |\n| `IdentitiesOnly yes` | 只使用指定的私钥，避免自动尝试其他 key 导致拒绝 |\n\n#### 3.4.3. 复制公匙到服务器\n\n方式1\n\n---\n\n在服务器创建一个文件夹保存ssh公匙，服务器用它来识别远程登录到它的电脑。\n\n```bash\nmkdir ~/.ssh\ntouch ~/.ssh/authorized_keys\nsudo chmod 700 ~/.ssh\nsudo chmod 600 ~/.ssh/authorized_keys\n```\n\n之后使用nano编辑器，将本地的.pub文件里的内容复制到authorized_keys即可。\n\n>- **千万别上传私钥**（例如 `id_rsa`、`id_ed25519`）。只传 `*.pub`。\n>- **权限必须正确**：- 确保服务器 `~/.ssh` 权限是 `700`，`~/.ssh/authorized_keys` 权限是 `600`，否则 SSH 会拒绝使用密钥。\n>- **每个公钥一行**，不要插入换行或空格。`authorized_keys` 可包含多把公钥（多台电脑可共用）。\n\n方式2\n\n---\n\nwindow可使用gitbash。linux直接输入：\n\n```bash\nssh-copy-id -i ~/.ssh/id_rsa_server.pub root@SERVER_IP\n```\n- `-i` 后面是你本地的公钥文件（比如 `~/.ssh/id_rsa_server.pub`）。\n- 运行会提示输入服务器密码，然后把公钥追加到服务器 `~/.ssh/authorized_keys`。\n**注意不要错传成私匙！**\n\n---\n\n#### 3.4.4. 登录\n\n尝试在本地ssh登录。正常的话不用输密码就可以直接登陆上：\n\n```bash\nssh Host\n```\n\n### 3.5. 改ssh端口&配置防火墙\n\n> 警告：此步操作需要谨慎，至少保留一个已登录的ssh终端，否则如果操作不当会导致被锁（无法登录到服务器），正确配置之前先不要启用防火墙。\n\n#### 3.5.1. 初步配置\n\nUbuntu 内置了UFW防火墙。通过防火墙，尽可能少的暴露端口，提升安全性。\n\n我们首先允许以下端口：\n- 22端口：SSH默认端口\n- 80端口：HTTP服务，如果你在服务器上架网站，这个端口必须开放。\n- 443端口：HTTPS服务\n\n```bash\nsudo ufw default deny incoming\nsudo ufw default allow outgoing\nsudo ufw allow 22/tcp    # SSH端口\nsudo ufw allow 80/tcp      # HTTP\nsudo ufw allow 443/tcp     # HTTPS\n```\n\n`sudo ufw default deny incoming`：默认拒绝所有进入服务器的流量（incoming traffic）。除非你明确允许某个端口，否则外部无法连接到你的服务器。\n`sudo ufw default allow outgoing`：默认允许服务器发出的所有流量（outgoing traffic）。服务器可以自由访问外部网络（比如下载更新、访问 API 等）。\n\n#### 3.5.2. 改SSH端口\n\n> **注意**：保留一个已经登录的 SSH 窗口，先测试新端口可用再关闭旧窗口，避免自己被锁。\n\n不使用默认SSH端口登录，提高安全性。\n\n1. 编辑 SSH 配置：\n\n```bash\nsudo nano /etc/ssh/sshd_config\n```\n\n找到：`#Port 22`\n修改为：`Port your_ssh_port`\n\n>建议 SSH 改到 **1024 以上，最好 2000~65000 的范围**，例如 2222、22022、55222。\n\n2. 防火墙允许该端口并启用防火墙\n\n```bash\nsudo ufw allow your_ssh_port/tcp\nsudo ufw enable\n```\n\n运行 `sudo ufw status` 命令检查防火墙规则。\n应该显示：\n```\nTo                         Action      From\n--                         ------      ----\n22/tcp                     ALLOW       Anywhere\n80/tcp                     ALLOW       Anywhere\n443/tcp                    ALLOW       Anywhere\nyour_ssh_port/tcp          ALLOW       Anywhere\n22/tcp (v6)                ALLOW       Anywhere (v6)\n80/tcp (v6)                ALLOW       Anywhere (v6)\n443/tcp (v6)               ALLOW       Anywhere (v6)\nyour_ssh_port/tcp (v6)     ALLOW       Anywhere (v6)\n```\n\n3. 重启 SSH：\n`sudo systemctl restart ssh`\n\n4. 测试新端口：\n`ssh -p your_ssh_port root@SERVER_IP`\n\n如果第四步访问被拒绝，别慌，使用命令：\n```bash\nsudo sshd -T | grep port\n```\n\n如果输出的是你设定的端口号，**且ufw中允许了设定端口**，那么可以忽略保留ssh窗口的note，直接重启云服务器，重新以新端口号登录，应该可以成功。\n\n#### 3.5.3. 关闭22端口\n\n成功登录后，可以关闭22端口了\n\n```bash\nsudo ufw delete allow 22/tcp\nsudo ufw reload\nsudo ufw status\n```\n\n### 3.6. ssh配置文件\n\n依旧：\n\n```bash\nsudo nano /etc/ssh/sshd_config\n```\n\n#### 3.6.1. 禁用 root远程登录&密码登录\n\n配置文件中设置：\n\n```\nPermitRootLogin no # 禁用root登录\nPasswordAuthentication no # 禁用密码登录\n```\n\n对于第二个选项，请自行决定。至于暴力破解，用Fail2ban工具可以防暴力破解。\n\n| 配置                         | 优势          | 风险                      |\n| -------------------------- | ----------- | ----------------------- |\n| PasswordAuthentication yes | 可以用密码登录（灵活） | 容易被暴力破解，安全性低            |\n| PasswordAuthentication no  | 安全性高，防止暴力攻击 | 如果 SSH Key 配置有问题，可能登录不上 |\n\n#### 3.6.2. 使用SSH2\n\n- `Protocol` 指定 SSH 使用的协议版本：\n    - **Protocol 1**：SSH-1，存在严重安全漏洞，不再推荐\n    - **Protocol 2**：SSH-2，更安全，更稳定\n- 现代 Linux 发行版默认使用 **Protocol 2**，但最好确认配置文件里明确指定。\n\n在配置文件中修改或在适当位置添加：\n```\nProtocol 2\n```\n\n#### 3.6.3. 重启ssh\n\n```bash\nsudo systemctl restart ssh\n```\n\n### 3.7. Fail2ban工具防暴力破解\n\n该工具可以自动封禁暴力破解 IP。\n\n```bash\nsudo apt install fail2ban\nsudo systemctl enable fail2ban\nsudo systemctl start fail2ban\n```\n\n#### 3.7.1. 配置fail2ban\n\n```\nsudo nano /etc/fail2ban/jail.local\n# 添加：\n[sshd]\nenabled = true\nmaxretry = 5\nfindtime = 86400\nbantime = 86400\n```\n\n- **enabled** → 是否启用该 jail\n- **port** → SSH 服务端口（可用逗号指定多个端口，如 22,2222）\n- **maxretry** → 超过多少次失败被 ban\n- **bantime** → 封禁持续时间，可改为 `-1` 永久封禁\n- **findtime** → 在findtime时间内输入maxretry次错误密码即被封禁。\n\n#### 3.7.2. 查看状态\n\n```bash\nsudo fail2ban-client status\n```\n\n```\nStatus for the jail: sshd\n|- Filter\n|  |- Currently failed: 3\n|  |- Total failed: 15\n|  `- File list: /var/log/auth.log\n`- Actions\n   |- Currently banned: 1\n   |- Total banned: 5\n   `- Banned IP list: 123.45.67.89\n```\n\n- `Banned IP list` → 被封禁的 IP\n- `Currently banned` → 当前封禁数量\n#### 3.7.3. 解封ip\n\n如果自己被 ban，可以在服务器端解封（假设你的 IP 是 `1.2.3.4`）：\n\n```bash\nsudo fail2ban-client set sshd unbanip 1.2.3.4\n```\n解封后你可以正常 SSH 登录。\n\n#### 3.7.4. 启用fail2ban\n\n```bash\nsudo systemctl enable --now fail2ban\n```\n#### 3.7.5. 小贴士\n1. **改规则前保持一个活动 SSH 会话**，测试新规则生效再退出\n2. **先小范围测试**：例如 `maxretry = 3, bantime = 60`，确认不会误锁自己\n3. **定期检查**：\n```bash\nsudo fail2ban-client status sshd\nsudo fail2ban-client status\n```\n\n\n> 做完上面部分后，在云服务器后台创建一个自定义镜像，备份一下，方便日后快速恢复。\n\n## 4. 系统维护部分\n\n### 4.1. ~~使用expkg~~\n\n## 5. 系统运行部分","tags":["VPS"],"categories":["VPS"]},{"title":"哈希表与设备号","url":"/posts/7167/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 1. 哈希表的通俗理解\n\n我们知道，线性链表灵活性高，扩展性强，但是查找效率低；而数组虽然查找效率高，但是扩展性，灵活性都不高。哈希表则巧妙的结合了这两种数据结构的优点，不仅插入、删除数据高效，同时查找效率也高，但是内存占用也高，相当于用空间换时间。\n\n### 1.1. 类比：快递仓库\n\n想象你在一个快递仓库工作，\n- 这个仓库有100个货架（0~99）。\n- 每个快递都有一个快递名。\n- 有一个hash牌的编码器，专门把这些快递名编码成0~99的数字，你根据这些数字把快递放在相应的货架。\n\n Like this：\n\n| 快递名   | 编码结果（货架号）                | 放到哪个架子 |\n| ----- | ------------------------ | ------ |\n| Alice | hash(\"Alice\") % 100 = 37 | 37号架   |\n| Bob   | hash(\"Bob\") % 100 = 12   | 12号架   |\n| Carol | hash(\"Carol\") % 100 = 37 | 37号架   |\n\nWTF？Alice 和 Carol 都被分到了37号架，怎么办？\n\n聪明的你在37号架上放一个“小篮子”，把所有撞到这里的快递都放一起。\n查找时，只需要在篮子里翻几下。\n\n### 1.2. 理解：哈希表的原理\n- hash表就是这个货架，可以理解为“链表数组”。\n\n```c\n#define TABLE_SIZE 10\nstruct hash_node *table[TABLE_SIZE];  // 数组，每个槽位一个指针，初始全为NULL\n```\n\n- 整个快递包裹，我们可以看作一个结构体。结构体成员“快递名”即为“键”，它们用来索引对应的快递；当然，结构体成员”快递里装的物品“就是“值”。\n\n```c\nstruct hash_node {\n    char *key;                // 键\n    char *value;              // 值\n    struct hash_node *next;   // 指向下一个节点的指针\n};\n```\n\n- 编码器呢，就是所谓的哈希函数，它会计算出一个整数，用于将“键” 映射到数组（哈希表）的某一个槽位中，也就是某个内存块啦。\n\n- 一槽不容两键？nonono！被伟大的hash神分配在同一槽的键值会形成链表啦~\n\n```c\nvoid insert(char *key, char *value)\n{\n    int index = hash(key) % TABLE_SIZE;  // 计算槽位\n    struct hash_node *new_node = malloc(sizeof(struct hash_node));\n    new_node->key = strdup(key);\n    new_node->value = strdup(value);\n\n    // 将新节点插入到链表头部\n    new_node->next = table[index];   // 指向原来的第一个节点\n    table[index] = new_node;         // 数组该槽位现在指向新节点\n}\n```\n\n更直观一点\n```\n[槽位2：链表首地址]---------[槽位3：链表首地址]---------[槽位4：空]---------\n\t| -> 最新添加的节点         | -> 节点\n\t| -> 后续添加的\n\t| -> 首次插入的节点\n```\n\n上文提供的链表插入方法是首插法，链表首地址由最新添加的节点地址呈现。\n\n## 2. 哈希表在linux中的应用\n\n在 Linux 里，每个设备（比如 `/dev/sda`, `/dev/ttyS0`）都有一个编号：\n**设备号 = 主号 + 次号**。\n你可以理解为：\n- 主号：设备类别（比如“硬盘类”、“串口类”）\n- 次号：同类中的编号（第1个、第2个）\n\n设备号类型定义：\n```c\ntypedef unsigned long long dev_t;\n```\n\n主次设备号可以通过以下宏操作：\n```c\nMAJOR(dev_t dev); // 获取主设备号\nMINOR(dev_t dev); // 获取次设备号\nMKDEV(int major, int minor); // 组合成一个dev_t\n```\n\n- 已注册的设备号可以使用`cat /proc/devices`查看\n- 内核是希望一个设备驱动(file_operation)可以独自占有一个主设备号和多个次设备号，而通常一个设备文件绑定一个主设备号和一个次设备号，所以设备驱动与设备文件是一对一或者一对多的关系。\n\n\n内核就像一个大仓库，存着成千上万个设备。\n系统要根据设备号，**快速找到对应的设备结构体**（里面保存操作函数、状态等信息）。\n\n于是它用哈希表来实现：\n把设备号算一算 → 得出“货架号” → 直接找到设备对应的信息结构。\n\n","tags":["Linux","哈希表","设备号","数据结构"],"categories":["Linux","内核编程"]},{"title":"Linux文件操作调用链探究","url":"/posts/31088/","content":"\n简单来说，底层的核心逻辑是**基于C语言的“多态”实现，通过函数指针表 (Function Pointer Table) 进行的“间接调用”**。\n\n内核本身（VFS层）并**不“认识”** 你的 `my_led_write` 函数。它只知道一个通用的“合同”或“接口”（即 `struct file_operations`），你的驱动在注册时，把自己的函数地址“登记”在了这份合同上。\n\n当用户调用 `write()` 时，内核会通过一系列的查找，最终找到你登记的那个函数地址，然后调用它。\n\n---\n\n## 🏛️ 底层逻辑的三大组件\n\n内核的这种设计，依赖于三个关键的结构体，它们共同构成了这个调用框架：\n\n### 1. `struct file_operations` (fops)\n\n这是**“合同” (Interface)**。\n\n- **它是什么？** 这是一个包含**大量函数指针**的结构体（如 `.open`, `.read`, `.write`, `.ioctl` 等）。\n    \n- **它的作用？** 它定义了一个字符设备**可以被如何操作**的所有标准方法。内核只关心这个“合同”，不关心是谁（哪个驱动）来实现它。\n    \n- **你的角色：** 在你的 LED 驱动中，你定义了一个 `led_fops` 变量，并**填充**了你实现的函数（如 `.write = my_led_write`）。\n    \n\n### 2. `struct cdev` (字符设备)\n\n这是**“登记处” (Registry)**。\n\n- **它是什么？** 代表一个“字符设备”的内核抽象。\n    \n- **它的作用？** 它的核心作用是将一个**设备号 (dev_t)** 与一份**“合同” (`file_operations`)** 绑定在一起。\n    \n- **你的角色：** 你在 `init` 函数中调用 `cdev_init(&led_cdev, &led_fops)`，这一步就是**“绑定”**；然后调用 `cdev_add()`，这一步就是**“向内核注册”**，告诉内核：“嘿，设备号 240:0 的操作方法，请参考 `led_fops`！”\n    \n\n### 3. `struct file` 和 `struct inode`\n\n这是**“上下文” (Context)**。\n\n- **`inode` (索引节点)：** 代表一个**文件系统中的文件**（如 `/dev/my_led`）。它在内核中是唯一的。它包含了这个文件的元数据，最重要的是，它包含了**设备号 (dev_t)**。\n    \n- **`file` (打开的文件)：** 代表一个**进程打开的文件实例**。当用户 `open()` 一个文件时，内核会创建一个 `struct file`。\n    \n    - **最关键的一点：** 在 `open` 的过程中，内核会根据 `inode` 里的设备号，通过 `cdev` 登记处，找到你驱动的 `file_operations` (即 `led_fops`)，然后**将这个 `led_fops` 的地址存储到新创建的 `struct file` 对象的 `f_op` 字段中**。\n        \n\n---\n\n## ⛓️ 完整调用链 (以 `write()` 为例)\n\n现在，我们把一个用户空间的 `write()` 调用串联起来，看看内核是如何一步步找到你的 `my_led_write` 函数的。\n\n**前提：** 你的驱动已加载 (`my_led_init` 已执行)。`alloc_chrdev_region` 分配了设备号 (假设 240:0)，`cdev_add` 已将 `led_cdev` (绑定了 `led_fops`) 注册到内核。\n\n### 阶段一：用户空间 `open()` (准备工作)\n\n1. **用户空间：** 应用程序调用 `fd = open(\"/dev/my_led\", O_RDWR);`\n    \n2. **系统调用：** 触发 `sys_open()` 系统调用，进入内核空间。\n    \n3. **VFS (内核)：** 内核的 VFS (虚拟文件系统) 层开始工作。\n    \n    - 它沿着路径名找到 `/dev/my_led` 对应的 `inode`。\n        \n    - VFS 发现这个 `inode` 是一个**字符设备文件** (S_IFCHR)。\n        \n    - VFS 从 `inode` 中读取**设备号 (dev_t)**，即 240:0。\n        \n4. **`cdev` 查找：** VFS 使用这个设备号 240:0，去 `cdev` 登记处（一个哈希表）查找。\n    \n5. **找到驱动：** VFS 找到了你注册的 `led_cdev`！\n    \n6. **创建 `file` 对象：** 内核创建一个新的 `struct file` 对象来代表这个打开的实例。\n    \n7. **核心步骤 (绑定)：** 内核从 `led_cdev` 中取出 `file_operations` 指针 (即 `led_fops`)，并将其**赋值给 `file->f_op`**。\n    \n  ```c\n    // VFS 内部的伪代码\n    struct file *new_file = create_file_struct();\n    new_file->f_op = led_cdev->ops; // led_cdev->ops 就是你的 led_fops\n    ```\n    \n8. **调用驱动的 `open`：** VFS 检查 `file->f_op->open` 是否存在。如果存在（即你的 `led_fops.open`），就调用它。\n    \n9. **返回 `fd`：** `open` 完成，`sys_open` 返回文件描述符 `fd` 给用户空间。这个 `fd` 在进程中唯一标识了第 6 步创建的 `struct file` 对象。\n    \n\n### 阶段二：用户空间 `write()` (执行调用)\n\n1. **用户空间：** 应用程序调用 `write(fd, \"1\", 1);`\n    \n2. **系统调用：** 触发 `sys_write()` 系统调用，进入内核空间。\n    \n3. **VFS (内核)：**\n    \n    - VFS 使用 `fd` 找到对应的 `struct file` 对象 (就是阶段一第 6 步创建的那个)。\n        \n    - VFS 检查这个 `struct file` 对象，确保它可写。\n        \n4. **核心分发 (Dispatch)：** VFS 执行类似如下的逻辑（这是**关键**！）：\n    \n  ```c\n    // VFS 内部的伪代码 (sys_write -> vfs_write)\n    struct file *filp = find_file_by_fd(fd);\n    \n    // 检查 \"合同\" 上有没有 write 方法\n    if (filp->f_op && filp->f_op->write) {\n        // 如果有，就调用它！\n        ret = filp->f_op->write(filp, user_buf, count, &filp->f_pos);\n    }\n    ```\n    \n5. **执行驱动代码：**\n    \n    - 因为 `filp->f_op` 指向的就是你的 `led_fops`。\n        \n    - 所以 `filp->f_op->write` 指向的就是你的 `my_led_write` 函数。\n        \n    - 内核**间接调用**了你的 `my_led_write` 函数，CPU 控制权转移到你的驱动代码。\n        \n6. **驱动工作：** 你的 `my_led_write` 函数被执行。它使用 `copy_from_user` 拷贝数据，然后（虚拟地）点亮 LED。\n    \n7. **返回：** 你的 `my_led_write` 返回 `1` (写入的字节数)。\n    \n8. **VFS (内核)：** VFS 拿到返回值，`sys_write` 随之返回。\n    \n9. **用户空间：** 应用程序的 `write()` 调用返回 `1`。\n    \n\n---\n\n## 📈 调用链图示\n\n这个流程可以简化为：\n\n`User Space` -> `System Call` -> `VFS (Generic Layer)` -> `Function Pointer Call` -> `Device Driver (Specific Code)`\n\n```\n[用户空间]\n   write(fd, ...);\n       |\n       v\n[内核空间 - 系统调用]\n   sys_write(fd, ...);\n       |\n       v\n[内核空间 - VFS]\n   vfs_write(...) {\n     // 1. 根据 fd 找到 struct file *filp\n     struct file *filp = fget(fd);\n     \n     // 2. 找到 filp->f_op (这个在 open 时已被设为 led_fops)\n     // 3. 执行函数指针\n     filp->f_op->write(filp, ...);  <---- 核心跳转！\n   }                                    |\n                                        |\n       +--------------------------------+\n       |\n       v\n[内核空间 - 你的驱动]\n   my_led_write(struct file *filp, ...) {\n     // ...\n     // copy_from_user(...)\n     // 控制硬件\n     // ...\n     return count;\n   }\n```\n\n## 核心总结\n\n内核调用驱动的逻辑，就是**“注册与回调”**：\n\n1. **注册 (Registration)：** 你的驱动 `init` 时，通过 `cdev_add` 把一个包含函数指针的 \"合同\" (`file_operations`) 注册到内核的 `cdev` 系统中。\n    \n2. **回调 (Callback)：** 当 VFS 需要对你的设备进行操作时，它不关心你的驱动叫什么，它只通过 `file` 对象找到那份 \"合同\"，然后调用 \"合同\" 上约定的函数指针。","tags":["Linux","调用链"],"categories":["Linux","内核编程"]},{"title":"大蟒蛇-sys/argparse库","url":"/posts/22025/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n# sys库\n\n`sys` 是 Python 标准库中的一个模块，提供了与 Python 解释器及其环境交互的功能。\n通过 `sys` 库，你可以访问与 Python 解释器相关的变量和函数，例如命令行参数、标准输入输出、程序退出等。命令行参数部分可用`argparse`库替代。\n\n## sys.argv\n描述：命令行参数的列表。`sys.argv[0]` 是脚本的名称，后续元素是传递给脚本的参数。\n语法：`sys.argv[]`\n示例：\n```python\nimport sys  \n  \nprint(\"脚本名称:\", sys.argv[0])  \nprint(\"参数列表:\", sys.argv[1:])\n```\n\n## sys.exit\n描述：用于退出程序。你可以传递一个整数作为退出状态码，通常 `0` 表示成功，非零值表示错误。\n语法：`sys.exit(num）`\n示例：\n```python\nimport sys\n\nprint(\"程序开始\")\nsys.exit(0)\nprint(\"这行代码不会执行\")\n```\n\n## sys.stdin/stdout/stderr\n描述：`sys.stdin`、`sys.stdout` 和 `sys.stderr` 分别代表标准输入、标准输出和标准错误流。你可以重定向这些流以实现自定义的输入输出行为。\n语法：`sys.stderr.write(\"err\")`\n示例：\n```python\nimport sys\n\n# 重定向标准输出到文件\nwith open('output.txt', 'w') as f:\n    sys.stdout = f\n    print(\"这行内容将写入 output.txt\")\n\n# 恢复标准输出\nsys.stdout = sys.__stdout__\nprint(\"这行内容将显示在控制台\")\n```\n\n## sys.version/version_info\n描述：提供了当前 Python 解释器的版本信息。\n语法：`sys.version`\n示例：\n```python\nimport sys\n\nprint(\"Python 版本:\", sys.version)\nprint(\"版本信息:\", sys.version_info)\n```\n\n## sys.path\n描述：列表，包含了 Python 解释器在导入模块时搜索的路径。可以修改这个列表来添加自定义的模块搜索路径。\n示例：\n```python\nimport sys\n\nprint(\"模块搜索路径:\", sys.path)\nsys.path.append('/custom/path')\nprint(\"更新后的模块搜索路径:\", sys.path)\n```\n\n## 其他\n\n| 属性               | 说明                                           |\n| ---------------- | -------------------------------------------- |\n| `sys.modules`    | 已加载模块的字典                                     |\n| `sys.platform`   | 操作系统平台标识（如 `'win32'`, `'linux'`, `'darwin'`） |\n| `sys.executable` | Python 解释器的绝对路径                              |\n| `sys.byteorder`  | 字节序（`'little'` 或 `'big'`）                    |\n| `sys.maxsize`    | 最大整数值（`2**31-1` 或 `2**63-1`）                 |\n\n# argparser库\n\n## ArgumentParser\n描述：用于创建解析命令行参数的对象。\n语法：\n```python\nargparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=<class 'argparse.HelpFormatter'>, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True)\n```\n示例：\n```python\nimport argparse\nparser = argparse.ArgumentParser(description=\"Example parser\")\n```\n\n## add_argument——重点\n描述：向ArgumentParser对象添加命令行参数。\n语法：\n```python\nArgumentParser.add_argument(name or flags..., action='store', nargs=None, const=None, default=None, type=None, choices=None, required=False, help=None, metavar=None)\n```\n示例：\n```python\nparser.add_argument('--verbose', action='store_true', help='Increase output verbosity')\n```\n\n补充：\n\n| 键        | 接受的值                         | 作用                          | 举例                  |\n| -------- | ---------------------------- | --------------------------- | ------------------- |\n| name     | 字符串                          | 变量的名字                       | ‘radius’            |\n| nargs    | 数字或’?‘或’‘或’+’                | 用来说明传入的参数个数（符号意义和正则表达式里的一致) | nargs=’?’ nargs=2   |\n| type     | list, str, tuple, set, dict等 | 设置读取参数的类型                   | type=int            |\n| default  | 类型跟type统一                    | 设置默认值                       | default=1           |\n| choices  | 装选项的list                     | 参数值只能从几个选项里面选择              | choices=[1,2,3,4]   |\n| required | True或False                   | 这个可选参数是否必须有（只能用于可选参数！否则报错）  | required=True       |\n| help     | 字符串                          | 说明一下这个参数是干嘛的                | help=“I don’t know” |\n| action   | 六种内置动作                       | 一旦这个有参数，就会触发相应的动作           | action=‘store_true’ |\n\n## parse_args\n描述：解析命令行参数。\n语法：\n```python\nArgumentParser.parse_args(args=None, namespace=None)\n```\n示例：\n```python\nargs = parser.parse_args()\nprint(args.[arg name])\n```\n\n## set_defaults\n描述：为指定的参数设置默认值。\n语法：\n```python\nArgumentParser.set_defaults(**kwargs)\n```\n示例：\n```python\nparser.set_defaults(name=\"John Doe\", age=30)  \n```\n\n## print_help\n描述：打印帮助信息。\n语法：\n```python\nArgumentParser.print_help()\n```\n示例：\n```python\nparser.print_help()\n```\n\n## add_subparsers\n描述：为ArgumentParser对象添加子命令解析器。\n语法：\n```python\nArgumentParser.add_subparsers(dest=None, parser_class=<class 'argparse.ArgumentParser'>, required=False, help=None)\n```\n示例：\n```python\nsubparsers = parser.add_subparsers(dest='command')\n```\n\n\n> 这上面几个是最常用的。\n\n---\n\n## add_mutually_exclusive_group\n描述：创建一个互斥的参数组，同一时间只能使用组内一个参数。\n语法：\n```python\nArgumentParser.add_mutually_exclusive_group(required=False)\n```\n示例：\n```python\ngroup = parser.add_mutually_exclusive_group()\ngroup.add_argument('--foo', action='store_true')\ngroup.add_argument('--bar', action='store_true')\n```\n\n## parse_known_args\n描述：解析命令行参数，但返回一个包含已知参数和未知参数的元组。\n语法：\n```python\nArgumentParser.parse_known_args(args=None, namespace=None)\n```\n示例：\n```python\nargs, unknown = parser.parse_known_args()\n```\n\n## convert_arg_line_to_args\n描述：将从文件读取的一行转换为参数列表。\n语法：\n```python\nArgumentParser.convert_arg_line_to_args(arg_line)\n```\n示例：\n```python\nargs = parser.convert_arg_line_to_args(\"foo --bar=3\")\n```\n\n## error\n描述：在命令行参数解析过程中发生错误时，抛出异常并输出错误信息。\n语法：\n```python\nArgumentParser.error(message)\n```\n示例：\n```python\nparser.error(\"Invalid argument\")\n```\n\n## exit\n描述：在解析命令行参数时遇到错误时，退出程序。\n语法：\n```python\nArgumentParser.exit(status=0, message=None)\n```\n示例：\n```python\nparser.exit(message=\"Exiting due to error\")\n```\n\n## parse_args_from_file\n描述：从文件中读取参数并解析。\n语法：\n```python\nArgumentParser.parse_args_from_file(filename)\n```\n示例：\n```python\nparser.parse_args_from_file('args.txt')\n```\n\n## add_argument_group\n描述：创建一个参数组，用于组织和描述相关参数。\n语法：\n```python\nArgumentParser.add_argument_group(title=None, description=None)\n```\n示例：\n```python\ngroup = parser.add_argument_group('Optional arguments')\ngroup.add_argument('--output', type=str, help='Output file')\n```\n\n## format_help\n描述：返回当前帮助信息的格式化字符串。\n语法：\n```python\nArgumentParser.format_help()\n```\n示例：\n```python\nhelp_text = parser.format_help()\n```\n","tags":["python","sys","argparse"],"categories":["python"]},{"title":"大蟒蛇-shutil库","url":"/posts/22415/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\nshutil库主要用于文件的高级操作，比如移动、复制、压缩和解压\n\n## shutil.copy\n描述：复制文件到指定路径。\n语法：`shutil.copy(src, dst)`\n示例：\n```python\nimport shutil\nshutil.copy('source.txt', 'destination.txt')\n```\n\n## shutil.copy2\n描述：复制文件到指定路径，同时保留文件的元数据。\n语法：`shutil.copy2(src, dst)`\n示例：\n```python\nimport shutil\nshutil.copy2('source.txt', 'destination.txt')\n```\n\n## shutil.copytree\n描述：递归复制整个目录树。\n语法：`shutil.copytree(src, dst)`\n示例：\n```python\nimport shutil\nshutil.copytree('source_dir', 'destination_dir')\n```\n\n## shutil.move\n描述：移动文件或目录到指定路径。\n语法：`shutil.move(src, dst)`\n示例：\n```python\nimport shutil\nshutil.move('source.txt', 'destination.txt')\n```\n\n## shutil.rmtree\n描述：递归删除目录树。慎用！ \n语法：`shutil.rmtree(path)`\n示例：\n```python\nimport shutil\nshutil.rmtree('directory')\n```\n\n## shutil.disk_usage\n描述：返回磁盘的总容量、已用空间和剩余空间。\n语法：`shutil.disk_usage(path)`\n示例：\n```python\nimport shutil\ntotal, used, free = shutil.disk_usage('/')\nprint(f\"Total: {total}, Used: {used}, Free: {free}\")\n```\n\n## shutil.chown\n描述：改变文件或目录的所有者和组。\n语法：`shutil.chown(path, user=None, group=None)`\n示例：\n```python\nimport shutil\nshutil.chown('file.txt', user='username', group='groupname')\n```\n\n## shutil.unpack_archive\n描述：解压归档文件。\n语法：`shutil.unpack_archive(filename, extract_dir=None)`\n示例：\n```python\nimport shutil\nshutil.unpack_archive('archive.zip', 'destination_folder')\n```\n\n## shutil.get_archive_formats\n描述：获取支持的归档格式列表。\n语法：`shutil.get_archive_formats()`\n示例：\n```python\nimport shutil\nformats = shutil.get_archive_formats()\nprint(formats)\n```\n\n## shutil.make_archive\n描述：创建一个归档文件。\n语法：`shutil.make_archive(base_name, format, root_dir=None, base_dir=None)`\n示例：\n```python\nimport shutil\nshutil.make_archive('archive_name', 'zip', 'folder_to_compress')\n```\n\n## shutil.move\n描述：移动文件或目录到指定路径。\n语法：`shutil.move(src, dst)`\n示例：\n```python\nimport shutil\nshutil.move('source.txt', 'destination_folder')\n```\n\n","tags":["python","shutil"],"categories":["python"]},{"title":"大蟒蛇-pathlib库","url":"/posts/63515/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## Path()\n描述：创建路径对象  \n语法：`Path(path_str)`  \n示例：\n```python\nfrom pathlib import Path\np = Path('/home/user/docs')\n\n```\n\n## cwd()\n描述：获取当前工作目录\n语法：`Path.cwd()`\n示例：\n```python\nPath.cwd()\n\n```\n\n## home()\n描述：获取用户主目录路径\n语法：`Path.home()`\n示例：\n```python\nPath.home()\n```\n\n## exists()\n描述：判断路径是否存在\n语法：`path.exists()`\n示例：\n```python\nPath('test.txt').exists()\n\n```\n\n## is_file()\n描述：判断是否为文件\n语法：`path.is_file()`\n示例：\n```python\nPath('test.txt').is_file()\n\n```\n\n## is_dir()\n描述：判断是否为目录\n语法：`path.is_dir()`\n示例：\n```python\nPath('/etc').is_dir()\n\n```\n\n## is_symlink()\n描述：判断是否为符号链接\n语法：`path.is_symlink()`\n示例：\n```python\nPath('link').is_symlink()\n\n```\n\n## iterdir()\n描述：列出目录内容（生成器）\n语法：`path.iterdir()`\n示例：\n```python\nfor item in Path('.').iterdir():\n    print(item)\n```\n\n## glob()\n描述：使用通配符匹配文件\n语法：`path.glob(pattern)`\n示例：\n```python\nlist(Path('.').glob('*.py'))\n```\n\n## rglob()\n描述：递归匹配文件\n语法：`path.rglob(pattern)`\n示例：\n```python\nlist(Path('.').rglob('*.py'))\n```\n\n## mkdir()\n描述：创建目录\n语法：`path.mkdir(parents=False, exist_ok=False)`\n示例：\n```python\nPath('new_dir').mkdir(exist_ok=True)\n\n```\n\n## rmdir()\n描述：删除空目录\n语法：`path.rmdir()`\n示例：\n```python\nPath('empty_dir').rmdir()\n\n```\n\n## unlink()\n描述：删除文件或符号链接\n语法：`path.unlink(missing_ok=False)`\n示例：\n```python\nPath('file.txt').unlink()\n\n```\n\n## rename()\n描述：重命名文件或目录\n语法：`path.rename(target)`\n示例：\n```python\nPath('old.txt').rename('new.txt')\n\n```\n\n## replace()\n描述：重命名（如目标存在则覆盖）\n语法：`path.replace(target)`\n示例：\n```python\nPath('a.txt').replace('b.txt')\n\n```\n\n## resolve()\n描述：返回绝对路径（解析符号链接）\n语法：`path.resolve()`\n示例：\n```python\nPath('..').resolve()\n\n```\n\n## absolute()\n描述：返回绝对路径（不解析符号链接）\n语法：`path.absolute()`\n示例：\n```python\nPath('file.txt').absolute()\n\n```\n\n## stat()\n描述：获取文件状态信息\n语法：`path.stat()`\n示例：\n```python\ninfo = Path('file.txt').stat()\nprint(info.st_size)\n\n```\n\n## read_text()\n描述：读取文本文件内容\n语法：`path.read_text(encoding=None)`\n示例：\n```python\nPath('a.txt').read_text()\n\n```\n\n## write_text()\n描述：写入文本内容\n语法：`path.write_text(data, encoding=None)`\n示例：\n```python\nPath('a.txt').write_text('Hello World')\n\n```\n\n## read_bytes()\n描述：读取二进制文件内容\n语法：`path.read_bytes()`\n示例：\n```python\ndata = Path('a.bin').read_bytes()\n\n```\n\n## write_bytes()\n描述：写入二进制数据\n语法：`path.write_bytes(data)`\n示例：\n```python\nPath('a.bin').write_bytes(b'\\x00\\x01')\n\n```\n\n## joinpath()\n描述：拼接路径\n语法：`path.joinpath(*other)`\n示例：\n```python\nPath('/home').joinpath('user', 'docs')\n\n```\n\n## with_name()\n描述：返回更改文件名的新路径\n语法：`path.with_name(name)`\n示例：\n```python\nPath('a.txt').with_name('b.txt')\n\n```\n\n## with_suffix()\n描述：修改文件扩展名\n语法：`path.with_suffix(suffix)`\n示例：\n```python\nPath('a.txt').with_suffix('.md')\n\n```\n\n## suffix\n描述：返回路径后缀\n语法：`path.suffix`\n示例：\n```python\nPath('a.txt').suffix\n\n```\n\n## suffixes\n描述：返回所有后缀（列表）\n语法：`path.suffixes`\n示例：\n```python\nPath('archive.tar.gz').suffixes\n\n```\n\n## stem\n描述：返回不带后缀的文件名\n语法：`path.stem`\n示例：\n```python\nPath('a.txt').stem\n\n```\n\n## name\n描述：返回文件名\n语法：`path.name`\n示例：\n```python\nPath('/home/user/a.txt').name\n\n```\n\n## parent\n描述：返回父路径\n语法：`path.parent`\n示例：\n```python\nPath('/home/user/a.txt').parent\n\n```\n\n## parents\n描述：返回所有上级目录\n语法：`path.parents`\n示例：\n```python\nfor p in Path('/a/b/c').parents:\n    print(p)\n\n```\n\n## as_posix()\n描述：以 POSIX 格式返回路径字符串\n语法：`path.as_posix()`\n示例：\n```python\nPath('C:\\\\a\\\\b').as_posix()\n\n```\n\n## as_uri()\n描述：返回文件URI\n语法：`path.as_uri()`\n示例：\n```python\nPath('/home/user/a.txt').as_uri()\n\n```\n\n## relative_to()\n描述：返回相对路径\n语法：`path.relative_to(base)`\n示例：\n```python\nPath('/home/user/docs/a.txt').relative_to('/home/user')\n\n```\n\n## match()\n描述：判断路径是否匹配模式\n语法：`path.match(pattern)`\n示例：\n```python\nPath('a.txt').match('*.txt')\n\n```\n\n## touch()\n描述：创建空文件或更新修改时间\n语法：`path.touch(exist_ok=True)`\n示例：\n```python\nPath('a.txt').touch()\n\n```\n\n## open()\n描述：打开文件（与内置 open 类似）\n语法：`path.open(mode='r', encoding=None)`\n示例：\n```python\nwith Path('a.txt').open('w') as f:\n    f.write('data')\n\n```\n","tags":["python","pathlib"],"categories":["python"]},{"title":"Python中元组、列表、字典和集合的区别","url":"/posts/53459/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n在Python中，元组（Tuple）、列表（List）、字典（Dictionary）和集合（Set）是四种常用的数据结构，它们各自有不同的特点和应用场景。\n\n## 列表（List） \n列表是一种有序且可变的数据序列，允许存储重复元素。 \n- 定义方式：使用方括号 _[]_，例如 _example_list = [1, 2, \"apple\", True]_。 \n- 特点：支持通过索引访问元素，可以动态添加、删除或修改元素。 \n- 应用场景：适用于需要频繁修改的有序数据集，例如购物清单或动态数组。\n\n## 元组（Tuple） \n元组是一种有序但不可变的数据序列，允许存储重复元素。 \n- 定义方式：使用圆括号 _()_，例如 _example_tuple = (1, 2, \"apple\", True)_。 \n- 特点：一旦创建后，内容无法更改，适合存储固定不变的数据。 \n- 应用场景：适用于需要保护数据不被修改的场景，例如坐标点或数据库查询结果。\n\n## 集合（Set） \n集合是一种无序且不允许重复的元素集合。 \n- 定义方式：使用大括号 _{}_ 或 _set()_ 函数，例如 _example_set = {1, 2, \"apple\", True}_。 \n- 特点：不支持索引访问，但可以进行数学集合运算（如交集、并集）。\n- 应用场景：适用于需要去重或快速判断元素是否存在的场景，例如处理唯一值集合。\n\n## 字典（Dictionary） \n字典是一种键值对的映射容器，其中键必须唯一，值可以重复。 \n- 定义方式：使用大括号 _{}_，例如 _example_dict = {\"name\": \"Alice\", \"age\": 25}_。 \n- 特点：从Python 3.7开始，字典的插入顺序保持不变。支持通过键快速查找对应的值。 \n- 应用场景：适用于存储键值映射关系的数据，例如配置文件或数据库表结构。\n\n## 总结\n- 有序性：列表和元组是有序的，集合和字典无序（但字典从Python 3.7起保持插入顺序）。\n- 可变性：列表和字典是可变的，元组不可变，集合可变但不支持索引。\n- 重复性：集合不允许重复元素，其他三种结构允许重复（字典的键必须唯一）。\n- 应用场景：根据数据的有序性、可变性和重复性需求选择合适的数据结构。","tags":["python"],"categories":["python"]},{"title":"大蟒蛇-os库","url":"/posts/37113/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n# Python `os` 模块函数大全速查表\n\n`os` 模块是 Python 标准库中用于与操作系统交互的接口，涵盖了文件/目录操作、环境变量管理、系统信息获取、进程控制等诸多功能。本文整理了常用函数及示例，便于查阅使用。\n\n## os.getcwd()\n描述：获取当前工作目录  \n语法：`os.getcwd()`  \n示例：\n```python\nimport os\nprint(os.getcwd())\n```\n\n## os.chdir()\n描述：改变当前工作目录  \n语法：`os.chdir(path)`  \n示例：\n```python\nos.chdir(\"/home/user\")\n```\n\n## os.listdir()\n描述：返回指定目录下的文件和文件夹列表  \n语法：`os.listdir(path=\".\")`  \n示例：\n```python\nprint(os.listdir(\".\"))\n```\n\n## os.mkdir()\n描述：创建单层目录  \n语法：`os.mkdir(path)`  \n示例：\n```python\nos.mkdir(\"test\")\n```\n\n## os.makedirs()\n描述：创建多级目录  \n语法：`os.makedirs(path, exist_ok=False)`  \n示例：\n```python\nos.makedirs(\"a/b/c\", exist_ok=True)\n```\n\n## os.rmdir()\n描述：删除空目录  \n语法：`os.rmdir(path)`  \n示例：\n```python\nos.rmdir(\"test\")\n```\n\n## os.removedirs()\n描述：删除多级空目录  \n语法：`os.removedirs(path)`  \n示例：\n```python\nos.removedirs(\"a/b/c\")\n```\n\n## os.remove()\n描述：删除文件  \n语法：`os.remove(path)`  \n示例：\n```python\nos.remove(\"file.txt\")\n```\n\n## os.rename()\n描述：重命名文件或目录  \n语法：`os.rename(src, dst)`  \n示例：\n```python\nos.rename(\"old.txt\", \"new.txt\")\n```\n\n## os.replace()\n描述：重命名文件，如果目标已存在会被覆盖  \n语法：`os.replace(src, dst)`  \n示例：\n```python\nos.replace(\"a.txt\", \"b.txt\")\n```\n\n## os.stat()\n描述：获取文件状态信息  \n语法：`os.stat(path)`  \n示例：\n```python\ninfo = os.stat(\"file.txt\")\nprint(info.st_size)\n```\n\n## os.walk()\n描述：递归遍历目录树  \n语法：`os.walk(top, topdown=True, onerror=None, followlinks=False)`  \n示例：\n```python\nfor root, dirs, files in os.walk(\".\"):\n    print(root, dirs, files)\n```\n补充：\n`top`：要遍历的顶级目录的路径。\n`topdown (可选)`：如果为 True（默认值），则从顶级开始向下遍历。如果为 False，则从底部的子目录开始向上遍历。\n`onerror (可选)`：是一个函数，用于错误处理。如果指定，则应该是一个接受单个参数（异常实例）的函数。如果未指定或为 None，错误将被忽略。\n`followlinks (可选)`：如果为 True，则会遍历符号链接指向的目录。\n\n## os.scandir()\n描述：高效迭代目录项  \n语法：`os.scandir(path=\".\")`  \n示例：\n```python\ndef traversal_files(path):\n    for item in os.scandir(path):\n        if item.is_dir():\n          dirs.append(item.path)\n\n        elif item.is_file():\n          files.append(item.path)\n\n    print('dirs:')\n    print('\\n'.join(dirs))\n\n    print()\n\n    print('files:')\n    print('\\n'.join(files))\n\ntraversal_files(r'./test')\n```\n\n## os.path.join()\n描述：拼接路径  \n语法：`os.path.join(path, *paths)`  \n示例：\n```python\nprint(os.path.join(\"folder\", \"file.txt\"))\n```\n\n## os.path.abspath()\n描述：获取绝对路径  \n语法：`os.path.abspath(path)`  \n示例：\n```python\nprint(os.path.abspath(\"test.txt\"))\n```\n\n## os.path.basename()\n描述：获取路径中的文件名  \n语法：`os.path.basename(path)`  \n示例：\n```python\nprint(os.path.basename(\"/home/user/file.txt\"))\n```\n\n## os.path.dirname()\n描述：获取路径中的目录部分  \n语法：`os.path.dirname(path)`  \n示例：\n```python\nprint(os.path.dirname(\"/home/user/file.txt\"))\n```\n\n## os.path.exists()\n描述：判断路径是否存在  \n语法：`os.path.exists(path)`  \n示例：\n```python\nprint(os.path.exists(\"file.txt\"))\n```\n\n## os.path.isfile()\n描述：判断路径是否为文件  \n语法：`os.path.isfile(path)`  \n示例：\n```python\nprint(os.path.isfile(\"file.txt\"))\n```\n\n## os.path.isdir()\n描述：判断路径是否为目录  \n语法：`os.path.isdir(path)`  \n示例：\n```python\nprint(os.path.isdir(\"folder\"))\n```\n\n## os.path.splitext()\n描述：分离文件名与扩展名  \n语法：`os.path.splitext(path)`  \n示例：\n```python\nprint(os.path.splitext(\"file.txt\"))\n```\n\n## os.path.getsize()\n描述：获取文件大小（字节）  \n语法：`os.path.getsize(path)`  \n示例：\n```python\nprint(os.path.getsize(\"file.txt\"))\n```\n\n## os.environ\n描述：环境变量相关  \n语法：`os.environ`  \n示例：\n```python\n# 获取环境变量\nvalue = os.environ.get(\"HOME\") # 如果不存在返回 None\n# 修改环境变量\nos.environ[\"MY_VAR\"] = \"123\"\nos.environ[\"PATH\"] = os.environ[\"PATH\"] + \":/my/custom/path\"\n# 删除 MY_VAR\ndel os.environ[\"MY_VAR\"]  \n```\n\n## os.system()\n描述：执行系统命令  **不推荐，推荐`subprocess`**\n语法：`os.system(command)`  \n示例：\n```python\nos.system(\"ls\")\n```\n\n## os.popen()\n描述：执行命令并获取输出  \n语法：`os.popen(command)`  \n示例：\n```python\noutput = os.popen(\"ls\").read()\nprint(output)\n```\n\n## os.getpid()\n描述：获取当前进程 ID  \n语法：`os.getpid()`  \n示例：\n```python\nprint(os.getpid())\n```\n\n## os.getppid()\n描述：获取父进程 ID  \n语法：`os.getppid()`  \n示例：\n```python\nprint(os.getppid())\n```\n\n## os.getlogin()\n描述：获取当前登录用户  \n语法：`os.getlogin()`  \n示例：\n```python\nprint(os.getlogin())\n```\n\n## os.getuid() / os.getgid()\n描述：获取当前进程用户/组 ID  \n语法：`os.getuid()` / `os.getgid()`  \n示例：\n```python\nprint(os.getuid(), os.getgid())\n```\n\n## os.setuid() / os.setgid()\n描述：设置用户/组 ID  \n语法：`os.setuid(uid)` / `os.setgid(gid)`  \n示例：\n```python\nos.setuid(1000)\n```\n\n## os.umask()\n描述：设置文件创建掩码  \n语法：`os.umask(mask)`  \n示例：\n```python\nos.umask(0o022)\n```\n\n## os.chmod()\n描述：修改文件权限  \n语法：`os.chmod(path, mode)`  \n示例：\n```python\nos.chmod(\"file.txt\", 0o644)\n```\n\n## os.link()\n描述：创建硬链接  \n语法：`os.link(src, dst)`  \n示例：\n```python\nos.link(\"a.txt\", \"b.txt\")\n```\n\n## os.symlink()\n描述：创建符号链接  \n语法：`os.symlink(src, dst)`  \n示例：\n```python\nos.symlink(\"a.txt\", \"link.txt\")\n```\n\n## os.readlink()\n描述：获取符号链接指向的路径  \n语法：`os.readlink(path)`  \n示例：\n```python\nprint(os.readlink(\"link.txt\"))\n```\n\n## os.utime()\n描述：修改文件的访问和修改时间  \n语法：`os.utime(path, times=None)`  \n示例：\n```python\nos.utime(\"file.txt\", (1620000000, 1620000000))\n```\n\n## os.truncate()\n描述：截断文件到指定大小  \n语法：`os.truncate(path, length)`  \n示例：\n```python\nos.truncate(\"file.txt\", 100)\n```\n\n## os.urandom()\n描述：生成随机字节数据  \n语法：`os.urandom(n)`  \n示例：\n```python\nprint(os.urandom(16))\n```\n\n## os.cpu_count()\n描述：返回 CPU 核心数  \n语法：`os.cpu_count()`  \n示例：\n```python\nprint(os.cpu_count())\n```\n\n## os.uname()\n描述：返回操作系统信息  \n语法：`os.uname()`  \n示例：\n```python\nprint(os.uname())\n```\n\n## os.name\n描述：获取操作系统类型标识  \n语法：`os.name`  \n示例：\n```python\nprint(os.name)\n```\n\n## os.sep\n描述：路径分隔符  \n语法：`os.sep`  \n示例：\n```python\nprint(os.sep)\n```\n\n## os.linesep\n描述：行分隔符  \n语法：`os.linesep`  \n示例：\n```python\nprint(repr(os.linesep))\n```\n\n## os.pathsep\n描述：系统路径分隔符  \n语法：`os.pathsep`  \n示例：\n```python\nprint(os.pathsep)\n```\n\n## os.devnull\n描述：空设备路径，用于丢弃输出  \n语法：`os.devnull`  \n示例：\n```python\nwith open(os.devnull, \"w\") as f:\n    f.write(\"This goes nowhere\")\n```\n","tags":["python","os"],"categories":["python"]},{"title":"Linux内核模块初体验","url":"/posts/49513/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n\n>本篇摘自野火嵌入式Linux系列教程驱动开发篇\n\n\n## 内核模块基本概念\n\n### 现代内核派系\n\n单内核：关键功能和服务功能均在内核空间提供\n\n - 运行效率高\n - 扩展性较差\n\n微内核：内核空间只提供关键功能，服务功能在用户空间提供\n\n- 运行效率较低\n- 安全性、扩展性较高\n\nlinux属于单内核，按理来说扩展性不好，但其的模块化设计又弥补了这一点。\n### 内核模块加载/卸载\n\n- 使用insmod命令加载\n- 使用rmmod命令卸载\n\n### 内核模块入口/出口\n\n- module_init()：加载模块式该函数自动执行，进行初始化操作\n- module_exit()：卸载模块时函数自动执行，进行清理操作\n\n### 内核模块信息声明\n\n- MODULE_LICENSE()：表示模块代码接受的软件许可协议，Linux内核遵循GPL V2开源协议，内核模块与linux内核保持一致即可。\n- MODULE_AUTHOR()：描述模块的作者信息\n- MODULE_DESCRIPTION()：对模块的简单介绍\n- MODULE_ALIAS()：给模块设置一个别名\n\n## 内核模块实验1\n\n### 实验环境\n\n- 开发板烧录好Debian镜像。\n- SSH连接MobaXterm\n- 启动开发板，搭建好SFTP。\n- 获取Debian镜像的内核源码并编译。\n\n### 编译4.19.71版本内核\n\n内核模块的功能需要依赖内核提供的各种底层接口\n\n1.下载linux内核源码\n\n​\tgithub:\n\n```\ngit clone https://github.com/Embedfire/ebf-buster-linux.git\n```\n\n​\tgitee:\n\n```\ngit clone https://gitee.com/Embedfire/ebf-buster-linux.git\n```\n\n2.安装必要环境工具库\n\n```\nsudo apt install make gcc-arm-linux-gnueabihf gcc bison flex libssl-dev dpkg-dev lzop\n```\n\n- gcc-arm-linux-gnueabihf 交叉编译器\n- bison 语法分析器\n- flex 词法分析器\n- libssl-dev OpenSSL通用库\n- lzop LZO压缩库的压缩软件\n\n3.一键编译内核\n\n```\nsudo ./make_deb.sh\n```\n\n>如果在电脑上编译不成功且无法解决，可以选择在开发板上编译，代价就是。。。嗯 it takes a long time\n\n4.获取编译出来的内核相关文件\n\n```\nYOURPATH/ebf_linux_kernel_6ull_depth1/build_image/\n```\n\n### 内核模块头文件\n\n- `#include <linux/module.h>`：包含内核模块信息声明的相关函数\n- `#include <linux/init.h>`：包含了 module_init()和 module_exit()函数的声明\n-  `#include <linux/kernel.h>`：包含内核提供的各种函数，如printk\n\n### 内核模块打印函数\n\n- `printf`：glibc实现的打印函数，工作于用户空间，不可在内核使用\n\n- `printk`：内核模块无法使用glibc库函数，内核自身实现的一个类printf函数，但是需要指定打印等级。\n  - `#define KERN_EMERG` \t\"<0>\" 通常是系统崩溃前的信息\n  - `#define KERN_ALERT`          \"<1>\" 需要立即处理的消息\n  - `#define KERN_CRIT`             \"<2>\" 严重情况\n  - `#define KERN_ERR`              \"<3>\" 错误情况\n  - `#define KERN_WARNING`      \"<4>\" 有问题的情况\n  - `#define KERN_NOTICE`       \"<5>\" 注意信息\n  - `#define KERN_INFO`            \"<6>\" 普通消息\n  - `#define KERN_DEBUG`        \"<7>\" 调试信息\n\n查看当前系统printk打印等级：`cat /proc/sys/kernel/printk`\n输出\n```\n7       4       1       7\n```\n表示：\n- 当前控制台日志级别\n- 默认消息日志级别\n- 最小的控制台级别\n- 默认控制台日志级别\n\n小于等于设定打印等级的消息不会被打印。\n打印内核所有打印信息：dmesg\n\n- 内核log缓冲区大小有限制，缓冲区数据可能被冲掉\n\n### 源码展示\n\n```c\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\nstatic int __init hello_init(void){\n    printk(KERN_EMERG\"[KERN_EMERG]Hello Kernel!\\n\");\n    printk(\"[DEFAULT]Hello Kernel!\\n\");\n    return 0;\n}\n\nstatic void __exit hello_exit(void){\n    printk(\"[DEFAULT]Goodbye Kernel!\\n\");\n}\n\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n\nMODULE_LICENSE(\"MIT\");\nMODULE_AUTHOR(\"gdm\");\nMODULE_DESCRIPTION(\"print: hello kernel\");\nMODULE_ALIAS(\"test_module\");\n```\n\n### Makefile分析\n\n```makefile\n# 定义内核路径\nKERNEL_DIR:=/home/debian/linux/driver_learning/ebf_linux_kernel_6ull_depth1/build_image/build\n# 定义编译工具集\nARCH:=arm\nCROSS_COMPILE:=arm-linux-gnueabihf-\n# 将变量导出，相当于作为环境变量，让内核Makefile继承此变量 否则变量只在当前文件可见。\nexport ARCH CROSS_COMPILE\n# 内核模块编译的标准变量，告诉内核编译哪个模块。\nobj-m:=hellokernal.o\n# -C 命令指切换到目标目录的makefile\n# M= 可以理解为module，指定模块所在路径\n# modules 是内核makefile定义的目标，触发“构建外部模块”完整规则\nall:\n    $(MAKE) -C $(KERNEL_DIR) M=$(CURDIR) moudules\n.PHONY:clean\nclean:\n    $(MAKE) -C $(KERNEL_DIR) M=$(CURDIR) clean\n```\n\n- `KERNEL_DIR`：指向linux内核具体路径\n- `export`：导出变量给子Makefile使用 \n- `obj-m` := <模块名>.o：定义要生成的模块\n- `$(MAKE)`：Makefile的默认变量，值为make\n- `选项”-C”`：让make工具跳转到linux内核目录下读取顶层Makefile\n- `M=`：表示内核模块源码目录\n- `$(CURDIR)`：Makefile默认变量，值为当前目录所在路径\n- `make modules`：执行Linux顶层Makefile的伪目标，它实现内核模块的源码读取并编译为.ko文件\n\n### 编译内核模块\n\n```\nmake\n```\n\n### 开发板加载内核模块\n\n```\ninsmod xxx.ko\n```\n\n\n","tags":["内核","内核编程"],"categories":["Linux","内核编程"]},{"title":"WSL-Archlinux安装后应该做什么？","url":"/posts/17327/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n- [1. 在WSL上安装Archlinux](#1-在wsl上安装archlinux)\n- [2. 更新系统](#2-更新系统)\n- [3. 基础配置](#3-基础配置)\n  - [3.1. 设置root密码](#31-设置root密码)\n  - [3.2. 创建普通用户并加入 `wheel` 组（方便后续 sudo 权限）：](#32-创建普通用户并加入-wheel-组方便后续-sudo-权限)\n  - [3.3. 编辑 sudo 权限](#33-编辑-sudo-权限)\n  - [3.4. 设定默认用户](#34-设定默认用户)\n  - [3.5. 设置语言和地区](#35-设置语言和地区)\n  - [3.6. AUR 支持](#36-aur-支持)\n  - [3.7. 关于换源](#37-关于换源)\n- [4. 个性化设置](#4-个性化设置)\n  - [4.1. 使用zsh替代bash](#41-使用zsh替代bash)\n  - [4.2. 使用oh-my-zsh为zsh提供插件服务](#42-使用oh-my-zsh为zsh提供插件服务)\n  - [4.3. 使用oh-my-posh为zsh提供主题](#43-使用oh-my-posh为zsh提供主题)\n\n\n## 1. 在WSL上安装Archlinux\n\n请参见—— [在 WSL 上安装 Arch Linux - Arch Linux 中文维基](https://wiki.archlinuxcn.org/wiki/%E5%9C%A8_WSL_%E4%B8%8A%E5%AE%89%E8%A3%85_Arch_Linux)\n\n## 2. 更新系统\n\n```bash\nsudo pacman -Syu\n```\n## 3. 基础配置\n\n### 3.1. 设置root密码\n```bash\npasswd\n```\n\n### 3.2. 创建普通用户并加入 `wheel` 组（方便后续 sudo 权限）：\n```bash\nuseradd -m -G wheel -s /bin/bash yourname\npasswd yourname\n```\n\n`-m`：自动创建用户目录\n`-G`：指定用户组\n`-s`：指定shell\n\n### 3.3. 编辑 sudo 权限\n安装 `sudo`，再启用 `wheel` 组：\n```bash\npacman -S sudo nano\n```\n\n```bash\nnano /etc/sudoers\n```\n\n去掉 `# %wheel ALL=(ALL:ALL) ALL` 前的注释\n\n>前面带%(如%wheel)则表示这是一个用户组，不带则表示这是一个用户。\n\n\n### 3.4. 设定默认用户\n不能总是用root用户登录。\n首先确保该用户已被创建，然后将以下行添加到 `/etc/wsl.conf`：\n\n```\n[user]\ndefault=username\n```\n\n### 3.5. 设置语言和地区\n目的是正确显示中文字符\n```bash\nlocale-gen\necho \"LANG=en_US.UTF-8\" > /etc/locale.conf\n```\n\n请参见——[简体中文本地化 - Arch Linux 中文维基](https://wiki.archlinuxcn.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E6%9C%AC%E5%9C%B0%E5%8C%96)\n\n### 3.6. AUR 支持\n可以下载来自社区的软件包，这里选用AUR助手 yay\n选择一个指定目录然后执行：\n```bash\npacman -S git base-devel --needed  #<-这是基本的开发工具包，如gcc、make\ngit clone https://aur.archlinux.org/yay-bin.git\ncd yay-bin\nmakepkg -si # 构建包\n```\n`-s`：自动安装依赖\n`-i`：编译完成后自动安装生成的包\n\n请参见——[yay - Arch Linux 中文维基](https://wiki.archlinuxcn.org/wiki/Yay)\n\n### 3.7. 关于换源\n\n打开`WSL-setting`（直接在win11里搜索）的网络设置，将网络模式由`NAT` 改为 `mirror`， 则可直接继承宿主机的网络环境。在宿主机使用网络安全工具即可，因此暂时没有换源。\n\n## 4. 个性化设置\n\n### 4.1. 使用zsh替代bash\n\n```bash\nsudo pacman -S zsh\nchsh -s /bin/zsh # 改变默认shell\n```\n\n### 4.2. 使用oh-my-zsh为zsh提供插件服务\n```bash\nyay -S oh-my-zsh.git\n```\n\n安装完成后 可以在 `/usr/share/oh-my-zsh` 中查看主题文件和插件以及其提供的`zshrc`配置模板，直接使用配置模板。\n```bash\ncp /usr/share/oh-my-zsh/zshrc ~/.zshrc\n```\n\n进入`/usr/share/oh-my-zsh\\plugins`目录 安装自动补全与语法高亮插件（不自带）\n```bash\ngit clone https://github.com/zsh-users/zsh-autosuggestions\n```\n\n```bash\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git\n```\n\n在 `.zshrc` 里添加：\n```\nplugins=(git zsh-autosuggestions zsh-syntax-highlighting)\n```\n\n### 4.3. 使用oh-my-posh为zsh提供主题\n你也可以使用`oh-my-zsh`的主题，只不过我更喜欢`oh-my-posh`的主题\n\n```bash\nyay -S oh-my-posh-bin\n```\n\n同样，安装完成后 可以在 `/usr/share/oh-my-posh` 中查看主题文件，\n编辑`~/.zshrc`：\n```bash\n#注释掉ZSH_THEME=\"robbyrussell\"\neval \"$(oh-my-posh init zsh --config 'amro')\"\n```\n\n\n> 建议不要使用类似于 `--config ~/.poshthemes/mytheme.omp.json`的选项，这可能会出现问题。\n\n\n重新加载：\n```bash\nsource ~/.zshrc\n```\n\n","tags":["WSL2","ArchLinux"],"categories":["Linux","记录"]},{"title":"POSIX IPC：System V 的继任者","url":"/posts/26506/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n- [1. POSIX IPC：System V 的继任者](#1-posix-ipcsystem-v-的继任者)\n  - [1.1. POSIX 消息队列](#11-posix-消息队列)\n    - [1.1.1. 消息队列属性](#111-消息队列属性)\n  - [1.2. POSIX 信号量](#12-posix-信号量)\n  - [1.3. POSIX 共享内存](#13-posix-共享内存)\n\n\n## 1. POSIX IPC：System V 的继任者\n\n**POSIX IPC**（Portable Operating System Interface）是一套新的 IPC 标准，旨在解决 **System V IPC** 的一些局限性。它提供了一套更统一、更现代的 API，使用**文件名**作为标识符，而不是 System V 的**键值**，这使得 IPC 资源的管理更加直观。\n\n### 1.1. POSIX 消息队列\n\n与 System V 消息队列类似，但 API 更简洁。\n\n- **特点**：\n\n    - **基于文件**：通过 `/dev/mqueue` 目录下的文件名来标识。\n\n    - **优先级**：支持消息优先级，高优先级的消息会被优先处理。\n\n    - **非阻塞模式**：可以设置消息队列为非阻塞模式，防止 `mq_send` 或 `mq_receive` 阻塞进程。\n\n- **使用**：\n\n    - **`mq_open()`**：创建或打开一个消息队列。\n\n    - **`mq_send()`**：发送消息。\n\n    - **`mq_receive()`**：接收消息。\n\n    - **`mq_close()`**：关闭消息队列。\n\n    - **`mq_unlink()`**：删除消息队列。\n\n#### 1.1.1. 消息队列属性\n\n在POSIX消息队列中，**消息队列属性**（`mq_attr`）是用来设置和获取消息队列的特性和参数的结构体。它的主要作用是控制消息队列的行为，例如最大消息数、消息大小等。`mq_attr`结构体包含了以下几个字段：\n```c\nstruct mq_attr {\n    long    mq_flags;      // 消息队列的标志\n    long    mq_maxmsg;     // 消息队列中最多可以容纳的消息数量\n    long    mq_msgsize;    // 队列中每条消息的最大大小\n    long    mq_curmsgs;    // 当前队列中的消息数\n};\n```\n\n1. `mq_flags`\n\n\t这个字段用于设置消息队列的标志。常见的标志有：\n\t\n\t- **`O_NONBLOCK`**：以非阻塞模式打开消息队列。这意味着如果消息队列为空，接收操作（`mq_receive()`）会立即返回，而不是阻塞等待。\n\t\n\t- **`O_RDWR`**：允许对消息队列进行读写操作。\n\t\n\t如果没有设置这些标志，消息队列将会默认阻塞模式操作。\n\n2. `mq_maxmsg`\n\n\t这个字段定义了消息队列可以容纳的最大消息数量。如果消息队列已经存满，且没有空间容纳新的消息，后续的消息发送（`mq_send()`）将会被阻塞，直到队列中有足够的空间。这个属性通常设置为你希望消息队列中能存储的消息个数。\n\n3. `mq_msgsize`\n\n\t此字段定义每条消息的最大字节数。在创建消息队列时，必须确保消息发送和接收操作的消息大小不会超过这个值。如果消息超过了这个大小，发送操作将返回错误。\n\n4. `mq_curmsgs`\n\n\t这个字段是一个只读属性，用于获取当前队列中的消息数量。它是一个动态更新的值，每次读取时会返回当前消息队列中实际存储的消息数。这个字段对应用程序来说很有用，尤其是在需要了解队列当前状态的场景。\n\n这个例子展示了两个不相关的进程如何通过 POSIX 消息队列进行通信。\n发送方(sender.c)：\n```c\n#include <stdio.h>\n#include <stdlib.h>          /* 动态内存管理及其他辅助功能如exit、abort */\n#include <string.h>\n#include <fcntl.h>           /* 提供 O_CREAT, O_RDWR 用于文件控制 */\n#include <sys/stat.h>        /* 文件属性操作 如chmod、umask */\n#include <mqueue.h>          /* 提供POSIX消息队列支持 */\n#include <unistd.h>          /* 提供POSIX接口 */\n\n#define MQ_NAME \"/my_mq\"\n\nint main() {\n    mqd_t mqd;\n    struct mq_attr attr;\n    char buffer[256];\n    const char *msg = \"Hello from sender!\";\n\n    // 设置消息队列属性\n    attr.mq_flags = 0;\n    attr.mq_maxmsg = 10;\n    attr.mq_msgsize = 256;\n    attr.mq_curmsgs = 0;\n\n    // 创建或打开消息队列\n    mqd = mq_open(MQ_NAME, O_CREAT | O_WRONLY, 0666, &attr);\n    if (mqd == (mqd_t)-1) {\n        perror(\"mq_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Sender: Sending message...\\n\");\n\n    // 发送消息，优先级为1\n    if (mq_send(mqd, msg, strlen(msg) + 1, 1) == -1) {\n        perror(\"mq_send\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 关闭消息队列描述符\n    mq_close(mqd);\n\n    printf(\"Sender: Message sent and mq closed.\\n\");\n    return 0;\n}\n```\n\n接收方(receiver.c)：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <mqueue.h>\n#include <unistd.h>\n\n#define MQ_NAME \"/my_mq\"\n\nint main() {\n    mqd_t mqd;\n    struct mq_attr attr;\n    char buffer[256 + 1];\n    unsigned int prio;\n\n    // 打开消息队列\n    mqd = mq_open(MQ_NAME, O_RDONLY);\n    if (mqd == (mqd_t)-1) {\n        perror(\"mq_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 获取消息队列属性\n    mq_getattr(mqd, &attr);\n\n    printf(\"Receiver: Waiting for message...\\n\");\n\n    // 接收消息\n    if (mq_receive(mqd, buffer, attr.mq_msgsize, &prio) == -1) {\n        perror(\"mq_receive\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Receiver: Received message: %s (Priority: %u)\\n\", buffer, prio);\n\n    // 关闭和删除消息队列\n    mq_close(mqd);\n    mq_unlink(MQ_NAME);\n\n    return 0;\n}\n```\n\n**编译和运行**： `gcc sender.c -o sender -lrt` `gcc receiver.c -o receiver -lrt` （需要链接实时库 `-lrt`） 先运行 `./sender`，再运行 `./receiver`。\n\n### 1.2. POSIX 信号量\n\n用于进程间的同步，功能与 System V 信号量类似，但提供了更简单的接口。\n\n- **特点**：\n\n    - **有名信号量**：通过一个文件名标识，可以用于非亲缘进程。\n\n    - **无名信号量**：常用于线程间的同步，存放在共享内存中，只能用于有亲缘关系的进程。\n\n- **使用**：\n\n    - **`sem_open()`**：创建或打开有名信号量。\n\n    - **`sem_wait()`**：原子性地减少信号量计数器，如果为0则阻塞。\n\n    - **`sem_post()`**：原子性地增加信号量计数器。\n\n    - **`sem_close()`**：关闭信号量。\n\n    - **`sem_unlink()`**：删除信号量。\n\n这个例子展示了如何使用 POSIX 信号量来同步两个进程对一个共享资源的访问。\n\n共享资源访问程序 (sem_client.c)：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>           /* For O_CREAT, O_RDWR */\n#include <sys/stat.h>        /* For mode constants */\n#include <semaphore.h>\n#include <unistd.h>\n\n#define SEM_NAME \"/my_semaphore\"\n\nint main() {\n    sem_t *sem;\n    int value;\n\n    // 打开信号量\n    sem = sem_open(SEM_NAME, 0); // O_CREAT is not needed here\n    if (sem == SEM_FAILED) {\n        perror(\"sem_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Client: Waiting to get semaphore...\\n\");\n\n    // P 操作：等待信号量，如果值为0则阻塞\n    if (sem_wait(sem) == -1) {\n        perror(\"sem_wait\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Client: Got the semaphore. Accessing shared resource...\\n\");\n    sleep(2); // 模拟访问共享资源\n\n    printf(\"Client: Finished. Releasing semaphore...\\n\");\n\n    // V 操作：释放信号量，计数器加1\n    if (sem_post(sem) == -1) {\n        perror(\"sem_post\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 关闭信号量\n    sem_close(sem);\n\n    return 0;\n}\n```\n\n信号量控制程序 (sem_main.c)：`\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <semaphore.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define SEM_NAME \"/my_semaphore\"\n\nint main() {\n    sem_t *sem;\n    pid_t pid;\n\n    // 创建并初始化信号量，初始值为1\n    sem = sem_open(SEM_NAME, O_CREAT, 0666, 1);\n    if (sem == SEM_FAILED) {\n        perror(\"sem_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Main: Semaphore created and initialized to 1.\\n\");\n\n    // 创建一个子进程\n    pid = fork();\n    if (pid == 0) {\n        // 子进程运行另一个程序来访问信号量\n        execlp(\"./sem_client\", \"sem_client\", NULL);\n        perror(\"execlp\"); // 如果执行失败\n        exit(EXIT_FAILURE);\n    } else if (pid > 0) {\n        // 父进程也尝试访问信号量\n        sleep(1); // 确保子进程先运行\n        printf(\"Main: Waiting to get semaphore...\\n\");\n        sem_wait(sem);\n        printf(\"Main: Got the semaphore. Accessing shared resource...\\n\");\n        sleep(2);\n        printf(\"Main: Finished. Releasing semaphore...\\n\");\n        sem_post(sem);\n\n        wait(NULL); // 等待子进程结束\n\n        // 删除信号量\n        sem_unlink(SEM_NAME);\n        printf(\"Main: Child process finished. Semaphore unlinked.\\n\");\n    }\n\n    // 关闭信号量\n    sem_close(sem);\n\n    return 0;\n}\n```\n\n**编译和运行**： `gcc sem_client.c -o sem_client -lrt` `gcc sem_main.c -o sem_main -lrt` （同样需要链接实时库 `-lrt`） 运行 `./sem_main`。\n\n\n\n### 1.3. POSIX 共享内存\n\n和 System V 共享内存一样，都是最快的 IPC 方式，但 POSIX 版本使用了文件描述符。\n\n- **特点**：\n\n    - **基于文件**：通过 `shm_open` 创建或打开一个共享内存对象，返回一个文件描述符。\n\n    - **内存映射**：通过 `mmap()` 将文件描述符对应的内存映射到进程的地址空间。\n\n- **使用**：\n\n    - **`shm_open()`**：创建或打开共享内存对象。\n\n    - **`ftruncate()`**：调整共享内存对象的大小。\n\n    - **`mmap()`**：将共享内存映射到进程地址空间。\n\n    - **`munmap()`**：解除映射。\n\n    - **`shm_unlink()`**：删除共享内存对象。\n\n这个例子展示了两个进程如何通过 POSIX 共享内存来共享一块内存区域，并用一个信号量来同步。\n\n写入方 (shm_writer.c)\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <semaphore.h>\n#include <unistd.h>\n\n#define SHM_NAME \"/my_shm\"\n#define SEM_NAME \"/my_shm_sem\"\n#define SHM_SIZE 4096\n\nint main() {\n    int shm_fd;\n    void *ptr;\n    sem_t *sem;\n    const char *msg = \"Hello from shm writer!\";\n\n    // 创建/打开共享内存对象\n    shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);\n    if (shm_fd == -1) {\n        perror(\"shm_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 设置共享内存大小\n    ftruncate(shm_fd, SHM_SIZE);\n\n    // 将共享内存映射到进程地址空间\n    ptr = mmap(0, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);\n    if (ptr == MAP_FAILED) {\n        perror(\"mmap\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 创建/打开信号量，用于同步\n    sem = sem_open(SEM_NAME, O_CREAT, 0666, 0); // 初始值为0，表示不可访问\n    if (sem == SEM_FAILED) {\n        perror(\"sem_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Writer: Writing to shared memory...\\n\");\n    // 写入数据\n    sprintf(ptr, \"%s\", msg);\n\n    // V 操作：释放信号量，通知读者可以读取了\n    sem_post(sem);\n    printf(\"Writer: Data written and semaphore posted.\\n\");\n\n    // 关闭\n    sem_close(sem);\n    munmap(ptr, SHM_SIZE);\n    close(shm_fd);\n\n    return 0;\n}\n```\n\n读取方 (shm_reader.c)：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <semaphore.h>\n#include <unistd.h>\n\n#define SHM_NAME \"/my_shm\"\n#define SEM_NAME \"/my_shm_sem\"\n#define SHM_SIZE 4096\n\nint main() {\n    int shm_fd;\n    void *ptr;\n    sem_t *sem;\n\n    // 打开共享内存对象\n    shm_fd = shm_open(SHM_NAME, O_RDONLY, 0666);\n    if (shm_fd == -1) {\n        perror(\"shm_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 将共享内存映射到进程地址空间\n    ptr = mmap(0, SHM_SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);\n    if (ptr == MAP_FAILED) {\n        perror(\"mmap\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 打开信号量\n    sem = sem_open(SEM_NAME, 0);\n    if (sem == SEM_FAILED) {\n        perror(\"sem_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Reader: Waiting for writer...\\n\");\n    // P 操作：等待信号量，直到有数据可用\n    sem_wait(sem);\n\n    printf(\"Reader: Data received: %s\\n\", (char *)ptr);\n\n    // 关闭和清理\n    sem_close(sem);\n    sem_unlink(SEM_NAME); // 删除信号量\n    munmap(ptr, SHM_SIZE);\n    close(shm_fd);\n    shm_unlink(SHM_NAME); // 删除共享内存对象\n\n    return 0;\n}\n```\n\n**编译和运行**： `gcc shm_writer.c -o shm_writer -lrt` `gcc shm_reader.c -o shm_reader -lrt` （同样需要链接实时库 `-lrt`） 先运行 `./shm_writer`，再运行 `./shm_reader`。\n\n\n\n","tags":["Linux","IPC","POSIX"],"categories":["Linux","内核编程"]},{"title":"深入浅出 Linux IPC：进程间通信的艺术","url":"/posts/46571/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n- [1. 为什么需要 IPC？](#1-为什么需要-ipc)\n- [2. 常见的 Linux IPC 机制](#2-常见的-linux-ipc-机制)\n  - [2.1. 管道（Pipes）](#21-管道pipes)\n  - [2.2. FIFO（命名管道）](#22-fifo命名管道)\n  - [2.3. 信号](#23-信号)\n    - [2.3.1. 信号的分类](#231-信号的分类)\n    - [2.3.2. 信号与 IPC 的关系](#232-信号与-ipc-的关系)\n    - [2.3.3. 信号的三种处理方式](#233-信号的三种处理方式)\n    - [2.3.4. 如何使用信号？](#234-如何使用信号)\n      - [2.3.4.1. 发送信号：`kill()` 函数](#2341-发送信号kill-函数)\n      - [2.3.4.2. 注册信号处理函数：`signal()` 和 `sigaction()`](#2342-注册信号处理函数signal-和-sigaction)\n  - [2.4. 信号集（Signal Set）和阻塞](#24-信号集signal-set和阻塞)\n    - [2.4.1. 信号集操作函数](#241-信号集操作函数)\n    - [2.4.2. 阻塞信号：`sigprocmask()`](#242-阻塞信号sigprocmask)\n  - [2.5. System V IPC (System V IPC)\\[^1\\]](#25-system-v-ipc-system-v-ipc)\n    - [2.5.1. 消息队列（Message Queues）](#251-消息队列message-queues)\n    - [2.5.2. 信号量（Semaphores）](#252-信号量semaphores)\n    - [2.5.3. 共享内存（Shared Memory）](#253-共享内存shared-memory)\n  - [2.6. IPC 总结与选择](#26-ipc-总结与选择)\n\n\n在 Linux 世界中，进程是独立的执行单元，拥有自己的地址空间。但很多时候，为了完成一个复杂的任务，不同的进程需要协同工作，交换数据。这时，我们就需要**进程间通信（IPC, Inter-Process Communication）**。IPC 就像是进程之间的一座桥梁，让它们能够相互“交谈”，共享信息。\n\n本文将带你深入了解 Linux 中常见的 IPC 机制，并以**使用为导向**，结合代码示例，让你能够快速掌握这些“通信”技术。\n\n## 1. 为什么需要 IPC？\n\n想象一个场景：你正在开发一个 Web 服务器。一个主进程负责监听网络请求，但处理这些请求非常耗时。如果主进程自己处理，服务器就会变得很慢，无法响应新的请求。一个更好的设计是，主进程每接收到一个请求，就创建一个新的子进程或将请求发送给一个工作进程池来处理。这样，主进程可以立即回去监听新的连接，而工作进程则专注于处理任务。\n\n在这个例子中，主进程需要将请求数据传递给工作进程。这就是 IPC 发挥作用的地方。\n\n## 2. 常见的 Linux IPC 机制\n\nLinux 提供了多种 IPC 机制，每种都有其独特的优缺点和适用场景。我们可以将它们分为两大类：**基于文件**和**基于内存**。\n\n### 2.1. 管道（Pipes）\n\n管道可能是最简单、最古老的 IPC 形式。它就像一个单向的“水管”，一端用于写入，另一端用于读取。\n\n- **特点**：\n\n    - **单向通信**：数据只能从一端流向另一端。\n\n    - **父子进程通信**：管道通常用于有亲缘关系的进程之间，比如父进程和子进程。\n\n    - **半双工**：虽然是单向，但如果创建两个管道，就可以实现双向通信。\n\n- **使用**：\n\n    - **`pipe()` 函数**：这是创建管道的核心函数。\n\n    ```c\n    #include <unistd.h>\n    int pipe(int pipefd[2]);\n    ```\n\n    `pipefd` 是一个包含两个文件描述符的数组，`pipefd[0]` 用于读取，`pipefd[1]` 用于写入。\n\n- **代码示例**：一个简单的父子进程通信。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/wait.h>\n\nint main() {\n    int pipefd[2];\n    pid_t pid;\n    char buf[20];\n    const char *msg = \"Hello from parent!\";\n\n    if (pipe(pipefd) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid > 0) { // 父进程\n        close(pipefd[0]); // 关闭读取端\n        write(pipefd[1], msg, strlen(msg) + 1);\n        close(pipefd[1]); // 关闭写入端，如果不关，子进程读端收不到EOF信号，则会一直读导致程序阻塞\n        wait(NULL);\n    } else { // 子进程\n        close(pipefd[1]); // 关闭写入端，如果不关\n        read(pipefd[0], buf, sizeof(buf));\n        printf(\"Child received: %s\\n\", buf);\n        close(pipefd[0]); // 关闭读取端\n    }\n\n    return 0;\n}\n```\n\n### 2.2. FIFO（命名管道）\n\n管道只能用于有亲缘关系的进程，那如果两个毫不相关的进程想通信怎么办？答案就是 **FIFO (First-In, First-Out)**，也叫**命名管道**。\n\n- **特点**：\n\n    - **文件系统路径**：它在文件系统中有一个路径名，不同于匿名管道。\n\n    - **非亲缘进程通信**：任意两个进程都可以通过这个路径名打开并通信。\n\n    - **单向**：和管道一样，FIFO 也是单向的，需要两个 FIFO 来实现双向通信。\n\n- **使用**：\n\n    - **`mkfifo()` 函数**或 **`mkfifo` 命令**：用来创建 FIFO。\n\n\n    ```c\n    #include <sys/types.h>\n    #include <sys/stat.h>\n    int mkfifo(const char *pathname, mode_t mode);\n    ```\n\n    - **`open()`, `read()`, `write()` 函数**：像操作普通文件一样来操作 FIFO。\n\n- **代码示例**：\n\n    - **`writer.c`**：\n\n    ```c\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <fcntl.h>\n    #include <sys/stat.h>\n    #include <unistd.h>\n\n    #define FIFO_NAME \"my_fifo\"\n\n    int main() {\n        int fd;\n        char *msg = \"Hello from writer!\";\n\n        mkfifo(FIFO_NAME, 0666);\n        fd = open(FIFO_NAME, O_WRONLY);\n        write(fd, msg, strlen(msg) + 1);\n        close(fd);\n        unlink(FIFO_NAME); // 删除命名管道文件\n        return 0;\n    }\n    ```\n\n    - **`reader.c`**：\n\n    ```c\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <fcntl.h>\n    #include <sys/stat.h>\n    #include <unistd.h>\n\n    #define FIFO_NAME \"my_fifo\"\n\n    int main() {\n        int fd;\n        char buf[20];\n\n        mkfifo(FIFO_NAME, 0666); // 保证文件存在\n        fd = open(FIFO_NAME, O_RDONLY);\n        read(fd, buf, sizeof(buf));\n        printf(\"Reader received: %s\\n\", buf);\n        close(fd);\n        return 0;\n    }\n    ```\n\n    你可以先运行 `writer.c`，再运行 `reader.c`。\n\n\n\n### 2.3. 信号\n\n**信号（Signal）** 是一种更轻量级、更异步的进程间通信和事件通知机制。它就像一个“软中断”，用来通知进程发生了某个事件。\n\n想象一下，你正在专注地工作，突然有人拍了你一下肩膀。你停下手中的活，转头看看发生了什么事，然后根据情况做出反应（比如，对方是同事，你可能和他聊两句；对方是领导，你可能马上站起来）。\n\n在 Linux 中，**信号**就是那个“拍肩膀”的动作。当一个进程收到一个信号时，它会暂停当前执行的任务，转而去处理这个信号，处理完后再恢复执行。\n\n- **发送者**：可以是内核（比如你按下 `Ctrl+C`，内核会发送 `SIGINT` 信号给前台进程）、也可以是其他进程（使用 `kill()` 函数）。\n\n- **接收者**：任何一个进程都可以接收信号。\n\n\n#### 2.3.1. 信号的分类\n\n信号有很多种，每种都有其特定的用途。常见的信号及其作用如下：\n\n|信号名称|默认行为|解释|\n|---|---|---|\n|**`SIGHUP` (1)**|终止进程|当终端关闭时发送给关联的进程。|\n|**`SIGINT` (2)**|终止进程|来自键盘中断，通常是 `Ctrl+C`。|\n|**`SIGQUIT` (3)**|终止并生成核心转储文件|来自键盘退出，通常是 `Ctrl+\\\\`。|\n|**`SIGKILL` (9)**|强制终止进程|无法被捕获、阻塞或忽略，强制杀死进程。|\n|**`SIGTERM` (15)**|终止进程|友好的终止请求，可以被捕获。`kill` 命令默认发送此信号。|\n|**`SIGCHLD`**|忽略|子进程终止或停止时发送给父进程。|\n|**`SIGSTOP`**|停止进程|无法被捕获、忽略，暂停进程。|\n|**`SIGCONT`**|继续进程|使停止的进程继续运行。|\n\n#### 2.3.2. 信号与 IPC 的关系\n\n- **异步通知**：信号是典型的异步 IPC 机制，它不像管道或共享内存那样传递数据，而是**传递事件信息**。\n\n- **轻量级**：相比于其他 IPC，信号的开销非常小。\n\n- **同步**：信号也可以用于同步目的，例如 `SIGCHLD` 信号常用于父进程等待子进程结束。\n\n\n理解信号，特别是信号集和阻塞的概念，对于编写健壮的多进程或多线程程序至关重要。它能让你更好地控制程序对外部事件的响应。\n\n\n#### 2.3.3. 信号的三种处理方式\n\n当进程收到一个信号时，它可以有三种处理方式：\n\n1. **执行默认动作（Default）**：大多数信号都有一个预定义的默认行为。例如，`SIGINT` 的默认行为就是终止进程。\n\n2. **忽略信号（Ignore）**：有些信号可以被忽略，即进程收到信号后不做任何处理。`SIGCHLD` 信号的默认行为就是忽略。\n\n3. **捕获信号（Catch）**：这是最灵活的方式。进程可以为某个信号注册一个**信号处理函数（Signal Handler）**。当信号到来时，进程会执行这个函数来处理信号，而不是执行默认动作。\n\n!!! caution\n    **注意**：`SIGKILL` 和 `SIGSTOP` 这两个信号是**不能被捕获、忽略或阻塞**的。它们是系统管理员强制终止或停止进程的“最后手段”。\n\n\n\n#### 2.3.4. 如何使用信号？\n\n##### 2.3.4.1. 发送信号：`kill()` 函数\n\n你可以使用 `kill()` 函数向另一个进程发送信号。\n\n```c\n#include <sys/types.h>\n#include <signal.h>\nint kill(pid_t pid, int sig);\n```\n\n- `pid`：目标进程的 ID。\n\n- `sig`：要发送的信号编号。\n\n\n##### 2.3.4.2. 注册信号处理函数：`signal()` 和 `sigaction()`\n\n- **`signal()` 函数**：这是最简单的注册方式，但它在不同系统上的行为可能不一致，不推荐在新代码中使用。\n\n- **`sigaction()` 函数**：这是 POSIX 标准推荐的方式，更强大，更可靠。\n\n\n```c\n#include <signal.h>\nint sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);\n```\n\n- `signum`：要捕获的信号编号。\n\n- `act`：指向 `struct sigaction` 结构体，该结构体定义了新的信号处理行为。\n\n- `oldact`：可选，用于保存旧的信号处理行为。\n\n\n**`struct sigaction` 结构体**：\n```c\nstruct sigaction {\n    void (*sa_handler)(int);  // 信号处理函数\n    sigset_t sa_mask;         // 信号集，在信号处理函数执行期间需要阻塞的信号\n    int sa_flags;             // 标志位\n};\n```\n\n### 2.4. 信号集（Signal Set）和阻塞\n\n当你在处理一个信号时，你可能不希望被其他信号打断。**信号集（`sigset_t`）** 就是用来管理一组信号的。通过操作信号集，你可以**阻塞（Block）** 某些信号，让它们在进程处理完当前任务后才被传递。\n\n#### 2.4.1. 信号集操作函数\n\n- **`sigemptyset()`**：初始化一个空的信号集。\n\n- **`sigaddset()`**：向信号集中添加一个信号。\n\n- **`sigdelset()`**：从信号集中删除一个信号。\n\n- **`sigismember()`**：检查一个信号是否在信号集中。\n\n\n#### 2.4.2. 阻塞信号：`sigprocmask()`\n\n`sigprocmask()` 函数用来设置进程的**信号阻塞掩码（Signal Mask）**。\n\n```c\n#include <signal.h>\nint sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\n```\n\n- `how`：指定如何修改信号阻塞掩码，有以下几种：\n\n    - `SIG_BLOCK`：将 `set` 中的信号添加到阻塞掩码中。\n\n    - `SIG_UNBLOCK`：将 `set` 中的信号从阻塞掩码中移除。\n\n    - `SIG_SETMASK`：将阻塞掩码设置为 `set`。\n\n- `set`：包含要阻塞或解除阻塞的信号集。\n\n- `oldset`：可选，用于保存旧的阻塞掩码。\n\n\n**示例**：在处理关键代码段时临时阻塞 `SIGINT`。\n\n```c\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n\nvoid my_handler(int sig) {\n    printf(\"Caught signal %d\\n\", sig);\n}\n\nint main() {\n    sigset_t block_mask, old_mask;\n\n    // 1. 设置要阻塞的信号集\n    sigemptyset(&block_mask);\n    sigaddset(&block_mask, SIGINT);\n\n    // 2. 阻塞 SIGINT 信号\n    sigprocmask(SIG_BLOCK, &block_mask, &old_mask);\n\n    printf(\"SIGINT is blocked. Press Ctrl+C...\\n\");\n    sleep(10); // 在这10秒内，Ctrl+C不会终止进程\n\n    printf(\"Unblocking SIGINT...\\n\");\n    // 3. 解除阻塞，恢复旧的信号掩码\n    sigprocmask(SIG_SETMASK, &old_mask, NULL);\n\n    printf(\"SIGINT is unblocked. Press Ctrl+C again.\\n\");\n\n    // 4. 注册一个信号处理函数\n    struct sigaction sa;\n    sa.sa_handler = my_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sigaction(SIGINT, &sa, NULL);\n\n    while(1) {\n        printf(\"Running...\\n\");\n        sleep(1);\n    }\n\n    return 0;\n}\n```\n\n运行这段代码，你会看到在阻塞期间，`Ctrl+C` 无法终止进程。当解除阻塞后，`Ctrl+C` 才能触发信号处理函数。\n\n\n### 2.5. System V IPC (System V IPC)[^1]\n\nSystem V IPC 是 Linux 系统中一组更高级、更强大的 IPC 机制，包括消息队列、信号量和共享内存。它们都是**基于内核**的，需要一个唯一的键值（key）来标识。\n\n#### 2.5.1. 消息队列（Message Queues）\n\n消息队列就像一个链表，允许进程向其中添加消息或从中读取消息。\n\n- **特点**：\n\n    - **异步通信**：发送进程可以发送消息后立即返回，不需要等待接收进程。\n\n    - **带类型**：消息可以带有类型，接收进程可以只接收特定类型的消息。\n\n    - **存储在内核中**：即使发送进程结束，消息依然保留在队列中，直到被读取。\n\n- **使用**：\n\n    - **`ftok()`**：将文件路径和整数转换为一个唯一的 IPC 键值。\n\n    - **`msgget()`**：创建或获取一个消息队列。\n\n    - **`msgsnd()`**：发送消息。\n\n    - **`msgrcv()`**：接收消息。\n\n    - **`msgctl()`**：控制消息队列，如删除。\n\n\n#### 2.5.2. 信号量（Semaphores）\n\n信号量主要用于**同步**，控制对共享资源的访问。它本身不传递数据，而是作为一种“计数器”。\n\n- **特点**：\n\n    - **互斥和同步**：常用于实现互斥锁，确保同一时间只有一个进程访问共享资源。\n\n    - **原子操作**：信号量的操作（P/V操作）是原子的，不会被中断。\n\n- **使用**：\n\n    - **`semget()`**：创建或获取一组信号量。\n\n    - **`semop()`**：对信号量进行操作，如加/减计数。\n\n    - **`semctl()`**：控制信号量。\n\n\n#### 2.5.3. 共享内存（Shared Memory）\n\n共享内存是最高效的 IPC 方式。它允许两个或多个进程共享同一块物理内存。\n\n- **特点**：\n\n    - **最高效**：一旦映射到进程的地址空间，读写操作就像访问普通内存一样，不需要内核的参与。\n\n    - **需要同步**：由于多个进程同时访问，需要用**信号量**等机制来同步访问，防止数据竞争。\n\n- **使用**：\n\n    - **`shmget()`**：创建或获取一个共享内存段。\n\n    - **`shmat()`**：将共享内存段附加到进程的地址空间。\n\n    - **`shmdt()`**：将共享内存段从进程的地址空间分离。\n\n    - **`shmctl()`**：控制共享内存，如删除。\n\n### 2.6. IPC 总结与选择\n\n|机制|适用场景|优点|缺点|\n|---|---|---|---|\n|**管道**|有亲缘关系的进程|简单，易于使用|单向，仅限于亲缘进程|\n|**FIFO**|无亲缘关系的进程|可以在文件系统中命名，灵活|单向，需要同步，读写时有阻塞|\n|**消息队列**|异步通信，少量数据|消息带类型，无需同步|效率较低，有大小限制|\n|**信号量**|进程间同步，互斥|用于控制访问，防止竞争|不传递数据|\n|**共享内存**|大量数据传输|最高效，读写速度快|必须配合其他同步机制使用|\n\n**如何选择？**\n\n- 如果是父子进程之间少量数据的通信，**管道**是最佳选择。\n\n- 如果是两个不相关的进程，且数据量不大，**消息队列**是一个不错的方案。\n\n- 如果需要传输大量数据，且对性能要求极高，**共享内存**是首选，但**必须**结合**信号量**或其他同步机制。\n\n- 如果你只想解决资源访问的同步问题，**信号量**是专门为此设计的。\n\n\n了解这些 IPC 机制，就如同掌握了进程之间“沟通”的多种语言。在开发时，选择合适的“语言”能让你的程序更加健壮、高效。现在，你可以尝试用这些机制来解决你遇到的实际问题了！\n\n[^1]: 作了解，重点使用POSIX IPC。","tags":["Linux","IPC"],"categories":["Linux","内核编程"]},{"title":"Linux-Process","url":"/posts/43741/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n!!! info \"\"\n    AI 辅助创作\n\n\n在 Linux 编程中，**进程（Process）** 是操作系统分配资源和调度的基本单位。每个进程都有自己独立的内存空间、代码段、数据段和执行上下文。多个进程之间常常需要协作，这就涉及到 **进程间通信（IPC, Inter-Process Communication）**。本篇博客会系统介绍进程的基础操作，并对常见的 IPC 方式进行详细解释与示例，带你从零开始掌握。\n\n---\n\n## 1. 进程与 PID\n\n每个进程都会有一个唯一的 **进程号（PID）**，可以通过 `getpid()` 获取当前进程号，通过 `getppid()` 获取父进程号。这在调试和进程管理时非常重要。\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    printf(\"当前进程PID=%d, 父进程PID=%d\\n\", getpid(), getppid());\n    return 0;\n}\n```\n\n⚠️ 注意：如果父进程先退出，子进程会被 `init` 进程接管，`ppid` 会变为 1。\n\n## 2. 创建进程 — `fork()`\n\n`fork()` 是创建新进程的主要方式。它会复制当前进程（父进程）的大部分内容，生成一个几乎一模一样的子进程。\n\n```c\npid_t pid = fork();\n```\n\n- **在父进程中，`fork()` 返回子进程的 PID。**\n    \n- **在子进程中，`fork()` 返回 0。**\n    \n- 如果失败，返回 -1。\n    \n\n示例：\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"[子进程] pid=%d, ppid=%d\\n\", getpid(), getppid());\n    } else if (pid > 0) {\n        printf(\"[父进程] pid=%d, 子进程pid=%d\\n\", getpid(), pid);\n    } else {\n        perror(\"fork 失败\");\n    }\n    return 0;\n}\n```\n\n!!! caution\n    - 子进程不会继承父进程的所有资源，例如文件锁。\n    \n    - `fork()` 之后，父子进程执行顺序不确定，需要通过 `wait()` 或其他机制控制。\n\n\n## 3. 程序替换 — `exec()` 系列\n\n子进程常常需要运行一个新的程序，这就需要 `exec()` 系列函数（如 `execlp`, `execvp` 等）。\n`exec` 系列函数的作用是：**用新的程序替换当前进程的代码段**，而进程的 PID、文件描述符（除非设置了 `FD_CLOEXEC`）等保持不变。它不会创建新进程，而是在当前进程内加载并运行新程序。\n### 常见函数\n\n`exec` 系列一共有 6 个常用函数，主要区别在于 **参数传递方式** 和 **是否依赖 PATH 环境变量**。\n\n|函数|参数传递方式|是否搜索 PATH|说明|\n|---|---|---|---|\n|`execl(path, arg0, arg1, ..., NULL)`|列表（逐个传参）|否|最常见，参数以不定长列表形式传递，最后必须以 `NULL` 结尾。|\n|`execv(path, argv[])`|数组|否|参数通过字符串数组传递，方便动态构造参数。|\n|`execlp(file, arg0, arg1, ..., NULL)`|列表|是|与 `execl` 类似，但会在 `PATH` 中搜索可执行文件。|\n|`execvp(file, argv[])`|数组|是|与 `execv` 类似，但会在 `PATH` 中搜索可执行文件。|\n|`execle(path, arg0, arg1, ..., NULL, envp[])`|列表|否|可以自定义环境变量，最后参数需提供 `envp`。|\n|`execve(path, argv[], envp[])`|数组|否|最底层的系统调用，其它 `exec` 函数最终都调用它。|\n\n说明：\n- `PATH`：系统环境变量\n- `path`：要执行的程序路径（可以是绝对路径，也可以是相对路径）。\n- `arg`：程序要输入的参数\n### 使用示例\n\n1. **execl：用绝对路径调用程序**\n\n```c\n#include <unistd.h>\n#include <stdio.h> \n\nint main() {     \nprintf(\"Before exec\\n\");     \nexecl(\"/bin/ls\", \"ls\", \"-l\", NULL);     \n// 只有 exec 调用失败时才会继续执行    \nperror(\"execl failed\");     \nreturn 1; }\n```\n\n2. **execvp：在 PATH 中搜索命令**\n    \n```c\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n    char *argv[] = {\"ls\", \"-a\", NULL};\n    execvp(\"ls\", argv);\n    perror(\"execvp failed\");\n    return 1;\n}\n```\n\n3. **execle：传入自定义环境变量**\n    \n```c\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n    char *envp[] = {\"MYVAR=HelloExec\", NULL};\n    execl(\"/usr/bin/env\", \"env\", NULL, envp);\n    perror(\"execle failed\");\n    return 1;\n}\n```\n\n### 注意事项\n\n- `exec` 系列 **不会返回**，除非调用失败。\n    \n- 若调用成功，原进程的代码和数据段会被新程序替换。\n    \n- **文件描述符默认继承**，可以用于在父进程中设置好管道/重定向，让子进程在 exec 后继续使用。\n    \n- 需要保证参数列表最后有 `NULL`，否则会引发不可预期错误。\n    \n\n## 4. 等待子进程 — `wait()` / `waitpid()`\n\n**父进程需要回收子进程退出时的资源，否则子进程会成为 僵尸进程（Zombie）。**\n\n这两个函数用于 **父进程等待子进程结束** 并**回收资源**，避免僵尸进程。\n\n### 1. wait()\n\n```c\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\npid_t wait(int *status);\n```\n\n- **参数**\n    \n    - `status`：指向整数的指针，用于存储子进程退出状态。如果不关心状态，可以传 `NULL`。\n        \n- **返回值**\n    \n    - 成功：返回结束的子进程 PID\n        \n    - 失败：返回 -1（例如没有子进程存在时）\n        \n- **使用示例**\n\n```c\n#include <stdio.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) { // 子进程\n        printf(\"Child running...\\n\");\n        return 42;\n    } else { // 父进程\n        int status;\n        pid_t cpid = wait(&status); // 等待子进程\n        if (WIFEXITED(status)) {   // 判断是否正常退出\n            printf(\"Child %d exited with code %d\\n\", cpid, WEXITSTATUS(status));\n        }\n    }\n    return 0;\n}\n```\n\n!!! caution   \n    - `wait()` 会阻塞父进程，直到任意一个子进程退出。\n        \n    - 如果父进程没有子进程，返回 -1 并设置 `errno = ECHILD`。\n        \n\n### 2. waitpid()\n\n```c\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\npid_t waitpid(pid_t pid, int *status, int options);\n```\n\n- **参数**\n    - `pid`：\n        \n        - `>0` ：等待指定 PID 的子进程\n            \n        - -1 ：等待任意子进程（功能类似 `wait()`）\n            \n        - 0 ：等待与调用进程同组的任意子进程\n            \n        - <-1：等待进程组 ID = |pid| 的任意子进程\n            \n    - `status`：指向整数的指针，用于保存退出状态\n        \n    - `options`：控制函数行为，常用值：\n        \n        - `0`：阻塞等待（默认行为）\n            \n        - `WNOHANG`：非阻塞，如果没有子进程退出立即返回 0\n            \n        - `WUNTRACED`：返回被暂停的子进程（收到 SIGSTOP）\n            \n        - `WCONTINUED`：返回继续运行的子进程（收到 SIGCONT）\n            \n- **返回值**\n    \n    - 成功：返回子进程 PID\n        \n    - 非阻塞且没有子进程退出：返回 0\n        \n    - 失败：返回 -1，并设置 `errno`\n        \n- **使用示例**\n    \n\n```c\n#include <stdio.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) { // 子进程\n        sleep(2);\n        return 100;\n    } else { // 父进程\n        int status;\n        pid_t cpid;\n        while ((cpid = waitpid(pid, &status, WNOHANG)) == 0) {\n            printf(\"Child still running...\\n\");\n            sleep(1);\n        }\n        if (WIFEXITED(status)) {\n            printf(\"Child %d exited with code %d\\n\", cpid, WEXITSTATUS(status));\n        }\n    }\n    return 0;\n}\n```\n\n!!! caution \n    - `waitpid()` 可以实现 **非阻塞等待**，适合父进程同时管理多个子进程。\n        \n    - `WIFEXITED(status)` 判断子进程是否正常退出。\n        \n    - `WIFSIGNALED(status)` 判断子进程是否被信号终止。\n        \n    - 使用 `waitpid()` 可以精准回收指定子进程，避免僵尸进程积累。\n        \n\n!!! note \"tips\"\n    - 父进程只需要等待任意子进程 → 用 `wait()` 即可。\n    \n    - 父进程需要精确控制或非阻塞 → 用 `waitpid()`。\n    \n    - 调用前一定要理解 **阻塞 vs 非阻塞**，避免父进程被卡住。\n\n## 5. 进程退出 — `exit()` 与 `_exit()`\n\n- `exit()`：会刷新缓冲区，执行清理函数。\n    \n- `_exit()`：立即退出，不做清理，通常在子进程 `fork()` 后的错误处理中使用。\n    \n\n⚠️ 区别：`exit()` 适合普通退出，`_exit()` 适合在 `fork()` 后不希望影响父进程的环境时使用。\n\n!!! caution\n    - 子进程执行退出函数后，子进程结束并变为僵尸🧟，内核保留子进程在进程表中的部分信息（PID、退出码等）占用少量系统资源，但不会再运行。需要父进程调用wait释放子进程资源，净化僵尸，释放灵魂👻\n\n\n## 6. ps 命令简述\n\n### `ps` 命令的常见用法\n\n#### 1. 查看当前终端中的进程\n\n这是最简单的用法，不加任何选项，`ps` 命令只会显示当前终端会话中运行的进程。\n\n```bash\nps\n```\n\n运行后你可能会看到类似下面的输出：\n\n```bash\nPID TTY          TIME CMD\n1234 pts/0    00:00:00 bash\n5678 pts/0    00:00:00 ps\n```\n\n- **PID**：进程的唯一标识符（Process ID）。\n    \n- **TTY**：进程运行所在的终端。\n    \n- **TIME**：进程使用的 CPU 时间。\n    \n- **CMD**：启动进程的命令。\n    \n\n#### 2. 查看所有进程\n\n如果你想查看系统中所有用户的所有进程，可以使用 `-e` 选项（代表所有进程）或 `-a` 选项（代表所有进程，除了会话引导进程）。\n\n```bash\nps -e\n```\n\n或者使用 `-ef` 组合，这是最常用的组合之一，它提供了更详细的信息：\n\n```bash\nps -ef\n```\n\n- **UID**：启动进程的用户 ID。\n    \n- **PID**：进程 ID。\n    \n- **PPID**：父进程 ID。\n    \n- **C**：CPU 利用率。\n    \n- **STIME**：进程启动时间。\n    \n- **TTY**：进程所在的终端。\n    \n- **TIME**：进程使用的 CPU 时间。\n    \n- **CMD**：启动进程的命令。\n    \n\n#### 3. 查看用户进程\n\n如果你只想查看某个特定用户（例如 `root`）的进程，可以使用 `-u` 选项。\n\n```bash\nps -u root\n```\n\n#### 4. 通过管道和 `grep` 查找特定进程\n\n在实际工作中，你通常会需要查找某个特定的进程，比如 Nginx 或 MySQL。这时，`ps` 命令通常会配合 `grep` 命令一起使用。`grep` 可以从 `ps` 的输出中过滤出你想要的信息。\n\n例如，查找所有与 Nginx 相关的进程：\n\n```bash\nps -ef | grep nginx\n```\n\n这里的 `|` 是管道符，它的作用是将 `ps -ef` 命令的输出作为 `grep` 命令的输入。\n\n### `ps` 命令的常用选项总结\n\n| 选项   | 描述                   |\n| ---- | -------------------- |\n| -e   | 显示所有进程               |\n| -f   | 显示完整格式的列表            |\n| -a   | 显示所有进程（不包括会话引导进程）    |\n| -u   | 按用户过滤进程              |\n| -aux | 最经典的组合，显示所有用户的详细进程信息 |\n\n### 实际应用示例\n\n假设你想查看当前系统中 CPU 或内存占用最高的几个进程，`ps` 命令可以与 `head`、`sort` 等命令结合使用。\n\n**查看 CPU 占用最高的 5 个进程：**\n\n```bash\nps -aux --sort=-%cpu | head -n 6\n```\n\n这里的 `--sort=-%cpu` 表示按 CPU 占用率降序排列，`head -n 6` 则取前 6 行（包括标题行）。\n\n### 解析 `ps -aux` 命令的输出\n\n当你运行 `ps -aux` 命令时，你会看到一个包含多个列的表格。每一列都提供了关于进程的重要信息。下面是对这些列的详细解释：\n\n- **USER**：启动该进程的用户。\n    \n- **PID**：进程的唯一标识符（**P**rocess **ID**）。当你需要杀死一个进程时，通常会用到这个 ID。\n    \n- **%CPU**：进程在最近一段时间内使用的 **CPU** 占用率。\n    \n- **%MEM**：进程使用的 **物理内存** 占用率。\n    \n- **VSZ**：进程使用的虚拟内存大小（**V**irtual **S**ize），单位为千字节（KB）。\n    \n- **RSS**：进程使用的 **物理内存** 大小（**R**esident **S**et **S**ize），单位为千字节（KB）。\n    \n- **TTY**：进程运行所在的终端。如果显示 `?`，表示该进程没有关联的终端，通常是系统进程。\n    \n- **STAT**：进程的当前状态（**STAT**us）。这是一个非常重要的列，常用的状态码有：\n    \n    - **R**：正在运行（**R**unning）或可运行（**R**unnable）。\n        \n    - **S**：可中断的睡眠状态（**S**leeping）。\n        \n    - **D**：不可中断的睡眠状态（**D**isk sleep），通常表示进程正在等待 I/O 操作。\n        \n    - **Z**：僵尸进程（**Z**ombie），进程已终止，但其父进程还未对其进行善后处理。\n        \n    - **T**：停止（**S**topped），进程被信号停止。\n        \n    - **<**：高优先级进程。\n        \n    - **N**：低优先级进程。\n        \n- **START**：进程启动的时间。\n    \n- **TIME**：进程已经消耗的 **CPU 时间** 总量。这与 %CPU 不同，%CPU 是瞬时值，而 TIME 是累积值。\n    \n- **COMMAND**：启动该进程的完整命令，包括所有参数。\n    \n\n### 示例解析\n\n假设你运行 `ps -aux` 看到以下一行输出：\n\n```bash\nroot      1234  0.0  0.1 23456 1234 ?        S    Sep01  0:05 /usr/sbin/sshd -D\n```\n\n- **USER**：`root` 用户。\n    \n- **PID**：进程 ID 是 `1234`。\n    \n- **%CPU**：CPU 占用率是 `0.0%`。\n    \n- **%MEM**：内存占用率是 `0.1%`。\n    \n- **VSZ**：虚拟内存大小是 `23456 KB`。\n    \n- **RSS**：物理内存大小是 `1234 KB`。\n    \n- **TTY**：`?`，表示没有关联的终端。\n    \n- **STAT**：`S`，表示进程处于可中断的睡眠状态。\n    \n- **START**：启动时间是 `Sep01`。\n    \n- **TIME**：总 CPU 时间是 `0:05`（5秒）。\n    \n- **COMMAND**：完整的命令是 `/usr/sbin/sshd -D`，这是一个 SSH 服务守护进程。\n    \n\n通过这些信息，你可以快速了解一个进程是由谁运行的、它消耗了多少资源、处于什么状态，以及它是什么程序。这对于系统监控和故障排除非常有帮助。","tags":["Linux","内核","进程"],"categories":["Linux","内核编程"]},{"title":"Linux C标准IO操作","url":"/posts/45385/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n# 📌 C 标准库 I/O 函数（基于 `<stdio.h>`）\n\n## 1. 打开和关闭文件\n\n```c\n#include <stdio.h>  \nFILE *fopen(const char *filename, const char *mode); \nint fclose(FILE *stream);\n```\n\n- **fopen 参数 mode 常用值：**\n    \n    - `\"r\"`：只读（文件必须存在）\n        \n    - `\"w\"`：只写（不存在则创建，存在则清空）\n        \n    - `\"a\"`：追加写（不存在则创建）\n        \n    - `\"r+\"`：读写（必须存在）\n        \n    - `\"w+\"`：读写（不存在则创建，存在则清空）\n        \n    - `\"a+\"`：读写（追加模式）\n        \n\n---\n\n## 2. 读写字符\n\n```c\nint fgetc(FILE *stream);     // 读取一个字符\nint fputc(int c, FILE *stream);  // 写入一个字符\n```\n\n示例：\n\n```c\nchar c = fgetc(fp);\nfputc('A', fp);\n```\n\n---\n\n## 3. 读写字符串\n\n```c\nchar *fgets(char *s, int size, FILE *stream); // 读取一行（最多 size-1 个字符） \nint fputs(const char *s, FILE *stream);       // 写入字符串\n```\n\n示例：\n\n```c\nchar buf[100]; fgets(buf, sizeof(buf), fp); \nfputs(\"Hello\\n\", fp);\n```\n\n---\n\n## 4. 格式化 I/O\n\n```c\nint fprintf(FILE *stream, const char *format, ...);  // 格式化输出到文件 \nint fscanf(FILE *stream, const char *format, ...);   // 格式化读取\n```\n\n示例：\n\n```c\nfprintf(fp, \"name=%s age=%d\\n\", \"Tom\", 20); \nfscanf(fp, \"%s %d\", name, &age);\n```\n\n---\n\n## 5. 块读写（适合二进制文件）\n\n```c\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); \nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n```\n\n示例：\n\n```c\nint data[10]; fwrite(data, sizeof(int), 10, fp); // 写10个整数 \nfread(data, sizeof(int), 10, fp);  // 读10个整数\n```\n\n---\n\n## 6. 文件定位\n\n```c\nint fseek(FILE *stream, long offset, int whence);  // 移动文件指针\nlong ftell(FILE *stream);                         // 获取当前位置 \nvoid rewind(FILE *stream);                        // 回到开头`\n```\n\n`whence` 可取：\n\n- `SEEK_SET`：文件开头\n    \n- `SEEK_CUR`：当前位置\n    \n- `SEEK_END`：文件末尾\n    \n\n---\n\n## 7. 缓冲刷新\n\n```c\nint fflush(FILE *stream);  // 强制把缓冲区写入文件\n```\n\n常用于写日志，避免异常退出时丢数据。\n","tags":["Linux","IO","内核"],"categories":["Linux","内核编程"]},{"title":"Linux 系统IO编程","url":"/posts/7076/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 文件描述符：内核分发的身份证\n\n在 Linux 系统中，**文件描述符（File Descriptor，简称 FD）是一个核心概念，它是一个非负整数**，用于唯一标识一个已打开的文件。这个文件可以是普通文件、目录、网络套接字（socket），甚至是设备（如键盘、显示器）。\n\n文件描述符的设计主要有以下几个优点：\n\n1. **简化了 I/O 接口**：无论是读写本地文件，还是进行网络通信，开发者都可以使用一套统一的系统调用（`read`, `write`, `close` 等），而无需关心底层的具体类型。这种“一切皆文件”的设计哲学是 Linux 简洁和强大的体现。\n    \n2. **隔离了应用程序与内核**：应用程序只知道一个简单的整数，而不需要知道文件在磁盘上的物理位置，也不用关心内核是如何管理文件的。所有复杂的操作都由内核在幕后完成。\n    \n3. **管理系统资源**：内核通过文件描述符表来管理每个进程打开的文件。当一个进程结束时，内核可以根据这个表自动关闭所有打开的文件，避免资源泄露。\n\n文件描述符的几个重要特点：\n\n- **唯一性**：在一个进程中，每个打开的文件都有一个独一无二的文件描述符。\n\n- **非负整数**：文件描述符的值通常从 3 开始分配，因为 0、1、2 这三个描述符被系统预留给标准输入、标准输出和标准错误。\n    \n    - **0**：标准输入（`stdin`），通常是键盘。\n        \n    - **1**：标准输出（`stdout`），通常是显示器。\n        \n    - **2**：标准错误（`stderr`），也通常是显示器。\n        \n- **进程私有**：文件描述符是在进程内部使用的，不同进程的文件描述符互不影响。例如，进程 A 的文件描述符 3 和进程 B 的文件描述符 3 可能指向完全不同的文件。\n\n## 最基础的系统调用函数\n\n **Linux I/O 编程中常见的系统调用函数**，这些函数位于 **`unistd.h`**（以及 `fcntl.h` 等）中，是用户态和内核态交互的基础接口。\n\n### 1. `open`\n\n```c\n#include <fcntl.h>    // open flags\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nint open(const char *pathname, int flags);\nint open(const char *pathname, int flags, mode_t mode);\n```\n\n#### 作用\n\n打开或创建一个文件，返回一个 **文件描述符**（fd，整数），后续 I/O 都依赖它。\n#### 参数\n\n- `pathname`：文件路径。\n    \n- `flags`：打开方式，常用值：\n    \n    - `O_RDONLY`：只读\n        \n    - `O_WRONLY`：只写\n        \n    - `O_RDWR`：读写\n        \n    - `O_CREAT`：若文件不存在则创建，需要配合 `mode` 参数\n        \n    - `O_TRUNC`：打开时清空文件\n        \n    - `O_APPEND`：写时追加到文件尾部\n\n\t- `O_NOBLOCK`：非阻塞模式\n        \n- `mode`：创建文件时的权限（如 `0666`，受 umask 影响）。\n#### 返回值\n\n- 成功：文件描述符（非负整数）\n    \n- 失败：`-1`，并设置 `errno`\n\n---\n\n### 2. `write`\n\n```c\n#include <unistd.h>\n\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n#### 作用\n\n向文件（或设备）写入数据。\n#### 参数\n\n- `fd`：文件描述符\n    \n- `buf`：要写入的数据缓冲区指针\n    \n- `count`：要写入的字节数\n#### 返回值\n\n- 成功：实际写入的字节数（可能小于 `count`）\n    \n- 失败：`-1`\n#### 注意\n\n- 对于普通文件，通常会写入全部数据。\n    \n- 对于管道、socket 等，可能分多次写入，需要循环写。\n\n---\n\n### 3. `read`\n\n```c\n#include <unistd.h>\n  \nssize_t read(int fd, void *buf, size_t count);\n```\n#### 作用\n\n从文件（或设备）读取数据。\n#### 参数\n\n- `fd`：文件描述符\n    \n- `buf`：存放读出数据的缓冲区\n    \n- `count`：最大读取字节数\n#### 返回值\n\n- 成功：实际读取的字节数\n    \n    - `0` 表示到达文件结尾 (EOF)\n        \n- 失败：`-1`\n#### 注意\n\n- 实际读取字节数可能小于 `count`。\n    \n- 对于阻塞 I/O，如果没有数据，可能会挂起等待。\n\n---\n\n### 4. `lseek`\n\n```c\n#include <unistd.h>  \n\noff_t lseek(int fd, off_t offset, int whence);\n```\n\n#### 作用\n\n移动文件读写位置（文件指针）。\n#### 参数\n\n- `fd`：文件描述符\n    \n- `offset`：偏移量（可正可负）\n    \n- `whence`：偏移起始点\n    \n    - `SEEK_SET`：从文件开头\n        \n    - `SEEK_CUR`：从当前位置\n        \n    - `SEEK_END`：从文件末尾\n#### 返回值\n\n- 成功：新的文件偏移位置\n    \n- 失败：`-1`\n#### 注意\n\n- 常用来实现随机读写。\n    \n- 对某些设备文件可能不支持（如管道）。\n    \n\n---\n\n### 5. `close`\n\n```c\n#include <unistd.h>\n\nint close(int fd);\n```\n\n#### 作用\n\n关闭一个打开的文件描述符，释放内核资源。\n#### 参数\n\n- `fd`：文件描述符\n#### 返回值\n\n- 成功：`0`\n    \n- 失败：`-1`\n\n## 常见函数查找表\n\n| 函数      | 头文件                       | 功能                      | 主要参数                                                                        | 返回值                       | 常见用途                |\n| ------- | ------------------------- | ----------------------- | --------------------------------------------------------------------------- | ------------------------- | ------------------- |\n| `open`  | `<fcntl.h>`, `<unistd.h>` | 打开或创建文件，返回文件描述符         | `pathname`：路径`flags`：打开方式（如 `O_RDONLY`）`mode`：权限（如 `0644`，仅在 `O_CREAT` 时有效） | 成功：文件描述符 (≥0)失败：`-1`      | 打开文件/设备，获得 `fd`     |\n| `write` | `<unistd.h>`              | 向文件写入数据                 | `fd`：文件描述符`buf`：数据缓冲区`count`：要写入字节数                                         | 成功：实际写入字节数失败：`-1`         | 向文件、管道、socket 写数据   |\n| `read`  | `<unistd.h>`              | 从文件读取数据                 | `fd`：文件描述符`buf`：存放数据的缓冲区`count`：最大读取字节数                                     | 成功：实际读取字节数`0`：文件结尾失败：`-1` | 读取文件、键盘输入、网络数据      |\n| `lseek` | `<unistd.h>`              | 改变文件读写位置（文件指针）          | `fd`：文件描述符`offset`：偏移量`whence`：参考位置（`SEEK_SET`/`SEEK_CUR`/`SEEK_END`）       | 成功：新的偏移位置失败：`-1`          | 随机读写文件、获取文件大小       |\n| `close` | `<unistd.h>`              | 关闭文件描述符，释放资源            | `fd`：文件描述符                                                                  | 成功：`0`失败：`-1`             | 程序结束或文件不再使用时关闭      |\n| `sync`  | `<unistd.h>`              | 将内核缓冲区中所有修改过的数据（脏页）写入磁盘 | 无                                                                           | 无返回值                      | 全局刷新，影响所有文件，效率较低    |\n| `fsync` | `<unistd.h>`              | 将指定文件的缓存数据强制写入磁盘        | `fd`：文件描述符                                                                  | 成功：`0`，失败：`-1`            | 精确到单个文件，常用于数据库、日志写入 |\n|`pipe`   | `<unistd.h>`               |创建匿名管道，用于进程间通信|`int pipefd[2]`|成功：0，失败：-1|`pipefd[0]` 读端，`pipefd[1]` 写端|\n|`unlink` | `<unistd.h>`               |删除一个文件（目录用 `rmdir`）|`pathname`：文件路径|成功：0，失败：-1|实际删除在引用计数归零时发生|\n|`access` | `<unistd.h>`               |  检查文件是否存在及权限      |`pathname, mode`|成功：0，失败：-1 | `mode` 可取 `R_OK, W_OK, X_OK, F_OK`|\n\n\n## 对比C 标准库IO操作\n\n使用c标准库的IO操作，小量频繁读写的效率更高，因为其内部自带有缓冲区。\n这可以理解为在系统IO上有封装了一层，进行文件操作时写入C自带缓冲区，满足一定条件再调用系统IO，将缓冲区的内容写入IO缓存区，再到内核的页缓存区，最后到物理的磁盘。\n\n| 特性       | Linux 系统调用 I/O                            | C 标准库文件操作                                                          |\n| -------- | ----------------------------------------- | ------------------------------------------------------------------ |\n| **头文件**  | `<unistd.h>`, `<fcntl.h>`                 | `<stdio.h>`                                                        |\n| **函数示例** | `open`, `read`, `write`, `lseek`, `close` | `fopen`, `fread`, `fwrite`, `fseek`, `fclose`, `fprintf`, `fscanf` |\n| **返回值**  | 直接返回字节数、文件描述符等，或 `-1`                     | 返回 `FILE*` 指针，或 `EOF` 等错误码                                         |\n| **数据单位** | 以 **字节（byte）** 为单位                        | 以 **缓冲区 / 结构化数据** 为单位（有缓冲机制）                                       |\n| **缓冲**   | **无用户态缓冲**，直接在用户空间和内核空间间传递数据              | **带缓冲区**（stdio 库内部维护缓存，加速小块读写）                                     |\n| **层次**   | 操作系统内核提供的 **底层接口**                        | 基于系统调用的 **封装库函数**                                                  |\n| **灵活性**  | 可操作普通文件、设备文件、socket、管道                    | 主要操作普通文件和标准输入输出                                                    |\n| **可移植性** | 偏向 Unix/Linux 系统                          | 跨平台（符合 ANSI C 标准，Windows/Linux 通用）                                 |\n| **典型用途** | 驱动开发、系统编程、精确控制 I/O                        | 应用层文件读写、文本处理、快速开发                                                  |\n\n\n","tags":["Linux","IO","内核"],"categories":["Linux","内核编程"]},{"title":"MakeFile简明指南","url":"/posts/4341/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n在软件开发中，项目通常包含很多源文件，如果每次编译都手动敲命令，不仅繁琐，还容易出错。  \n**Makefile** 可以帮助我们自动化构建流程，大幅提升效率。本文将介绍 Makefile 的基础语法与常用用法。\n\n---\n\n- [1. 基础用法](#1-基础用法)\n- [2. 执行逻辑^1](#2-执行逻辑1)\n  - [2.1. 🔄 执行流程示意图](#21--执行流程示意图)\n- [3. 伪目标 .PHONY](#3-伪目标-phony)\n- [4. 变量](#4-变量)\n  - [4.1. 赋值符号](#41-赋值符号)\n- [5. 隐含规则与通配符](#5-隐含规则与通配符)\n- [6. 条件分支](#6-条件分支)\n  - [6.1. 语法](#61-语法)\n  - [6.2. 示例一：根据平台选择clean执行方式](#62-示例一根据平台选择clean执行方式)\n  - [6.3. 示例二：调试模式与发布模式](#63-示例二调试模式与发布模式)\n- [7. 函数](#7-函数)\n  - [7.1. `subst` —— 字符串替换](#71-subst--字符串替换)\n  - [7.2. `patsubst` —— 模式替换](#72-patsubst--模式替换)\n  - [7.3. `wildcard` —— 获取文件列表](#73-wildcard--获取文件列表)\n  - [7.4. `notdir` —— 去掉路径，只保留文件名](#74-notdir--去掉路径只保留文件名)\n  - [7.5. `dir` —— 获取路径部分](#75-dir--获取路径部分)\n  - [7.6. `basename` 、 `addsuffix` 和 `addprefix` —— 批量处理文件名](#76-basename--addsuffix-和-addprefix--批量处理文件名)\n  - [7.7. `shell` —— 执行 shell 命令](#77-shell--执行-shell-命令)\n- [8. 完整示例程序](#8-完整示例程序)\n\n\n## 1. 基础用法\n\n一个典型的规则格式如下：\n\n```make\ntarget: dependencies\n<TAB> command\n```\n\n- target：目标文件，比如可执行文件或中间文件。\n- dependencies：依赖文件（源文件、头文件等）。\n- command：生成目标所需要执行的命令（必须以 TAB 缩进 开头）。\n\n示例：\n```make\nmain.o: main.c\n\tgcc -c main.c -o main.o\n```\n\n!!! warning\n    由于makfile对空格、tab极其敏感，建议编写时打开编辑器的空格、tab显示，并避免不必要的空格，规范化书写。\n\n\n## 2. 执行逻辑[^1]\n\n当我们执行 `make` 时，大致流程如下：\n\n1. **解析 Makefile**\n   - `make` 会从当前目录寻找 `Makefile` 或 `makefile` 文件。\n   - 读取其中的规则、变量、伪目标等定义。\n\n2. **确定默认目标**\n   - 一般是文件中的第一个目标（例如 `app`）。\n   - 也可以通过命令行指定，例如：  \n```bash\nmake clean\n```\n\n3. **检查依赖关系**\n   - 从目标开始，逐层检查依赖文件是否存在、是否比目标文件更新。\n   - 如果依赖文件比目标文件“新”，说明目标需要重新生成。\n\n4. **执行命令**\n   - 对需要更新的目标，执行其规则中定义的命令。\n   - 命令必须以 **TAB 缩进** 开头。\n\n5. **递归构建**\n   - 如果依赖文件本身也是其他规则的目标，则会递归检查和执行。\n   - 直到所有依赖满足，才最终生成目标。\n\n6. **结束**\n   - 如果所有目标都已是最新，则 `make` 会提示：\n```\nmake: 'app' is up to date.\n```\n\n### 2.1. 🔄 执行流程示意图\n\n```text\n          make\n           │\n           ▼\n   读取并解析 Makefile\n           │\n           ▼\n   确定要构建的目标 (默认/指定)\n           │\n           ▼\n   检查目标的依赖文件\n           │\n    ┌──────┴────────┐\n    │               │\n依赖比目标旧      依赖比目标新/不存在\n    │               │\n目标已是最新    执行规则命令 → 生成新目标\n```\n\n!!! info \"tips\"\n    可以使用 make -f [makefile_name] 指定使用某个makefile文件。\n    \n    \n## 3. 伪目标 .PHONY\n\n有些目标不是实际文件，而只是一个操作，例如 `clean`。  \n这时建议使用 **.PHONY** 声明：\n\n```make\n.PHONY: clean  \nclean:  \n\trm -r  [filepath]\n```\n指定make目标文件：\n```make\nmake clean\n```\n\n## 4. 变量\n\nMakefile 支持变量，常用于保存编译器或编译选项。\n使用示例如下：\n```make\nCC = gcc\nCFLAGS = -Wall -g\n\napp: main.o utils.o\n\t$(CC) $(CFLAGS) main.o utils.o -o app\n\nmain.o: main.c\n\t$(CC) $(CFLAGS) -c main.c -o main.o\n\nutils.o: utils.c\n\t$(CC) $(CFLAGS) -c utils.c -o utils.o\n```\n\n### 4.1. 赋值符号\n\n- **=** \n\t我称之为最终赋值，同一个变量无论被赋值多次，永远取最后指定的值。\n示例：\n```make\nVIR_A = A\nVIR_B = $(VIR_A) B\nVIR_A = AA\n```\n最后VIR_B的值是AA B。\n- **:=**\n\t立即赋值，正常逻辑的赋值号，类似于c语言的赋值号。\n- **?=**\n\t如果变量在之前没有被赋值则赋值。\n\t可以理解为\n\t```\n\t#ifndef\n\t#define ...\n\t#endif\n\t```\n- **+=**\n\t追加赋值，将值追加到变量中。\n\n## 5. 隐含规则与通配符\n\nMake 内置了一些规则，可以用简写方式：\n- `$@`：目标文件名\n- `$<`：第一个依赖文件\n- `$^`：所有依赖文件\n\n`%` 表示可以匹配任意长度的字符串，用于定义一类文件的生成规则。例如：\n```make\n%.o: %.c     \n\tgcc -c $< -o $@\n```\n- 含义：\n    - `%.o` 表示所有以 `.o` 结尾的目标文件。\n    - `%.c` 表示所有以 `.c` 结尾的源文件。\n    - `$<` 是第一个依赖文件（这里是 `.c` 文件）。\n    - `$@` 是目标文件（这里是 `.o` 文件）。\n- 作用：这条规则表示，所有 `.c` 文件可以通过编译生成对应的 `.o` 文件。\n\n---\n\n`%` 可以匹配文件名的某一部分，用于简化规则。例如：\n```\nbuild/%: src/%     \n\tcp $< $@\n```\n- 含义：\n    - `build/%` 表示目标文件在 `build/` 目录下。\n    - `src/%` 表示依赖文件在 `src/` 目录下。\n    - `$<` 是依赖文件，`$@` 是目标文件。\n- 作用：这条规则表示，将 `src/` 目录下的文件复制到 `build/` 目录下。\n\n---\n\n在模式规则中，`%` 可以用于定义多个目标。例如：\n```\n%.a: %.b %.c     \n\tcat $^ > $@`\n```\n- 含义：\n    - `%.a` 是目标文件。\n    - `%.b` 和 `%.c` 是依赖文件。\n    - `$^` 表示所有依赖文件，`$@` 是目标文件。\n- 作用：这条规则表示，将 `.b` 和 `.c` 文件合并生成 `.a` 文件。\n\n---\n\n## 6. 条件分支\n\n在 Makefile 中，我们可以使用条件语句来根据不同情况执行不同规则或定义变量。常见的有 `ifeq`、`ifneq`、`ifdef`、`ifndef`。\n### 6.1. 语法\n```make\nifeq (条件1, 条件2)\n    # 当 条件1 == 条件2 时执行这里\nelse\n    # 否则执行这里\nendif\n\nifneq (条件1, 条件2)\n    # 当 条件1 != 条件2 时执行这里\nendif\n\nifdef 变量名\n    # 当变量已定义时执行这里\nendif\n\nifndef 变量名\n    # 当变量未定义时执行这里\nendif\n```\n\n### 6.2. 示例一：根据平台选择clean执行方式\n```make\n# 默认变量\nCC = gcc\n\n# 判断系统\nifeq ($(OS), Windows_NT)\n    RM = del\nelse\n    RM = rm -f\nendif\n\napp: main.o\n\t$(CC) main.o -o app\n\nclean:\n\t$(RM) *.o app\n```\n\n### 6.3. 示例二：调试模式与发布模式\n```make\n# 设置编译选项\nCFLAGS = -Wall\n\nifeq ($(MODE), debug)\n    CFLAGS += -g\nelse\n    CFLAGS += -O2\nendif\n\napp: main.o\n\t$(CC) $(CFLAGS) main.o -o app\n```\n使用方式：\n```bash\nmake MODE=debug   # 调试模式，带调试信息\nmake MODE=release # 默认优化模式\n```\n\n## 7. 函数\n\nMakefile 内置了许多函数，用来处理字符串、文件名、路径等。  \n常见函数格式为：\n\n```make\n$(函数名 参数1 参数2 ...)\n```\n\n下面介绍一些**常用函数**\n\n### 7.1. `subst` —— 字符串替换\n\n```make\n$(subst from,to,text)\n```\n\n- 功能：将 `text` 中的 `from` 替换为 `to`。\n    \n- 示例：\n\n```\nSRC = main.c utils.c \nOBJ = $(subst .c,.o,$(SRC)) \n\n# 结果：OBJ = main.o utils.o\n```\n\n---\n\n### 7.2. `patsubst` —— 模式替换\n\n```make\n$(patsubst pattern,replacement,text)\n```\n\n- 功能：更灵活的字符串替换，支持通配符 `%`。\n    \n- 示例：\n```make\nSRC = main.c utils.c test.c\nOBJ = $(patsubst %.c,%.o,$(SRC))\n\n# 结果：OBJ = main.o utils.o test.o\n```\n\n---\n\n### 7.3. `wildcard` —— 获取文件列表\n\n```make\n$(wildcard pattern)\n```\n\n- 功能：匹配符合模式的文件。\n    \n- 示例：\n```make\nSRC = $(wildcard *.c)\n# 结果：SRC = 当前目录下所有 .c 文件\n```\n\n---\n\n### 7.4. `notdir` —— 去掉路径，只保留文件名\n\n```make\nFILES = src/main.c src/utils.c\nNAMES = $(notdir $(FILES))\n# 结果：NAMES = main.c utils.c\n```\n---\n\n### 7.5. `dir` —— 获取路径部分\n\n```make\nFILES = src/main.c src/utils.c\nPATHS = $(dir $(FILES))\n# 结果：PATHS = src/ src/\n```\n\n---\n\n### 7.6. `basename` 、 `addsuffix` 和 `addprefix` —— 批量处理文件名\n\n```make\nFILES = main.c utils.c\n\n# 去掉后缀\nNAMES = $(basename $(FILES))\n# NAMES = main utils\n\n# 批量添加后缀\nOBJS = $(addsuffix .o,$(NAMES))\n# OBJS = main.o utils.o\n\n# 批量添加前缀\nOBJS = $(addprefix -I,$(NAMES))\n# OBJS = -Imain -Iutils\n```\n\n---\n\n### 7.7. `shell` —— 执行 shell 命令\n\n```make\nDATE = $(shell date +%Y-%m-%d)\n```\n\n这样可以在 Makefile 中直接使用系统命令的输出。\n\n## 8. 完整示例程序\n\n这是一个完整Makefile示例程序，用于将c语言程序编译为可执行的二进制bin文件。它可以制成镜像供SoC烧录。\n\n```make\n#0###########################################################\n\n# 设置目录变量，方便统一管理和修改\n# 当前根目录:\nROOT_DIR := .\n\n# 中间目标文件（.o）输出目录:\nBUILD_DIR := build\n\n# 最终生成的二进制文件（.bin）目录:\nBIN_DIR := bin\n\n# 工程名\nNAME := key\n\n# 指定链接脚本\nLDS = imx.lds\n\n#############################################################\n\n#1###########################################################\n\n# 自动查找 src/ 目录下的所有 .c 文件\nSRCS = $(shell find $(ROOT_DIR) -name \"*.c\")\n\n# 将 SRC中的 xxx.c 转换为 build/xxx.o\n# 同时添加 build/startup.o（汇编启动文件）\nOBJS = $(BUILD_DIR)/startup.o\nOBJS += $(patsubst %.c,$(BUILD_DIR)/%.o,$(SRCS))\n\n# 自动查找所有包含头文件的目录\nINC_DIRS = $(shell find $(ROOT_DIR) -type f -name \"*.h\" -exec dirname {} \\; | sort -u)\nINCLUDES = $(addprefix -I, $(INC_DIRS))\n\n#############################################################\n\n#2###########################################################\n\n# 设置编译工具（使用 ARM 的交叉编译工具链）\nCC := arm-none-eabi-\n\n# 编译器（用于 .c 和 .S 文件）:\nGCC := $(CC)gcc\n\n# 链接器:\nLD := $(CC)ld\n\n# 用于将 elf 转为 bin 格式:\nOBJCOPY := $(CC)objcopy\n\n# 用于反汇编\nOBJDUMP := $(CC)objdump\n\n# 编译选项（GCC 编译阶段）\n# -I：指定头文件搜索目录\n# -Wall：打开所有警告\n# -O2：优化等级 2（推荐用于 release）\n# -nostdlib：不链接标准库（适用于裸机）\n# -c：只编译，不链接\nGCC_FLAGS = $(INCLUDES) -Wall -nostdlib -c\n\n# 链接器选项\nLD_FLAGS = -T$(LDS)\n\n# 使用 objdump 工具对生成的 ELF 文件进行反汇编\n# -D：反汇编所有节（包括代码段、启动代码等）\n# -m arm：指定目标架构为 ARM\n# .elf：输入的可执行文件\n# > .dis：将反汇编结果输出为 .dis 文本文件\nOBJDUMP_FLAGS = -D -m arm $(BUILD_DIR)/$(NAME).elf > $(BUILD_DIR)/$(NAME).dis\n\n#############################################################\n\n#3###########################################################\n\n# 目标：生成最终的二进制文件 bin/$(NAME).bin\n$(BIN_DIR)/$(NAME).bin: $(OBJS)\n\t# 链接所有 .o 文件生成 elf 格式可执行文件\n    $(LD) $(LD_FLAGS) $(OBJS) -o $(BUILD_DIR)/$(NAME).elf\n\t# 反汇编 调试用\n    $(OBJDUMP) $(OBJDUMP_FLAGS)\n\t# 把 elf 文件转换为裸机二进制文件（无符号、无头信息）\n    $(OBJCOPY) -O binary -S $(BUILD_DIR)/$(NAME).elf $@\n \n# 编译汇编启动文件 startup.S，生成 build/startup.o\n$(BUILD_DIR)/startup.o: startup.S\n\t# 注意 startup.S 是汇编文件，用 gcc 编译也可以，默认会调用汇编器\n    $(GCC) $(GCC_FLAGS) $< -o $@\n\n# 编译每个 .c 文件到 build/xxx.o\n# $@：目标文件（例如 build/main.o）\n# $<：依赖的源文件（例如 src/main.c）\n$(BUILD_DIR)/%.o: %.c\n\t# 修复由于没有文件夹报错\n    mkdir -p $(dir $@)\n    $(GCC) $(GCC_FLAGS) -c $< -o $@\n\n#############################################################\n\n.PHONY: clean\nclean:\n    rm -r $(BUILD_DIR)/* $(BIN_DIR)/*\n```\n\n一个更通用的模板\n```make\n# 通用 Makefile 模板\n\n# 1. 编译器及选项\nCC      := gcc             # C 编译器 (可改成 g++)\nCFLAGS  := -Wall -O2       # 编译参数\nLDFLAGS :=                 # 链接参数 (库路径)\nLDLIBS  := -lm             # 依赖的库 (-lpthread, -lrt 等)\n\n# 2. 目录结构\nSRC_DIR := src             # 源码目录\nOBJ_DIR := build           # 目标文件目录\nBIN_DIR := bin             # 可执行文件目录\n\n# 3. 自动收集源文件\nSRCS := $(wildcard $(SRC_DIR)/*.c)\nOBJS := $(patsubst $(SRC_DIR)/%.c,$(OBJ_DIR)/%.o,$(SRCS))\nTARGET := $(BIN_DIR)/app   # 生成的可执行文件名\n\n# 4. 默认目标\nall: $(TARGET)\n\n# 5. 链接规则\n$(TARGET): $(OBJS) | $(BIN_DIR)\n\t$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)\n\n# 6. 编译规则\n$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n# 7. 目录生成\n$(OBJ_DIR) $(BIN_DIR):\n\tmkdir -p $@\n\n# 8. 清理\n.PHONY: clean run\nclean:\n\trm -rf $(OBJ_DIR) $(BIN_DIR)\n\n# 9. 运行 (可选)\nrun: all\n\t./$(TARGET)\n\n```\n\n[^1]: 仅作了解\n\n","tags":["MakeFile"],"categories":["Linux","项目管理"]},{"title":"交叉编译器相关知识梳理","url":"/posts/27939/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n</details>\n\n---\n\n\n\n"},{"title":"关于Linux开发板与上位机的连接方式","url":"/posts/32814/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n</details>\n\n---\n\n\n\n>本文旨在记录自己的IMX6ULL开发板上位机连接的过程。~~为什么感觉是后端这一块呢？~~\n\n## 1. 前提条件\n\n\n>- 装有Debian/Ubuntu系统的、安装了ssh服务的、带有网络设备及驱动的开发板\n>- MobaXterm工具\n>- 目前使用的上位机是Win11平台，后续再研究Linux平台。\n\n\n\n## 2. 基本操作\n\n### 2.1. 查询设备网络连接状态及ip地址\n`ifconfig` 命令\n\n### 2.2. 连接测试\n`ping` 命令\n\n### 2.3. 动态分配ip/主动申请ip地址\n```bash\nudhcpc -i eth0\n```\n\n**`udhcpc`**\n- 全称是 _Micro DHCP Client_，是 BusyBox 提供的一个轻量级 DHCP 客户端工具。\n- 它会向局域网里的 DHCP 服务器（比如路由器、主机上的 Internet Connection Sharing 服务）发送请求，请求一个 IP 地址。\n\n**`-i eth0`**\n- 指定要使用的网络接口，这里是 `eth0`（开发板上的以太网网卡）。\n- 如果你用的是其他网卡（比如 `eth1` 或 `enp0s3`），需要改成对应名字。\n\n成功的话，它会显示类似：\n```bash\nudhcpc: sending discover\nudhcpc: sending select for 192.168.137.2\nudhcpc: lease of 192.168.137.2 obtained, lease time 86400\n```\n这表示网卡已经从 DHCP 服务器那里拿到了 IP（这里是 `192.168.137.2`）。如果没有 DHCP 服务器响应，就会一直 `sending discover`，说明没有可分配 IP。\n\n### 2.4. 手动设置设备ip地址\n\n```bash\nifconfig eth0 192.168.10.2 netmask 255.255.255.0 up\n```\n\n`up` 指启用\n\n### 2.5. 查询ssh是否开启\n\n```bash\nsudo systemctl status ssh\n```\n\n### 2.6. 开启ssh服务\n\n```bash\nsystemctl start ssh\n```\n或\n```bash\n/etc/init.d/ssh start\n```\n\n### 2.7. ssh远程连接\n\n```bash\nssh [username]@[ip-addr/hostname]\n```\n\n### 2.8. 通过MobaXterm连接\n填好即可。\n![](Snipaste_2025-09-07_19-20-07.png)\n\n`hostname` 可以输入同名指令查看。\n\n## 3. 方式一：无线网络连接\n\n>\"优点\"：无线通信。\n\"缺点\"：延迟可能较高。\n\n\n### 3.1. 同一网络下\n\n在同一网段下（连接同一个WIFI），通过ssh建立连接。简简单单。\n\n### 3.2. 不同网络下\n\n>待补充。\n\n## 4. 方式二：通过网线与Win电脑连接\n\n>\"优点\"：延迟低。\n\"缺点\"：有线通信。\n\n### 4.1. 点对点通信（无需共享电脑网络）\n\n>\"优点\"：操作简单。\n\"缺点\"：开发板不能共享电脑网络。\n\n将开发板网口和电脑网口用网线连接，进入电脑`网络和Internet`设置，选择`以太网`\n\nip分配改为手动，ip地址可以分配为`192.168.10.1`\n掩码为`255.255.255.0`\n![](Snipaste_2025-09-07_19-29-57.png)\n\n开发板端同样指定ip地址和掩码，须在同一网段，例如`192.168.10.7` 。这样两个设备就能互相找到了。\n再在电脑上进行ping测试。能ping通用ssh/MobaXterm连接即可。\n\n### 4.2. 点对点通信并共享电脑网络（电脑成网关）\n\n>\"优点\"：开发板不仅可以与电脑建立通信，还能共享电脑网络。\n\"缺点\"：操作较复杂。\n\n电脑通过wifi连接网络，通过以太网接口连接开发板。\n在电脑控制面板>网络和Internet>网络和共享中心 右侧更改适配器设置，双击无线网卡设备（连接网络的那个设备）选择属性> 共享选项卡 勾选\n![](Snipaste_2025-09-07_19-41-42.png)\n\n提示：\n![](Snipaste_2025-09-07_19-41-53.png)\n\n意思是：当该功能被启用时，你的LAN口 ip地址 自动被设置为 `192.168.137.1`，要通过这个LAN口连接网络的设备需将自己ip地址设置为动态获取，也就是在开发板执行前面的动态获取ip地址的命令。\n\n当开发版成功获取到ip地址（见基本操作节 分配ip地址）后，则可以正常建立连接。","tags":["Linux","网络","通信"],"categories":["Linux","记录"]},{"title":"无聊随便打点字","url":"/posts/7593/","content":"\n---\n\n# 和时间赛跑 林清玄\n\n读小学的时候，我的外祖母去世了。外祖母生前最疼爱我。我无法排除自己的忧伤，每天在学校的操场上一圈一圈地跑着，跑得累倒在地上，扑在草坪上痛哭。\n\n那哀痛的日子持续了很久，爸爸妈妈也不知道如何安慰我。他们知道与其欺骗我说外祖母睡着了，还不如对我说实话：外祖母永远不会回来了。\n\n“什么是永远不会回来了呢？”我问。\n\n“所有时间里的事物，都永远不会回来了，你的昨天过去了，它就永远变成昨天，你再也不能回到昨天了。爸爸以前和你一样小，现在再也不能回到你这么小的童年了。有一天你会长大，你也会像外祖母一样老，有一天你度过了你的所有时间，也会像外祖母一样永远不能回来了。”爸爸说。\n\n爸爸等于给我说了一个谜，这个谜比“一寸光阴一寸金，寸金难买寸光阴”还让我感到可怕，比“光阴似箭，日月如梭”更让我有一种说不出的滋味。\n\n以后，我每天放学回家，在庭院时看着太阳一寸一寸地沉进了山头，就知道一天真的过完了。虽然明天还会有新的太阳，但永远不会有今天的太阳了。\n\n我看到鸟儿飞到天空，它们飞得多块呀。明天它们再飞过同样的路线，也永远不是今天了。或许明天飞过这条路线的，不是老鸟，而是小鸟了。\n\n时间过得飞快，使我的小心眼不只是着急，还有悲伤。有一天我放学回家，看到太阳快落山了，就下决心说：“我要比太阳更快地回家。”我狂奔回去，站在庭院里喘气的时候，看到太阳还露着半边脸，我高兴地跳起来。那一天我跑赢了太阳。以后我常做这样的游戏，有时和太阳赛跑，有时和西北风比赛，有时一个暑假的作业，我十天就做完了。那时我三年级，常把哥哥五年级的作业拿来做。每一次比赛胜过时间，我就快乐得不知道怎么形容。\n\n后来二十年里，我因此受益无穷。虽然我知道人永远跑不过时间，但是可以比原来跑快一步，如果加把劲，有时可以快好几步。那几步虽然很小很小，用途却很大很大。\n\n如果将来我有什么要教给孩子，我会告诉他：假若你一直和时间赛跑，你就可以成功。\n\n# 秋天的怀念 史铁生\n\n双腿瘫痪后，我的脾气变得暴怒无常。望着望着天上北归的雁阵，我会突然把面前的玻璃砸碎；听着听着李谷一甜美的歌声，我会猛地把手边的东西摔向四周的墙壁。母亲就悄悄地躲出去，在我看不见的地方偷偷地听着我的动静。当一切恢复沉寂，她又悄悄地进来，眼边红红的，看着我。“听说北海的花儿都开了，我推你去走走。”她总是这么说。母亲喜欢花，可自从我双腿瘫痪后，她侍弄的那些花都死了。“不，我不去！”我狠命地捶打这两条可恨的腿，喊着：“我活着有什么劲！”母亲扑过来抓住我的手，忍住哭声说：“咱娘儿俩在一块儿，好好儿活……”可我却一直都不知道，她的病已经到了那步田地。后来妹妹告诉我，她常常肝疼得整宿整宿翻来覆去地睡不了觉。\n\n那天我又独自坐在屋里，看着窗外的树叶“唰唰啦啦”地飘落。母亲进来了，挡在窗前：“北海地菊花开了，我推着你去看看吧。”她憔悴的脸上现出央求般的神色。“什么时候？”你要是愿意，就明天？“她说。我的回答已经让她喜出望外了。”好吧，就明天。“我说。她高兴得一会坐下，一会站起：”那就赶紧准备准备。“”唉呀，烦不烦？几步路，有什么好准备的！“她也笑了，坐在我身边，絮絮叨叨地说着”看完菊花，咱们就去‘仿膳’，你小时候最爱吃那儿的豌豆黄儿。还记得那回我带你去北海吗？你偏说那杨树花是毛毛虫，跑着，一脚踩扁一个……“她忽然不说了。对于”跑“和”踩“一类的字眼儿。她比我还敏感。她又悄悄出去了。\n\n她出去了。就再也没回来。\n\n邻居们把她抬到车上时，她还在大口大口地吐着鲜血。我没想到她已经病成那样。看着三轮车远去，也绝没有想到那竟是永远的诀别。\n\n邻居的小伙子背着我去看她的时候，她正艰难地呼吸着，像她那一生艰难的生活。别人告诉我，他昏迷前的最后一句话是：”我那个有病的儿子和我那个未成年的女儿……“\n\n又是秋天，妹妹推着我去北海看了菊花。黄色的花淡雅、白色的花高洁、紫红色的花热烈而深沉，泼泼洒洒，秋风中正开的烂漫。我懂得母亲没有说完的话，妹妹也懂。我俩在一块儿，要好好儿活……","categories":["其他"]},{"title":"I-MX6ULL的中断实验（下）","url":"/posts/33465/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## C语言下中断模块\n\n### 核心思路：\n每个中断对象包含：1个中断处理函数和需要传入的参数——一个函数指针+一个未定义类型指针。所以将中断对象打包成一个结构体：\n```c\n/* 定义中断处理函数原型 */\ntypedef void (*sys_irq_handler_t)(unsigned int id, void *para);\n\n/* 定义中断函数结构体 */\ntypedef struct _sys_irq_handle{\n    sys_irq_handler_t irqHandler;\n    void* usrPara;\n}sys_irq_handle_t;\n```\n\n指定一个默认中断处理函数：\n```c\n/* 定义默认中断处理函数 */\nstatic void default_irqHandler(unsigned int id, void *para){\n    while(1);\n}\n```\n\n将所有中断对象归入一个表中，按中断id索引：\n```c\n#define NUM_OF_IT_VECTORS 160\nstatic sys_irq_handle_t irqTable[NUM_OF_IT_VECTORS];\n```\n\n后续可能涉及到中断嵌套，因此定义一个中断嵌套计数器：\n```c\nstatic unsigned int irqNesting; //中断嵌套计数器\n```\n\n初始化中断对象表：\n```c\n/* 初始化中断处理表 */\nstatic void sys_iqrTable_init(void){\n    unsigned char i = 0;\n    irqNesting = 0; //中断嵌套计数器\n    for(i = 0; i< NUM_OF_IT_VECTORS; i++){\n        irqTable[i].irqHandler = default_irqHandler;\n        irqTable[i].usrPara = NULL;\n    }\n}\n```\n\n在上一节中，我们实现了当进入中断时跳入一个名为`system_irqhandler`的函数处理中断。因此我们需要定义该函数：\n```c\n/// @brief 中断处理函数\n/// @param gicciar 寄存器gicciar的值\n/// @note 进入irq中断后自动调用\nvoid system_irqhandler(unsigned int gicciar){ \n    uint32_t id = gicciar & 0x3ff; //从gicciar寄存器中读取中断id号（0~9位 故& 0x3ff）\n    /* 安全检查 */\n    if(id == 1023 || id >= NUM_OF_IT_VECTORS) return; //1023即没有中断，即0~9位全为1\n    irqNesting++;\n    /* 开始处理 */\n    irqTable[id].irqHandler(id, irqTable[id].usrPara);\n    irqNesting--;\n}\n```\n\n我们不可能只用默认中断处理函数，肯定要自己自定义，自定义完处理函数后，将该函数注册给中断对象，因此我们需要一个用于注册的函数：\n```c\n/// @brief 用于注册你自定义的中断处理函数\n/// @param irq_id 你为哪个中断写好了处理函数，写入id\n/// @param handler 你写的处理函数的地址\n/// @param para 要传入的参数\nvoid register_irqHandler(IRQn_Type irq_id, sys_irq_handler_t handler, void *para){\n    irqTable[irq_id].irqHandler = handler;\n    irqTable[irq_id].usrPara = para;\n}\n```\n\n\n## 配置gpio外部中断\n\n通过原理图可知，应配置为上升沿触发。\n\n### 配置GPIO_ICR寄存器\n寄存器用于指定触发方式——上升沿触发。\n我的开发板应指定GOIO5_ICR1_icr1 为 10。\n\n### 配置GPIO_IMR寄存器\n该寄存器用于使能中断。\n我的开发板应指定GPIO5_IMR_imr1 为 1——UNMASKED\n\n## 中断后清除中断标志位\n参考手册中指出，处理完中断后，需清除GPIO_ISR寄存器的相应位。\n需要注意的是**通过对该位写1清除。**\n\n## GIC 配置\n\njust like NVIC... you must know cubemx right？\n\n### 使能相应的中断ID\nGPIO5_1对应的中断id为74\n![](Snipaste_2025-08-24_23-51-22.png)\n但是注意这段话：\n![](Snipaste_2025-08-24_23-53-41.png)\n\n告诉我们前面还有32个中断接到了CPU的接口 所以中断ID为 74+32 = 106。\n\n### 配置中断优先级\n\n## 注册中断处理函数\n","tags":["嵌入式","Linux"],"categories":["Linux","记录"]},{"title":"I-MX6ULL的中断实验（上）","url":"/posts/32440/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n:::info\n学习笔记记录，非教程。\n:::\n\n- [1. Cortex-A7中断系统](#1-cortex-a7中断系统)\n  - [1.1. Cortex-A中断向量表](#11-cortex-a中断向量表)\n  - [1.2. 中断向量表偏移](#12-中断向量表偏移)\n  - [1.3. GIC v2中断控制器](#13-gic-v2中断控制器)\n    - [1.3.1. GIC 的主要功能](#131-gic-的主要功能)\n    - [1.3.2. 核心结构](#132-核心结构)\n    - [1.3.3. 核心原理（简单版）](#133-核心原理简单版)\n  - [1.4. 中断号](#14-中断号)\n- [2. 添加中断向量表](#2-添加中断向量表)\n- [3. 复位中断函数的编写](#3-复位中断函数的编写)\n  - [3.1. 操作CP15协处理器](#31-操作cp15协处理器)\n  - [3.2. 中断向量表偏移](#32-中断向量表偏移)\n  - [3.3. 设置sp指针](#33-设置sp指针)\n  - [3.4. 清除.bss段](#34-清除bss段)\n- [4. IRQ中断函数的编写](#4-irq中断函数的编写)\n  - [4.1. 保存中断现场（防止破坏原任务状态）](#41-保存中断现场防止破坏原任务状态)\n  - [4.2. 从 GIC（通用中断控制器）读取中断号](#42-从-gic通用中断控制器读取中断号)\n  - [4.3. 切换到 SVC 模式执行 C 语言中断处理函数](#43-切换到-svc-模式执行-c-语言中断处理函数)\n  - [4.4. 结束中断并恢复现场](#44-结束中断并恢复现场)\n- [5. 整个启动文件](#5-整个启动文件)\n\n\n## 1. Cortex-A7中断系统\n\n### 1.1. Cortex-A中断向量表\nCortex-A中断向量[^1]表有8个中断，其中重点关注IRQ。Cortex-A的中断向量表需要用户自己去定义。\n\n![](Snipaste_2025-08-11_21-20-27.png)\n\n各中断的简单介绍：\n![](Snipaste_2025-08-11_21-27-07.png)\n\n其中IRQ中断为非向量中断，所有中断共享同一入口，再软件判断来源。\n大概是这样：\n![](Snipaste_2025-08-11_21-27-26.png)\n\n### 1.2. 中断向量表偏移\n\n通过设置中断向量表偏移，指定中断向量表的地址。\n\n### 1.3. GIC v2中断控制器\n\n类似于STM32的NVIC，CortexA7使用 GIC v2 作为中断控制器，比NVIC更强大因为GIC能处理多核的中断。\n#### 1.3.1. GIC 的主要功能\n\n1. **收集中断**  \n    接收来自外设和 CPU 内部的各种中断请求（SPI、PPI、SGI）。\n2. **优先级管理**  \n    按优先级裁定哪个中断先被处理。\n3. **目标选择**  \n    把中断发给指定的 CPU 核，或广播给多个核。\n4. **中断屏蔽与使能**  \n    软件可选择屏蔽某个中断或所有中断。\n5. **确认与结束**  \n    CPU 核心在处理前向 GIC 确认（acknowledge），处理完向 GIC 报告结束（end of interrupt）。\n#### 1.3.2. 核心结构\n\nARM GIC 主要由两部分组成：\n- **Distributor（分发器）**  \n    负责接收所有外设中断，决定送到哪一个 CPU。\n- **CPU Interface（CPU 接口）**  \n    每个 CPU 核对应一个接口，负责和 Distributor 通信，接收/确认/结束中断。\n\n#### 1.3.3. 核心原理（简单版）\n\nGIC 的核心流程基本就是三步：\n1. **接收中断请求**  \n    外设（SPI）、特定 CPU 相关的中断（PPI）、核间中断（SGI）都送进 GIC。  \n2. **仲裁优先级 + 选择目标 CPU**  \n    - 比较中断优先级（Priority）        \n    - 检查中断是否被屏蔽（Enable Mask）    \n    - 根据目标 CPU 配置（Target CPU Mask）决定发给谁    \n3. **通知 CPU → CPU 响应 → 完成汇报**\n    - 发信号到目标 CPU 接口 \n    - CPU 读取中断号（acknowledge）并执行 ISR   \n    - ISR 结束后 CPU 通知 GIC（end of interrupt）\n\n### 1.4. 中断号\n中断的 ID Card。\n![](Snipaste_2025-08-11_21-54-28.png)\n\n\n## 2. 添加中断向量表\n\n- **向量表的“表项”是指令，不是纯地址。**\n    \n- 每个向量入口的指令都指向某个具体的处理函数（Reset_Handler、IRQ_Handler 等）。\n    \n- 当发生异常，CPU 硬件会取指执行入口指令 → `ldr pc, =xxx` → 跳到真正的处理函数。\n    \n\n这样，**只要依次写好这些跳转指令，后续再告诉cpu这些指令在哪个位置，就等于告诉 CPU“各种异常该去哪”**。\n\n:::danger\n**中断向量表必须按固定顺序来定义**，顺序是由 ARM 硬件架构规定的，不是随便排列的。这样CPU才能正确处理不同的异常\n:::\n\n```asm\n/* 设置中断向量表，当中断来时，CPU就会执行对应指令 */\n\n    /* 顺序不能改变，名字可以改变！ */\n\n    ldr pc, =Reset_Handler      /* 复位中断                     */  \n\n    ldr pc, =Undefined_Handler  /* 未定义中断                    */\n\n    ldr pc, =SVC_Handler        /* SVC(Supervisor)中断        */\n\n    ldr pc, =PrefAbort_Handler  /* 预取终止中断                   */\n\n    ldr pc, =DataAbort_Handler  /* 数据终止中断                   */\n\n    ldr pc, =NotUsed_Handler    /* 未使用中断                    */\n\n    ldr pc, =IRQ_Handler        /* IRQ中断                    */\n\n    ldr pc, =FIQ_Handler        /* FIQ(快速中断)未定义中断           */\n```\n\n## 3. 复位中断函数的编写\n\n### 3.1. 操作CP15协处理器\n\n**关闭I、D Cache 和MMU**\n\n<details>\n\n<summary>为什么要这样做？</summary>\n\nCP15 是 Cortex-A 系列处理器的 **系统控制寄存器集**，其中 **SCTLR（System Control Register, c1）** 控制了处理器的一些核心行为，例如：\n\n| 位   | 功能                              |\n| --- | ------------------------------- |\n| M   | MMU 使能位（Memory Management Unit） |\n| C   | 数据缓存使能位                         |\n| I   | 指令缓存使能位                         |\n| A   | 对齐检查（Alignment）使能               |\n| Z   | 缓存清零 / 压缩乘法指令                   |\n| V   | 高速异常向量表                         |\n| …   | 其他一些调试、异常行为控制                   |\n\n在复位后，SCTLR 寄存器的初始值不一定是你想要的运行状态。不同的 SoC 或板级支持包可能默认值不同，有些位可能 **默认启用某些功能但不适合裸机启动阶段**。\n\n在裸机启动阶段，你通常需要：\n\n1. **禁用 MMU 和缓存**：\n    \n    - 在初始化页表和内存映射前，启用 MMU 会导致访问非法地址或产生未定义行为。\n    - 数据缓存如果没有正确初始化，可能会导致数据写入内存不一致。\n        \n2. **关闭对齐检查**：\n    \n    - 对齐检查在裸机启动阶段可能会导致异常，因为启动代码可能使用非对齐访问。\n        \n3. **保证指令执行顺序一致**：\n    \n    - SCTLR 的某些位会影响指令缓存和流水线行为。\n    - 在系统初始化阶段，确保缓存和 MMU关闭可以让你更容易调试和保证代码执行顺序。\n        \n4. **统一系统行为**：\n    \n    - 不同芯片可能在复位后 SCTLR 寄存器的默认值不同。\n    - 显式初始化可以保证启动代码在各种芯片上行为一致。\n\n如果不重置这些位可能的风险：\n\n- **访问未定义**：\n    \n    - 如果 MMU 默认启用但页表未初始化，访问内存可能触发数据异常。\n        \n- **数据不一致**：\n    \n    - 缓存启用但未正确设置缓存策略，读写内存可能得到错误数据。\n        \n- **异常频发**：\n    \n    - 对齐检查默认启用，而启动代码中可能有非对齐访问，导致异常。\n        \n- **调试困难**：\n    \n    - 程序执行行为不确定，难以定位启动问题。\n\n\n</details>\n\n代码如下：\n```asm\n* 禁用MMU、cache、对齐检查等，配置适合裸机启动的环境，这样的启动代码移植性更好 */\n\n    mrc     p15, 0, r0, c1, c0, 0     /*  读取CP15系统控制寄存器   */\n\n    bic     r0,  r0, #0x1000          /*  清除第12位（I位）禁用 I Cache  */\n\n    bic     r0,  r0, #0x4             /*  清除第 2位（C位）禁用 D Cache  */\n\n    bic     r0,  r0, #0x2             /*  清除第 1位（A位）禁止严格对齐   */\n\n    bic     r0,  r0, #0x800           /*  清除第11位（Z位）分支预测   */\n\n    bic     r0,  r0, #0x1             /*  清除第 0位（M位）禁用 MMU   */\n\n    mcr     p15, 0, r0, c1, c0, 0     /*  将修改后的值写回CP15寄存器   */\n```\n\n### 3.2. 中断向量表偏移\n\n访问CP15 VBAR（Vector Base Address Register）寄存器，该寄存器是专门指定中断向量表偏移首地址的。\n- `dsb`（Data Synchronization Barrier）保证所有数据访问指令执行完再继续。\n- `isb`（Instruction Synchronization Barrier）保证新的 VBAR 设置马上生效，不会被 CPU 指令流水线里的旧指令影响。\n\n```asm\n/* 访问CP15 VBAR寄存器 设置中断向量表偏移 */\n\n    ldr r0, =0x80000000\n\n    dsb\n\n    isb /* 数据同步指令 */\n\n    mcr p15, 0, r0, c12, c0, 0\n\n    dsb\n\n    isb\n```\n\n### 3.3. 设置sp指针\n\n内核工作在不同模式下，User模式和是Sys模式共用sp寄存器，而其他模式是独享一个sp寄存器。\n- ARMv7-A 每个异常模式都有自己的栈指针寄存器，如果不设置，进入该模式时可能破坏未知内存。\n- 给每种模式单独分配内存空间，可以防止中断嵌套、函数调用等操作时栈互相冲突。\n\n\n### 3.4. 清除.bss段\n\n<details>\n\n<summary>bss段是什么？</summary>\n\n在编译链接后，程序的内存布局通常分为几个主要段：\n\n- **.text**：存放代码（只读）。\n    \n- **.data**：存放已初始化的全局/静态变量（初始值不为 0）。\n    \n- **.bss**：存放**未初始化的**或者**初始化为 0** 的全局/静态变量。\n\n`.bss` 只在运行时需要分配内存，编译产物中不占用存储空间（只是记录了大小），这样可以减少可执行文件体积。\n\n</details>\n\n<details>\n\n<summary>为什么要这样做？</summary>\n\n根据 **C 语言标准**：\n\n> 所有未显式初始化的全局变量、静态变量在程序开始执行前必须被初始化为 0。\n\n这意味着：\n\n- 如果 `bss` 段中的内容不是全 0，程序可能会读到**随机的旧内存内容**。\n    \n- 硬件上，RAM 启动后可能是**杂乱的值**（上电状态、上次运行残留、调试器写入等）。\n    \n\n因此，**启动代码（crt0 或汇编 startup.s）通常会在 `main()` 之前清零 bss 段**，保证所有这些变量是干净的 0。\n\n</details>\n\n```asm\n/* 清除bss段 防止未初始化变量等数据访问错误 */\n\n    ldr r0, =__bss_start\n\n    ldr r1, =__bss_end\n\n    mov r2, #0\n\nbss_clear:          /* ia: increse after */\n\n    stmia r0!, {r2} /* stmia: 从r0所存地址开始，将r2的值写入该地址，写入后地址自动递增 */\n\n    cmp r0, r1\n\n    ble bss_clear /* less & equal */\n```\n\n\n## 4. IRQ中断函数的编写\n\n\n<details>\n\n<summary>中断函数实现了什么？（详细版）</summary>\n\n### 4.1. 保存中断现场（防止破坏原任务状态）\n\n一旦 CPU 进入 IRQ 模式，中断处理代码首先：\n\n- 把 `lr`（中断返回地址）、`r0`~`r3`、`r12` 等易被破坏的寄存器压栈保存。\n    \n- 保存 `SPSR`（中断进入时的 CPSR 状态），以便中断结束时恢复原任务的运行状态。\n    \n\n**目的**：防止中断服务过程破坏被中断的程序的寄存器内容和运行状态。\n\n---\n\n### 4.2. 从 GIC（通用中断控制器）读取中断号\n\n- 读取 **GICC_IAR**（Interrupt Acknowledge Register）寄存器。\n    \n- 这个寄存器会返回当前触发的中断 ID（是哪一个外设触发的 IRQ）。\n    \n\n**目的**：确定是哪个具体中断源发生了 IRQ。\n\n---\n\n### 4.3. 切换到 SVC 模式执行 C 语言中断处理函数\n\n- ARMv7-A 的 IRQ 模式不适合直接运行通用 C 代码（栈、寄存器不统一），所以这里切到 SVC 模式。\n    \n- 在 SVC 模式下调用 `system_irqhandler`（C 写的总中断处理函数）。\n    \n- `system_irqhandler` 会根据中断号去调用具体外设的中断处理例程。\n    \n\n**目的**：统一用 SVC 模式的栈和环境执行中断逻辑，方便用 C 语言写 ISR 分发器。\n\n---\n\n### 4.4. 结束中断并恢复现场\n\n- 切回 IRQ 模式。\n    \n- 向 GIC 写 **EOIR**（End of Interrupt Register），通知 GIC 这个中断处理完成，可以接收新的中断。\n    \n- 从栈中弹出寄存器和 `SPSR`，恢复进入中断前的状态。\n    \n- 用 `subs pc, lr, #4` 返回到中断发生前的指令位置继续运行。\n    \n\n**目的**：\n\n- 告诉中断控制器“我处理完了”。\n    \n- 让 CPU 完整回到被打断的程序，像中断没发生一样继续执行。\n\n</details>\n\n省流版：\n当一个程序在 **SVC 模式** 下运行时，如果来了 IRQ：\n1. CPU 自动切到 IRQ 模式。\n2. 把 **SVC 模式的 CPSR** 存进 **IRQ 模式的 SPSR**。\n3. 把返回地址放进 IRQ 模式的 LR。\n4. 开始执行 IRQ 模式的向量入口代码（也就是 `IRQ_Handler`）。\nirq_handler:\n- 保存现场\n- 查中断号\n- 切换到svc模式 调用用c语言编写的中断分发函数 根据中断号分发到中断处理函数 来执行中断处理\n- 结束中断、恢复现场\nps： 最后一行subs指令有点抽象。。。。。。。。\n\n\n## 5. 整个启动文件\n\n```asm\n.global _start\n/* 以下两个变量在链接脚本中定义 */\n.global __bss_start\n.global __bss_end\n_start:\n    @ /* 1.设置处理器模式为SVC模式(其实CotexA内核上电默认即为SVC模式故不需要写) */\n    @ mrs r0, cpsr                /* 读取cpsr到r0 */\n    @ bic r0, r0, #0x1f           /* bic bit-clear位清零 */          \n    @                             /* 等同于R0 = R0 & (~Operand2) 这个操作数2自己推算*/\n    @                             /* 现在这个操作相当于将r0的前5位清零了 */\n    @ orr r0, r0, #0x13           /* orr 按位或 */\n    @ msr cpsr, r0                /* 写入cpsr */  \n    /* 设置中断向量表，当中断来时，CPU就会执行对应指令 */\n    /* 顺序不能改变，名字可以改变！ */\n    ldr pc, =Reset_Handler      /* 复位中断                     */  \n    ldr pc, =Undefined_Handler  /* 未定义中断                    */\n    ldr pc, =SVC_Handler        /* SVC(Supervisor)中断        */\n    ldr pc, =PrefAbort_Handler  /* 预取终止中断                   */\n    ldr pc, =DataAbort_Handler  /* 数据终止中断                   */\n    ldr pc, =NotUsed_Handler    /* 未使用中断                    */\n    ldr pc, =IRQ_Handler        /* IRQ中断                    */\n    ldr pc, =FIQ_Handler        /* FIQ(快速中断)未定义中断           */\nReset_Handler:  \n    cpsid i                           /* Change Processor State Interrupt or abort Disable irq */\n\n    /* 禁用MMU、cache、对齐检查等，配置适合裸机启动的环境，这样的启动代码移植性更好 */\n    mrc     p15, 0, r0, c1, c0, 0     /*  读取CP15系统控制寄存器   */\n    bic     r0,  r0, #0x1000          /*  清除第12位（I位）禁用 I Cache  */\n    bic     r0,  r0, #0x4             /*  清除第 2位（C位）禁用 D Cache  */\n    bic     r0,  r0, #0x2             /*  清除第 1位（A位）禁止严格对齐   */\n    bic     r0,  r0, #0x800           /*  清除第11位（Z位）分支预测   */\n    bic     r0,  r0, #0x1             /*  清除第 0位（M位）禁用 MMU   */\n    mcr     p15, 0, r0, c1, c0, 0     /*  将修改后的值写回CP15寄存器   */\n    /* 访问CP15 VBAR寄存器 设置中断向量表偏移 */\n    ldr r0, =0x80000000\n    dsb\n    isb /* 数据同步指令 */\n    mcr p15, 0, r0, c12, c0, 0\n    dsb\n    isb\n    /* 清除bss段 防止未初始化变量等数据访问错误 */\n    ldr r0, =__bss_start\n    ldr r1, =__bss_end\n    mov r2, #0\nbss_clear:          /* ia: increse after */\n    stmia r0!, {r2} /* stmia: 从r0所存地址开始，将r2的值写入该地址，写入后地址自动递增 */\n    cmp r0, r1\n    ble bss_clear /* less & equal */  \n    /* 设置各个模式下的栈指针，\n     * 注意：IMX6UL的堆栈是向下增长的！\n     * 堆栈指针地址一定要是4字节地址对齐的！！！\n     * DDR范围:0X80000000~0X9FFFFFFF\n     */\n    /* 进入IRQ模式 */\n    mrs r0, cpsr\n    bic r0, r0, #0x1f   /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  */\n    orr r0, r0, #0x12   /* r0或上0x13,表示使用IRQ模式                   */\n    msr cpsr, r0        /* 将r0 的数据写入到cpsr_c中                    */\n    ldr sp, =0x80600000 /* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB */\n    /* 进入SYS模式 */\n    mrs r0, cpsr\n    bic r0, r0, #0x1f   /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  */\n    orr r0, r0, #0x1f   /* r0或上0x13,表示使用SYS模式                   */\n    msr cpsr, r0        /* 将r0 的数据写入到cpsr_c中                    */\n    ldr sp, =0x80500000 /* 设置SYS模式下的栈首地址为0X80400000,大小为2MB */\n    /* 进入SVC模式 */\n    mrs r0, cpsr\n    bic r0, r0, #0x1f   /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  */\n    orr r0, r0, #0x13   /* r0或上0x13,表示使用SVC模式                   */\n    msr cpsr, r0        /* 将r0 的数据写入到cpsr_c中                    */\n    ldr sp, =0X80400000 /* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */\n    cpsie i             /* 打开全局中断 */\n    /* 跳转到main函数 */\n    b main\n/* 未定义中断 */\nUndefined_Handler:\n    ldr r0, =Undefined_Handler\n    bx r0\n/* SVC中断 */\nSVC_Handler:\n    ldr r0, =SVC_Handler\n    bx r0\n/* 预取终止中断 */\nPrefAbort_Handler:\n    ldr r0, =PrefAbort_Handler  \n    bx r0\n/* 数据终止中断 */\nDataAbort_Handler:\n    ldr r0, =DataAbort_Handler\n    bx r0  \n/* 未使用的中断 */\nNotUsed_Handler:\n    ldr r0, =NotUsed_Handler\n    bx r0  \n/* IRQ中断！重点！！！！！ */\nIRQ_Handler:\n    /* 保护现场 */\n    push {lr}                   /* 保存lr地址 */\n    push {r0-r3, r12}           /* 保存r0-r3，r12寄存器 */\n    mrs r0, spsr                /* 读取spsr寄存器 */\n    push {r0}                   /* 保存spsr寄存器 */ \n\n    /* 读取GIC控制器基地址 */\n    mrc p15, 4, r1, c15, c0, 0 /* 从CP15的C0寄存器内的值到R1寄存器中\n                                * 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49\n                                * Cortex-A7 Technical ReferenceManua.pdf P68 P138\n                                */                          \n    add r1, r1, #0X2000         /* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 */\n    /* 查询中断号 */\n    ldr r0, [r1, #0XC]          /* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，\n                                 * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据\n                                 * 这个中断号来绝对调用哪个中断服务函数\n                                 */\n    push {r0, r1}               /* 保存r0,r1 */\n    cps #0x13                   /* 进入SVC模式，允许其他中断再次进去 */\n    push {lr}                   /* 保存SVC模式的lr寄存器 */\n    ldr r2, =system_irqhandler  /* 加载C语言中断处理函数到r2寄存器中*/\n    blx r2                      /* 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 */\n    pop {lr}                    /* 执行完C语言中断服务函数，lr出栈 */\n    cps #0x12                   /* 进入IRQ模式 */\n    pop {r0, r1}                \n    str r0, [r1, #0X10]         /* 中断执行完成，写EOIR，相当于确认中断执行完成 */\n    pop {r0}                        \n    msr spsr_cxsf, r0           /* 恢复spsr */\n    pop {r0-r3, r12}            /* r0-r3,r12出栈 */\n    pop {lr}                    /* lr出栈 */\n    subs pc, lr, #4             /* 将lr-4赋给pc */\n/* FIQ中断 */\nFIQ_Handler:\n    ldr r0, =FIQ_Handler    \n    bx r0\nloop:\n    b loop\n```\n\n\n[^1]: 中断向量，英文名为Interrupt Vector，在早期计算机体系结构里，“vector”常被用作“指针/地址索引”的意思，所以”向量“实际上就是地址指针的意思。","tags":["嵌入式","Linux"],"categories":["Linux","记录"]},{"title":"I-MX6ULL主频与时钟配置实验","url":"/posts/33477/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n:::info\n学习笔记记录，非教程。\n:::\n\n\n## 系统时钟浅析\n\n### 7路PLL\n\n为了方便生成时钟，6从24MHz晶振生出来7路PLL。这7路PLL中有的又生出来PFD。\n- `PLL1`：ARM PLL供给ARM内核。\n- `PLL2`：sysytem PLL，528MHz，528_PLL，此路PLL分出了4路PFD，分别为PLL2_PFD0~PFD3\n- `PLL3`: USB1 PLL，480MHz 480_PLL，此路PLL分出了4路PFD，分别为PLL3_PFD0~PFD3。\n- `PLL4`: Audio PLL，主供音频使用。\n- `PLL5`: Video PLL，主供视频外设，比如RGB LCD接口，和图像处理有关的外设。\n- `PLL6`：ENET PLL，主供网络外设。\n- `PLL7`: USB2_PLL ,480MHz，无PFD。\n\n详见 IMX6ULL参考手册 Chapter 18 Clock Controller Module (CCM)\n\n附 时钟树图：\nt形为多路选择器\n\n![](Snipaste_2025-08-06_22-02-07.png)\n![](Snipaste_2025-08-06_22-03-45.png)\n\n\n### 要初始化的PLL和PFD\n\n- PLL1，\n- PLL2，以及PLL2_PFD0~PFD3.\n- PLL3以及PLL3_PFD0~PFD3.\n其他需要时再设置。\n一般按照时钟树里面的值进行设置。\n\n## 具体配置\n\n### 系统主频的配置\n\n根据时钟树来设定系统主频。具体时钟配置的说明可以参见 IMX6ULL参考手册 18.5.1.5\nCCM internal clock generation \n下图为时钟切换器 （CCM_CLK_SWITCHER） 控制输出的示意图。\n\n![](Snipaste_2025-08-07_10-00-08.png)\n\n1. 要设置ARM内核主频为528MHz，设置CACRR寄存器的ARM_PODF位为2分频，然后设置PLL1=1056MHz即可。CACRR的bit3~0为ARM_PODF位，可设置0~7，分别对应1~8分频。应该设置CACRR寄存器的ARM_PODF=1。\n\n2. 切换时钟源。PLL1输出为pll1_sw_clk。pll1_sw_clk有两路可以选择，分别为pll1_main_clk，和step_clk，通过CCSR寄存器的pll1_sw_clk_sel位(bit2)来选择。为0的时候选择pll1_main_clk，为1的时候选额step_clk。\n\n3. 在修改PLL1的时候，也就是设置系统时钟的时候需要给6ULL一个临时的时钟，也就是step_clk。在修改PLL1的时候需要将pll1_sw_clk切换到step_clk上。\n\n4. 设置step_clk。Step_clk也有两路来源，由CCSR的step_sel位(bit8)来设置，为0的时候设置step_clk为osc=24MHz。为1的时候不重要，不用。\n\n5. 时钟切换成功以后就可以修改PLL1的值。\n\n6. 通过CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位(bit6~0)来设置PLL1的频率，公式为：\n\n\t\tOutput = fref*DIV_SEL/2  1056=24*DIV_SEL/2=>DIEV_SEL=88。\n\t\t\n\t\t设置CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位=88即可。PLL1=1056MHz\n\t\t\n\t\t还要设置CCM_ANALOG_PLL_ARM寄存器的ENABLE位(bit13)为1，也就是使能输出。\n\n7. 在切换回PLL1之前，设置置CACRR寄存器的ARM_PODF=1！！切记。\n\n### 其他PLL设置\n\nPLL2和PLL3。PLL2固定为528MHz，PLL3固定为480MHz。\n\n1. 初始化PLL2_PFD0~PFD3。寄存器CCM_ANALOG_PFD_528用于设置4路PFD的时钟。比如PFD0= 528 * 18 / PFD0_FRAC。 设置PFD0_FRAC位即可。比如PLL2_PFD0=352M=528 *  18 / PFD0_FRAC，因此FPD0_FRAC=27。\n2. 同理初始化PLL3_PFD0~PFD3\n\n## 外设时钟\n\nAHB_CLK_ROOT、PERCLK_CLK_ROOT以及IPG_CLK_ROOT。\n\n因为PERCLK_CLK_ROOT和IPG_CLK_ROOT要用到AHB_CLK_ROOT，所以我们要初始化AHB_CLK_ROOT。\n\n### AHB_CLK_ROOT的初始化\n\nAHB_CLK_ROOT=132MHz。\n\n设置CBCMR寄存器的PRE_PERIPH_CLK_SEL位，设置CBCDR寄存器的PERIPH_CLK_SEL位0。设置CBCDR寄存器的AHB_PODF位为2，也就是3分频，因此396/3=132MHz。\n\n### IPG_CLK_ROOT初始化\n\n设置CBCDR寄存器IPG_PODF=1，也就是2分频。\n\n### PERCLK_CLK_ROOT初始化\n\n设置CSCMR1寄存器的PERCLK_CLK_SEL位为0，表示PERCLK的时钟源为IPG。\n\n\n## 这篇文章写得很不错,摘录一些\n\n[【嵌入式Linux】i.MX6ULL 时钟树——理论分析-CSDN博客](https://blog.csdn.net/Beihai_Van/article/details/139868239)\n\n### 总结PFD配置寄存器:\n\nCCM_ANALOG_PFD_528n 寄存器控制着 i.MX 6ULL 处理器中四个分数分频器的配置，包括时钟门控、稳定性状态和分数分频值。这些分频器用于生成不同频率的时钟信号，以满足各种外设的需求。\n\n1. CLKGATE 位 (Clock Gate): 时钟门控\n- 作用: CLKGATE 位控制着对应 PFD 的时钟信号是否被开启或关闭。\n- 值:\n\t- 0: 时钟信号开启，PFD 正常工作，可以输出分频后的时钟信号。\n\t- 1: 时钟信号关闭，PFD 处于关闭状态，不输出时钟信号。\n- 目的:\n\t- 省电: 当某个外设不需要时钟信号时，可以通过设置 CLKGATE 位为 1 来关闭该 PFD 的时钟，从而减少功耗。\n\t- 控制时钟信号: 在某些情况下，可能需要动态地控制某个外设的时钟信号，例如在系统启动或进入低功耗模式时。\n2. STABLE 位 (Stable): 稳定性状态\n\n- 作用: STABLE 位指示对应 PFD 的输出时钟信号是否已经稳定。\n- 值:\n\t当新的分数分频值生效时，位域的值会反转（从 0 变为 1 或从 1 变为 0）。这个反转就像一个信号，表明分频器已经完成调整。\n- 目的:\n\t- 诊断: STABLE 位是一个只读位，用于诊断 PFD 的稳定性。\n\t- 确保时钟信号质量: 在修改 PFD 的分数分频值后，需要等待 STABLE 位反转，才能确保输出的时钟信号稳定可靠。\n\n### i.MX6U 芯片 PLL 时钟详解\n\ni.MX6U 芯片拥有多个 PLL（Phase-Locked Loop，锁相环）模块，用于生成各种频率的时钟信号，为芯片内部的不同模块和外设提供时钟源。下面整理了 i.MX6U 芯片的 7 个主要 PLL：\n\n1. ARM_PLL (PLL1)\n\t- 用途: 为 ARM 内核提供时钟信号。\n\t- 倍频: 可编程，最高可倍频至 1.3GHz。\n\t- 特点: ARM 内核的运行速度直接取决于此 PLL 的输出频率。\n2. 528_PLL (PLL2)\n\t- 用途: 为系统总线、内部逻辑单元、DDR 接口、NAND/NOR 接口等提供时钟源。\n\t- 倍频: 固定 22 倍频，不可编程。\n\t- 输出频率: 24MHz * 22 = 528MHz。\n\t- 特点: 该 PLL 以及其生成的 4 路 PFD (PLL2_PFD0~PLL2_PFD3) 是 i.MX6U 内部系统总线的核心时钟源。\n3. USB1_PLL (PLL3)\n\t- 用途: 主要用于 USB1PHY，但也可作为其他外设的时钟源。\n\t- 倍频: 固定 20 倍频。\n\t- 输出频率: 24MHz * 20 = 480MHz。\n\t- 特点: 该 PLL 以及其生成的 4 路 PFD (PLL3_PFD0~PLL3_PFD3) 可用于多种外设。\n4. USB2_PLL (PLL7)\n\t- 用途: 为 USB2PHY 提供时钟信号。\n\t- 倍频: 固定 20 倍频。\n\t- 输出频率: 24MHz * 20 = 480MHz。\n\t- 特点: 虽然序号标为 4，但实际是 PLL7。\n5. ENET_PLL (PLL6)\n\t- 用途: 用于生成网络所需的时钟信号。\n\t- 倍频: 固定 20+5/6 倍频。\n\t- 输出频率: 24MHz * (20+5/6) = 500MHz。\n\t- 特点: 可在此 PLL 的基础上生成 25/50/100/125MHz 的网络时钟。\n6. VIDEO_PLL (PLL5)\n\t- 用途: 用于显示相关外设，例如 LCD。\n\t- 倍频: 可调整，输出范围在 650MHz~1300MHz。\n\t- 分频: 可选 1/2/4/8/16 分频。\n\t- 特点: 可根据显示设备的需求调整输出频率和分频比。\n7. AUDIO_PLL (PLL4)\n\t- 用途: 用于音频相关外设。\n\t- 倍频: 可调整，输出范围在 650MHz~1300MHz。\n\t- 分频: 可选 1/2/4 分频。\n\t- 特点: 可根据音频设备的需求调整输出频率和分频比。\n总结:\n\ni.MX6U 芯片通过多个 PLL 模块，生成各种频率的时钟信号，为芯片内部的不同模块和外设提供时钟源。每个 PLL 的倍频和分频都可以根据需要进行配置，以满足不同外设的需求。\n","tags":["嵌入式","Linux"],"categories":["Linux","记录"]},{"title":"I-MX6ULL开发板C语言运行环境搭建并点灯","url":"/posts/2969/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n:::info\n学习笔记记录，非教程。\n:::\n\n## C语言运行环境搭建\n\n前面我们讲解了如何用汇编语言编写 LED 灯实验，但是实际开发过程中汇编用的很少，大部分都是 C 语言开发，汇编只是用来完成 C 语言环境的初始化。本文我们就来学习如何用汇编来完成 C 语言环境的初始化工作，然后从汇编跳转到 C 语言代码里面去。\n\n### 设置处理器模式\n\n对于Cortex-A处理器，有多种运行模式，例如User模式、中断模式等。除用户（User）模式为非特权模式，其余均为特权模式，特权模式下程序可以访问所有系统资源，还有自己独有的寄存器组，而非特权模式下访问受限。\n\n![](Snipaste_2025-07-28_17-13-11.png)\n\n而现在我们需要将处理器模式设置为SVC模式。\n这就需要了解到内核寄存器组中的CPSR寄存器，其低四位为处理器运行模式控制位。\n\n![](Snipaste_2025-07-28_17-16-59.png)\n\n![](Snipaste_2025-07-28_17-19-33%201.png)\n\n![](Snipaste_2025-07-28_17-20-27.png)\n\n设置CPSR寄存器的bit4-0，也就是M[4:0]为10011=0X13。读写状态寄存器需要用到 MRS[^1] 和 MSR[^2] 指令。MRS将CPSR寄存器数据读出到通用寄存器里面，MSR指令将通用寄存器的值写入到CPSR寄存器里面去。\n\n为啥不用SDR、LDR？因为这他妈属于处理器内部自己在传输数据，而不是从寄存器与存储器！而且它只能操作通用寄存器。\n\n![](Snipaste_2025-07-28_17-26-03.png)\n\n### 设置sp寄存器\n\n也就是栈的起始地址。\nSp可以指向内部RAM，也可以指向DDR，我们将其指向DDR。Sp设置到哪里？512MB的范围0x80000000~0x9FFFFFFF。栈大小，0x200000=2MB，很大大大大了。\n\n再提一嘴，由于NXP给我们提供的SDK包里面有初始化DDR等一系列操作，所以这里我们可以方便的设置sp寄存器，其他处理器（启动方式设置为DDR的情况下）如果没有初始化DDR，还需要先初始化DDR。\n\n这里再说一下栈的特性，有点抽象……\n- 向上增长：即从低地址往高地址增长。以此判断即可。\n- 向下增长：从高地址往低地址增长。\n- 栈底：栈的起始位置。根据定义，如果是向下增长的，那么栈底为高地址。以此类推。\n- 栈顶：程序运行时sp指针所指示的位置，不断变化。\n处理器栈增长方式，对于A7而言是向下增长的。设置sp指向0x80200000。\n\n\n\n### 跳转到C语言\n\n使用b指令，跳转到C语言函数，比如main函数。\n\n其实我们在stm32的启动文件中也可以看到这些操作，提一嘴……\n\n## 实操\n\n我的文件结构长这样：\n```\nproject/\n├── Makefile、lds\n├── src/\n│   └── main.c\n├── inc/\n│   └── main.h\n├── build/\n└── bin/\n```\n\n同时为了学习makefile，makefile就写得比较复杂：\n注意makefile文件对缩进、空格非常敏感！\n```Makefile\n# 设置目录变量，方便统一管理和修改\n# 源代码目录:\nSRC_DIR := src\n# 头文件目录:\nINC_DIR := inc\n# 中间目标文件（.o）输出目录:\nBUILD_DIR := build\n# 最终生成的二进制文件（.bin）目录:\nBIN_DIR := bin\n\n# 设置编译工具（使用 ARM 的交叉编译工具链）\n# 编译器（用于 .c 和 .S 文件）:\nCC = arm-none-eabi-gcc\n# 链接器:\nLD = arm-none-eabi-ld\n# 用于将 elf 转为 bin 格式:\nOBJCOPY = arm-none-eabi-objcopy\n\n# 编译选项（GCC 编译阶段）\n# -I：指定头文件搜索目录\n# -Wall：打开所有警告\n# -nostdlib：不链接标准库（适用于裸机）\n# -c：只编译，不链接\nGCC_FLAGS = -I$(INC_DIR) -Wall -nostdlib -c\n\n# 链接器选项\n# -Ttext=0x80000000：设置代码段的起始地址（你设备上运行程序的入口地址）\n# -e _start：显式设置程序入口点（防止链接器猜测）\nLD_FLAGS = -Timx.lds\n\n# 自动查找 src/ 目录下的所有 .c 文件\nSRCS = $(wildcard $(SRC_DIR)/*.c)\n\n# 将 src/xxx.c 转换为 build/xxx.o\n# 例如：src/main.c → build/main.o\n# 同时添加 build/startup.o（汇编启动文件）\n# 这里注意是按顺序链接的，所以startup一定要在第一个否则链接到的地址不对（查看反汇编可知）\nOBJS = $(BUILD_DIR)/startup.o\nOBJS += $(patsubst $(SRC_DIR)/%.c,$(BUILD_DIR)/%.o,$(SRCS))\n\n# 目标：生成最终的二进制文件 bin/ledc.bin\n$(BIN_DIR)/ledc.bin: $(OBJS)\n# 链接所有 .o 文件生成 elf 格式可执行文件\n    $(LD) $(LD_FLAGS) $(OBJS) -o $(BUILD_DIR)/ledc.elf\n# 反汇编 调试用\n    arm-none-eabi-objdump -D -m arm $(BUILD_DIR)/ledc.elf > $(BUILD_DIR)/ledc.dis\n# 把 elf 文件转换为裸机二进制文件（无符号、无头信息）\n    $(OBJCOPY) -O binary -S $(BUILD_DIR)/ledc.elf $@\n\n# 编译汇编启动文件 startup.S，生成 build/startup.o\n$(BUILD_DIR)/startup.o: startup.S\n# 注意 startup.S 是汇编文件，用 gcc 编译也可以，默认会调用汇编器\n    $(CC) $(GCC_FLAGS) $< -o $@\n\n# 编译每个 .c 文件到 build/xxx.o\n# $@：目标文件（例如 build/main.o）\n# $<：依赖的源文件（例如 src/main.c）\n$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c\n    $(CC) $(GCC_FLAGS) $< -o $@\n\n.PHONY: clean\nclean:\n    rm $(BUILD_DIR)/*.o $(BUILD_DIR)/*.elf $(BIN_DIR)/*.bin $(BUILD_DIR)/*.dis\n```\n\nmain.c\n```c\n#include \"main.h\"\n\nvoid clk_enable(void){\n    LED_CLK_REG = 0xffffffff;\n}\n\nvoid led_init(void){\n    LED_MUX_REG = 0x5;          //复用为GPIO1_IO4\n    LED_PAD_REG = 0x10b0;       //设置电气属性\n    LED_GPIO_DIR_REG = 0x10;    //io4设置为输出\n}\n\nint main(void){\n    clk_enable();\n    led_init();\n    LED_GPIO_DATA_REG = 0x0;      //输出为低电平\n    while(1);\n    return 0;\n}\n```\n\nmain.h\n```c\n#ifndef __MAIN_H_  \n#define __MAIN_H_\n\n#define LED_CLK_REG *((volatile unsigned int*)0x020c406c)\n#define LED_MUX_REG *((volatile unsigned int*)0x020e006c)\n#define LED_PAD_REG *((volatile unsigned int*)0x020e02f8)\n#define LED_GPIO_DIR_REG *((volatile unsigned int*)0x0209c004)\n#define LED_GPIO_DATA_REG *((volatile unsigned int*)0x0209c000)\n\n#endif\n```\n\nstartup.S\n```asm\n  \n.global _start\n\n_start:\n\n    @ /* 1.设置处理器模式为SVC模式(其实CotexA内核上电默认即为SVC模式故不需要写) */\n    @ mrs r0, cpsr                /* 读取cpsr到r0 */\n    @ bic r0, r0, #0x1f           /* bic bit-clear位清零 */          \n    @                             /* 等同于R0 = R0 & (~Operand2) 这个操作数2自己推算*/\n    @                             /* 现在这个操作相当于将r0的前5位清零了 */\n    @ orr r0, r0, #0x13           /* orr 按位或 */\n\n    @ msr cpsr, r0                /* 写入cpsr */\n    @下面这段是重置CP15寄存器的一些位，好像加了更保险一些。目前还没弄明白，但是实测不需要也可以运行。\n    @ mrc     p15, 0, r0, c1, c0, 0     /*读取CP15系统控制寄存器   */\n    @ bic     r0,  r0, #0x1000     /*  清除第12位（I位）禁用 I Cache  */\n    @ bic     r0,  r0, #0x4     /*  清除第 2位（C位）禁用 D Cache  */\n    @ bic     r0,  r0, #0x2             /*  清除第 1位（A位）禁止严格对齐   */\n    @ bic     r0,  r0, #0x800     /*  清除第11位（Z位）分支预测   */\n    @ bic     r0,  r0, #0x1             /*  清除第 0位（M位）禁用 MMU   */\n    @ mcr     p15, 0, r0, c1, c0, 0     /*  将修改后的值写回CP15寄存器   */\n\n    /* 2.设置sp寄存器 */\n    ldr sp, =0x80100000         /* 栈大小1M */\n    \n    /* 3.跳转到main函数 */\n    b main\nloop:\n    b loop\n```\n\n链接脚本：\n```lds\n\nENTRY(_start)\nSECTIONS {\n    . = 0x80000000;\n    \n    . = ALIGN(4);\n    .text :\n    {\n        build/startup.o\n        *(.text)\n    }\n\n    . = ALIGN(4);\n    .rodata : \n    {\n        *(.rodata*)\n    }\n    \n    . = ALIGN(4);\n    .data : \n    {\n        *(.data)\n    }\n\n    . = ALIGN(4);\n    __bss_start = .;  \n    .bss :\n    {\n        *(.bss)\n        *(COMMON)\n    }\n    __bss_end = .;\n }\n\n```\n\n[^1]: **M**ove to **R**egister from **S**pecial register.  加载到通用寄存器\n[^2]: **M**ove to **S**pecial register from **R**egister.  恢复到特殊寄存器","tags":["嵌入式","Linux"],"categories":["Linux","记录"]},{"title":"浅析IMX镜像文件结构","url":"/posts/undefined/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n:::info\n学习笔记记录，非教程。\n:::\n\n## 当使用内部BootROM启动时，发生了什么？\n\n当我们通过设置BOOT_MODE[1:0]为内部启动模式时，即芯片通过执行内部的bootROM固有的代码来启动，在此模式下，芯片会执行内部的 boot ROM 代码，这段 boot ROM 代码会进行硬件初始化(一部分外设)，然后从 boot 设备(就是存放代码的设备、比如 SD/EMMC、NAND)中将代码拷贝出来复制到指定的 RAM 中，一般是 DDR。\n\n- 设置内核时钟为396MHz。使能MMU和Cache，使能L1cache、L2 cache、MMU，目的就为了加速启动。\n- 从BOOT_CFG设置的外置存储中，读取image，然后做相应的处理。\n\n![](Snipaste_2025-07-14_19-59-23.png)![](Snipaste_2025-07-14_20-01-17.png)\n其中内存管理单元（Memory Management Unit）用于将物理地址翻译为虚拟内存地址，以及通过虚拟内存访问实际物理内存。而初始化高速缓存则是加速数据访问。\n\n## 镜像文件结构\n\n在上一节[【点灯大师】点亮I.MX6ULL开发板的LED灯](https://blog.godmao.top/posts/43400/)提到过，通过汇编生成的bin文件并不能直接使用，还需要添加额外的头文件信息。我们使用VSCODE（需要扩展hex-editor）打开生成的img文件，这个文件是上一节我们使用`mkimage.sh`生成的。我们可以先查看一下这个sh文件方便理解：\n我们只截取通过sd卡启动的配置参数：\n```shell\nelif [ \"$1\" == \"sd\" ]; then\n    ../bin/$IMG_BUILDER --combine base_addr=0x80000000 ivt_offset=0x400 app_offset=0x2000 dcd_file=dcd.bin app_file=sdk20-app.bin ofile=sdk20-app.img image_entry_point=0x80002000\n```\n\n可以看到，该脚本为我们默认设置的基址为0x80000000，也就是绝对的起始地址，在此基础上，偏移app_offset即为应用程序的起始地址。因此程序的起始地址（bin的起始地址）为0x80002000，ivt表则是偏移了1024字节，0x400。\n![](Snipaste_2025-07-14_21-25-46.png)\n接下来我们看img文件的内容：\n![](Snipaste_2025-07-14_21-34-13.png)","tags":["Linux","boot"],"categories":["Linux","记录"]},{"title":"【点灯大师】点亮I.MX6ULL开发板的LED灯","url":"/posts/43400/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n:::info\n学习笔记记录，非教程。\n:::\n\n- [1. 汇编LED原理分析](#1-汇编led原理分析)\n- [2. 初始化流程](#2-初始化流程)\n  - [2.1. STM32的大致IO初始化流程](#21-stm32的大致io初始化流程)\n  - [2.2. I.MX6ULL IO初始化](#22-imx6ull-io初始化)\n- [3. 汇编语言实现](#3-汇编语言实现)\n- [4. 链接与格式转换](#4-链接与格式转换)\n  - [4.1. 链接](#41-链接)\n  - [4.2. 格式转换](#42-格式转换)\n- [5. 使用官方SDK包生成镜像文件](#5-使用官方sdk包生成镜像文件)\n- [6. 安装SDK包](#6-安装sdk包)\n  - [6.1. （可选）检查可用性](#61-（可选）检查可用性)\n  - [6.2. 生成镜像文件](#62-生成镜像文件)\n- [7. 烧录到SD卡](#7-烧录到sd卡)\n- [8. 达成成就【点灯大师】](#8-达成成就点灯大师)\n- [9. 参考资料](#9-参考资料)\n\n\n## 1. 汇编LED原理分析\n\n为什么不像STM32那样直接使用c语言？\n\n答：因为ST已经为你用汇编写好了初始化过程，比如初始化时钟等等外设，初始化Ram，设置sp指针，配置好c语言运行环境等等。而一般这些一块CortexA架构的板子是不提供的。\n\n所以我们要使用汇编：\n\n1. 初始化一些SOC外设。\n2. 初始化DDR[^1]。\n>这个I.MX6U倒是不需要。I.MX内部的ROM存放了自己编写的启动代码，这些启动代码可以读取DDR配置信息，并完成其的初始化。\n3. 设置sp指针，一般指向DDR，设置好C语言运行环境。\n\n\n## 2. 初始化流程\n\n> 具体原理、寄存器详细位讲解可以看正点原子的Linux驱动开发指南。\n\n这里我们对比STM32的IO初始化流程来学习I.MX的初始化流程\n\n### 2.1. STM32的大致IO初始化流程\n1. 使能时钟\n2. 设置IO复用，复用为GPIO\n3. 配置GPIO的电气属性\n4. 使用GPIO——利用控制寄存器设置GPIO的输入输出功能\n\n### 2.2. I.MX6ULL IO初始化\n\n同样的，IO的使用分为两个部分，CONFIG和CONTROL\n\nCONFIG部分，I.MX的每个IO都有两个寄存器来配置，分别是多路复用寄存器（IOMUXC_SW_MUX_CTL_PAD_XX_XX）和配置电气特性的寄存器（IOMUXC_SW_PAD_CTL_PAD_XX_XX）它们在命名的第三个字段加以区分。我们可以查阅正点原子的Linux驱动开发指南以及官方的参考手册查看每一位的意义。\n\nCONTROL部分，也有各种寄存器，来控制IO的各个功能，比如*GPIOx_DR*寄存器就是控制输入输出的高低电平，共有32位，每一位控制第x组IO各个引脚的高低电平。\n\n使能时钟，CCGR0~CCGR6这7个寄存器控制着6ULL所有外设时钟的使能。（参考《I.MX6UL 参考手册》的第 18 章“Chapter 18: ClockController Module(CCM)”）\n\n总结一下，I.MX6ULL的初始化一个IO流程如下：\n\n1. 使能时钟，CCGR0~CCGR6这7个寄存器控制着6ULL所有外设时钟的使能。为了简单，设置CCGR0~CCGR6这7个寄存器全部为0XFFFFFFFF，相当于使能所有外设时钟。\n2. IO复用，将寄存器IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03的bit3~0设置为0101=5，这样GPIO1_IO03就复用为GPIO。\n3. 寄存器IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03是设置GPIO1_IO03的电气属性。包括压摆率、速度、驱动能力、开漏、上下拉等。\n4. 配置GPIO功能，设置输入输出。设置GPIO1_GDIR寄存器bit3为1，也就是设置为输出模式。设置GPIO1_DR寄存器的bit3，为1表示输出高电平，为0表示输出低电平。\n\n## 3. 汇编语言实现\n\n在了解上述内容后我们可以正式开始写代码了，在Linux环境下新建`led.s`汇编文件。\n内容可以参考如下\n```asm\n/* 点亮led汇编代码 */\n\n.global _start @全局标号\n\n_start:\n\n@1.使能时钟\n    @查找原理图和参考手册可知，LED1连接GPIO1-io4，GPIO1的时钟属于CCM_CCGR1 CG13（26-27位）\n\nldr r0, =0x020c406c @将寄存器地址加载到r0\nldr r1, =0xFFFFFFF  @为了方便打开全部时钟，相应的功耗也有所增加\nstr r1, [r0] @将r1中的值存入以r0中的值为地址的寄存器中\n  \n2.设置io引脚复用为gpio\n  \nldr r0, =0x020e006c @将寄存器地址加载到r0\nmov r1, #5 @将寄存器要设置的值加载到r1\nstr r1, [r0]\n\n\n@3.设置io电气属性\n\n    /*\n\n     * bit0     SRE压摆率       0       disable\n\n     * bit5:3   DSE io驱动能力  110     R0/6\n\n     * bit7:6   speed          10      100MHz\n\n     * bit11    ODE 开路输出     0      disable\n\n     * bit12    PKE 使能pull/keeper 1   enable\n\n     * bit13    PUE pull or keeper 0   keeper\n\n     * bit15:14 上下拉电阻       00      100K下拉\n\n     * bit16    HYS             0       disable\n\n     */\n\nldr r0, =0x020e02f8\nldr r1, =0x10b0 @将寄存器要设置的值加载到r1\nstr r1, [r0]\n \n@4.设置GPIO功能\n    @设置为输出 GDIR寄存器\n\nldr r0, =0x0209c004\nmov r1, #16\nstr r1, [r0] @将GPIO1组的第4个io口设置为输出模式\n\n    @设置为输出低电平 DR寄存器\n\nldr r0, =0x0209c000\nmov r1, #0\nstr r1, [r0] @将GPIO1组的第4个io口设置为输出低电平  \n\n@5.防止CPU进入未知状态\n\n    @写入死循环\nloop:\n    b loop\n    \n/* Finally! END! */\n```\n\n\n## 4. 链接与格式转换\n\n> 默认已安装了`arm-linux-gnueabihf`编译套件\n\n### 4.1. 链接\n使用命令\n```zsh\narm-linux-gnueabihf-ld -Ttext 0X80000000 led.o -o led.elf\n```\n上述命令中-Ttext 就是指定链接起始地址，“-o”，我理解为output，指定链接生成的 elf 文件名，这里我们命名为 led.elf。上述命令执行完以后就会在工程目录下多一个 led.elf 文件。\n这个elf相当于win中的exe，是一个可执行文件。\n\n### 4.2. 格式转换\n使用命令\n```zsh\narm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin\n```\n上述命令中，“-O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出，\n选项“-S”表示不要复制源文件中的重定位信息和符号信息，“-g”表示不复制源文件中的调试\n信息。\n至此我们终于等到了想要的东西—led.bin 文件。\n但是 I.MX6U 不能直接烧写编译生成的.bin 文件，我们需要在.bin 文件前面添加一些头信息构成满足 I.MX6U 需求的最终可烧写文件，I.MX6U 的最终可烧写文件组成如下：\n1. Image vector table，简称 IVT，IVT 里面包含了一系列的地址信息，这些地址信息在\nROM 中按照固定的地址存放着。\n2. Boot data，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。\n3. Device configuration data，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置。\n4. 用户代码可执行文件，比如 led.bin。\n## 5. 使用官方SDK包生成镜像文件\n\n!!你不会以为我要用正点原子或者野火提供的镜像制作软件吧孩子!!\n\n此步所需软件：\n:::success\n- NXP SDK_2.2_MCIM6ULL\n:::\n\n第二个可从NXP官网获取。\n## 6. 安装SDK包\n使用共享文件夹将“SDK_2.2_MCIM6ULL_RFP_Linux.run” 拷贝到Linux下，存放位置自定。用chmod添加权限。然后运行.run文件生成SDK，linux下的源文件命令如下：\n```zsh\n./SDK_2.2_MCIM6ULL_RFP_Linux.run\n```\n\n### 6.1. （可选）检查可用性\n此步所需软件：\n:::success\n- gcc-arm-none-eabi交叉编译套件\n- cmake\n:::\n\n在Linux环境下，\n添加临时环境变量，执行以下命令：\n```zsh\nexport ARMGCC_DIR=/usr\n```\n\n进入工程文件**SDK_2.2_MCIM6ULL/boards/evkmcimx6ull/demo_apps/hello_world/armgcc** ，这是官方的demo，运行build_ddr_release.sh脚本\n```zsh\n./build_ddr_release.sh\n```\n\n进入同文件夹的 `ddr_release` 文件夹，会发现里面有一个sdk20-app.img，这实际上是添加了头文件的可用img文件。\n\n跳转到第7节烧录到sd卡并启动。连接到串口后会板子会发送\"hello world\"。\n\n#### 2025-10-26补充\n\n>首先感谢我当时写了这篇文章，，，，，查阅起来真是太方便了\n当我指定编译器并运行脚本时提示缺少newlib库，这里推荐使用ARM官方的编译工具链，以避免缺少库的问题。\n附链接：[Arm GNU Toolchain Downloads – Arm Developer](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)\n\n###  6.2. 生成镜像文件\n进入工程文件**SDK_2.2_MCIM6ULL/tools/imgutil/evkmcimx6ull**\n查看readme.txt 查看使用教程\nreadme.txt内容如下：\n```txt\n   IMGUTIL User Guide\n  \n   ======================================\n   \n   1. Build SDK2.0 application\n   2. Copy built binary (.bin file) to imgutil/<board> folder and rename to sdk20-app.bin\n   3. In imgutil/<board> folder, run mkimage.sh in mingw32 shell to get bootable image file sdk20-app.img\n       a. If the image is built with ram link file, use \"mkimage.sh ram\" to make the bootable image.\n       b. If the image is built with flash link file, use \"mkimage.sh flash\" to make the bootable XIP image.\n       c. If the image is built with ram link file and want to boot from MicroSD card, use \"mkimage.sh sd\" to make the bootable image.\n\n   ======================================\n```\n\n大致意思：\n1. build SDK（前面已经做了）\n2. 复制你要制作为镜像的bin文件到对应的设备文件夹并将复制的bin文件改名为`sdk20-app.bin`\n> 我们的板子是imx6ull，故复制到当前文件夹\n3. 使用 mkimage.sh+参数 来制作镜像 参数指定启动方式，有：\n\t-  ram\n\t- flash\n\t- sd\n参数我们使用sd。\n\n```zsh\n./mkimage sd\n```\n\n运行后，生成了`sdk20-app.img`文件\n\n## 7. 烧录到SD卡\n\n由于我使用的是WSL环境，WSL访问USB比较不方便所以改在win下烧录。\n\n此步所需软件：\n:::success\n- Win32DiskImager\n:::\n\n此步非常简单，将生成的img文件传到win文件夹下，使用Win32DiskImager软件烧录到连接到win的SD卡。\n\n\n## 8. 达成成就【点灯大师】\n\n将SD卡插入imx6ull，设置启动方式为SD卡，具体设置需参考你板子的硬件原理图，比如我的：\n![](Snipaste_2025-06-30_00-49-08.png)\n成功点亮！\n![](WIN_20250630_00_50_53_Pro.jpg)\n\n\n## 9. 参考资料\n\n- 《【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.81》\n- [[野火]嵌入式Linux驱动开发实战指南——基于i.MX6ULL系列 — [野火]嵌入式Linux驱动开发实战指南——基于i.MX6ULL系列 文档](https://doc.embedfire.com/linux/imx6/driver/zh/latest/index.html)\n- 《IMX6ULL参考手册》\n\n[^1]: Double Data Rate SDRAM 双倍数据速率同步动态随机存储器","tags":["嵌入式","Linux"],"categories":["Linux","记录"]},{"title":"Shell脚本流程控制简明指南","url":"/posts/21870/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n- [1. 条件判断语句 if/else](#1-条件判断语句-ifelse)\n  - [1.1. 基本语法：](#11-基本语法)\n  - [1.2. 示例：](#12-示例)\n- [2. 判断符号说明](#2-判断符号说明)\n- [3. case 分支结构](#3-case-分支结构)\n  - [3.1. 语法：](#31-语法)\n  - [3.2. 示例：](#32-示例)\n- [4. for 循环](#4-for-循环)\n  - [4.1. 遍历列表：](#41-遍历列表)\n  - [4.2. 使用 C 风格语法：](#42-使用-c-风格语法)\n- [5. while 循环](#5-while-循环)\n  - [5.1. 基本语法：](#51-基本语法)\n  - [5.2. 示例：](#52-示例)\n- [6. until 循环](#6-until-循环)\n- [7. 跳出循环：break 和 continue](#7-跳出循环break-和-continue)\n\n\nShell 脚本不仅可以批量处理命令任务，还拥有完整的流程控制语法结构，包括条件判断、循环与分支等逻辑控制结构。本文将简明介绍 Shell 的基本流程控制语法，适用于 bash 环境。\n\n## 1. 条件判断语句 if/else\n\n### 1.1. 基本语法：\n\n```shell\nif [ 条件 ]; then\n    命令1\nelif [ 条件 ]; then\n    命令2\nelse\n    命令3\nfi\n```\n写成一行：\n```shell\nif [ ]; then ; fi\n```\n\n### 1.2. 示例：\n\n```shell\nread -p \"请输入一个数字: \" num\nif [ \"$num\" -gt 0 ]; then\n    echo \"正数\"\nelif [ \"$num\" -lt 0 ]; then\n    echo \"负数\"\nelse\n    echo \"零\"\nfi\n```\n\n---\n\n## 2. 判断符号说明\n\n|条件表达式|含义|\n|---|---|\n|`-eq`|等于（整数）|\n|`-ne`|不等于|\n|`-gt`|大于|\n|`-lt`|小于|\n|`-ge`|大于等于|\n|`-le`|小于等于|\n|`-z str`|字符串是否为空|\n|`-n str`|字符串是否非空|\n|`str1 = str2`|字符串相等|\n|`-f file`|是否为普通文件|\n|`-d dir`|是否为目录|\n\n> 注意：`[` 和 `]` 要有空格；变量最好加引号防止空值。\n\n## 3. case 分支结构\n\n用于多个条件的匹配处理。\n\n### 3.1. 语法：\n\n```shell\ncase $变量 in\n    模式1)\n        命令 ;;\n    模式2)\n        命令 ;;\n    *)\n        默认命令 ;;\nesac\n```\n\n### 3.2. 示例：\n\n```shell\nread -p \"请输入选项[a/b/c]: \" choice\ncase $choice in\n    a) echo \"你选择了A\" ;;\n    b) echo \"你选择了B\" ;;\n    c) echo \"你选择了C\" ;;\n    *) echo \"无效选项\" ;;\nesac\n```\n\n## 4. for 循环\n\n### 4.1. 遍历列表：\n\n```shell\nfor var in 值1 值2 值3; do\n    命令\ndone\n```\n\n```shell\nfor name in Alice Bob Charlie; do\n    echo \"Hello, $name\"\ndone\n```\n### 4.2. 使用 C 风格语法：\n\n```bash\nfor ((i=1; i<=5; i++)); do\n    echo \"第 $i 次\"\ndone\n```\n\n## 5. while 循环\n\n### 5.1. 基本语法：\n\n```shell\nwhile [ 条件 ]; do\n    命令\ndone\n```\n### 5.2. 示例：\n\n```shell\ni=1\nwhile [ $i -le 5 ]; do\n    echo \"循环第 $i 次\"\n    ((i++))\ndone\n```\n\n## 6. until 循环\n\n与 `while` 相反：**条件为假时执行**\n\n```shell\ni=1\nuntil [ $i -gt 5 ]; do\n    echo \"第 $i 次\"\n    ((i++))\ndone\n```\n\n## 7. 跳出循环：break 和 continue\n\n```shell\nfor ((i=1;i<=10;i++)); do\n    if [ $i -eq 5 ]; then\n        break   # 提前结束循环\n    fi\n    echo $i\ndone\n```\n\n```shell\nfor ((i=1;i<=5;i++)); do\n    if [ $i -eq 3 ]; then\n        continue   # 跳过当前循环\n    fi\n    echo $i\ndone\n```","tags":["Linux","shell"],"categories":["Linux","入门"]},{"title":"shell脚本入门","url":"/posts/27290/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n作为linux嵌入式开发，掌握一些shell脚本的基础是必要的。\n\n- [1. shell脚本的写法](#1-shell脚本的写法)\n- [2. shell脚本的一些基本用法](#2-shell脚本的一些基本用法)\n  - [2.1. 输入参数](#21-输入参数)\n  - [2.2. 整形运算](#22-整形运算)\n  - [2.3. test命令](#23-test命令)\n    - [2.3.1. 文件测试](#231-文件测试)\n    - [2.3.2. 字符串比较](#232-字符串比较)\n    - [2.3.3. 数值比较](#233-数值比较)\n    - [2.3.4. 逻辑操作符](#234-逻辑操作符)\n  - [2.4. 条件判断](#24-条件判断)\n- [3. 拓展：shell脚本中`$`的作用](#3-拓展shell脚本中的作用)\n  - [3.1. 变量引用](#31-变量引用)\n  - [3.2. 命令替换](#32-命令替换)\n  - [3.3. 位置参数和特殊变量](#33-位置参数和特殊变量)\n  - [3.4. 算术扩展](#34-算术扩展)\n  - [3.5. 字符串操作和默认值处理](#35-字符串操作和默认值处理)\n\n\n\n\n## 1. shell脚本的写法\nshell是个纯文本文件，命令从上而下，一行一行开始执行，shell脚本的扩展名为.sh\n第一行：\n```shell\n#！/bin/bash\n```\n表示使用bash\n\n## 2. shell脚本的一些基本用法\n\n### 2.1. 输入参数\n`read`常用选项：\n- -a array 将输入的值作为数组赋值\n- -d delim 指定输入结束的标识符\n- -p prompt 在输入前打印提示信息\n- -t timeout 设置超时时间\n- -e 在输入的时候可以使用命令补全\n- -s silent 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。\n\n---\n\n### 2.2. 整形运算\n 使用`$[]`进行算数扩展\n```shell\nread -p \"two num: \" num1 num2\necho \"$num1 + $num2 = $[num1 + num2]\"\n```\n\n---\n\n### 2.3. test命令\n\n用于查看文件是否存在、权限等信息。可以对数值、字符、文件三方面测试，**返回布尔值**\n格式：\n```shell\ntest EXPRESSION\n# 或\n[ EXPRESSION ]  # 注意方括号内必须有空格\n```\n\n#### 2.3.1. 文件测试\n\n| 操作符 | 描述      | 示例                     |\n| --- | ------- | ---------------------- |\n| -e  | 文件是否存在  | `[ -e file.txt ]`      |\n| -f  | 是普通文件   | `[ -f /path/to/file ]` |\n| -d  | 是目录     | `[ -d /path/to/dir ]`  |\n| -r  | 可读      | `[ -r file.txt ]`      |\n| -w  | 可写      | `[ -w file.txt ]`      |\n| -x  | 可执行     | `[ -x script.sh ]`     |\n| -s  | 文件大小 >0 | `[ -s logfile ]`       |\n| -L  | 是符号链接   | `[ -L symlink ]`       |\n\n#### 2.3.2. 字符串比较\n\n| 操作符                | 描述    | 示例                       |\n| ------------------ | ----- | ------------------------ |\n| -z STRING          | 字符串为空 | `[ -z \"$var\" ]`          |\n| -n STRING          | 字符串非空 | `[ -n \"$var\" ]`          |\n| STRING1 = STRING2  | 字符串相等 | `[ \"$var1\" = \"$var2\" ]`  |\n| STRING1 != STRING2 | 字符串不等 | `[ \"$var1\" != \"$var2\" ]` |\n\n#### 2.3.3. 数值比较\n\n|操作符|描述|示例|\n|---|---|---|\n|-eq|等于|`[ \"$a\" -eq \"$b\" ]`|\n|-ne|不等于|`[ \"$a\" -ne \"$b\" ]`|\n|-gt|大于|`[ \"$a\" -gt \"$b\" ]`|\n|-ge|大于或等于|`[ \"$a\" -ge \"$b\" ]`|\n|-lt|小于|`[ \"$a\" -lt \"$b\" ]`|\n|-le|小于或等于|`[ \"$a\" -le \"$b\" ]`|\n\n#### 2.3.4. 逻辑操作符\n\n`test` 支持逻辑组合：\n\n|操作符|描述|示例|\n|---|---|---|\n|!|逻辑非|`[ ! -f \"$file\" ]`|\n|-a|逻辑与|`[ \"$a\" -eq 1 -a \"$b\" -eq 2 ]`|\n|-o|逻辑或|`[ \"$a\" -eq 1 -o \"$b\" -eq 2 ]`|\n\n**现代推荐写法**：使用 `&&` 和 `||` 替代 `-a` 和 `-o`，更符合 POSIX 标准\n\n---\n\n### 2.4. 条件判断\n\n:::warning\n和 Java、PHP 等语言不一样，sh 的流程控制不可为空\n:::\n\n**这个我单独开一篇算了....**\n\n## 3. 拓展：shell脚本中`$`的作用\n\n在 Shell 中，`$` 是一个非常核心的符号，主要用于**变量引用**、**命令替换**、**参数访问**、**字符串操作**等。下面按不同用途分类说明：\n### 3.1. 变量引用\n\n`$变量名` 用于获取变量的值：\n\n```shell\nname=\"lemon\"\necho $name     # 输出: lemon\n```\n\n```shell\necho ${name}world   # 输出: lemonworld\n```\n\n### 3.2. 命令替换\n\n`$(command)` 会执行 `command` 命令，并将其标准输出结果替换为字符串：\n\n```shell\necho \"Today is $(date)\"\n# 输出: Today is Wed Jun 18 17:00:00 CST 2025\n```\n\n等价于旧式：`` `command` ``\n\n### 3.3. 位置参数和特殊变量\n\nShell 脚本中 `$` 也用于获取传入脚本的参数或特殊含义变量：\n\n|表达式|含义|\n|---|---|\n|`$0`|脚本名|\n|`$1` ~ `$9`|脚本参数（第1~9个）|\n|`$@`|所有参数（独立）|\n|`$*`|所有参数（整体）|\n|`$#`|参数个数|\n|`$$`|当前脚本/进程的 PID|\n|`$?`|上一个命令的返回值|\n|`$!`|最近一个后台进程的 PID|\n\n示例：\n```shell\n#!/bin/bash\n\necho \"【\\$0】：脚本名称：$0\"\necho \"【\\$1】：第一个参数：$1\"\necho \"【\\$2】：第二个参数：$2\"\necho \"【\\$#】：参数总数：$#\"\n\necho \"【\\$@】：所有参数（逐个显示）\"\nfor arg in \"$@\"; do\n    echo \"  - $arg\"\ndone\n#  或echo \"【\\$@】：所有参数:\" \"$@\"\necho \"【\\$*】：所有参数（整体显示）\"\nfor arg in \"$*\"; do\n    echo \"  - $arg\"\ndone\n\necho \"【\\$$】：当前脚本的 PID 是：$$\"\n\n# 模拟一个命令并查看返回值\necho \"执行 ls 命令：\"\nls > /dev/null\necho \"【\\$?】：上一个命令的退出状态码：$?\"\n\n# 模拟后台命令并查看其 PID\nsleep 5 &\necho \"【\\$!】：最近一个后台任务的 PID 是：$!\"\n\n```\n\n\n常见问题：`${@}`与 `${*}`的区别\n\n| 表达式      | 解释                                |\n| -------- | --------------------------------- |\n| `\"${@}\"` | 把每个参数**作为独立字符串**处理，适合 for 循环      |\n| `\"${*}\"` | 把所有参数当作**一个整体字符串**处理，若带引号会合并成一个参数 |\n\n### 3.4. 算术扩展\n\n用 `$(())` 或 `$[]` 进行算术运算：\n\n```bash\na=5\nb=3\necho $[a + b]  # 输出: 8\n```\n\n### 3.5. 字符串操作和默认值处理\n\n支持 `:-`, `:=`, `:+`, `:?` 等操作：\n\n```shell\necho ${var:-default}   # var未定义则使用\"default\"\n```\n\n\n","tags":["Linux","shell"],"categories":["Linux","入门"]},{"title":"Ubuntu下连接文件","url":"/posts/36626/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n在 Linux 系统中，我们常常需要在不同位置引用同一个文件，或者希望通过某种方式为某个文件设置别名。这时候，文件“连接（Link）”机制就派上用场了。本文将详细介绍 Linux 下的硬链接（Hard Link）与符号链接（Symbolic Link，又称软链接）的概念、区别以及实际用法。\n\n---\n\n## 📌 一、什么是文件连接？\n\nLinux 中的“连接”指的是为某个文件创建一个别名或指针，使你可以通过多个路径访问同一个文件内容。\n\n连接分为两种类型：\n\n- **硬链接（Hard Link）**\n- **符号链接（Symbolic Link 或 Soft Link）**\n\n---\n\n## 🔗 二、硬链接（Hard Link）\n\n### 1. 概念\n\n硬链接是文件系统中的一种机制，它为**同一个 inode（索引节点）** 创建多个目录项。多个硬链接本质上是“平等的”，互为镜像。\n\n### 2. 特点\n\n- 同一个 inode 号，表示指向同一个文件内容。\n- 删除其中一个链接不会影响其他链接。\n- 不支持对目录创建硬链接（为避免环形结构）。\n- 只能对同一文件系统内的文件创建。\n\n### 3. 创建命令\n\n```bash\nln 源文件 目标文件\n```\n\n### 4.实验\n查看链接数\n```bash\nls -l\n```\n\n第二列显示的数字表示链接数（包括自己）。\n\n![](Snipaste_2025-06-14_21-30-04.png)\n可见其所占用的存储空间是相同的，说明它们本质是相同的，指向同一incode，删除链接源文件，其他文件依然可以运行。\n例如：\n```bash\nrm hello\n./ hello2\n```\n依然正常输出\n\n---\n\n## 三、符号链接（Symbolic Link / Soft Link）\n\n### 1. 概念\n\n符号链接类似 Windows 的快捷方式，它是一个**特殊类型的文件**，包含了另一个文件的路径。\n\n### 2. 特点\n\n- 是一个独立的文件，有自己的 inode。\n- 链接路径，而非直接指向数据块。\n- 删除源文件会导致符号链接失效（变成“悬挂链接”或“死链接”）。\n- 可跨文件系统，也可指向目录。\n\n:::bug\n**请使用绝对路径，否则拷贝文件到另一目录时会失去软连接**\n:::\n### 3. 创建命令\n\n```bash\nln -s 源文件 目标链接名\n```\n\n### 4. 实验\n\n拷贝文件保留软链接\n```bash\ncp -d [源] [目的]\n```\n\n当使用相对路径时：\n![](Snipaste_2025-06-14_21-42-53.png)\n![](Snipaste_2025-06-14_21-48-24.png)\n使用绝对路径：\n![](Snipaste_2025-06-14_21-54-29.png)\n\n---\n\n## 🆚 四、硬链接 vs 符号链接\n\n|特性|硬链接（Hard Link）|符号链接（Symbolic Link）|\n|---|---|---|\n|是否有独立 inode|否|是|\n|是否可跨文件系统|否|是|\n|是否可链接目录|否|是（需管理员权限）|\n|删除原文件后|内容仍保留|链接失效（悬挂链接）|\n|作用|多个文件名共享内容|文件快捷方式|\n\n---\n\n## 🧪 五、补充\n\n### 查找所有指向同一 inode 的文件\n\n```bash\nfind . -inum <inode号>\n```\n\n### 查找所有死链接\n\n```bash\nfind . -xtype l\n```\n---\n\n## ✅ 六、总结\n\n| 关键点  | 硬链接       | 符号链接       |\n| ---- | --------- | ---------- |\n| 安全性  | 内容冗余，较安全  | 容易产生死链接    |\n| 灵活性  | 不支持跨系统和目录 | 灵活，可指向任意路径 |\n| 适用场景 | 本地备份，核心文件 | 快捷方式，快捷访问  |\n","tags":["Linux","链接文件"],"categories":["Linux","入门"]},{"title":"踩坑记录：WSL下对u盘格式化修改后在win下连接u盘发现盘内内容未改变","url":"/posts/20676/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n## 问题描述\n我将USB读卡器插入microSD卡（该SD卡此前刷入过micropython固件包），并将其连接至电脑，接着我在win系统下，在SD卡目录下创建了一个文件wtf.txt，然后打开WSL，使用usbip将该u盘共享，在WSL下，u盘能正确读取、挂载，我在WSL重新对这个u盘使用fdisk重新分区，mkfs重新格式化为FAT32文件系统，并且在WSL下touch了一个新文件hi.txt，使用sync同步，然后使用usbipd的命令断开连接，接入win系统后，wtf.txt居然还在，再次将u盘接入WSL，发现hi.txt也在，也就是说，同样的SD卡，两个系统读到的东西却不一样，这是怎么回事？\n按照网上的主流方法，尝试过编译内核添加usb驱动支持，手动安装usbip工具都不管用。\n## 问题解决\n在使用fdisk分区时，我发现如下警告：\n```text\nThe device contains hybrid MBR -- writing GPT only.\n```\n\n在询问chatgpt后，弄清了这条警告的含义：\n1. **磁盘中检测到 Hybrid MBR**：即使之前格式化或重分区过，它仍可能保留有旧的混合结构。\n2. **当前正尝试用 GPT 格式重写该磁盘**：工具会忽略 MBR 部分，只写入纯 GPT。    \n\n**Hybrid MBR（混合主引导记录）** 是一种兼容机制，它允许一个磁盘同时拥有：\n- 一部分 **MBR（传统 BIOS 启动支持）**\n- 一部分 **GPT（用于现代系统的分区方案）**\n\n这种结构通常用于让 **使用 GPT 分区的磁盘**仍然可以在一些只识别 MBR 的系统中启动，比如旧版 BIOS 系统。\n\n我突然想起来这个SD卡不就是之前用于引导启动micropython固件的吗，所以存在混合结构，而正是这样的混合结构，是使得在win下，系统读到的是MBR分区表，Linux下读到的是GPT分区表，这就像 SD 卡前面贴着两张标签纸（MBR 和 GPT）：\n- Windows 看标签 A，就看到旧文件\n- Linux 看标签 B，就看到新文件\n- 它们根本没在“同一张纸”上操作\n\n于是我按照GPT提供的方法，使用命令彻底清除磁盘前部（包括 MBR & GPT）：\n```bash\nsudo dd if=/dev/zero of=/dev/sdd bs=1M count=10\nsync\n```\n完全抹除了旧的结构信息，再次重复分区、格式化、挂载、创建文件等操作，这下两个系统读取到的文件就同步了😍！\n\n## 特别感谢\n\n- [ChatGPT](https://chatgpt.com/)!，AI改变世界啊~\n- 我自己！\n","tags":["Linux","踩坑记录"],"categories":["Linux","记录"]},{"title":"Ubuntu下文件权限管理","url":"/posts/10180/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n在命令行界面下，输入命令\n```bash\ncd /dev\nls -l\n```\n\n得到输出如下：\n\n![](Snipaste_2025-06-14_17-39-42.png)\n\n每列释义如下：\n\n| 列   | 示例值            | 含义说明                                 |\n| --- | -------------- | ------------------------------------ |\n| 1   | `crw-rw----`   | 文件类型与权限（c 表示字符设备；接下来是用户/组/其他的读写执行权限） |\n| 2   | `1`            | 硬链接数量（对于设备文件通常是1）                    |\n| 3   | `root`         | 文件（或设备）的所有者                          |\n| 4   | `root`         | 所属用户组                                |\n| 5   | `188, 0`       | 主设备号和次设备号（**仅对设备文件存在**，表示对应驱动和设备）    |\n| 6   | `Jun 14 16:45` | 最后修改时间                               |\n| 7   | `ttyUSB0`      | 文件名（这里是设备名）                          |\n\n## 主次设备号\n主设备号（Major Number）\n- 决定了这个文件对应哪个**驱动程序**。\n- 比如所有的 `ttyUSBx` 设备可能都由主设备号 188 对应的驱动处理。\n\n次设备号（Minor Number）\n- 由主设备号指定的驱动程序使用，用于区分同一驱动管理下的不同设备。\n- 比如 `ttyUSB0` 是第一个设备，`ttyUSB1` 是第二个，以此类推。\n\n## 文件权限位详解\n第一列是文件权限位，每位释义如下：\n\n| 位次   | 含义           | 示例    | 说明                                |\n| ---- | ------------ | ----- | --------------------------------- |\n| 1    | 文件类型         | `-`   | `-` 普通文件、`d` 目录、`l` 软链接、`c` 字符设备等 |\n| 2-4  | 所有者权限（user）  | `rwx` | 读（r）、写（w）、执行（x）                   |\n| 5-7  | 用户组权限（group） | `r-x` |                                   |\n| 8-10 | 其他人权限（other） | `r--` |                                   |\n权限字符：\n\n| 字符  | 含义                          |\n| --- | --------------------------- |\n| `r` | 可读（read）：可以读取文件内容或列出目录内容    |\n| `w` | 可写（write）：可以修改文件内容或添加/删除目录项 |\n| `x` | 可执行（execute）：可执行程序或进入目录     |\n| `-` | 没有该权限                       |\n\n## 文件权限修改\n\n### 一、`chmod` 命令概述\n\n用于更改文件或目录的权限，支持 **符号法** 和 **数字法**。\n\n---\n\n### 二、权限基础\n\n|权限字符|权限含义|对文件作用|对目录作用|\n|---|---|---|---|\n|`r`|读权限|可读取内容|可列出目录文件|\n|`w`|写权限|可修改内容|可创建/删除文件|\n|`x`|执行权限|可执行|可进入目录|\n\n---\n\n### 三、符号法（Symbolic Mode）\n\n#### 语法\n\n```bash\nchmod [对象][操作][权限] 文件名\n```\n#### 对象（权限归属）\n\n|符号|含义|\n|---|---|\n|`u`|所有者|\n|`g`|所属组|\n|`o`|其他用户|\n|`a`|所有人（ugo）|\n\n#### 操作符\n\n|符号|含义|\n|---|---|\n|`+`|添加权限|\n|`-`|删除权限|\n|`=`|赋予权限（替换）|\n\n#### 示例\n\n```bash\nchmod u+x file.sh     # 给所有者添加执行权限\nchmod g-w file.txt    # 移除组的写权限\nchmod o=r file.txt    # 其他人只读\nchmod a+x run.sh      # 所有人添加执行权限\n```\n\n---\n\n### 四、数字法（Octal Mode）\n\n#### 权限与数字映射\n\n|权限|数值|含义|\n|---|---|---|\n|`---`|0|无权限|\n|`--x`|1|执行|\n|`-w-`|2|写|\n|`-wx`|3|写 + 执行|\n|`r--`|4|读|\n|`r-x`|5|读 + 执行|\n|`rw-`|6|读 + 写|\n|`rwx`|7|全部权限|\n 相当于以二进制对应的十进制来表示，这点应该不陌生。\n#### 示例\n\n```bash\nchmod 755 script.sh    # 所有者全部权限，其他用户读+执行\nchmod 644 note.txt     # 所有者读写，其他人只读\nchmod 700 secret.txt   # 只有所有者有权限\n```\n\n---\n\n### 五、递归权限修改\n\n```bash\nchmod -R 755 myfolder     # 递归修改目录及其下所有文件/子目录权限\n```\n\n---\n\n### 六、使用 find 批量设置权限\n\n```bash\nfind . -type f -exec chmod 644 {} \\;   # 设置所有文件权限\nfind . -type d -exec chmod 755 {} \\;   # 设置所有目录权限\n```\n\n---\n\n### 七、常见目录权限推荐\n\n|目录|推荐权限|含义说明|\n|---|---|---|\n|`/home/用户名`|`700`|仅用户本人访问|\n|`/tmp`|`1777`|所有人可写，Sticky 位保护|\n|网站目录|`755`|其他人可访问但不可修改|\n\n---\n\n### 八、特殊权限简述（可选）\n\n|权限|作用|示例|\n|---|---|---|\n|SUID|执行程序时使用文件所有者权限|`chmod u+s`|\n|SGID|同上，应用于组|`chmod g+s`|\n|Sticky|只能删除自己文件（多用于/tmp）|`chmod +t`|\n\n---\n","tags":["Linux","Ubuntu","文件系统"],"categories":["Linux","入门"]},{"title":"Ubuntu下磁盘管理","url":"/posts/30265/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n前面我们成功让WSL读取到Win系统的USB设备，下面来学习WSL下磁盘的管理。\n\n## 磁盘和目录的容量查询命令\n\n`df` ：查看文件系统使用量，主要查看文件系统的使用量。\n`du` ：评估文件系统的磁盘使用量，主要查看单个文件大小。\n`lsblk` ：*List Block Devices* 列出系统中SSD、U盘等存储设备的信息\n## 磁盘的挂载卸载\n\n还记得前面提到的[Ubuntu文件系统结构](https://blog.godmao.top/posts/7417/)吗？想要读取u盘里的文件，需要把u盘挂载在某个目录下才能访问。\n\n### 什么是挂载？\n挂载就是“**把设备上的文件系统接入Linux的目录结构中**”。\n- Linux 的目录结构是一个**统一的树形结构**（根目录 `/` 是起点）。\n- 所有的文件、文件夹、设备访问，都要通过这个统一的目录树。\n- 当你插入一个U盘时，它本身是一个独立的文件系统（如FAT32），Linux不会自动将其连接进目录树，除非你明确地**挂载**它。\n\n### 为什么Linux要挂载？Windows为什么不需要？\n**Linux设计哲学：**\n- Linux源于Unix，追求“一切皆文件”，统一的目录结构。\n- 所有设备都必须通过`/dev/xxx`表示为一个文件，然后挂载到某个目录（如`/mnt/usb`）才可以访问。\n**Windows的方式：**\n- Windows是“盘符式”的，每个设备有独立的盘符（如`E:\\`, `F:\\`），操作系统会**自动识别并挂载**。\n- 挂载过程对用户是透明的，但其实系统内部也在完成挂载，只是隐藏了细节。\n所以：**Windows系统也挂载，只是自动化并且用盘符表示；Linux则更显式且灵活**。\n\n### Linux下如何手动挂载u盘？\n\n如果是U盘可以挂载在`/dev/media/`目录或`/dev/mnt/`目录\n#### 1.查看u盘设备名\n在使用usbipd使WSL读取到u盘后，运行如下命令：\n```bash\nlsblk\n```\n\n会看到类似这样的输出：\n```\nsdb      8:16   1  29.8G  0 disk\n├─sdb1   8:17   1  10.0G  0 part\n├─sdb2   8:18   1   9.8G  0 part\n└─sdb3   8:19   1  10.0G  0 part\n```\n这里 `sdb1` 是U盘的分区名。磁盘可能有很多分区嘛。\n\n#### 2.为每个分区创建挂载点目录\n```bash\nsudo mkdir -p /mnt/usb1 /mnt/usb2 /mnt/usb3\n```\n\n#### 3.逐个挂载\n```bash\nsudo mount /dev/sdb1 /mnt/usb1\nsudo mount /dev/sdb2 /mnt/usb2\nsudo mount /dev/sdb3 /mnt/usb3\n```\n如果某个分区的文件系统不是自动识别的（报错），你可以指定类型挂载，例如：\n```bash\nsudo mount -t vfat /dev/sdb1 /mnt/usb1\nsudo mount -t ext4 /dev/sdb2 /mnt/usb2\nsudo mount -t ntfs /dev/sdb3 /mnt/usb3\n```\n如果不清楚类型运行如下命令可以查看：\n```bash\nsudo blkid /dev/sdb1 /dev/sdb2 /dev/sdb3\n```\n\n### 卸载\n```bash\nsudo umount /mnt/usb1\nsudo umount /mnt/usb2\nsudo umount /mnt/usb3\n```\n\n## 磁盘分区\n\n### fdisk命令常用选项\n| 命令 | 含义                     | 功能说明                                     |\n|------|--------------------------|----------------------------------------------|\n| `m`  | help                     | 显示所有可用命令                             |\n| `p`  | print                    | 显示当前分区表                               |\n| `n`  | new                      | 创建一个新分区（主分区或逻辑分区）           |\n| `d`  | delete                   | 删除一个已有分区                             |\n| `t`  | type                     | 修改分区的类型 ID                            |\n| `l`  | list                     | 列出所有分区类型 ID                         |\n| `a`  | toggle bootable          | 切换分区的启动标志（设置/取消可引导分区）   |\n| `w`  | write                    | 写入分区表并退出                             |\n| `q`  | quit                     | 不保存更改，直接退出                         |\n| `g`  | gpt                      | 创建新的 GPT 分区表                          |\n| `o`  | dos                      | 创建新的空白 DOS (MBR) 分区表                |\n| `v`  | verify                   | 验证分区表的完整性                           |\n| `x`  | expert                   | 进入专家模式（用于高级操作）                 |\n### 用fdisk打开要分区的磁盘\n```bash\nsudo fdisk /dev/sde\n```\n\n:::warning\n千万不要误选，否则可能破坏你的数据。\n:::\n\n### 删除分区\n```bash\nCommand (m for help): p        ← 查看当前分区情况（确认要删哪个）\nCommand (m for help): d        ← 删除分区\nPartition number (1,2,...): 2  ← 选择你要删除的分区编号（比如 2 表示 /dev/sdb2）\nCommand (m for help): w        ← 保存更改并退出\n```\n\n### 创建分区\n```bash\nCommand (m for help): n\n```\n\n![](Snipaste_2025-06-12_17-21-39.png)\n\n1：分区编号，直接回车接受默认编号。\n2：起始扇区，默认值通常合适，直接回车即可。\n3：结束扇区 or 分区大小，可以输入：扇区编号（直接回车使用剩余空间）或者手动输入大小（例如：`+1G`、`+512M`）\n\n### 写出\n保存并退出。\n```bash\nCommand (m for help): w\n```\n\n## 格式化分区\n当用 `fdisk` 创建完一个分区后，这个分区只是“逻辑划分好了”，但**还不能使用**，必须要**格式化（创建文件系统）**才能真正读写数据。\n\n### 为什么要格式化？\n格式化的本质是：\n\n> **在分区上写入特定的文件系统结构**（如 ext4、FAT32、NTFS 等）。\n\n只有这样，操作系统才知道如何在这块区域内组织、存储和查找文件。\n\n### 1.选择格式化类型\n| 文件系统  | 说明                               |\n| ----- | -------------------------------- |\n| ext4  | Linux常用，性能稳定，支持大文件               |\n| vfat  | FAT32，兼容Windows/Mac/Linux，不支持大文件 |\n| ntfs  | Windows常用，Linux可读写（需驱动）          |\n| exfat | 新型通用格式，支持大文件，跨平台兼容性好             |\n### 2.执行格式化命令\n*make file system* -type\n```bash\nsudo mkfs.vfat -f 32 /dev/sde2\n```\n没有mkfs的先安装，不然报错：\n```\nfailed to execute mkfs.vfat: No such file or directory\n```\n安装：\n```bash\nsudo apt update\nsudo apt install dosfstools\n```\n\n### 检查\n可以输入命令：\n```bash\nsudo blkid /dev/sde1 /dev/sde2\n```\n检查type\n输出：\n```\nsde1: UUID=\"FBD5-E06C\" BLOCK_SIZE=\"512\" TYPE=\"vfat\" PARTUUID=\"3b15f93b-f163-491d-9f0f-94be96692beb\"\nsde2: UUID=\"FC22-7890\" BLOCK_SIZE=\"512\" TYPE=\"vfat\" PARTUUID=\"248a2fdb-2255-4a7a-802e-e5a11bb87c53\"\n```\n","tags":["Linux","Ubuntu","磁盘管理"],"categories":["Linux","入门"]},{"title":"WSL下连接USB设备","url":"/posts/13715/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n⭐⭐⭐本文参考自微软官方WSL文档——[连接 USB 设备 | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/connect-usb)\n\n由于WSL不提供本机连接USB设备的支持，因此需要安装开源项目usbipd-win来支持USB的共享连接。\n\n## 什么是usbpid？\nusbipd 是一个**用于管理 USB/IP（USB over IP）服务的命令行工具**，可以在 Windows 下使用。 USB/IP 是一种协议，允许**通过网络共享USB 设备**。 usbipd工具允许用户在 Windows 上共享 USB 设备，使其他计算机能够通过网络访问这些设备。\n\n## 安装 USBIPD-WIN 项目\n1. 转到 [usbipd-win 项目的最新发布页面](https://github.com/dorssel/usbipd-win/releases)。\n2. 选择 .msi 文件，该文件将下载安装程序。 （你可能会收到一条警告，要求你确认你信任此下载）。\n3. 运行下载 usbipd-win_x.msi 安装程序文件。\n\n这将安装：\n- 名为 `usbipd` 的服务，（显示名称：USBIP 设备主机）。 可以使用 Windows 中的服务应用检查此服务的状态。\n- 命令行工具 `usbipd`。 此工具的位置将添加到 PATH 环境变量。\n- 名为 `usbipd` 的防火墙规则，用于允许所有本地子网连接到服务。 可修改此防火墙规则以微调访问控制。\n\n4. 若要附加 USB 设备，请运行以下命令。 （不再需要使用提升的管理员提示。确保 WSL 命令提示符处于打开状态，以使 WSL 2 轻型 VM 保持活动状态。 **请注意，只要 USB 设备连接到 WSL，Windows 将无法使用它。** 一旦连接到 WSL，任何在 WSL 2 上运行的发行版都可以使用该 USB 设备。 请确认设备是否已连接 `usbipd list`。 在 WSL 提示符下，运行 `lsusb` 以验证 USB 设备是否已列出，并且可以使用 Linux 工具与之交互。\n\n```powershell\nusbipd attach --wsl --busid <busid>\n```\n\n5. 打开 Ubuntu（或首选 WSL 命令行），并使用以下命令列出附加的 USB 设备：\n\n```bash\nlsusb\n或者\nlsblk -f\n```\n\n若没有找到命令，则先下载`usbutils`\n![](Snipaste_2025-06-12_00-11-23.png)\n```bash\nsudo apt install usbutils\n```\n\n可以看到已经成功读取到u盘，并且能够使用普通 Linux 工具与之交互。 根据应用程序，可能需要配置 udev 规则，以允许非根用户访问设备。\n![](Snipaste_2025-06-12_00-18-59.png)\n6. 在 WSL 中使用设备后，可以物理断开 USB 设备的连接，或者从 PowerShell 运行以下命令：\n\n```powershell\nusbipd detach --busid <busid>\n```\n\n\n","tags":["Linux","WSL2","USB"],"categories":["Linux","WSL2"]},{"title":"Ubuntu文件系统结构","url":"/posts/7417/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\nUbuntu文件系统结构清单。\n<!--more-->\n\n> 万物皆文件\n\n**仅作学习记录。**\n\n| 目录          | 说明                                                  |\n| ----------- | --------------------------------------------------- |\n| `/`         | 根目录，是所有文件和目录的起点。                                    |\n| `/bin`[^1]  | 存放系统启动和运行所需的基本命令（如 `ls`, `cp`, `mv`）。               |\n| `/boot`     | 启动相关文件，如内核 (`vmlinuz`)、引导加载器配置等。                    |\n| `/dev`      | 包含所有设备（驱动）文件（如硬盘、终端、USB 设备）。                        |\n| `/etc`      | 系统配置文件目录（如网络、用户、服务配置）。                              |\n| `/home`     | 每个普通用户的主目录（如 `/home/alice`）。                        |\n| `/lib`      | 存放系统程序所需的共享库文件。                                     |\n| `/lib64`    | 存放64位系统的共享库（与 `/lib` 类似）。                           |\n| `/media`    | 可移动设备挂载点（如U盘、CD-ROM）。                               |\n| `/mnt`      | 临时挂载文件系统的目录，供管理员使用。                                 |\n| `/opt`      | 为第三方软件提供安装位置。                                       |\n| `/proc`     | 虚拟文件系统，内核和进程信息以文件形式展现（如 `/proc/cpuinfo`）。存放系统运行的信息？ |\n| `/root`     | `root` 用户的主目录（注意：不是 `/`）。                           |\n| `/run`      | 存放运行时数据，如系统启动后生成的PID文件或Socket文件。                    |\n| `/sbin`     | 存放系统管理类命令，仅供 `root` 用户使用（如 `reboot`, `fsck`）。       |\n| `/srv`      | 存放提供服务的数据（如网站、FTP 服务器数据）。                           |\n| `/sys`      | 虚拟文件系统，表示内核设备结构，供 `udev` 和其他工具使用。                   |\n| `/tmp`      | 存放临时文件（系统重启后清空）。                                    |\n| `/usr`      | 多数用户空间程序和库的安装目录。                                    |\n| `/usr/bin`  | 非必要基本命令（大部分用户程序）的位置。                                |\n| `/usr/sbin` | 系统管理命令的位置，供管理员使用。                                   |\n| `/usr/lib`  | `/usr/bin` 和 `/usr/sbin` 程序所用库文件。                   |\n| `/var`      | 可变数据文件（如日志、缓存、邮件、数据库文件等）。                           |\n\n[^1]:Faker VS Bin 你蹲我的意思吗\n","tags":["Linux","Ubuntu","文件系统"],"categories":["Linux","入门"]},{"title":"Linux常用的命令总结","url":"/posts/37616/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\nLinux下常用的命令清单及补充。\n<!--more-->\n\n**仅作学习记录。**\n\n| 命令         | 说明                 | 使用格式                   |\n| ---------- | ------------------ | ---------------------- |\n| `ls`       | 列出目录内容             | `ls [选项] [目录]`         |\n| `cd`       | 改变当前目录             | `cd [目录]`              |\n| `pwd`      | 显示当前工作目录           | `pwd`                  |\n| `cp`       | 复制文件或目录            | `cp [选项] 源文件 目标文件`     |\n| `mv`       | 移动文件或目录，重命名文件      | `mv [选项] 源文件 目标文件`     |\n| `rm`       | 删除文件或目录            | `rm [选项] 文件`           |\n| `touch`    | 创建空文件              | `touch 文件名`            |\n| `mkdir`    | 创建目录               | `mkdir [选项] 目录名`       |\n| `rmdir`    | 删除空目录              | `rmdir 目录名`            |\n| `chmod`    | 更改文件或目录权限          | `chmod [选项] 权限 文件`     |\n| `chown`    | 更改文件或目录的所有者        | `chown 用户:组 文件`        |\n| `chgrp`    | 更改文件或目录的所属组        | `chgrp 组 文件`           |\n| `cat`      | 查看文件内容             | `cat 文件名`              |\n| `more`     | 分页显示文件内容           | `more 文件名`             |\n| `less`     | 分页显示文件内容（支持上下翻页）   | `less 文件名`             |\n| `head`     | 查看文件开头部分           | `head [选项] 文件`         |\n| `tail`     | 查看文件尾部部分           | `tail [选项] 文件`         |\n| `find`     | 查找文件或目录            | `find [路径] [选项] [表达式]` |\n| `grep`     | 文本搜索               | `grep [选项] \"模式\" 文件`    |\n| `tar`      | 压缩或解压文件            | `tar [选项] [文件]`        |\n| `gzip`     | 压缩文件               | `gzip 文件名`             |\n| `gunzip`   | 解压.gz文件            | `gunzip 文件名.gz`        |\n| `zip`      | 压缩文件               | `zip [选项] 压缩包 文件`      |\n| `unzip`    | 解压.zip文件           | `unzip 压缩包`            |\n| `df`       | 查看文件系统磁盘空间使用情况     | `df [选项]`              |\n| `du`       | 查看目录或文件的磁盘使用情况     | `du [选项] 文件/目录`        |\n| `top`      | 查看系统进程状态           | `top`                  |\n| `ps`       | 查看进程状态             | `ps [选项]`              |\n| `kill`     | 终止进程               | `kill [选项] 进程号`        |\n| `pstree`   | 以树形结构显示进程          | `pstree`               |\n| `free`     | 查看内存使用情况           | `free [选项]`            |\n| `uname`    | 查看系统信息             | `uname [选项]`           |\n| `ifconfig` | 配置网络接口             | `ifconfig [网络接口]`      |\n| `ip`       | 查看或配置网络            | `ip [选项]`              |\n| `ping`     | 测试网络连接             | `ping [选项] 地址`         |\n| `scp`      | 安全复制文件             | `scp 源文件 用户@主机:目标`     |\n| `rsync`    | 同步文件和目录            | `rsync [选项] 源 目标`      |\n| `wget`     | 从网络下载文件            | `wget [选项] URL`        |\n| `curl`     | 与网络交互（下载、上传文件等）    | `curl [选项] URL`        |\n| `alias`    | 创建命令别名             | `alias 别名='命令'`        |\n| `history`  | 查看命令历史             | `history`              |\n| `man`      | 查看命令手册             | `man 命令名`              |\n| `echo`     | 输出字符串到终端           | `echo \"文本\"`            |\n| `tee`      | 从标准输入读取，并将其内容输出到文件 | `命令 \\| tee 文件`         |\n| `cut`      | 按列切割文件内容           | `cut -d 分隔符 -f 列 文件`   |\n| `awk`      | 强大的文本处理工具          | `awk '条件 {动作}' 文件`     |\n| `sed`      | 流编辑器，处理文本数据        | `sed 's/模式/替换文本/' 文件`  |\n| `tr`       | 转换字符               | `tr '旧字符' '新字符' < 文件`  |\n| `wc`       | 统计文件字数、行数、字节数等     | `wc [选项] 文件`           |\n| `whoami`   | 查看当前用户             | `whoami`               |\n| `sudo`     | 以超级用户身份执行命令        | `sudo 命令`              |\n| `exit`     | 退出终端或当前Shell会话     | `exit`                 |\n| `file`     | 文件类型查看命令           |  `file 文件路径`           |\n\n## ls\n-a 列出全部\n-l 以列展示\n\n## ranger\n一个终端文件管理器（Vim风格）\n\n| 操作        | 快捷键                |\n| --------- | ------------------ |\n| 向上/向下     | 方向键                |\n| 进入目录或打开文件 | `l / Enter`        |\n| 返回上一级目录   | 方向键                |\n| 创建新文件     | `:touch filename`  |\n| 创建新目录     | `:mkdir dirname`   |\n| 删除文件/目录   | `D` 然后确认           |\n| 重命名       | `cw`               |\n| 复制        | `yy`（复制）+ `pp`（粘贴） |\n| 剪切        | `dd`（剪切）+ `pp`（粘贴） |\n| 预览文件内容    | 自动或按 `i`           |\n| 搜索文件名     | `/关键词`             |\n| 退出        | `q` 或 `:q`         |\n\n## grep\n\n`grep` 是 Linux 系统中一个强大的文本搜索工具，用于在文件中查找符合条件的字符串或正则表达式，并打印匹配的行。它的名字来源于 \"Global Regular Expression Print\"。\n### 基本语法\n\n`grep [选项] \"搜索内容\" 文件名`\n\n### 常用选项\n\n1. **`-i`**：忽略大小写。\n\n    `grep -i \"hello\" file.txt`\n    - 匹配 `hello`、`HELLO` 等。\n    \n2. **`-n`**：显示匹配行的行号。\n\n    `grep -n \"hello\" file.txt`\n    - 输出匹配行及其行号。\n    \n3. **`-v`**：反向匹配，显示不包含搜索内容的行。\n    \n    `grep -v \"hello\" file.txt`\n    \n4. **`-c`**：仅显示匹配的行数。\n    \n    `grep -c \"hello\" file.txt`\n    \n5. **`-r` 或 `-R`**：递归搜索目录中的文件。\n    \n    `grep -r \"hello\" /path/to/directory`\n    \n6. **`-l`**：仅显示包含匹配内容的文件名。\n    \n    `grep -l \"hello\" *.txt`\n    \n7. **`-w`**：匹配整个单词。\n    \n    `grep -w \"hello\" file.txt`\n    \n8. **`-A` 和 `-B`**：显示匹配行的上下文。\n    \n    - **`-A`**：显示匹配行后面的若干行。\n        `grep -A 2 \"hello\" file.txt`\n        \n    - **`-B`**：显示匹配行前面的若干行。\n        `grep -B 2 \"hello\" file.txt`\n        \n    - **`-C`**：同时显示匹配行的前后若干行。\n        `grep -C 2 \"hello\" file.txt`\n        \n\n### 正则表达式支持\n\n`grep` 支持基本正则表达式（BRE）和扩展正则表达式（ERE，需使用 `egrep` 或 `grep -E`）。\n\n- **匹配任意字符**：`grep \"h.llo\" file.txt` 匹配 `hello`、`hallo` 等。\n- **匹配开头**：`grep \"^hello\" file.txt` 匹配以 `hello` 开头的行。\n- **匹配结尾**：`grep \"hello$\" file.txt` 匹配以 `hello` 结尾的行。\n- **匹配多个选项**：`grep -E \"hello|world\" file.txt` 匹配 `hello` 或 `world`。\n\n### 实例\n\n1. 查找文件中包含 \"error\" 的行并显示行号：\n\n    `grep -n \"error\" log.txt`\n    \n2. 在当前目录及子目录中查找包含 \"TODO\" 的文件：\n\n    `grep -r \"TODO\" .`\n    \n3. 查找以 \"INFO\" 开头的日志行：\n\n    `grep \"^INFO\" log.txt`\n    \n4. 查找不包含 \"DEBUG\" 的行：\n\n    `grep -v \"DEBUG\" log.txt`\n\n## du\n-s 只显示指定目录总大小 \n-h 以单位k、m、g显示\n\n## tar\n\n`tar [选项] -f 归档文件名 [文件或目录]`\n### 选项：\n- -c：创建新的归档文件。\n- -x：解压归档文件。\n- -t：列出归档文件的内容。\n- -v：显示详细操作过程。\n- -z：使用 gzip 压缩或解压。\n- -j：使用 bzip2 压缩或解压。\n- -J：使用 xz 压缩或解压。\n- --delete：从归档文件中删除指定文件（仅限 GNU tar）。\n\n### 常见操作示例：\n\n1. **创建归档文件**\n\n\t将文件 _file1_ 和 _file2_ 以及目录 _dir_ 打包成 _archive.tar_：\n\t`tar -cvf archive.tar file1 file2 dir`\n\n2. **解压归档文件**\n\n\t解压 _archive.tar_ 到当前目录：\n\t`tar -xvf archive.tar`\n\n3. **压缩归档文件**\n\n\t将目录 _dir_ 打包并使用 gzip 压缩为 _archive.tar.gz_：\n\t`tar -czvf archive.tar.gz dir`\n\n4. **解压压缩归档文件**\n\n\t解压 _archive.tar.gz_：\n\t`tar -zxvf archive.tar.gz`\n\n5. **列出归档文件内容**\n\n\t查看 _archive.tar_ 中的文件和目录：\n\t`tar -tvf archive.tar`\n\n6. **向归档文件追加文件**\n\n\t将 _newfile_ 添加到已存在的 _archive.tar_ 中：\n\t`tar -rvf archive.tar newfile`\n\n7. **删除归档文件中的文件**\n\n\t从 _archive.tar_ 中删除 _file1_：\n\t`tar --delete -f archive.tar file1`\n\n8. **解压到指定目录**\n\n\t将 _archive.tar.gz_ 解压到 _/tmp/files_ 目录：\n\t`tar -zxvf archive.tar.gz -C /tmp/files`\n\n### **注意事项**\n\n- 使用 _-v_ 可以查看详细的操作过程。 \n- 解压时，_-C_ 选项可以指定目标目录。\n- 压缩时，建议根据文件类型选择合适的压缩算法（如 gzip、bzip2 或 xz）。\n\n## dd\n\n### dd 命令简介\n\n`dd` 是 Linux 和类 UNIX 系统中一个功能强大的命令行工具，主要用于低级别的数据复制和转换操作。它可以处理设备文件、磁盘、分区、文件等，常用于备份、恢复、创建磁盘镜像等任务。\n\n`dd if=<输入文件> of=<输出文件> [参数...]`\n\n- **if**：指定输入文件（input file），如 `/dev/zero`、磁盘设备或普通文件。\n- **of**：指定输出文件（output file），如磁盘设备或普通文件。\n- **参数**：用于控制块大小、数据量等。\n### 常用参数\n\n- **bs=大小**：设置块大小（如 `bs=1M` 表示每次读写 1MB 数据）。\n- **count=数量**：指定复制的块数。\n- **skip=数量**：跳过输入文件的前若干块。\n- **seek=数量**：跳过输出文件的前若干块。\n- **status=progress**：显示进度信息。\n\n### 常见用法\n\n1. **创建空文件**\n    \n    `dd if=/dev/zero of=empty_file bs=1M count=10`\n    \n    - 创建一个大小为 10MB 的空文件。\n2. **制作磁盘镜像**\n        \n    `dd if=/dev/sda of=/path/to/image.img bs=1M`\n    \n    - 将整个磁盘 `/dev/sda` 制作成镜像文件。\n3. **恢复磁盘镜像**\n    \n    `dd if=/path/to/image.img of=/dev/sda bs=1M`\n    \n    - 将镜像文件写回磁盘。\n4. **清空磁盘数据**\n        \n    `dd if=/dev/zero of=/dev/sda bs=1M`\n    \n    - 用零填充整个磁盘 `/dev/sda`，清空数据。\n5. **测试磁盘读写速度**\n    \n    `dd if=/dev/zero of=testfile bs=1G count=1 oflag=direct`\n    \n    - 创建一个 1GB 的文件，测试写入速度。\n\n### 注意事项\n\n- `dd` 是一个强大的工具，但操作不当可能导致数据丢失，尤其是涉及磁盘设备时，请务必确认输入和输出路径。\n- 使用 `status=progress` 参数可以实时查看操作进度。\n\n## find\n\n`find` 是 Linux 中非常强大的命令，用于在指定目录下递归查找文件或目录，并支持多种条件过滤和操作。以下是它的基本用法和常见示例：\n\n### 基本语法\n\n`find [路径] [选项] [表达式]`\n\n- **路径**：指定查找的目录（如 `/`, `.` 表示当前目录）。\n- **选项**：控制查找行为（如按文件名、大小、时间等）。\n- **表达式**：定义匹配条件或操作（如执行命令）。\n\n### 常用选项\n\n1. **按文件名查找**\n\n    `find /path -name \"filename\"`\n    - 区分大小写：`-name`\n    - 不区分大小写：`-iname`\n\n2. **按文件类型查找**\n\n    `find /path -type [f|d|l]`\n\n    - `f`：普通文件\n    - `d`：目录\n    - `l`：符号链接\n\n3. **按文件大小查找**\n\n    `find /path -size [+|-]N[c|k|M|G]`\n    \n    - `+N`：大于 N 单位\n    - `-N`：小于 N 单位\n    - `N`：等于 N 单位\n    - 单位：`c`（字节）、`k`（KB）、`M`（MB）、`G`（GB）\n\n4. **按修改时间查找**\n\n    `find /path -mtime [+|-]N`\n    \n    - `+N`：N 天前修改\n    - `-N`：N 天内修改\n    - `N`：正好 N 天前修改\n    - 访问时间：`-atime`，状态更改时间：`-ctime`\n\n5. **按权限查找**\n\n    `find /path -perm [mode]`\n    \n    - 精确匹配：`-perm 644`\n    - 至少包含权限：`-perm -644`\n\n6. **按用户或组查找**\n\n    `find /path -user username find /path -group groupname`\n\n### 执行操作\n\n1. **删除匹配的文件**\n    \n    `find /path -name \"*.log\" -delete`\n    \n    或\n\n    `find /path -name \"*.log\" -exec rm -f {} \\;`\n    \n2. **查找并执行命令**\n    \n    `find /path -type f -name \"*.txt\" -exec cat {} \\;`\n    \n    - `{}`：表示当前匹配的文件\n    - `\\;`：表示命令结束\n\n3. **查找并移动文件**\n    \n    `find /path -name \"*.jpg\" -exec mv {} /new/path/ \\;`\n    \n\n### 综合示例\n\n1. 查找当前目录下所有 `.txt` 文件：\n\n    `find . -name \"*.txt\"`\n    \n2. 查找 `/var/log` 目录下最近 7 天修改的文件：\n\n    `find /var/log -mtime -7`\n    \n3. 查找 `/home` 目录下大于 100MB 的文件：\n    \n    `find /home -size +100M`\n    \n4. 查找 `/tmp` 目录下权限为 777 的文件并删除：\n\n    `find /tmp -perm 777 -delete`\n    ","tags":["Linux","命令"],"categories":["Linux","入门"]},{"title":"如何优雅的在win上运行Linux","url":"/posts/26155/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n 在 Windows 和 Linux 之间切换开发环境是一件让人头疼的事。幸运的是，WSL（Windows Subsystem for Linux）为我们提供了一种优雅的解决方案：**在 Windows 上原生运行 Linux**，无需虚拟机或双系统。本文将带你优雅地入门 WSL，从安装到使用，让你轻松拥有双系统的快乐而不牺牲效率。\n\n## 一、WSL 是什么？\n\nWSL（Windows Subsystem for Linux）是微软提供的一种兼容层，使你可以直接在 Windows 上运行 Linux 用户空间环境。当前主流版本是 **WSL 2**，它使用轻量虚拟化技术，提供完整的 Linux 内核和更好的性能。那么它有什么好处呢？\n- Linux 、Windows文件共享。你可以在Windows的文件资源管理器上处理Linux子系统的文件\n- 命令混用，在Windows里可以运行Liunx命令，在Linux里可以运行Windows程序\n- 显卡直通，在AI训练方面非常方便\n等等....\n\n## 二、准备工作\n\n:::success\n- Windows 10（版本 2004 及以上，推荐 21H2 或更高）\n- 或 Windows 11（原生支持 WSL 2）\n:::\n本文以win11为例。\n### 开启必要功能\n在搜索栏搜索 `启动或关闭window功能`\n![](Snipaste_2025-06-07_23-29-33%201.png)\n开启如下两项：\n- 适用于Linux的Windows子系统\n- 虚拟机平台\n![](Snipaste_2025-06-07_23-32-13.png)\n然后**重启以使更改生效**。\n如果是win11的话重启后可以看到文件资源管理器中有个Linux\n![](Snipaste_2025-06-07_23-36-31.png)\n## 安装Linux子系统\n\n:::warning\nwin11原生支持WSL2，如果没有安装WSL，可以点击这个链接安装\n[Windows Subsystem for Linux - Microsoft Apps](https://apps.microsoft.com/detail/9p9tqf7mrm4r?ocid=pdpshare&hl=en-us&gl=US)\n:::\n\n这里提供两种方法安装WSL2：\n\n### 直接安装发行版\n\n打开下面的链接：\n[旧版 WSL 的手动安装步骤 | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-1---enable-the-windows-subsystem-for-linux)\n直接下载想要的系统的发行版：\n![](Snipaste_2025-06-08_00-08-42.png)\n\n下载下来后将文件后缀改为`.zip`,解压缩\n![](Snipaste_2025-06-08_00-11-46.png)\n\n解压后，选择x64版本，同样的方法，继续解压\n![](Snipaste_2025-06-08_00-14-29.png)\n\n解压后，复制如下两个文件到你想要安装的指定目录\n![](Snipaste_2025-06-08_00-14-53.png)\n\n例如我的是`E:\\Linux\\Ubuntu-24.04LTS`\n\n在目录下双击运行exe文件，自此安装完成。\n![](Snipaste_2025-06-08_00-18-01.png)\n### 命令行安装（不推荐）\n\n不推荐原因如下：\n- 此方法下安装的Linux子系统默认安装在c盘，无法更改安装路径，想要迁移比较麻烦。\n- 由于服务器原因，下载很慢，需要一些上网技巧才能流畅下载。\n\n打开cmd命令提示符窗口，输入如下命令：\n```shell\nwsl --update\nwsl --install\n```\n等待安装成功。默认安装Ubuntu系统。\n也可以指定版本\n输入\n```shell\nwsl --list --online\n```\n可以查看当前可安装的发行版。\n![](Snipaste_2025-06-08_00-01-29%201.png)\n比如安装Debian，直接输入\n```shell\nwsl --install Debian\n```\n等待安装完成即可。\n\n**安装完成后提示输入用户名和密码，注意密码输入是不显示的。**\n\n\n### 开始使用\n💡如果你的电脑只有那种丑丑的简陋的命令行工具，可以在微软商店下载一个`Windows Terminal Preview`获得更好的体验\n![](Snipaste_2025-06-08_00-21-38.png)\n\n### 常用命令速查\n| 命令                                     | 功能                |\n| -------------------------------------- | ----------------- |\n| `wsl`                                  | 启动默认 Linux 发行版    |\n| `wsl -l -v`                            | 查看已安装的发行版和 WSL 版本 |\n| `wsl --set-version <发行版> 2`            | 将指定发行版升级到 WSL 2   |\n| `wsl --set-default-version 2`          | 设置默认启动Linux版本     |\n| `wsl -d <发行版>`                         | 启动指定发行版           |\n| `wsl --shutdown`                       | 关闭所有正在运行的 WSL 实例  |\n| `wsl --unregister <发行版>`               | 卸载发行版             |\n| `wsl --export Ubuntu ubuntu.tar`       | 对子系统进行备份与恢复 【导出】  |\n| `wsl --import <自定义名> <目标路径> <.tar源路径>` | 对子系统进行读取/恢复  【导入】 |\n## 启动\n可以使用命令行启动（见上表）也可在`Windows Terminal Preview`下直接点击\n![](Snipaste_2025-06-08_00-26-24.png)\n即可打开~\n\n## 换源\n这里使用清华源\n[ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror](https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/)\n有详细的使用介绍，根据自己的版本选择文件路径以及格式复制粘贴即可，以Ubuntu24.04为例：\n使用命令\n```shell\nsudo nano /etc/apt/sources.list.d/ubuntu.sources\n```\n进入编辑页面后，先把原来的配置源删除，再粘贴。\n![](Snipaste_2025-06-08_13-50-00.png)\n然后按`Ctrl+O` `Enter` `Ctrl+x`退出 （\"^\"指Ctrl \"M\"指Alt）\n退出后使用命令 \n```shell\nsudo apt update\n```\n更新软件包数据库。\n最后使用\n```shell\nsudo apt upgrade\n```\n升级软件包。\n\n## 退出系统\n`Windows Terminal Preview`下，直接叉掉Linux命令行窗口即可退出\n或在Linux命令行窗口直接使用命令\n```shell\nexit\n```\n推出后等待几秒可以输入\n```shell\nwsl -l -v\n```\n查看Liunx状态：是停止\n![](Snipaste_2025-06-08_14-16-16.png)\n还可以使用 \n```shell\nwsl --shutdown\n```\n一次性关闭所有运行的实例。\n## 卸载系统\n使用命令\n```shell\nwsl --unregister <发行版名>\n```\n即可卸载\n\n## C/C++ 环境搭建\n\n比较简单，默认的 Ubuntu 软件源包含了一个软件包组，名称为 \"build-essential\",它包含了 GNU 编辑器集合，GNU 调试器，和其他编译软件所必需的开发库和工具。  \n想要安装开发工具软件包，直接\n```shell\nsudo apt install build-essential\n```\n验证\n```shell\ngcc -v\ng++ -v\ngdb -v\n```\n 有一个没有的话 单独安装一下即可\n```shell\n sudo apt install gdb\n```\n## 推荐玩法\n### VScode插件\n使用 WSL 作为开发环境，结合 VS Code 的 **Remote - WSL 插件**，在 Windows 中编辑、WSL 中运行。\n直接下载插件\n![](Snipaste_2025-06-08_14-28-45.png)\n在Linux终端打开某个文件夹 然后使用命令即可在Linux环境下运行VScode\n```shell\ncode .\n```\n\n![](Snipaste_2025-06-08_14-31-11.png)\n还可以直接使用VScode终端输入Linux命令。\n![](Snipaste_2025-06-08_14-43-03.png)\n\n## 推荐安装\n\n`ranger`：文件管理器\n`usbipd`：共享usb","tags":["Linux","WSL2"],"categories":["Linux","WSL2"]},{"title":"[自用]16届烂桥杯嵌入式赛道模块代码整理","url":"/posts/44982/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n##  时间片轮询调度\n\n```c\n\nuint8_t TaskCount = 0;//用于记录任务数量\n\ntypedef enum {\n\trun,wait,stop\n}TaskStatus;//任务状态\n\ntypedef struct {\n\tuint8_t TaskRunTime;\n\tuint8_t TaskTimer;\n\tTaskStatus Status;\n\tvoid (*FC)();\n}TaskStrust;//任务信息块：注意两点1.注意Timer和runtime的数据类型为uchar，最大为255 2.时间片为2ms\nTaskStrust TaskList[]={0};\n\nvoid OS_Init(TIM_HandleTypeDef* htim){\n\tHAL_TIM_Base_Start_IT(htim);\n\tTaskCount = sizeof(TaskList)/sizeof(TaskList[1]);\n\tif(TaskCount > MAX_TASK) while(1);\n}\n\nvoid OS_IT_Run(void){\n\tuint8_t i;\n\tfor(i = 0;i < TaskCount;i++){\n\t\tif(TaskList[i].Status == wait){\n\t\t\tif(++TaskList[i].TaskTimer >= TaskList[i].TaskRunTime){\n\t\t\t\tTaskList[i].TaskTimer = 0;\n\t\t\t\tTaskList[i].Status = run;\n\t\t\t}\t\t\n\t\t}\n\t}\n\n}\n//自带死循环，主函数里运行\nvoid OS_Run(void){\n\tuint8_t j = 0;\n\twhile(1){\n\t\tif(TaskList[j].Status == run){\n\t\t\tTaskList[j].FC();\n\t\t\tTaskList[j].Status = wait;\n\t\t}\n\t\tif(++j >= TaskCount) j = 0;\n\t}\n}\n```\n\n## 频率测量\n\n核心思路：\n\n1/（（这一次的计数值-上一次记录的计数值）x （1/时钟频率））= 时钟频率/（记录差值）\n\n\n```c\ntypedef struct {\n    uint8_t i;//记录当前是第几次。\n    int former;//前一次记录的计数值\n    int now;//现在记录的计数值\n    int result;//频率结果\n    uint8_t ElapsedTime;//定时器溢出次数\n}FreqInfo;\n\nreqInfo F1 = {0};\nFreqInfo F2 = {0};\n\n//启动频率测量\nvoid Freq_Start(void){\n    HAL_TIM_Base_Start_IT(&htim3);//对应F1\n    HAL_TIM_IC_Start_IT(&htim3,TIM_CHANNEL_1);\n    HAL_TIM_Base_Start_IT(&htim8);//对应F2\n    HAL_TIM_IC_Start_IT(&htim8,TIM_CHANNEL_1);\n}\n\nstatic void Freq_Measure(FreqInfo* Fx,TIM_HandleTypeDef *htim){\n    if(Fx->i == 0){\n        Fx->result = 1000000/(Fx->now - Fx->former);\n        __HAL_TIM_ENABLE(htim);\n    }\n}\n\nvoid Freq_Fuc(void){\n    Freq_Measure(&F1,&htim3);\n\tFreq_Measure(&F2,&htim8);\n}\n\t\n//中断\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim){\n\n    if(htim->Instance == TIM3){\n        switch(F1.i){\n            case 0: \n                F1.former = HAL_TIM_ReadCapturedValue(&htim3,TIM_CHANNEL_1) + 65535 * F1.ElapsedTime;\n                F1.i = 1;\n                break;\n            case 1:\n                F1.now = HAL_TIM_ReadCapturedValue(&htim3,TIM_CHANNEL_1) + 65535 * F1.ElapsedTime;\n                __HAL_TIM_DISABLE(&htim3);\n                F1.ElapsedTime = 0;\n                F1.i = 0;\n                break;\n            default:break;\n        }\n    }\n\n    else if(htim->Instance == TIM8){\n        switch(F2.i){\n            case 0:\n                F2.former = HAL_TIM_ReadCapturedValue(&htim8,TIM_CHANNEL_1) + 65535 * F2.ElapsedTime;\n                F2.i = 1;\n                break;\n            case 1:\n                F2.now = HAL_TIM_ReadCapturedValue(&htim8,TIM_CHANNEL_1) + 65535 * F2.ElapsedTime;\n                __HAL_TIM_DISABLE(&htim8);\n                F2.ElapsedTime = 0;\n                F2.i = 0;\n                break;\n            default:break;\n        }\n    }\n}\n\n//在溢出中断中记录溢出次数\n\n```\n\n## 共享变量\n```c\n#include \"SharedData.h\"\n\n//初始化\nstatic Data1 shareddata1 = {0,0};\n\n//获取Data1指针的接口\nData1* get_shared_data(void) {\n    return &shareddata1;\n}\n\n```\n## 按键\n```c\nuint8_t KeyBit(void){\n    uint8_t keybit = 0x00;\n    //读取B1的电平状态并把他左移到bit0位\n    keybit |= HAL_GPIO_ReadPin(B1_GPIO_Port,B1_Pin) << 0;\n    //同上\n    keybit |= HAL_GPIO_ReadPin(B2_GPIO_Port,B2_Pin) << 1;\n    keybit |= HAL_GPIO_ReadPin(B3_GPIO_Port,B3_Pin) << 2;\n    keybit |= HAL_GPIO_ReadPin(B4_GPIO_Port,B4_Pin) << 3;\n    return keybit;\n}\n\nvoid task_Key(void){\n\tstatic uint8_t Trg,Cont;\n    unsigned char ReadData = KeyBit() ^ 0x0f;   \t// 取反：在没有按键按下的情况下，其始终为0x00\n    Trg = ReadData & (ReadData ^ Cont);             // 2\n    Cont = ReadData; \n    if(Trg && Cont){};\n    if(Trg && Cont == 0){};\n}\n```\n\n## LCD\n引脚初始化为全低就行\n\n## LED\nLD口 为 PD2 低电平不允许写入，高电平允许写入。\n```c\n#include \"LED.h\"\n#include \"SharedData.h\"\n\nuint16_t LD_state = 0;  //记录LD各位状态\nuint16_t LD_state_before = 0; \n\nvoid LED_init(void){\n\tHAL_GPIO_WritePin(LD1_GPIO_Port,GPIO_PIN_All,GPIO_PIN_SET);\n\tHAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_SET);\n\tHAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_RESET);\n}\n\nvoid LED_lightLD(uint8_t LDnum){\n\t\t\n\tLD_state |= (LD1_Pin << LDnum); //其他位不变，需要改变的位变为1\n\t\t\n\t\n}\n\nvoid LED_closeLD(uint8_t LDnum){ \n\n\tLD_state &= ~(LD1_Pin << LDnum); //其他位不变，需改变的位变为0\n\t\n}\n\n\nvoid Call_ChangeLD(void(*fc)(uint8_t),uint8_t LDnum){\n\t\n\tLDnum -= 1;\n\tfc(LDnum);\n\tif(LD_state_before != LD_state){\n\t\tHAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(LD1_GPIO_Port,GPIO_PIN_All,GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(LD1_GPIO_Port,LD_state,GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_RESET);\n\t\tLD_state_before = LD_state;\n\t}\n\telse return;\n\t\n}\n\nvoid LED_Fuc(void){\n\n\tif(Read_Show_index(0)) {\n\t\tCall_ChangeLD(LED_closeLD,1);\n\t\tCall_ChangeLD(LED_lightLD,2);\n\t}\n\telse {\t\n\t\tCall_ChangeLD(LED_closeLD,2);\n\t\tCall_ChangeLD(LED_lightLD,1);\n\t}\n\tif(Read_Show_index(1)){\n\t\tCall_ChangeLD(LED_lightLD,8);\n\t}\n\telse Call_ChangeLD(LED_closeLD,8);\n\t\n}\n```\n\n## 串口重定向与数据处理\n```c\n#define BUFFER_SIZE 50\n#define CMDNUM 6\n\n\nvoid TF1(void);\nvoid TF2(void);\nvoid PF1(void);\nvoid PF2(void);\nvoid returnF1(void);\nvoid returnF2(void);\n\n\nchar rx_DataBuffer[BUFFER_SIZE] = {0};\nchar tx_DataBuffer[BUFFER_SIZE] = {0};\nchar cmd[BUFFER_SIZE] = {0};\n\nuint16_t tx_len = 0;  // 当前缓冲区数据长度\nuint8_t tx_busy = 0;  // 发送状态标志\n\nuint8_t rx_handle = 0; //处理接收数据标志\nuint8_t rx_len = 0;\n\ntypedef struct{\n    uint8_t* cmd_str;\n    void (*fc)();\n}cmdinfo;\n\n\ncmdinfo cmdlist[] = {\n    {\"TF1\",TF1},\n    {\"TF2\",TF2},\n    {\"PF1\",PF1},\n    {\"PF2\",PF2},\n    {\"F1\",returnF1},\n    {\"F2\",returnF2}\n};\n\nvoid TheUART_start(void){\n    HAL_UARTEx_ReceiveToIdle_DMA(&huart1,(uint8_t*)rx_DataBuffer,0x0f);\n}\n\nvoid TheUART_dma_transmit(void)\n{\n    // 如果 DMA 还在忙，则不启动新的传输\n    if (tx_busy) return;\n\n    tx_busy = 1;  // 标记为发送中\n    HAL_UART_Transmit_DMA(&huart1,(uint8_t*)tx_DataBuffer,tx_len-1);//-1为了防止傻逼烂桥杯的验证程序不通过\n}\n\n\nint fputc(int ch, FILE *f)\n{\n    // 确保缓冲区不会溢出\n    if (tx_len < BUFFER_SIZE - 1)\n    {\n        tx_DataBuffer[tx_len++] = (uint8_t)ch;\n    }\n\n    // 如果遇到换行符，或者缓冲区接近满，就启动 DMA 发送\n    // 注意咯，如果缓冲区没满的情况下，只有检测到/n才会触发DMA的发送。所以在缓\n    // 冲区没满的情况下，如果你想要发送字符串\"abc\"，printf(\"abc\")是没用的，\n    // printf(\"abc\\n\")才有用哦。\n\n    \n    if (ch == '\\n' || tx_len >= BUFFER_SIZE - 1)\n    {\n        TheUART_dma_transmit();\n    }\n\n    return ch;\n}\n\n\nvoid TheUART_HandleRxdata(void){\n\n    if(rx_handle == 1){\n\n        uint8_t i = 0;\n        strcpy(cmd,rx_DataBuffer);\n        cmd[rx_len] = '\\0';\n        if(!Read_Show_index(1)){\n            other();\n            rx_len = 0;\n            rx_handle = 0;\n            TheUART_start();\n            return;\n        }\n        for(i = 0;i < CMDNUM;i++){\n            if(strcmp((const char*)cmd,(const char*)cmdlist[i].cmd_str) == 0){\n                cmdlist[i].fc();\n                rx_len = 0;\n                rx_handle = 0;\n                TheUART_start();\n                return;\n            }\n        }\n        other();\n        rx_len = 0;\n        rx_handle = 0;\n        TheUART_start();\n    }\n    else return;\n}\n\n//命令函数\nvoid TF1(void){\n\n}\n\nvoid TF2(void){\n\n}\n\nvoid PF1(void){\n\n}\n\nvoid PF2(void){\n\n}\n\nvoid returnF1(void){\n\n}\n\nvoid returnF2(void){\n\n}\n\nvoid other(void){\n}\n\n//中断\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)\n{\n    if(huart->Instance == USART1)  // 确保是目标串口\n    {\n        tx_len = 0;  // 清空缓冲区\n        tx_busy = 0; // 标记为可用\n    }\n}\n\nvoid HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size){\n\n    if(huart->Instance == USART1){\n        rx_len = Size;\n        rx_handle = 1;\n    }\n\n}\n```\n\n## ADC：使用定时器TRGO信号触发ADC转换\n```c\ndouble ADC_Data = .0;\n\nvoid ADCFuc_Init(ADC_HandleTypeDef *hadc){\n    HAL_ADCEx_Calibration_Start(hadc,ADC_SINGLE_ENDED);//校准\n    HAL_ADC_Start_IT(hadc);\n}\n\n\nchar ADCFuc_ReturnResult(void){\n    double result = ADC_Data;\n    result = (result / 4095.0) * 3.3;\n}\n\n\n//中断-------------------------------------------------------------//\nvoid HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc){\n\n    if(hadc->Instance == ADC2){\n        ADC_Data = HAL_ADC_GetValue(&hadc2);\n    }\n}\n```\n\n## at24c02\n```c\ninclude \"i2c_hal.h\"\n\n#define COMMAND_W   0xA0\n#define COMMAND_R   0xA1\n\nvoid at24c02_Init(void){\n    I2CInit();\n}\n\n/// @brief at24c02写数据\n/// @param address 要写入的地址\n/// @param data 要写入的数据\nvoid at24c02_Write(uint8_t address,uint8_t data){\n    \n    I2CStart();\n\n    I2CSendByte(COMMAND_W);\n    I2CWaitAck();\n\n    I2CSendByte(address);\n    I2CWaitAck();\n\n    I2CSendByte(data);\n    I2CWaitAck(); \n\n    I2CStop();\n}\n\n/// @brief at24c02读数据\n/// @param address 要读数据的地址\n/// @return 读出的数据\nuint8_t at24c02_Read(uint8_t address){\n    uint8_t data = 0;\n    I2CStart();\n\n    I2CSendByte(COMMAND_W);\n    I2CWaitAck();\n\n    I2CSendByte(address);\n    I2CWaitAck();\n\n    I2CStart();//不释放总线的情况下重启通信，发送读命令。\n\n    I2CSendByte(COMMAND_R);\n    I2CWaitAck();\n\n    data = I2CReceiveByte();\n    I2CSendNotAck();//通知从机不再发送数据\n\n    I2CStop();\n\n    return data;\n}   \n\n```\n\n## 韩信在干嘛？韩信在偷塔！能做到吗？哇他出了一个名刀·司命！猫雷！\n挂一张梦老师保佑！\n![](https://tiebapic.baidu.com/forum/w%3D580%3B/sign=770517cb7fdbb6fd255be52e391faa18/8326cffc1e178a829fdedc90b003738da977e824.jpg?tbpicau=2025-04-12-05_1fd40d1758be922db3d2562ec3e230c3)","tags":["蓝桥杯"],"categories":["嵌入式","程序架构"]},{"title":"hexo主题Klise-enhanced使用文档","url":"/posts/20333/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n## 说明\n\n本主题是根据dewjonh的hexo主题[Klise](https://github.com/dewjohn/hexo-theme-Klise)改的，我非常喜欢这款主题，但是由于此主题原作者好像不再维护，对hexo的现版本（2024）的适配不太好，于是便自己修修补补用着🙂但是由于我没有太多的精力分配在前端上，所以有些代码可能有些不专业，希望各位大佬见谅并指正。当然如果有任何bug请尽管issue，我会尽力修复！\n\n## 主题概览\n\n![](Snipaste_2025-04-06_15-26-39.png)\n\n![](Snipaste_2025-04-06_15-27-19.png)\n\n![](Snipaste_2025-04-06_15-27-54.png)\n\n你可以查看[demo](https://im.godmao.top/)或[我的博客](https://im.godmao.top/)来阅览主题效果。\n\n## 相较于原版有何改动\n\n- 😢把scss全编译为css了，只有一个main.css文件，包含了所有的渲染样式....不过不用担心我注释了嘻嘻🤓\n- 将原主题的深色模式进一步适配，并修改了一些元素的显示风格。\n## 使用方法\n\n### 首先，\n你需要下载一个字数统计插件:\n```bash\nnpm install hexo-wordcount --save\n```\n\n如果不想要下载或无法下载成功，你也可以放弃字数统计功能。前往主题文件夹下的`layout\\post.ejs`删除\n```ejs\n字数: <span class=\"post-count\"><%= wordcount(page.content) %></span>\n\n预计阅读时间: <span class=\"post-count\"><%= min2read(page.content) %>min</span>\n```\n两行。\n\n### 然后，\n安装主题文件\n```bash\ngit clone https://github.com/g0dmao/hexo-theme-Klise-enhanced.git\n```\n\n将主题根目录的`_config.hexo-theme-Klise-enhanced.yml`移动到博客根目录。你可以打开该文件进行主题的一些配置。\n\n在博客配置文件`_config.yml`中启用主题。\n\n### 最后，\nenjoy！\n\n## 个性化部分\n\n### 自定义背景\n打开主题文件夹下的`source\\css\\main.css`在头部修改，可以自定义明暗模式下不同的背景，已做好注释。\n\n### 当网页失去焦点时标签页标题的显示文字\n打开主题文件夹下的`layout\\layout.ejs` 修改document.title即可。\n```html\n<script defer>\n\n  document.addEventListener('visibilitychange', function () {\n\n  if (document.visibilityState == 'hidden') {\n\n      normal_title = document.title;\n\n      document.title = '点一下';\n\n  } else document.title = normal_title;\n\n});\n\n</script>\n```\n### 可选\n你可以安装如下插件获得更好的浏览体验。\n#### hexo-renderer-markdown-it-plus\n不使用自带的md渲染器。使用markdown-it渲染器，丰富的插件提供更好的md浏览体验。\n\n####  hexo-tips\n在文章中生成各种提示卡片，此主题已做好适配。\n\n#### hexo-blog-encrypt\n文章加密插件。\n\n## 可能的问题\n\n### tags、categories页面显示不正确\n首先检查页面的路径设置是否正确。若正确则试着在相应页面的`index.md` 里添加type和layout标签：\n![](Snipaste_2025-04-06_16-18-33.png)\ntags页面 type、layout 为tags。\ncategories页面 type、layout 为 categories。","tags":["网页","hexo主题"],"categories":["其他"]},{"title":"从c底层到嵌入式驱动开发的学习参考路线","url":"/posts/25619/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n以下是专为 **嵌入式Linux驱动开发工程师** 设计的 **学习路线**，整合了目标、重点、时间分配、书籍推荐和实战建议，力求清晰高效。由`deepseekR1`生成。\n\n---\n\n### **一、学习路线总图**\n```mermaid\ngraph LR\n  A[C语言+硬件] --> B[操作系统+驱动基础] --> C[驱动专项+内核机制] --> D[实战深化]\n```\n\n---\n\n### **二、分阶段详解**\n#### **阶段1：C语言与硬件交互（1-2个月）**\n**目标**：  \n- 掌握C语言底层操作能力，理解程序如何直接控制硬件。  \n\n**核心内容**：\n\n| **知识点**         | **必要程度** | **深入程度**       | **推荐书籍/资源**             |\n|--------------------|--------------|--------------------|------------------------------|\n| 指针与内存管理     | ★★★★★        | 理解内存布局       | 《C程序设计语言》（K&R）      |\n| 结构体与位操作     | ★★★★☆        | 能操作寄存器       | 《嵌入式C语言自我修养》        |\n| 汇编基础           | ★★★☆☆        | 阅读简单汇编       | 《ARM Cortex-M权威指南》       |\n| 编译流程（GCC）    | ★★★★☆        | 熟悉预处理-链接    | CSAPP第3章                    |\n| 硬件交互（GPIO）   | ★★★★☆        | 裸机程序开发       | STM32官方手册                 |\n\n**实践项目**：  \n1. 用STM32直接操作寄存器点亮LED（无需库函数）。  \n2. 用C实现内存池分配器（模拟`malloc/free`）。  \n\n**工具**：  \n- **STM32CubeIDE**：调试裸机程序。  \n- **objdump**：反汇编查看代码生成。  \n\n**对Linux的用处**：  \n- 理解驱动中 **寄存器映射**（如`ioremap`）。  \n- 诊断 **内存越界** 和 **硬件访问错误**。  \n\n---\n\n#### **阶段2：操作系统核心+驱动基础（2-3个月）**\n**目标**：  \n- 理解操作系统核心机制，入门Linux驱动开发。  \n\n**核心内容**：  \n\n| **知识点**         | **必要程度** | **深入程度**       | **推荐书籍/资源**             |\n|--------------------|--------------|--------------------|------------------------------|\n| 进程与线程         | ★★★☆☆        | 理解上下文切换     | 《操作系统导论》（OSTEP）     |\n| 虚拟内存           | ★★★★☆        | 页表工作原理       | 《深入理解计算机系统》第9章   |\n| 中断与异常         | ★★★★☆        | 中断处理流程       | 《Linux设备驱动程序》（LDD3） |\n| 内核模块开发       | ★★★★★        | 字符设备驱动       | LDD3第3章                    |\n| 设备树（DT）       | ★★★★☆        | 解析硬件配置       | 内核文档《Device Tree Usage》 |\n\n**实践项目**：  \n1. 编写虚拟字符设备驱动（实现`read`/`write`）。  \n2. 为LED驱动添加设备树支持（`.dts`文件配置）。  \n\n**工具**：  \n- **QEMU**：模拟ARM设备运行Linux。  \n- **dmesg**：查看内核日志。  \n\n**对Linux的用处**：  \n- 掌握驱动开发框架（`file_operations`）。  \n- 理解 **设备树** 如何解耦硬件配置。  \n\n---\n\n#### **阶段3：驱动专项+内核机制（3-6个月）**\n**目标**：  \n- 精通主流驱动开发技术，深入内核核心机制。  \n\n**核心内容**：  \n\n| **知识点**         | **必要程度** | **深入程度**       | **推荐书籍/资源**             |\n|--------------------|--------------|--------------------|------------------------------|\n| GPIO/I2C/SPI驱动   | ★★★★★        | 完整驱动开发       | 《精通Linux设备驱动程序开发》 |\n| 中断处理           | ★★★★★        | 顶半部/底半部      | 内核源码`drivers/irqchip`     |\n| 内核同步机制       | ★★★★☆        | 自旋锁/RCU         | 《Linux内核设计与实现》第5章  |\n| DMA与内存管理      | ★★★☆☆        | 缓存一致性         | 内核文档《DMA-API-HOWTO》     |\n| 电源管理           | ★★★☆☆        | suspend/resume     | 内核文档《Power Management》  |\n\n**实践项目**：  \n1. 为树莓派开发I2C传感器驱动（如BMP280）。  \n2. 实现带中断的按键驱动（`request_irq`）。  \n\n**工具**：  \n- **逻辑分析仪**：抓取SPI/I2C时序。  \n- **perf**：分析驱动性能瓶颈。  \n\n**对Linux的用处**：  \n- 掌握真实硬件驱动开发流程。  \n- 理解内核 **并发控制** 和 **中断优化**。  \n\n---\n\n#### **阶段4：实战深化（持续学习）**\n**目标**：  \n- 参与真实项目，解决复杂问题。  \n\n**核心内容**：  \n\n| **知识点**         | **必要程度** | **深入程度**       | **推荐资源**                 |\n|--------------------|--------------|--------------------|------------------------------|\n| 内核子系统         | ★★★★☆        | 输入/IIO子系统     | 内核源码`drivers/input`       |\n| 调试与调优         | ★★★★☆        | ftrace/kgdb        | 内核文档《ftrace使用指南》    |\n| 社区贡献           | ★★★☆☆        | 提交内核补丁       | LKML（Linux内核邮件列表）     |\n\n**实践项目**：  \n1. 为开源驱动修复Bug（如内核Bugzilla中的简单问题）。  \n2. 优化驱动性能（减少中断延迟或内存占用）。  \n\n**工具**：  \n- **git**：管理内核代码修改。  \n- **checkpatch.pl**：检查代码规范。  \n\n**对Linux的用处**：  \n- 积累真实项目经验，提升工程能力。  \n- 理解Linux内核社区的协作方式。  \n\n---\n\n### **三、时间分配建议**\n| **阶段**               | **建议时长** | **核心目标**                     | **时间占比** |\n|------------------------|--------------|----------------------------------|--------------|\n| C语言与硬件交互        | 1-2个月      | 裸机操作寄存器                   | 15%          |\n| 操作系统+驱动基础      | 2-3个月      | 字符设备驱动+设备树              | 30%          |\n| 驱动专项+内核机制      | 3-6个月      | GPIO/I2C/中断驱动开发            | 40%          |\n| 实战深化               | 持续         | 项目经验+社区贡献                | 15%          |\n\n---\n\n### **四、驱动开发工程师核心能力**\n1. **硬件能力**：  \n   - 阅读芯片手册（如时钟配置、寄存器定义）。  \n   - 使用示波器调试I2C/SPI通信问题。  \n\n2. **内核能力**：  \n   - 编写符合内核编码规范（`checkpatch.pl`）的代码。  \n   - 理解设备模型（总线/设备/驱动）。  \n\n3. **调试能力**：  \n   - 分析内核Oops和Panic日志。  \n   - 使用`trace-cmd`跟踪函数调用链。  \n\n---\n\n### **五、学习建议与避坑**\n1. **必做**：  \n   - 每天阅读内核驱动源码（如`drivers/gpio`）。  \n   - 用真实硬件（树莓派/BeagleBone）替代仿真。  \n\n2. **避免**：  \n   - 沉迷自制操作系统内核（除非目标为内核研发）。  \n   - 过早研究编译器后端优化（如LLVM Pass）。  \n\n3. **捷径**：  \n   - 直接参考内核中类似驱动的实现（如`drivers/i2c/busses/i2c-bcm2835.c`）。  \n   - 参与开源社区（从文档改进开始）。  \n\n---\n\n### **六、驱动开发面试常见问题**\n- **基础问题**：  \n  - 解释`platform_driver`和`platform_device`的作用。  \n  - 自旋锁为什么不能在睡眠场景使用？  \n\n- **实战问题**：  \n  - 如何为一个新硬件编写设备树节点？  \n  - 驱动中出现`Unable to handle kernel paging request`如何调试？  \n\n---\n\n按此路线，**12-18个月** 可达到嵌入式Linux驱动工程师的入职要求。**记住：驱动开发的本质是“用软件精确描述硬件行为”**，保持对硬件的敏感度是关键！","tags":["嵌入式","学习路线"],"categories":["嵌入式"]},{"title":"Kelly McGonigal, Ph.D.《自控力》第四章阅读感悟","url":"/posts/57146/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。摘录自微信读书。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n# 04 容忍罪恶：为何善行之后会有恶行？\n\n## 警惕“放纵许可”\n\n>  不是每一次自控力失效都是因为真的失去了控制。有时，我们是有意识地选择了在诱惑面前屈服。\n\n>  我们要思考一下，这整个过程如何削弱了我们的动力，乐观精神如何允许我们放纵自己，为什么觉得自己品德高尚反而是通往罪恶的快速通道。每一次我们都会发现，放弃抵抗是一种选择，而且并非不可避免。了解我们是如何给自己许可的，能让我们学会如何不离正轨。\n\n>  当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。\n\n>  当你做善事的时候，你会感觉良好。这就意味着，你更可能相信自己的冲动。而冲动常常会允许你做坏事。\n\n>  他们只是被自己之前良好的行为所蒙蔽，没看到这些决定会带来的伤害而已。\n\n>  如果你去锻炼了就说自己很“好”，没去锻炼就说自己很“坏”，那么你很可能因为今天去锻炼了，明天就不去了。\n\n>  简单说来，只要我们的思想中存在正反两方，好的行为就总是允许我们做一点坏事。\n\n>  他们这样为自己辩解：“我已经这么好了，应该得到一点奖励。”这种对补偿的渴望常常使我们堕落。因为我们很容易认为，纵容自己就是对美德最好的奖励。我们忘记了自己真正的目标，向诱惑屈服了。\n\n>  如果按照这个荒谬的逻辑，我们可以把所有的自我放纵都变成引以为傲的事。（信用卡账单会让你产生负罪感吗？怎么会呢，起码你没有因为要付账单而去抢银行！）\n\n>  我们通常相信本能，只有当需要解释自己的判断时，我们才寻求逻辑。\n\n>  因为过去的善行而感觉良好，这让你为今后的纵容找到了借口。当你觉得自己像个圣人的时候，纵容自己的念头听起来没什么错。它听起来很正确，就像是你应得的一样。如果你自控的唯一动力就是成为一个足够好的人，那么每当你自我感觉良好的时候，你就会放弃自控。\n\n>  它让我们相信，放弃节食、打破预算、多抽根烟这些不良行为都是对自己的“款待”。这很疯狂，但对大脑来说，它有可怕的诱惑力，能让你把“想做的事”变成“必须做的事”。\n\n>  我们用大吃甜食、熬夜晚睡、信用卡负债来判断自己是善还是恶。但是，这些事无法真正体现什么是罪恶，什么是美德。当我们从道德的角度思考自己面对的意志力挑战时，我们就失去了自我判断能力，看不到这些挑战有助于我们得到自己想要的东西\n\n>  进步可能让我们放弃曾经为之奋斗的东西。\n\n>  当你取得进步的时候，你的大脑就停止了思维进程，而这个进程正是推动你追求长远目标的关键。然后，那个放纵自我的声音就会响起来，你就会转而关注那些还没有得到满足的目标。心理学家称之为“目标释放”。你曾努力克制的目标会变得更加强大，诱惑也会变得更加难以抵挡。\n\n>  但关注进步确实会让我们离成功越来越远。\n\n>  在大多数情况下，我们总在寻找停下来的理由。\n\n>  你不应该想着“我做到了，好了，现在我可以做点我真正想做的事了！”应该想着“我做这件事是因为我想要……”\n\n>  记住我们为什么会拒绝诱惑，这是个很有效的办法。\n\n>  所谓的奖励看起来更像对目标的威胁，屈服于诱惑的感觉并不好。记住理由还有助于你发现并抓住机遇，以便完成目标。\n\n>  下一回，当你发现自己在用曾经的善行给现在的放纵作辩护时，停下来想一想，你当时为什么能拒绝诱惑。\n\n## 明日复明日、拖延\n\n>  这很好地解释了，我们想到未来的选择时，就会很容易犯下大错。我们不断期望明天能作出和今天不同的选择，但这种期望是错误的\n\n>  这种乐观精神让我们能在今天放纵自己——尤其是当你确信自己下次不会作出同样选择的时候。\n\n>  如果我们现在表现糟糕，却用对未来的乐观期待来掩饰它，那么还不如一开始就不要设定这个目标。\n\n>  帮助人们克服这种“明日复明日”的想法。当你想改变某种行为的时候，试着减少行为的变化性，而不是减少那种行为。\n\n>  我们都希望说服自己，我们想要的东西并没有那么坏。正如你将要看到的，我们迫切想给诱惑我们的对象加以道德标准，好让我们在放纵自己的时候毫无负罪感。\n\n## 警惕“光环效应”\n\n>  当我们想获得放纵许可的时候，我们会寻找任何一个美德的暗示，为自己放弃抵抗作辩护。\n\n>  只要使你放纵的东西和使你觉得品德高尚的东西同时出现，就会产生光环效应。\n\n>  你会不会因为关注一个事物最有益的品质，而允许自己沉溺于它？\n\n>  当“光环效应”影响到你的意志力挑战时，你需要找到最具体的测量标准（比如卡路里、花费、消耗或浪费的时间），以此判断这个选择是否和你的目标相符。\n\n>  只要某些事让我们觉得自己尽力了，不用再担心那些问题了，我们就会蜂拥而上。而一旦我们的罪恶感和焦虑消失了，我们就会觉得可以重新开始一贯浪费的生活方式了。\n\n>  从本质上看，道德许可就是一种身份危机。我们之所以会奖励自己的良好行为，是因为我们内心深处认为，真正的自己想做坏事。从这点来看，每次自控都是一种惩罚，只有放纵自我才是奖励。但我们为什么一定要这样看待自己呢？想要走出“道德许可”的陷阱，我们就要知道，那个想变好的自己才是真正的自己，想按核心价值观生活的自己。如此一来，我们就不会认为那个冲动、懒散、容易受诱惑的自己是“真正”的自己了。\n\n>  如果只按照“正确”和“错误”来判断做过的事，而不是牢记我们真正想要的东西，就会带来与目标相抵触的冲动，并允许我们做出妨碍自己的行为。想要做到始终如一，我们就需要认同目标本身，而不是我们做善事时的光环。\n\n## 思考\n\n这一章对我来说帮助很大，我就一直陷入了完成目标->放纵这样的怪圈。实际上，对所做的事加以道德标准，也就是用”好“与”坏“衡量一件事其实是一个思维陷阱。如果这样做，你就会为自己的放纵找到理由——我都做了这么多”好“事了，偶尔做做”坏“事也不要紧。我们很容易认为，纵容自己就是对美德最好的奖励。我们忘记了自己真正的目标，向诱惑屈服了。本章还提到了两个有意思的观点：”进步可能让我们放弃曾经为之奋斗的东西“、”道德高尚之人更可能走上犯罪道路“，这两个观点也可以用”道德许可“加以解释。所以我们不应该为自己做过的”好“事而蒙蔽双眼，那只是一件事，而无任何属性!!别引申到坏事!!。\n\n而”光环效应“则是对”道德许可“的延申，它指出如果使你放纵的东西和使你觉得品德高尚的东西同时出现，这会更让你放纵得无负罪感，你会不会因为关注一个事物最有益的品质，而允许自己沉溺于它？比如，你的目标是学习一下午，而你却捣鼓了一天你的博客，你会说”好吧其实捣鼓博客也学习到了很多东西“，而你真正得目标却被忽视。\n\n关于拖延问题，我们总是会高估明天的自己。认为明天的自己是完美的，我们想到未来的选择时，就会很容易犯下大错。我们不断期望明天能作出和今天不同的选择，但这种期望是错误的。如果你今天表现”糟糕“，那么明天大概率也是一样的。如何克服这种问题呢？当你想改变某种行为的时候，试着减少行为的变化性，而不是减少那种行为。比如你抽烟，今天抽一包，那你明天也抽一包，后天也抽一包，这样每支烟就不仅仅代表着今天的这一支，你还会联想到：我的天哪，我今天抽完明天还要抽这么多，这太可怕了。然后你就有意识的减少吸烟频率。但是我感觉这种方法对我来说没什么用。只作记录\n\n凯利博士告诉我们如何真正地看待问题。如果只按照“正确”和“错误”来判断做过的事，而不是牢记我们真正想要的东西，就会带来与目标相抵触的冲动，并允许我们做出妨碍自己的行为。**想要做到始终如一，我们就需要认同目标本身，而不是我们做善事时的光环。**\n\n**我们之所以会奖励自己的良好行为，是因为我们内心深处认为，真正的自己想做坏事。从这点来看，每次自控都是一种惩罚，只有放纵自我才是奖励。但我们为什么一定要这样看待自己呢？** 想要走出“道德许可”的陷阱，我们就要知道，那个想变好的自己才是真正的自己，想按核心价值观生活的自己。如此一来，我们就不会认为那个冲动、懒散、容易受诱惑的自己是“真正”的自己了。\n","tags":["阅读感悟","自控力"],"categories":["阅读"]},{"title":"三行代码实现按键的长短按检测","url":"/posts/862/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 话不多说直接上代码\n\n```c\nuchar cont,trg;    //triger触发 continue连续\nvoid KeyScan()\n{\n\tuchar ReadData =  PINB^0xff;\n\ttrg = ReadData & (ReadData^cont);\n\tcont = ReadData;\n}\n```\n\n就完事了，灰常的amzing啊。\n\n## 尝试理解\n\n首先我们要理解`PINB`，这里的`PINB`指的是我们的单片机GPIOB的所有Pin的端口数据，而每个端口的数据（高/低——1/0）对应1个bit位。例如某单片机有八个端口只有端口0为高，其余皆为低，则PINB=0000 0001。在STM32Hal库中，我们可以这样实现：\n```c\nuint8_t KeyBit(void){\n    uint8_t keybit = 0x00;\n    //读取B1的电平状态并把他左移到bit0位\n    keybit |= HAL_GPIO_ReadPin(B1_GPIO_Port,B1_Pin) << 0;\n    //同上\n    keybit |= HAL_GPIO_ReadPin(B2_GPIO_Port,B2_Pin) << 1;\n    keybit |= HAL_GPIO_ReadPin(B3_GPIO_Port,B3_Pin) << 2;\n    keybit |= HAL_GPIO_ReadPin(B4_GPIO_Port,B4_Pin) << 3;\n    return keybit; \n\n}\n```\n\n### 取反\n\n第一行代码就相当于是取反操作，使没有按键按下时data始终为0x00。\n\n注意，不一定就是异或0xff，按照上面的hal库方法，你的PINB变量实际上只有四位有效位，为了让没有按键按下时data为0x00，我们异或0x0f即可，或者将keybit初始化为0xf0然后异或0xff；而有时GPIO输入接了下拉，没有输入的情况本来就是0，这时就不需要再取反。反正就是要让它没有按键按下时等于0x00。\n\n<details>\n\n<summary>点击即看异或真值表</summary>\n\n与0异或不变，与1异或取反\n\n| A   | B   | A ⊕ B |\n| --- | --- | ----- |\n| 0   | 0   | 0     |\n| 0   | 1   | 1     |\n| 1   | 0   | 1     |\n| 1   | 1   | 0     |\n\n</details>\n\n### 单击按下\n\n第一次PB0按下的情况  \n端口数据原本为0xfe，ReadData读端口并且取反，变为 0x01 （第一行）。\n因为这是第一次按下，所以Cont是上次的值，应为为0。与0异或不改变原有值，那么第二行执行的实际是：\n```\nTrg = 0x01 & (0x01^0x00) = 0x01  \n``` \n\n将cont赋值\n\n```\nCont = ReadData = 0x01\n```\n结果就是：\n- ReadData ＝ 0x01\n- Trg ＝ 0x01\n- Cont ＝ 0x01\n\n### 按下后还没有完全松开（引申到长按）\n\n此时程序依然在执行。\n- 第一行：不变，依然为0x01。\n- 第二行：操作为——把检测到的按下按钮对应的bit为给置0了，让Trg等于0了\n- 第三行：不变，依然为0x01。\n\n我们可以看到唯一变了的地方就是Trg被置0了。\n\n### 完全松开\n很好理解，肯定全为0x00了。\n\n### 笔者的思考\n\n该代码的核心思路我认为是用三种不同的数据内容代表不同的三种情况（未按下、单按、长按）按照这种思路，我们甚至还可以扩展。\n\n`ReadData`存储原始的端口电平数据，不能改变。后续的两个数据都会基于这个原始数据。\n`Trg` 用于按键触发。`ReadData`中有bit位有上升沿时，Trg会记录这个上升沿：只有bit从0变为1，Trg才会置1。按下判断的条件是：`Trg`、`Cont`均为1。\n`Cont` 用于长按。长按的判断条件是：`Trg`为0的情况下`Cont`依然为1。\n\n这样的思路让我联想到了3-8译码器的巧妙设计，通过3个值的输入，可以得到8个值的输出，用3个值就可以为8个不同的情况进行处理。\n\n## 在STM32中使用\n\n附上我的使用方法，我使用的是[时间片轮询架构](http://im.godmao.top/posts/39448/)。\n\n```c\n\n#define B1 0x01\n\n#define B2 0x02\n\n#define B3 0x04\n\n#define B4 0x08\n\nuint8_t KeyBit(void){\n\n    uint8_t keybit = 0x00;\n\n    //读取B1的电平状态并把他左移到bit0位\n    keybit |= HAL_GPIO_ReadPin(B1_GPIO_Port,B1_Pin) << 0;\n    //同上\n    keybit |= HAL_GPIO_ReadPin(B2_GPIO_Port,B2_Pin) << 1;\n    keybit |= HAL_GPIO_ReadPin(B3_GPIO_Port,B3_Pin) << 2;\n    keybit |= HAL_GPIO_ReadPin(B4_GPIO_Port,B4_Pin) << 3;\n\n    return keybit;\n\n}\n\nvoid KeyFuc(void){//按键逻辑\n\n    static uint8_t i = 0;                           //长按时间计数器\n\n    //核心代码：三行代码完成按键单、长按检测\n\n    unsigned char ReadData = KeyBit() ^ 0x0f;       // 取反：在没有按键按下的情况下，其始终为0x00\n\n    Trg = ReadData & (ReadData ^ Cont);             // 2\n\n    Cont = ReadData;                                // 3                        \n\n    if(Trg && Cont){//单击逻辑      \n\n        switch(Trg){                            \n\n            case B4: Key4_Fuc();break;\n\n            case B3: Key3_Fuc();break;          \n\n            case B2: Key2_Fuc();break;          \n\n            case B1: Key1_Fuc();break;  \n\n            default: break;\n\n        }\n\n    }\n\n    if(Cont && 0 == Trg) i++;//以下为长按逻辑\n    else i = 0;\n    \n    if(i >= 20){\n        i = 0;\n\n        switch(Cont)\n        {\n\n            case B3: Key3_Fuc_Preesed();break;\n\n            default: break;\n\n        }\n\n    }\n\n  \n\n}\n\n```\n\n## 关于消抖问题\n\n~~不知道为什么，按理来说是需要消抖的，但是实际跑起来的时候没有消抖也非常稳，，，可能是我的按键检测任务执行间隔比较长？~~\n\n--- \n\n2025.03.28 补充修改：如果使用时间片轮询调度，理论上如果按键扫描任务执行间隔时间较长，是不用消抖的。这就解释了为什么我的程序没有消抖也那么稳！例如，假设你设置的时间片调度间隔是 100ms，如果按键每次扫描时是 100ms 执行一次，假设按键抖动的周期是 10ms，那么每次扫描时按键就已经稳定了。这样，按键的物理状态变化就不太可能被误判为多个状态变化，因为时间间隔本身已经足够长。当然代价是 **会牺牲按键响应速度，以及无法应用快速连按的按键逻辑**\n\n--- \n\n关于消抖我还没有实际上机跑过，但是也写一下，Deepseek写的：\n\n```c\n#define DEBOUNCE_TIME 1 //消抖时间参数，根据时间片的时间来设定\n\ntypedef enum {\n    KEY_STATE_IDLE,//空闲\n    KEY_STATE_PRESSED,//按下\n    KEY_STATE_RELEASED//松开\n} KeyState;\n\nKeyState key_state = KEY_STATE_IDLE;\n\nuint16_t debounce_timer = 0;\n\nvoid KeyScan() {\n    uchar ReadData = PINB ^ 0xff;\n    uchar new_trg = ReadData & (ReadData ^ cont);\n\n    switch (key_state) {\n        case KEY_STATE_IDLE:\n            if (new_trg != 0) { // 检测到按键变化\n                key_state = KEY_STATE_PRESSED;\n                debounce_timer = DEBOUNCE_TIME;\n            }\n            break;\n\n        case KEY_STATE_PRESSED:\n            if (debounce_timer > 0) {\n                debounce_timer --;\n            } else {\n                if (ReadData == (PINB ^ 0xff)) { // 确认按键状态\n                    trg = new_trg;\n                    cont = ReadData;\n\t\t    if(trg && cont){\n\t\t\t/*写单击逻辑*/\n\t\t    }\n                    key_state = KEY_STATE_RELEASED;\n                } else {\n                    key_state = KEY_STATE_IDLE;\n                }\n            }\n            break;\n\n        case KEY_STATE_RELEASED:\n            if (new_trg == 0) { // 等待按键释放\n                key_state = KEY_STATE_IDLE;\n            }\n            break;\n    }\n}\n```\n\n","tags":["程序架构","按键检测"],"categories":["嵌入式","程序架构"]},{"title":"嵌入式模块化设计中的数据共享优化方案","url":"/posts/58440/","content":"\n<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 问题的提出\n\n在嵌入式项目中，模块化每个功能有利于管理和理清开发思路，但是，当我们需要将模块联动起来的时候，需要一些必要的变量以实现两个模块之间的互相配合，最常见的方法是使用全局变量，但这样做使模块间耦合性[^1]大大提高了。\n\n## 有什么更好的方案吗\n\n有的兄弟有的。只不过要牺牲一些效率（需要通过接口访问）。我们可以为共享变量建立一个专门的.c/.h文件，例如`SharedData.c/.h`。\n这个文件集中管理模块间的共享变量。这样做结构清晰，每个模块**只依赖 `SharedData.h`，而不是彼此依赖**\\ \n同时我们通过两种方法使需要访问变量的模块成功读取或修改变量：\n- 结构体封装+指针传递\n- 通过函数提供读取和修改的接口\n\n## 结构体封装+指针传递\n\n:::recommend\n\n- 共享变量较多时非常好用。\n- **隐藏全局变量**，外部模块无法直接访问共享数据而是通过指针，安全性高。\n- 更好扩展。\n- 方便，无需为每个变量都写函数接口以提供修改与读取。\n- **访问速度快**。\n\n:::\n\n### .h文件\n```c\n#ifndef SHARED_DATA_H\n#define SHARED_DATA_H\n\ntypedef struct {\n    int sensor_value;\n    int motor_speed;\n} SharedData;\n\n// 只提供获取指针的接口，而不是直接暴露变量\nSharedData* get_shared_data(void);\n\n#endif\n```\n\n### .c文件\n\n```c\n#include \"shared_data.h\"\n\nstatic SharedData system_data = {0, 0}; // 只在本文件可见\n\nSharedData* get_shared_data() {\n    return &system_data;\n}\n```\n\n### 在其他模块中使用\n\n```c\n#include \"shared_data.h\"\n\nvoid moduleA_update() {\n    SharedData *data = get_shared_data();\n    data->sensor_value += 10;\n}\n```\n\n:::warning\n\n不推荐将**接收共享变量的指针的变量**定义为全局变量。尽管这样会方便一些。**指针可能被多个模块修改**，导致指向无效地址（增加 bug 风险）。推荐在每个函数内部通过接口访问变量。如果一定要这样做，请一定避免空指针（记住初始化指针）\n\n:::\n\n使用全局指针示例：\n```c\nstatic SharedData *data;  // 仅限当前文件访问\n\nvoid moduleA_init() {\n    data = get_shared_data();//避免空指针\n}\n```\n\n## 通过函数提供读取和修改的接口\n\n:::recommend\n\n- **灵活访问变量。你可以严格控制对数据的访问，如只读、避免非法值写入等；同时也可以自定义访问方法，如按位读取。非常的好用。**\n- 可扩展性强。\n\n:::\n\n:::error\n\n- 代码冗长，调用花销稍大。\n- 变量太多时需要为每个变量都写接口，太麻烦。所以才要和上面的方法联合起来使用，只为必要的变量编写接口，其余通过第一种方法访问。\n\n:::\n\n### .h文件\n\n```c\n#ifndef SHARED_DATA_H\n#define SHARED_DATA_H\n\nvoid setSensorValue(int value);\nint getSensorValue();\n\nvoid setMotorSpeed(int speed);\nint getMotorSpeed();\n\n#endif\n\n```\n\n### .c文件\n\n```c\n#include \"shared_data.h\"\n\nstatic int sensor_value = 0;\nstatic int motor_speed = 0;\n\nvoid setSensorValue(int value) {\n    if (value >= 0) {  // 限制非法值\n        sensor_value = value;\n    }\n}\n\nint getSensorValue() {\n    return sensor_value;\n}\n\nvoid setMotorSpeed(int speed) {\n    if (speed >= 0) {\n        motor_speed = speed;\n    }\n}\n\nint getMotorSpeed() {\n    return motor_speed;\n}\n\n```\n\n### 在其他模块中使用\n\n```c\n#include \"shared_data.h\"\n\nvoid moduleA_update() {\n    setSensorValue(getSensorValue() + 10);\n}\n```\n\n## 联合起来\n\n将两种方式联合起来使用——大部分变量，我们使用指针接口访问即可；如果有些变量需要一些个性化要求，我们为这些变量编写定制的接口就好。\n\n## 挖坑\n\n降低耦合性的方法还有使用单例模式，以及RTOS中的消息/事件机制。后续研究。\n\n[^1]: 代码耦合性（Coupling）是指模块或组件之间的依赖程度。如果代码耦合性很高，模块之间会紧密依赖，导致代码难以维护、扩展和测试。\n\n","tags":["嵌入式","程序架构","降低耦合"],"categories":["嵌入式","程序架构"]},{"title":"串口重定向的非阻塞方法","url":"/posts/18285/","content":"\n<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 常用方式\n\n有时我们需要串口打印信息到上位机，最便捷的方法是重定向 `printf()`，网上的常用方法如下：\n\n```c\n\nint fputc(int ch, FILE *f){    \n\tHAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xffff);\n    \n\treturn ch;   \n}\n\nint fgetc(FILE *f){\n    \n\tuint8_t ch = 0;\n\t    \n\tHAL_UART_Receive(&huart1, &ch, 1, 0xffff);\n\t    \n\treturn ch;   \n}\n\n```\n\n### 这样做的缺点\n\n- 这是 **阻塞模式**，每次 `printf()` 都要等待数据发送完毕，影响 CPU 执行效率。\n- 如果数据较多，会降低实时性，阻塞主循环。\n\n## 使用非阻塞的方式：灵活运用DMA\n\n我们使用DMA非阻塞发送。具体步骤如下：\n\n### 1. 定义缓冲区。\n\n根据fputc()的特性（这里先按下不表），使用 DMA 发送时，`printf()` 需要先把数据存到 **一个缓冲区**，然后一次性使用 DMA 发送出去。\n\n```c\n\n#define TX_BUFFER_SIZE 256  // 发送缓冲区大小\nuint8_t uart_tx_buffer[TX_BUFFER_SIZE];  // 串口发送缓冲区\nvolatile uint16_t tx_len = 0;  // 当前缓冲区数据长度\nvolatile uint8_t tx_busy = 0;  // 发送状态标志\n\n```\n\n### 2. 重定向 `fputc()`，使用缓冲区\n\n```c\n\nint fputc(int ch, FILE *f)\n{\n    // 确保缓冲区不会溢出\n    if (tx_len < TX_BUFFER_SIZE - 1)\n    {\n        uart_tx_buffer[tx_len++] = (uint8_t)ch;\n    }\n\n    // 如果遇到换行符，或者缓冲区接近满，就启动 DMA 发送\n    // 注意咯，如果缓冲区没满的情况下，只有检测到/n才会触发DMA的发送。所以在缓\n    // 冲区没满的情况下，如果你想要发送字符串\"abc\"，printf(\"abc\")是没用的，\n    // printf(\"abc\\n\")才有用哦。\n    if (ch == '\\n' || tx_len >= TX_BUFFER_SIZE - 1)\n    {\n        uart_dma_transmit();\n    }\n\n    return ch;\n}\n\n\n```\n\n### 3. 定义DMA 发送函数\n\n```c\n\nvoid uart_dma_transmit(void)\n{\n    // 如果 DMA 还在忙，则不启动新的传输\n    if (tx_busy) return;\n\n    tx_busy = 1;  // 标记为发送中\n    HAL_UART_Transmit_DMA(&huart1, uart_tx_buffer, tx_len);\n}\n\n```\n\n### 4. DMA 传输完成回调\n\n```c\n\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)\n{\n    if (huart->Instance == USART1)  // 确保是目标串口\n    {\n        tx_len = 0;  // 清空缓冲区\n        tx_busy = 0; // 标记为可用\n    }\n}\n\n```\n\n\n## 一些疑惑的解答\n\nQ: 茂神茂神，你的说的非阻塞方式的确很不错，但是还是太吃操作了，我就不能直接在 `fputc()`里写 `HAL_UART_Transmit_DMA`吗？\\\n\\\nA: 可以的兄弟可以的。`fputc()` 是发送一个字符对吧，理论上我们只需要把DMA传输的字节数改为1就行了对吧？nonono，首先DMA是非阻塞的对吧，也就是激活了它，他就只管发，不管你完没完成，你都可以再次激活它，如果像你这样做，当发送字符流时大概率是这种情况：\n> `fputc()`打电话给DMA的秘书说我要发这个字符，然后他就认为我已经给DMA说了叫它发送这个字符啦，所以这个字符就发出去啦，剩下就不关我的事啦。结果DMA秘书看到DMA此时还在忙于上次发送，于是判断DMA为`HAL_BUSY`没有办法把字符交给DMA。这个字符信息就丢失了。。。。","tags":["STM32","嵌入式","程序架构","串口"],"categories":["嵌入式","程序架构"]},{"title":"CubeMX配置功能系列：iic","url":"/posts/58129/","content":"\n<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 说明\n由于前面已经详细介绍了iic通信协议（详见[通信协议：iic [ g0dMa0's Blog ]](https://im.godmao.top/posts/55329/)），这里主要就硬件iic在cubemx中的配置作介绍。\n\n## 通道设置\n![](Snipaste_2025-03-12_14-59-01.png)\n哈哈没想到吧，iic通道不止支持iic协议，孩子。\\\nSMBus-系统管理总线，是iic的扩展。利用系统管理总线，设备可提供制造商信息，告诉系统它的型号/部件号，保存暂停事件的状态，报告不同类型的错误，接收控制参数，和返回它的状态。SMBus为系统和电源管理相关的任务提供控制总线。\\\nSMBus 为系统和电源管理这样的任务提供了一条控制总线，使用 SMBus 的系统，设备之间发送和接收消息都是通过 SMBus，而不是使用单独的控制线，这样可以节省设备的管脚数。\\  \n所以它与iic的区别很明显了，一个是该总线上连接设备自身可以控制总线(I2C，速率较高)，想干嘛就干嘛；另一个是设备之间可以通过它来传送信息，但是速率比较慢，比如用在检测各元件状态并更新硬件设置引脚等，同时廉价是它的优点。\\\n\\\n**SMBus-Alert**是一个带中断线的可选信号，用于那些希望扩展他们的控制能力而牺牲一个引脚的设备。SMBALERT和SCL和SDA信号一样，是一种线与信号。SMBALERT通常和SMBus广播呼叫地址一起使用。与SMBus有关的消息为2字节。**单一的从设备可以通过SMBALERT发信号给主机表示它希望进行通信**，这可通过设置I2C_CR1寄存器上的ALERT位实现。主机处理该中断并通过提醒响应地址ARA(Alert Response Address，地址值为0001100x)访问所有SMBALERT设备。只有那些将SMBALERT拉低的设备能应答ARA。此状态是由 I2C_SR1寄存器中的SMBALERT状态标记来标识的。主机执行一个修改过的接收字节操作。由从发送设备提供的7位设备地址被放在字节的7个最高位上，第八个位可以是0或1。如果多个设备把SMBALERT拉低，最高优先级设备(最小的地址)将在地址传输期间通过标准仲裁赢得通信权。在确认从地址后，此设备不得再拉低它的SMBALERT，如果当信息传输完成后，主机仍看到SMBALERT低，就知道需要再次读ARA。没有执行SMBALERT信号的主机可以定期访问ARA。有关SMBus提醒模式的更多详细资料，请参考2.0版的SMBus规范。**说白了还是通信，只不过是从机与从机的通信** \\\n我先忽略系统管理总线协议。专注于iic。\n## 主模式设置\n![](Snipaste_2025-03-12_17-56-13.png)\n\n### Custom Timing\n这个牛逼了，iiC通信依赖于特定的时序参数，如时钟频率、高低电平时间等。STM32CubeMX通常提供预定义的时序配置，适用于常见场景。但在某些情况下，预定义配置可能无法满足需求，这时就需要手动调整时序参数。\n\n通过“Custom Timing”，你可以根据具体需求调整以下参数：\n\n1. **SCL时钟频率**：设置SCL时钟的频率。    \n2. **SCL高低电平时间**：分别设置SCL高电平和低电平的持续时间。   \n3. **数据建立和保持时间**：设置数据在时钟边沿前后的稳定时间。\n4. **起始和停止条件时间**：设置起始和停止条件的持续时间。\n#### 使用场景\n- **非标准I2C设备**：某些设备可能需要特定的时序。\n- **优化性能**：在高噪声环境中，调整时序可以提高通信稳定性。  \n- **调试**：在调试时，手动调整时序有助于排查问题。\n#### 配置步骤\n1. 在CubeMX中启用I2C外设。\n2. 选择“Custom Timing”选项。\n3. 手动输入所需的时序参数。\n4. 生成代码并验证配置。\n#### 注意事项\n- 确保时序参数符合I2C规范和设备要求。\n- 错误的配置可能导致通信失败或损坏设备。\n通过“Custom Timing”，你可以更灵活地配置I2C通信，满足特定需求。\n#### 看完以后发现我还是不会用啊，，，，，\n\n### Timing \n这个是和上面那个一起用的，我猜是把Timing这个设定值写入某个寄存器里，然后这个寄存器的不同位控制着不同的时序参数，如高低电平时间什么的。没有深究。因为估计也不会用自定义时序。\n![](Snipaste_2025-03-12_18-39-27.png)\n自定义时序enable 后的界面如上图所示。\n\n### RiseTime/FallTime/Coefficient of Digital Filter\n控制iic上升沿/下降沿的时间，iic对于上下降沿的时间是有要求的。\\\n数字滤波器系数。不启用设置为0，启用则可设置为1-15，表示1-15个iic外设时钟。\\\n这三个参数要遵循一套非常复杂的时序计算方法的，也和对应的外设有关系，在设置前也要阅读相关的外设资料。此处暂且不展开。\n\n### Analog Filter\n模拟滤波器。\n\n## 从模式设置\n### Clock No Stretch Mode\n**IIC时钟拉伸(Clock stretching)**：\\\n有时候低速从机可能由于上一个请求还没处理完，无法继续接收主机的后续请求，**即主机的数据传输速率超过了从机的处理能力**。这种情况下，从机可以进行时钟拉伸来要求主机暂停传输数据 。通常时钟都是由主机提供的，从机只是在SDA上读数据或者发数据。\n时钟拉伸则是从机在主机释放SCL后，将SCL主动拉低并保持，此时要求主机停止在SCL上产生脉冲以及在SDA上发送数据，直到从机释放SCL（SCL为高电平）。之后主机便可以继续正常的数据传输了。可见时钟拉伸实际上是利用了时钟同步的机制，只是时钟由从机产生。 如果系统中存在这种低速从机并且从机实现了时钟拉伸，主机必须能够处理这种情况，**实际上大部分从机设备中不包含SCL驱动器的，因此无法拉伸时钟。**\n\n### Primary Address Length selection\n从设备地址长度 置从设备的地址是7bit还是10bit。大部分为7bit。\n\n### General call address\n**通用广播地址是为了寻址总线上所有设备。** 如果一个设备不需要使用广播功能，可以不响应广播。如果设备需要使用广播功能，则它在检测到广播地址后发送响应，并作为从机接收读取总线上发送的数据。主机不知道总线上有多少从机发送响应。**总线上所有可以响应广播的从机读取广播地址后的第二个及后面的字节。** 不能处理这些广播数据的从机通过不发送响应的方式忽略它。同样地，**如果有一个或一个以上的从机发送响应，则主机就检测不到总线上其它没有响应的设备。** 广播消息的含义总是定义在第二个字节。\n![](65d333b522f92fae6584d6d5cccc4de9.jpeg)\n<details>\n\n<summary>以下内容需要的时候再看</summary>\n\n有两种可能情况：\n\n- 最低位“B”为0\n- 最低位“B”为1\n\n- “B”为0，第二个字节包括以下定义：\n0000 0110（06h）：复位并通过硬件写内容到从机的可编程部分。所有可以响应此类广播的从机，收到此两字节后，进行复位并进入它们地址的可编程部分。注意确保设备在加电后不会将SDA或SCL拉低，因为这些低电平会阻塞总线；\n0000 0100（04h）：通过硬件写内容到从机的可编程部分，作用类似（06h），但设备不会复位；\n0000 0000（00h）：这个不应该作为第二个字节用。\n编程时序参考相应设备的DATASHEET。\\\n\n- “B”为1，两字节广播定义为“硬件广播”。主机在编程后，可以发送既定的从机地址到总线上，构成两字节序列的“硬件广播”。主机可能并不知道总线上从机的地址，它只能通过硬件广播的方式，将自身地址通知给系统。\n硬件广播的第二个字节的前七位包括主机的地址。总线上的智能设备如微控制器，读取此地址并接收主机发送的其它信息。如果主机也可以作为从机使用，则以上读取的主机地址实际上也就是（切换主从模式后的）从机地址。在系统中，一种可能是系统复位后设备由主机发送模式切换到从机接收模式，这时由系统主机先告诉硬件主机数据应送往的从机地址，这样当硬件主机发送数据时就可以直接向指定从机（地址）发送数据了。\n如下所示：\n\n</details>\n\n![](e76a7cecc118d861220014786be3e39b.jpeg)\n\n### Dual Address Acknowledged\n双地址确认。允许从机响应两个不同的地址。有啥用？？？？\n\n### Primary slave address\n从设备初始地址。不用填。\n\n\n## 参考资料\n- ⭐⭐⭐[I2C详解（二）_i2c general call-CSDN博客](https://blog.csdn.net/sternlycore/article/details/85759475)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n- [IIC设备驱动程序（六）————SMBus协议-CSDN博客](https://blog.csdn.net/yangguoyu8023/article/details/71440688)\n- [【STM32F030开发日志/评测/笔记】+（1）STM32F0处理器I2C时间配... - STM32团队 ST意法半导体中文论坛](https://shequ.stmicroelectronics.cn/thread-571931-1-1.html)\n- ⭐⭐⭐[【STM32】HAL库 STM32CubeMX教程十二---IIC(读取AT24C02 )_hal iic-CSDN博客](https://blog.csdn.net/as480133937/article/details/105259075)\n","tags":["STM32","CubeMX","嵌入式","iic"],"categories":["嵌入式","配置功能"]},{"title":"通信协议：iic","url":"/posts/55329/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 说明\n\niic作为当今嵌入式应用中最常见的串行通信协议之一!!我愿将其与UART和SPI并称三幻神!!，是对于嵌入式开发者是最基本的要求，因为老是会忘记iic协议的一些细节，故作记录。\n\n## iic简介\n\n**IIC(Inter－Integrated Circuit)总线**是一种由NXP（原PHILIPS）公司开发的两线式串行总线，用于连接微控制器及其外围设备。**是一种半双工同步的低速通信协议**。多用于主控制器和从器件间的主从通信，在小数据量场合使用，传输距离短，任意时刻只能有一个主机等特性。\\\n\\\nIC使用两根信号线进行通信：一根时钟线SCL，一根数据线SDA。IIC将SCL处于高时SDA拉低的动作作为开始信号，SCL处于高时SDA拉高的动作作为结束信号；传输数据时，SDA在SCL低电平时改变数据，在SCL高电平时保持数据，每个SCL脉冲的高电平传递1位数据。\n\n## 主要特性\n\n- IC用2根信号线通信：串行数据线 SDA、串行时钟线 SCL；\n- IIC总线上所有器件的SDA、SCL引脚输出驱动都为**开漏(OD) 结构**，通过外接上拉电阻实现总线上所有节点SDA、SCL信号的线与逻辑关系；\n- 总线上的所有设备通过软件寻址且具有唯一的地址（7位或10位）。7位“从机专用地址码”，其高4位为由生产厂家制定的设备类型地址，低3位为器件引脚定义地址（由使用者定义）；10位地址不常见；\n- 任何时刻都只存在简单的主从关系，按数据传输的方向，主机可以是主发送器或主接收器；\n- 支持多主机。在总线上存在多个主机时，通过冲突检测和仲裁机制防止多个主机同时发起数据传输时存在的冲突；\n- IIC总线上所有器件都具有“自动应答”功能，保证数据传输的正确性； **主机和从机的区别在于对SCL的发送权，只有主机才能发送SCL**；\n- IIC总线允许挂载最多的设备数量取决于总线上最大电容值，一般为400pf（Hs模式100pf）\n\n支持的传输速率：\n\n| 模式                     | 速度      |\n| ---------------------- | ------- |\n| 标准模式（Standard Mode）    | 100kb/s |\n| 快速模式（Fast Mode）        | 400kb/s |\n| 增强快速模式（Fast Mode Plus） | 1Mb/s   |\n| 高速模式（High Speed Mode）  | 3.4Mb/s |\n| 极速模式（Ultra-FastMode）   | 5Mb/s   |\n\n## 硬件结构\n\n### 总线结构\nIIC使用两根信号线进行通信，要求两根线都使用 **开漏输出接上拉电阻** 的配置，以此实现总线上所有节点SDA、SCL信号的**线与**逻辑关系。\nRp电阻的取值有一定的要求，太小会导致灌入电流过大，使’低’数据不稳定，甚至损坏端口；太大会导致信号上升缓慢，使得数据传输出错。在不同应用场景及供电电压下有不同的取值要求。 \n![](79b9189018381624841758e3ade6e477.png)\n\n### 仲裁机制\n\n#### 开漏输出\n开漏输出回顾：当输入为高电平时，三级管导通，输出为低电平。输入为低电平，输出不确定，在这种情况下，如果使用强上拉，则可以输出高电平。开漏输出是实现”线与“的一种方案。\n#### 线与\n多个开漏输出连接在一起时，只要有一个输入为低电平，那么总体表现为低电平（处于低电平的那个io口把vdd流向Vout的电流引走了）。\n![](Snipaste_2025-03-11_20-01-18.png)\n\n“线与“使得总线上不会出现数据冲突，实现了总线的仲裁控制。总线的控制权会交给最后一个输出低电平的设备，其它设备（输出高）通过检测总线上的电平状态（状态低），对比与自己输出状态不一致，则自动退出对总线的控制请求，从而防止了总线上的数据冲突。\n\n## 🌟时序逻辑\n### 数据有效性\nscl为高电平期间，为数据采集期，所以sda上的数据此时一定要保持稳定哦~\n![](6c89c55012485f151df1a9fb48843d3f.jpeg)\n\n### 开始与结束信号\n有设备想要sda总线控制权时，会主动把sda拉低。平时sda为高。\n- **开始信号（START/S）：** **SCL为高时**，SDA从高到低的跳变产生开始信号 。\n- **结束信号（STOP/P）  ：** **SCL为高时**，SDA从低到高的跳变产生结束信号。\n- **重复开始信号（ReSTART/Sr）：** 在结束时不给出STOP信号，而以一个时钟周期内再次给出开始信号作为替代。\n![](f749a6ab4f928522a99db173fd504647.png)\n\n### 传输格式（字节格式）\nSDA数据线上的每个字节**必须是8位**，对于每次传输的**字节数没有限制**。每个字节（8位）数据传送完后紧跟着应答信号（ACK，第9位）。数据的先后顺序为：**高位在前** 。\n![](d3bbca378362c28829cee243a8497ef7.png)\n\n### ACK信号\n\n协议规定数据传输过程必须包含应答（ACK）。接收器通过应答告知发送的字节已被成功接收，之后发送器可以进行下一个字节的传输。所以主机产生数据传输过程用了9个时钟。发送器在应答时钟周期内释放对SDA总线的控制，这样 **接收器** 可以通过将SDA线拉低告知发送器：数据已被成功接收。(谁接收，谁发送应答信号)!!发送端对接收端说：我他妈要给你发数据了，收到货他妈回复一下0!!\n应答信号分为两种：  \n1. 当第9位(应答位)为 **低电平** 时，为 **ACK**  （Acknowledge）   信号  \n2. 当第9位(应答位)为 **高电平** 时，为 **NACK**（Not Acknowledge）信号\n\n主机发送数据，从机接收时，ACK信号由从机发出。当在SCL第9位时钟高电平信号期间，如果SDA仍然保持高电平，则主机可以直接产生STOP条件终止以后的传输或者继续ReSTART开始一个新的传输 !!此时主机发现事情不对，我他妈辛辛苦苦给你发的货你连句回应都没有，主机可以选择不发了，或者继续用爱发电发发发 大声发！来财，来~我是憋佬仔!!\\\n\\\n从机发送数据，主机读取数据时，ACK信号由主机给出。主机响应ACK表示还需要再接收数据，而当主机接收完想要的数据后，通过发送NACK告诉从机读取数据结束、释放总线。随后主机发送STOP命令，将总线释放，结束读操作。!!从机这个fw，纯添狗级别的、麦当劳级别的、ATM级别的。主机叫一直叫从机爆金币，从机真就一直爆，榨干从机了就直接把他甩了他妈的!!\n\n### 7bit完整传输示意图\n![](f313f22e0c7bc962ff6e9e5afc2bbc95.png)\n\n没错前7位是地址，发完地址发送读/写命令，然后发送端交出sda控制权，等待接收端的应答信号。如果从机没有给出ACK应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由master来决定如何处理（STOP或ReSTART）。\n\n### 从机发，主机收的情况\n主机对向从机读取数据时，方式同发送数据有所不同，要多一次通信过程。\n主机需要先向从机发送一次信号，告诉从机”我要读取数据“，然后**重开一次通信**[^1]，等待从机主动返回数据。\n![](Snipaste_2025-03-11_20-50-32.png)\n\n### 10bit传输\n随着IIC设备日益增多，7位的从机地址逐渐不能满足使用，于是从机地址从7位扩充到了10位。7位和10位地址的设备可以共存于同一个I2C总线系统互不冲突，展现了良好的兼容性。\\\n10-bit 地址的IIC设备需要 2-Byte 来传输从设备地址信息，所以采用了这样的设计：第一个字节为 11110 + 地址高两位(第10、9bit) + 读写控制位，第二个字节为从设备地址低8位，除此之外与7-bit设备相同。（因为 “1111 0xx” 为 IIC 中特地保留的16个特殊指令地址中的一个，所以7-bit设备不会响应该首字节的呼叫，只有10-bit设备会响应，从而实现良好兼容。!!好样的，iic👍👍👍为你骄傲!!）\n直接贴图了\n写\n![](5569e1d0e47921103fe2d9d5b8ce83f9.jpeg)\n读\n![](dee04bba6b887b740ab122eac9bc37bf.jpeg)\n注意第一帧都是write哦。\n\n## 参考文章 \n- ⭐⭐⭐[基础通信协议之 IIC (I2C) 详细讲解_i2c通信的详细讲解-CSDN博客](https://blog.csdn.net/qq_39829913/article/details/104718185)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n- [二十、I2C总线仲裁机制 - 轻轻的吻 - 博客园](https://www.cnblogs.com/yuanqiangfei/p/15781416.html)\n- [GPIO推挽与开漏输出的“线与“特性 - 知乎](https://zhuanlan.zhihu.com/p/638360051)\n\n[^1]: 重复启动信号（Repeated Start）是一种特殊的操作，**它允许在不释放总线的情况下从写模式切换到读模式**。这种方式可以避免总线被其他设备占用，或者防止主设备发送 STOP 信号后，其他设备试图接管总线。","tags":["嵌入式","iic","通信协议"],"categories":["嵌入式","通信协议"]},{"title":"CubeMX配置功能系列：ADC（下）","url":"/posts/55933/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 目录\n- [目录](#目录)\n- [1. 输入模式](#1-输入模式)\n  - [1.1. 单端输入](#11-单端输入)\n  - [1.2. 差分输入](#12-差分输入)\n- [2. 继续看config部分](#2-继续看config部分)\n  - [2.1. 通用设置部分：](#21-通用设置部分)\n  - [2.2. ADC 设置部分：](#22-adc-设置部分)\n    - [2.2.1. ClockPre...](#221-clockpre)\n    - [2.2.2. Resolusion](#222-resolusion)\n    - [2.2.3. Data Ali...](#223-data-ali)\n    - [2.2.4. Gain Com...](#224-gain-com)\n    - [2.2.5. Scan Conversion Mode](#225-scan-conversion-mode)\n    - [2.2.6. End Of Conversion Selection](#226-end-of-conversion-selection)\n    - [2.2.7. Low Power Auto Wait](#227-low-powerautowait)\n    - [2.2.8. Continuous Conversion Mode](#228-continuous-conversion-mode)\n    - [2.2.9. Discontinuous Conversion Mode](#229-discontinuous-conversion-mode)\n    - [2.2.10. DMA Continuous Requests](#2210-dma-continuous-requests)\n    - [2.2.11. Overrun behaviour](#2211-overrun-behaviour)\n    - [2.2.12. Conversion Data Managerment Mode（H7）](#2212-conversion-data-managerment-modeh7)\n  - [2.3. 规则转换模式](#23-规则转换模式)\n    - [2.3.1. Enable Regular Conversions](#231-enable-regular-conversions)\n    - [2.3.2. Enable Regular Oversamping（不常用）](#232-enable-regular-oversamping不常用)\n    - [2.3.3. Oversamping Right Shift（不常用）](#233-oversamping-right-shift不常用)\n    - [2.3.4. Number Of Conversion](#234-number-of-conversion)\n    - [2.3.5. External Trigger Conversion Soure（触发转换的外部来源）](#235-external-trigger-conversion-soure触发转换的外部来源)\n    - [2.3.6. External Trigger Conversion Edge（触发转换的外部沿）](#236-external-trigger-conversion-edge触发转换的外部沿)\n    - [2.3.7. Rank](#237-rank)\n    - [2.3.8. Offset Number](#238-offset-number)\n  - [2.4. 然后是注入转换模式](#24-然后是注入转换模式)\n    - [2.4.1. 规则通道：](#241-规则通道)\n    - [2.4.2. 注入通道：](#242-注入通道)\n  - [2.5. 最后是可爱的看门小狗🥰~](#25-最后是可爱的看门小狗)\n- [3. 参考函数](#3-参考函数)\n- [4. 参考博客](#4-参考博客)\n\n\n## 1. 输入模式\n我们打开cubemx的配置，配置通道时有如下选择：分别是差分输入和单端输入。\n![](Snipaste_2025-03-09_19-30-43.png)\n\n### 1.1. 单端输入\n\n单端输入方式优点就是简单，缺点是如果VIN受到干扰，由于GND电位始终是0V，所以最终采样值也会随着干扰而变化。采样值=VIN（叠加干扰值 ）- 0V\n\n如图所示，单端输入只有一个输入引脚ADCIN，使用公共地GND作为电路的返回端，ADC的采样值=ADCIN电压-GND的电压(0V)。这种输入方式优点就是简单，缺点是如果vin受到干扰，由于GND电位始终是0V，所以最终ADC的采样值也会随着干扰而变化。\n![](8c60645887a08582fd0cd8f9cba6b8da.png)\n\n### 1.2. 差分输入\n\n差分受到的干扰是差不多的，输入的共模干扰，在输入时会被减掉，从而降低了干扰，缺点就是接线复杂一些。\n\n差分信号 优点：易分辨小信号、抗干扰EMS强；缺点:双线\n\n而差分输入比单端输入多了一根线，最终的ADC采样值=(ADCIN电压)-(ADCIN-电压)，由于通常这两根差分线会布在一起，所以他们受到的干扰是差不多的，输入共模干扰，在输入ADC时会被减掉，从而降低了干扰，缺点就是接线复杂一些。而且需要VIN+和VIN-两路反相的输入信号。\n\n差分输入的是将两个输入端的差值作为信号，这样可以免去一些误差，比如你输入一个1V的信号可电源有偏差实际输入要大0.1.就可以用差分输入1V和2V一减就把两端共有的那0.1误差剪掉了。单端输入无法去除这类误差。\n\n![](Snipaste_2025-03-09_19-43-28.png)\n\n## 2. 继续看config部分\n\n![](Snipaste_2025-03-09_19-45-21.png)\n![](Snipaste_2025-03-09_19-45-32.png)\n\n### 2.1. 通用设置部分：\n- 当只启用1个ADC时，只能选择**独立模式**，如果使用双ADC并要求同步的话，则会有更多选择。双重ADC同步模式，两个ADC同时采集一个或多个通道，可以提高采样率。这个双ADC同步模式的选择先不作记录了！\n### 2.2. ADC 设置部分：\n#### 2.2.1. ClockPre...\n时钟预分频，双时钟域架构。目的是让ADC达到稳定的工作频率[^1]（异步时钟模式（Asynchronous clock mode，基于PLL2P时钟）同步时钟模式（Synchronous clock mode，基于AHB时钟）有些型号的单片机则是直接从时钟树专门分出了一个ADC时钟频率配置。\n![](Snipaste_2025-03-09_20-30-53.png)\n\n#### 2.2.2. Resolusion\n分辨率。不再赘诉。请见上篇\n\n#### 2.2.3. Data Ali...\n数据对齐。不再赘诉。请见上篇\n\n#### 2.2.4. Gain Com... \n增益补偿：对所有转换后的数据进行增益补偿。每次转换后，数据根据增益补偿对采样后的数据进行变换。\n\n#### 2.2.5. Scan Conversion Mode\n扫描模式。不再赘诉。请见上篇\n\n#### 2.2.6. End Of Conversion Selection\n转换结束标志选择：指定转换结束后是否产生EOS中断或单次转换结束事件标志（EOC）。有End of single conversion（EOC） 与 End of sequence of conversion（EOS）两种选择。这两个事件会触发中断与DMA。\\\n\\\n在多通道转换过程中，如果选择了End of sequence of conversion，会在一组数据转换完成后发出EOS标志，如下图所示。如果不选，则不会置位该标志。\n![](Snipaste_2025-03-09_20-42-09.png)\n选择EOS目的是等所有通道转换完毕后，产生中断后将全部数据取出来，或者使用DMA将全部数据取出来。\n\n#### 2.2.7. Low Power Auto Wait\n低功耗自动延迟等待模式，可选参数为 ENABLE 和 DISABLE，当使能时，仅当一组内所有之前的数据已处理完毕时，才开始新的转换，适用于低频应用。**该模式仅用于 ADC 的轮询模式，不可用于 DMA 以及中断。**\n\n#### 2.2.8. Continuous Conversion Mode\n是否启用连续转换。不再赘诉。请见上篇 **若想使用ADC+DMA的话，必须先使能连续转换模式**。\n\n#### 2.2.9. Discontinuous Conversion Mode\n间断模式，再赘诉一下。这里的不连续含义是指每次触发进行一个子组的转换，跟Continuous Conversion Mode的连续含义不一样。例如使能了该配置，该参数的下方就立马出现Number Of Discontinuous Conversions，如果它设为2，且ADC1使能了通道1，2，5，7，10，11的话，那么第一次触发ADC1采样时，就会采样通道1与通道2的值，再一次触发ADC1采样的话，就会采样通道5与通道7值，如此类推。值得注意的是，Continuous Conversion Mode与Discontinuous Conversion Mode不能同时使能，两者不能共存。\n\n#### 2.2.10. DMA Continuous Requests\nDMA连续请求：指定 DMA 请求是否以一次性模式执行(当达到转换次数时，DMA 传输停止)或在连续模式下(DMA 传输无限制，无论转换的数量)。[^2]\n- 不使能：在这种模式下，每次有新的转换数据可用时，ADC都会生成一个DMA传输请求，一旦DMA到达最后一个DMA传输，即使转换已经再次开始，ADC也会停止生成DMA请求，适合转换固定数量数据的情况。\n- 使能：在这种模式下，每当数据寄存器中有新的转换数据可用时，即使DMA已经到达最后一次DMA传输，ADC也会生成DMA传输请求。这允许在循环模式下配置DMA来处理连续的模拟输入数据流。\n\n#### 2.2.11. Overrun behaviour\n溢出处理：用于配置ADC转换数据未及时读取，造成溢出时的处理。\n- Overrun data preserved:保留旧数据，丢弃和丢失新的转换。\n- Overrun data overwritten:数据寄存器被最后一次转换的结果覆盖，之前未读的数据丢失\n![](Snipaste_2025-03-09_21-17-16.png)\n\n#### 2.2.12. Conversion Data Managerment Mode（H7）\n转换数据管理模式。不使用DMA的话，不使用DFSDM数字滤波器做后期处理的话，选择Regular Conversion data stored in DR register only即可。其实就是选择存放转换完成的模拟量数据的地方而已。\n\n### 2.3. 规则转换模式\n\n#### 2.3.1. Enable Regular Conversions\n使能规则转换。使能它才能采集各个通道上的模拟量。\n\n#### 2.3.2. Enable Regular Oversamping（不常用）\n使能规则过采样。\n![](Snipaste_2025-03-10_14-20-12.png)\n\n#### 2.3.3. Oversamping Right Shift（不常用）\n过采样右移。**过采样器能将累加的采样值进行右移**。有什么用？比如过采样设置15，那么将采集16个值进行累加。接着配置右移动4位的话，相当于将刚才的累加值除以16，得到平均值。不需要在程序里求平均了。当然，如果大家喜欢在程序里求平均值也是可以的。\n\n#### 2.3.4. Number Of Conversion\n转换通道数。根据ADC配置的通道数来选择。有多少转换通道就设置几。\n\n#### 2.3.5. External Trigger Conversion Soure（触发转换的外部来源）\n选择触发转换的来源：\n- Regular Conversion launched by software （软件触发）\n- Timer 1 Capture Compare 1 event （定时器1捕获比较事件1）\n- … （各种定时器触发来源）\n一般使用软件触发就行。\n\n#### 2.3.6. External Trigger Conversion Edge（触发转换的外部沿）\n选择定时器触发时，需要进一步选择触发的沿。选择软件触发时，该项为None。\nTrigger detection on the rising edge（上升沿）\nTrigger detection on the falling edge（下降沿）\nTrigger detection on the rising and falling edge（上升与下降沿）\n\n#### 2.3.7. Rank\n![](Snipaste_2025-03-10_14-29-51.png)\n\n- Channel：选择采样的通道。\n-  Sampling Time：采样时间。配置多少个时钟周期，建议采样时间尽量长一点，以获得较高的准确度。总的转换时间=采样时间+逐次逼近时间（TSAR）。[^3]\n逐次逼近参考时间：请查阅相关数据手册。\n这是一个参考：\n![](Snipaste_2025-03-10_14-31-52.png)\n\n#### 2.3.8. Offset Number\n偏移序号？？不懂。\n\n### 2.4. 然后是注入转换模式\n我们看到，在选择了ADC的相关通道引脚之后，在模拟至数字转换器中有两个通道：注入通道与规则通道。规则通道至多16个，注入通道至多4个。\n\n#### 2.4.1. 规则通道：\n规则通道相当于你正常运行的程序，看它的名字就可以知道，很规矩，就是正常执行程序。\n#### 2.4.2. 注入通道：\n注入通道可以打断规则通道，听它的名字就知道不安分，如果在规则通道转换过程中，有注入通道进行转换，那么就要先转换完注入通道，等注入通道转换完成后，再回到规则通道的转换流程。类似于中断。\n![](Snipaste_2025-03-10_14-43-22.png)\n\n### 2.5. 最后是可爱的看门小狗🥰~\n当被ADC转换的模拟电压值低于低阈值或高于高阈值时，便会产生中断。阈值的高低值由ADC_LTR和ADC_HTR配置。\n可以防止读取到的电压值超量程或者低于量程，也可以监控CPU温度，防止温度过高，反正是用处多多。\n\n## 3. 参考函数\n```c\n//开启ADC 3种模式 ( 轮询模式 中断模式 DMA模式 )\nHAL_ADC_Start(&hadcx);       //轮询模式开启ADC\nHAL_ADC_Start_IT(&hadcx);       //中断轮询模式开启ADC\nHAL_ADC_Start_DMA(&hadcx);       //DMA模式开启ADC\n\n//关闭ADC 3种模式 ( 轮询模式 中断模式 DMA模式 )\nHAL_ADC_Stop();\nHAL_ADC_Stop_IT();\nHAL_ADC_Stop_DMA();\n\n//ADC校准函数 ：F4系列不支持\nHAL_ADCEx_Calibration_Start(&hadcx);      \n\n//读取ADC转换值\nHAL_ADC_GetValue();\n\n//等待转换结束函数.第一个参数为哪个ADC,第二个参数为最大等待时间\nHAL_ADC_PollForConversion(&hadc1, 50);\n\n//ADC中断回调函数\nHAL_ADC_ConvCpltCallback();\n\n//转换完成后回调，DMA模式下DMA传输完成后调用\n\n//规则通道及看门狗配置\nHAL_ADC_ConfigChannel(); //配置规则组通道\nHAL_ADC_AnalogWDGConfig();\n```\n\n\n\n## 4. 参考博客\n有星星的是我觉得写的很好的博客。\n- ⭐⭐⭐[STM32H743-梳理ADC模数转换器在CubeMX上的配置_overrun behaviour-CSDN博客](https://blog.csdn.net/wallace89/article/details/117048846)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n- ⭐⭐⭐[STM32CubeIde ADC配置详解_end of conversion selection-CSDN博客](https://blog.csdn.net/demonneverhunts/article/details/135155881)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n- ⭐⭐⭐[【STM32】HAL库 STM32CubeMX教程九---ADC_cubemx adc-CSDN博客](https://blog.csdn.net/as480133937/article/details/99627062)\n- [ADC的单端输入、伪差分输入、差分输入区别？_差分adc-CSDN博客](https://blog.csdn.net/chenhuanqiangnihao/article/details/122086308)\n\n\n[^1]:ADC的工作频率需要查阅相关数据手册,工作频率太高会导致转换无法完成。\n[^2]: 在连续模式下，DMA 必须配置为循环模式。否则，当达到 DMA 缓冲区最大指针时将触发溢出。\n[^3]: 时间可以用ADC时钟周期来衡量。例如12bitADC的逐次逼近时间为12.5个ADC时钟周期\n","tags":["STM32","CubeMX","ADC","嵌入式"],"categories":["嵌入式","配置功能"]},{"title":"Hello World","url":"/posts/16107/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"CubeMX配置功能系列：ADC（上）","url":"/posts/9852/","content":"\n<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 目录\n- [目录](#目录)\n- [1. 说明](#1-说明)\n- [2. Analog-to-Digital Converter简介](#2-analog-to-digital-converter简介)\n- [3. STM32里的ADC是如何进行转换的？](#3-stm32里的adc是如何进行转换的)\n  - [3.1. 数据对齐](#31-数据对齐)\n  - [3.2. 具体说明：](#32-具体说明)\n- [4. ADC的转换模式](#4-adc的转换模式)\n  - [4.1. 关于是否要持续转换](#41-关于是否要持续转换)\n  - [4.2. 如果有多个通道](#42-如果有多个通道)\n- [5. 参考博客](#5-参考博客)\n\n## 1. 说明\n\nADC作为对我来说不怎么用的功能，记录一下很有必要。本文以*STM32G4*系列为例。供自己学习与记录且只做简单介绍。有一定基础的朋友可参考。\n\n## 2. Analog-to-Digital Converter简介\n\n模拟到数字转换器，简称ADC。将连续的模拟信号转换为数字信号。\n\n## 3. STM32里的ADC是如何进行转换的？\n\n采用的是SAR（逐次逼近）的方法。通过二分比较使数字量逼近真实的模拟信号量。\\\n\\\n一般stm32中的ADC储存转换结果的寄存器有效位为12位，也可以说该ADC的分辨率为12位。模拟量经过转换后与数字量是线性关系[^1]，0x000代表测量最小值。0xfff代表测量最大值（即参考电压值）。\n\n### 3.1. 数据对齐\n\n尽管分辨率为12位，也是放在16位寄存器里的，那么就涉及数据对齐的问题。\n- 若12位数据是右对齐的，即结果为0x0???，这样得到的结果直接就是转换结果。\n- 若选择左对齐，即结果为0x???0，相当于`0x0???<<4`!!不会有人觉得是左移1位吧!! 我们都知道右移四位相当于乘以2^4^，比实际数据增大了16倍。那么我们为什么还需要左对齐呢？有时我们对分辨率要求不高，只需大概判断，所以我们用左对齐取出寄存器的高8位，相当于舍弃4位转换精度，降为8位分辨率。\n### 3.2. 具体说明：\n\n例如，我们需要测量模拟量为0.9V 过程如下[^2]：\n\n1. 通过GPIO口采样待测电压到电容上。\n2. 切断与待测信号的连接，将待测电压保持在电容上。\n3. 我们从最高位开始 ?000-0000-0000 ，我们知道 1000-0000-0000 刚好对应十进制2048，根据线性关系2048刚好对应参考电压的一半。所以这里相当于将参考电压值的一半1.65v与待测电压比较。如果待测电压没有1.65v高，就将最高位置0。我们就知道待测电压对应在0~2048之间。此时我们就要和1024比较，1024二进制表示为 0100-0000-0000，刚好是次高位置1的情况。以此类推，直到12位全部比较完，就能确定哪些位是1哪些位是0。\n\n\n\n## 4. ADC的转换模式\n### 4.1. 关于是否要持续转换\n1. 单次转换模式：ADC只执行一次转换；\n2. 连续转换模式：转换结束之后马上开始新的转换；\n### 4.2. 如果有多个通道\n1. 扫描模式：ADC扫描被规则通道和注入通道选中的所有通道，在每个组的每个通道上执行单次转换。在每个转换结束时，这一组的下一个通道被自动转换。如果设置了CONT位（开启了连续转换模式），转换不会在选择组的最后一个通道上停止，而是再次从选择组的第一个通道继续转换。\n2. 间断模式：触发一次，转换一个通道，再触发，再转换。在所选转换通道循环，由触发信号启动新一轮的转换，直到转换完成为止。\n\n## 5. 参考博客\n给星星的是我觉得写得很好的博客。\n- ⭐⭐⭐[【STM32】HAL库 STM32CubeMX教程九---ADC_cubemx adc-CSDN博客](https://blog.csdn.net/as480133937/article/details/99627062)\n\n[^1]: 以12位分辨率ADC为例，参考电压3.3v：电压值y=转换结果x·3.3/4096.\n[^2]:  参考电压3.3v，12位精度","tags":["STM32","CubeMX","ADC","嵌入式"],"categories":["嵌入式","配置功能"]},{"title":"单片机（伪）多任务处理：时间片轮询法","url":"/posts/39448/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 引入\n\n在新手刚刚入门时，通常使用的程序架构为裸机、顺序执行。也就是说把所有的功能放在一个`while(1)`死循环中然后单片机不断循环执行。有必要的话会加上一些中断用来处理一些紧急事件或者外部的信号，构成经典的前后台系统。但是这样做有什么弊端呢？这是我在我踩过坑后意识到的：\n\n1. 有些程序完全不需要频繁执行，比如LED的刷新，按键的检测等。放在死循环中执行对CPU比较浪费。\n2. 随着功能的增多或者代码变得复杂你会感觉到程序越写越困难，循环中的功能模块有时需要和中断联动，各个模块之间也有可能需要联动起来。即使使用状态机也力不从心...\n3. 勉勉强强完成了任务，后期的维护也变得相当的麻烦。\n\n踩过坑后的我痛定思痛：准备以后写程序都请出RTOS这个大手子。但是后来我又发现 有时你想要实现的功能刚好介于复杂与不复杂之间...咋理解呢，就是说用顺序执行，复杂了点，用RTOS吧好像也没必要...毕竟移植还是挺麻烦的。当然还有就是RTOS体量过大，有些单片机吃不下，或者吃下了但是也撑的吃不下自己写的代码了!!属于是小鸟胃这一块，不过目前我还没遇到过，我用的单片机基本上属于大卫戴这一块!!\n\n## 时间片轮询法\n\n为了优化上面这些问题，大佬们于是提出了一种基于时间片的裸机开发架构，我们可以利用一个定时器提供心跳，不断的进行计数。然后当定时时间一到，那么就可以开始执行相应的任务了。\n\n### Talk is cheap，Show me the code.\n\n首先是.h头文件\n```c\n#ifndef __OS_H__\n#define __OS_H__\n\n//任务状态\ntypedef enum TaskStatus\n{\n    wait,run,stop\n\n}TaskStatus;//等待运行、正在运行、停止运行\n\n\n//任务信息块\ntypedef struct\n{\n\n    uint16_t    TaskTimer;    //用于计时\n\n    uint16_t    TaskRunTime;  //每隔多少时间运行一次\n\n    TaskStatus  Status;       //任务状态\n\n    void (*FC)();             //任务函数指针\n\n}TaskStruct;\n\n  \nvoid OSInit(TIM_HandleTypeDef htim);//初始化设置，这里是用的STM32hal库\n\nvoid OS_IT_RUN(void);//放在提供心跳的定时器中断里运行\n\nvoid OS_Run(void);//主函数里运行的\n \n#endif\n```\n\n然后是.c\n```c\n/**\n\n  ******************************************************************************\n\n  * @file           : OS.c\n\n  * @brief          : 任务函数、OS内核\n\n  ******************************************************************************\n\n  */\n\n#include \"OS.h\"\n\n/* 任务声明------------------------------------------------------------------*/\n\nvoid A(void);\nvoid B(void);\nvoid C(void);\n\n/* -------------------------------------------------------------------------*/\n\n/* 任务清单配置---------------------------------------------------------------*/\n\nuint8_t TaskCount = 0;//记录任务数量  \n\nTaskStruct TaskList[] = {\n\n    {0,5,run,A},\n\n    {0,10,wait,B},\n\n    {0,3,wait,C},\n\n};//任务清单\n\n/* -------------------------------------------------------------------------*/\n\n  \n  \n\n/* 任务同步所需公共变量--------------------------------------------------------*/\n\n/* -------------------------------------------------------------------------*/\n\n  \n  \n\n/* OS 主功能代码--------------------------------------------------------------*/\n\nvoid OSInit(TIM_HandleTypeDef htim){//可以根据自己的需求重新写\n\n    HAL_TIM_Base_Start_IT(&htim);                       //打开定时器\n\n    TaskCount = sizeof(TaskList)/sizeof(TaskList[0]);   //利用sizeof计算数组长度的方法可得到任务数量\n\n}\n\n  \n//放在中断中执行\nvoid OS_IT_RUN(void){\n\n    uint8_t i;\n\n    for(i=0;i<TaskCount;i++){              //遍历所有循环\n\n        if(TaskList[i].Status == wait){    //当任务wait状态，执行以下步骤\n\n            if(++TaskList[i].TaskTimer >= TaskList[i].TaskRunTime){\n            //计时，并判断是否到达定时时间                 \n            //如果到了定时时间，则将任务挂起，并复位计时（也可以执行完后复位，效果一样）\n                TaskList[i].TaskTimer = 0;\n\n                TaskList[i].Status = run;\n            }\n\n        }\n\n    }\n\n}\n\n  \n\n//放在main函数中执行，自带死循环，用于执行任务\nvoid OS_Run(void){\n\n    uint8_t j=0;\n\n    while(1){\n\n        if(TaskList[j].Status == run){                  //判断一个任务是否为run状态\n\n            TaskList[j].FC();                           //执行该任务函数\n\n            TaskList[j].Status = wait ;                 //取消任务的run状态\n\n        }\n\n        if(++j>=TaskCount)j=0;                          //不断循环遍历所有任务\n\n        /* 这里可以定义空闲任务 */\n\n    }\n\n}\n\n  \n\n/* -------------------------------------------------------------------------*/\n```\n\n**按照分而治之的思想，完全可以把任务函数重新写在一个task.c文件中，这样更加简洁美观**。\n采用上面的代码，个人认为比为每个功能函数提供一个flag，时间到达后将任务标志为置位。然后在main函数的循环中检查标志位状态（类似状态机）那种方法要方便。避免了一些重复的工作。\n\n### 什么意思\n\n比如我有三个功能：\n- A：5ms执行一次 \n- B：10ms执行一次\n- C：3ms执行一次\n\n我们随机提拔一个定时器作为心跳时钟，说白了就是掐表的嘛。这个定时器一般使用基本定时器性价比高一点。这个定时器每隔1ms就叫一下，我们可以决定ABC在上电时候时是否执行，或者上电后延迟一个自己的任务周期再执行。比如我们设定上电时：仅A执行。如果我们忽略代码的执行时间，那么程序就是这么运行的：\n\n`A-1ms-1ms-1ms(C)-1ms-1ms(A)-1ms(C)-1ms-1ms-1ms(C)-1ms(A、B)--------`\n\n如果上一个功能模块已经执行完了，但下一个功能模块的定时时间还没到，便会产生空闲时间，这那些1ms后没有括号的就是CPU的空闲段。同样可以像RTOS那样把空闲时间给空闲任务。\n注意当前延时了多少时间是一个函数执行完就直接开始计算的，我之前就理解为了一个时间片只有一个函数执行。实际上不是的。\n\n## 这样的方法有什么不足？\n\n1. 首先，像这样的丐版RTOS，实时性并没有真正的RTOS高，不是说执行就执行，会有一些延迟。\n2. **如果某个任务运行时间超过一个时间片，它可能会一直占用CPU，导致后面的任务无法及时执行，从而影响系统的响应时间。然后一整个就乱了。** ~~但是个人感觉如果实时性要求不高，也无伤大雅🤔~~\n\n比如时间片为1ms。A运行时间为2ms，每隔4ms执行一次。B运行时间不计，每隔3ms运行一次。\n\n（A1ms-1ms）-1ms(B)-1ms(A1ms-1ms)(B)-1ms-1ms(A1ms([^1])-1ms)(B[^2])-----\n\n[^1]: 这里该执行B了，但由于A抢占CPU，无法执行。\n[^2]: 这次B实际上隔了4ms才执行\n\n## 参考文章\n\n- [嵌入式裸机设计思想——时间片轮裸机开发架构+状态机+定时器调度机制_基于状态机制 定时器-CSDN博客](https://blog.csdn.net/qq_63922192/article/details/132746564)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n- [STM32裸机-时间片任务轮询_时间片轮询-CSDN博客](https://blog.csdn.net/weixin_44843021/article/details/117490107)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n","tags":["嵌入式","程序架构","单片机","多任务"],"categories":["嵌入式","程序架构"]},{"title":"属于自己的引导页","url":"/posts/38456/","content":"## 网站截图\n\n![](Snipaste_2025-03-01_13-57-17.png)\n\n## 感谢\n\n网站整体的代码架构和设计思路都基于[Zyyo](https://zyyo.net/)的个人主页，这是GitHub项目地址：[ZYYO666/homepage: 我的个人主页，homepage,个人引导页,简约主页,个人导航](https://github.com/ZYYO666/homepage)\n\n很多css动画来自codepen里的大佬，我自己稍加修改！以下为部分网页使用的：\n- [时钟](https://codepen.io/graphilla/details/zEZKpN)\n- [列表收起与展开](https://codepen.io/dannymoerkerke/details/wBwYzRe)\n- [hello world动画](https://codepen.io/yoannhel/details/DMzjog)\n\n## 后记\n\n放寒假，在家实在无聊，看到各路大佬都有一个属于自己blog，便有了建一个自己的blog的想法。于是了解到了hexo ，然后各种抄能力🤓也算是搭好了自己的一个博客并托管在了GitHub，结果没想到还不够过瘾，想知道完全从0开始搭一个静态网页是什么体验，于是又在边搞边学的情况下整了个这个引导页，学习到了html和css（没有js，js全是抄的...🥹~~好吧其实部分源码架构也是抄的，毕竟也可以学习一下大佬写代码的结构~~）\n\n## TO DO\n\n- [ ]  适配黑夜模式\n- [ ]  适配移动端","tags":["网页","web"],"categories":["其他"]},{"title":"CubeMX配置功能系列：Timer（下）","url":"/posts/48581/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 1. 目录\n- [1. 目录](#1-目录)\n- [2. 说明](#2-说明)\n- [3. TIM 各种模式详解](#3-tim-各种模式详解)\n\t- [3.1. 从模式](#31-从模式)\n\t\t- [3.1.1. 简介](#311-简介)\n\t\t- [3.1.2. 复位模式（RM）](#312-复位模式rm)\n\t\t- [3.1.3. 门控模式（GM）](#313-门控模式gm)\n\t\t- [3.1.4. 触发模式（TM）](#314-触发模式tm)\n\t\t- [3.1.5. 外部时钟模式1](#315-外部时钟模式1)\n\t\t- [3.1.6. 一个示例](#316-一个示例)\n\t\t- [3.1.7. 参考](#317-参考)\n\t- [3.2. 编码器模式](#32-编码器模式)\n\t- [3.3. 触发源](#33-触发源)\n\t- [3.4. 时钟源](#34-时钟源)\n\t- [3.5. 主模式](#35-主模式)\n\t\t- [3.5.1. 比较与捕获](#351-比较与捕获)\n\t- [3.6. 一些疑惑的地方](#36-一些疑惑的地方)\n\t\t- [3.6.1. Q：`output compare no output`是什么模式？好矛盾的名字。。。](#361-qoutput-compare-no-output是什么模式好矛盾的名字)\n\t\t- [3.6.2. Q：输出比较和PWM生成模式有何区别与联系？](#362-q输出比较和pwm生成模式有何区别与联系)\n\t\t- [3.6.3. Q：何为强制输出？有啥用？](#363-q何为强制输出有啥用)\n\t\t\t- [3.6.3.1. 强制输出模式的工作原理：](#3631-强制输出模式的工作原理)\n\t\t\t- [3.6.3.2. 主要功能：](#3632-主要功能)\n\t\t\t- [3.6.3.3. 工作模式：](#3633-工作模式)\n\t\t\t- [3.6.3.4. 例子：](#3634-例子)\n\t\t\t- [3.6.3.5. 总结：](#3635-总结)\n\t\t- [3.6.4. Q：输入捕获的间接模式？](#364-q输入捕获的间接模式)\n\t\t\t- [3.6.4.1. 特点：](#3641-特点)\n\t\t\t- [3.6.4.2. 以下是直接与非直接模式的比较](#3642-以下是直接与非直接模式的比较)\n\t\t- [3.6.5. 参考](#365-参考)\n\n\n## 2. 说明\n\n本文以STM32G4系列为例。供自己学习与记录且只做简单介绍。有一定基础的朋友可参考。\n\n--- \n\n## 3. TIM 各种模式详解\n\n如下为一个高级定时器的配置页面\n![](CubeMX配置功能系列：Timer（上）/Snipaste_2025-02-22_14-10-44.png)\n\n### 3.1. 从模式\n\n可配置功能\n![](CubeMX配置功能系列：Timer（上）/Snipaste_2025-02-22_14-14-22.png)\n\n#### 3.1.1. 简介\n\n定时器的从模式控制器可以对计数器实现哪些控制或影响呢？从模式控制器检测到触发输入信号时，可以对定时器进行如下操作而控制或影响计数器的工作：\n\n1. 对计数器复位\n2. 启动或停止计数器的计数动作\n3. 使能计数器模块的工作\n4. 通过触发信号为计数器提供时钟源\n\n#### 3.1.2. 复位模式（RM）\n\n主定时器出现信号后：从定时器计数器复位并产生一个中断。\n\n不妨以计数器向上计数为例，将它配置在复位从模式。比方说当计数器计数到某个数据的时候，来了个触发信号，计数器不再继续往上计数，而是重新归0后开始计数。当然，计数器的实际复位操作与触发沿之间往往会有个小的延时，这是由于触发信号作为有效触发脉冲的话，还需要经过定时器内的同步电路确认。\n\n关于处于复位模式下的定时器，有两点提醒：\n\n1. 只要有复位触发脉冲出现，计数器就会被复位重置。复位次数取决于触发脉冲次数。\n2. 工作在复位模式下的定时器，其使能需靠软件代码实现，即使能定时器的CEN@TIMx_CR1位。\n\n#### 3.1.3. 门控模式（GM）\n\n主定时器出现信号后：从定时器计数器开始工作\n\n主定时器信号结束后：从定时器计数器停止工作并产生中断\n\n#### 3.1.4. 触发模式（TM）\n\n主定时器出现信号后：从定时器计数器开始工作，并且不会停止。\n\n触发模式主定时器只是提供了一个启动从定时器开始时间的控制，并不会有其他效果，触发从模式下，触发信号具有相当于软件使能计数器的作用，即置位CEN@TIMx_CR1，这也是它最大最明显的特征。\n\n#### 3.1.5. 外部时钟模式1\n\n外部时钟模式1从模式比较特别，当计数器的时钟源来自触发信号时，此时定时器就工作在外部时钟1从模式，此时触发信号扮演着双角色，即**触发信号**与**时钟信号**。\n\n比如，我们可以使用来自ETR脚的滤波信号ETRF作为触发信号并担当计数器的时钟源。\n\n#### 3.1.6. 一个示例\n\nQ：开启两个定时器，定时器2与定时器3，均作pwm输出，定时器3的pwm输出跟随定时器2的pwm输出。\n如何做才能又准又稳定还不占用cpu资源？\n\n大致思路：定时器2的ch2输出，并将ch2的OC2REF作为从定时器3的TRGO，并通过主从对应表，找到相应的ITRx，当出现上升沿或下降沿时，会触发从定时器的开启。应将定时器3配置为触发模式（Trigger Mode）\n\n#### 3.1.7. 参考\n\n- 👍👍👍[【话说定时器系列】之三：STM32定时器的信号触发与主从模式-电子工程世界](https://news.eeworld.com.cn/mcu/ic634774.html)\n- [stm32定时器从模式解析_stm32定时器主从模式-CSDN博客](https://blog.csdn.net/weixin_44748127/article/details/123726458)\n\n### 3.2. 编码器模式\n\n对于编码器模式，它是针对编码器应用的一个特定从模式，应用时注意使用定时器的通道1、通道2引进编码器脉冲，这里不赘述。\n\n\n### 3.3. 触发源\n\n![](Snipaste_2025-02-22_14-34-20.png)\n\n结合原理图，我们可以知道定时器可由触发源触发启动。\n\n\n### 3.4. 时钟源\n\n分为内部时钟和外部触发（外界其他信号源），不再赘诉。\n\n\n### 3.5. 主模式\n\n这是通道1的可配置功能：\n![](Snipaste_2025-02-22_15-02-04.png)\n![](Snipaste_2025-02-22_15-02-14.png)\n\n细讲一下\n#### 3.5.1. 比较与捕获\n\n捕获\n\n什么是捕获？\n\n所谓捕获就是通过检测捕获通道上的边沿信号。在边沿信号发生跳变（比如上升沿/下降沿）的时候，将当前定时器的值(TIMx_CNT)存放到对应的通道的捕获/比较寄存器(TIMx_CCR)里面，完成一次捕获。\n\nSTM32支持一下捕获模式：\n\n1. 输入捕获模式\n2. PWM输入模式\n\n输入捕获模式可以用来测量脉冲宽度或者测量频率。下图是输入捕获测量高电平脉宽的原理，假定定时器工作在向上计数模式，图中 t1~t2 时间，就是需要测量的高电平时间。\n![](20220309022442146.png)\n测量方法如下：首先设置定时器通道x为上升沿捕获，这样，t1 时刻，就会捕获到当前的 CNT 值，然后立即清零 CNT，并设置通道x下降沿捕获，这样到 t2 时刻，又会发生捕获事件，得到此时的 CNT 值，记为CCRx2。这样，根据定时器的计数频率，我们就可以算出 t1~t2 的时间，从而得到高电平脉宽。\n\n比较\n\n什么是比较？\n\n所谓比较就是计数器的值和与装载的值进行比较，**和外部的信号没关系**。\n\nSTM32支持一下比较模式：\n\n1. 强制输出模式\n2. 输出比较模式\n3. **PWM模式**\n4. 单脉冲模式\n\n### 3.6. 一些疑惑的地方\n\n#### 3.6.1. Q：`output compare no output`是什么模式？好矛盾的名字。。。\n\nA：`Output Compare No Output`意味着该定时器的输出比较（Output Compare）功能已经启用，但它不会实际输出到引脚上。具体来说，定时器的输出比较功能通常是用来生成定时信号（比如 PWM 或捕获信号）。如果你选择`Output Compare No Output`，这表示：\n\n1. **输出比较功能启用**：定时器仍然会根据设置的比较值（比如定时器计数器和比较寄存器的匹配）产生一个事件。\n2. **不输出到引脚**：虽然比较功能可以触发中断或设置状态，但是并没有配置定时器的输出引脚（比如一个 PWM 信号）去响应这些事件。这种配置适用于只需要定时器功能（比如触发中断）而不需要具体的硬件输出。\n\n`Output Compare No Output`就是配置定时器的输出比较功能，不去生成实际的引脚信号，可能只是用来**触发事件**或**控制中断**。\n\n#### 3.6.2. Q：输出比较和PWM生成模式有何区别与联系？\n\nA：输出比较（Output Compare）和 PWM 生成模式（PWM Generation Mode）虽然都依赖于定时器的输出比较功能，但它们的应用场景和工作方式有所不同。下面是它们之间的主要区别与联系：\n\n| **模式**    | **输出比较（Output Compare）**     | **PWM 生成模式（PWM Generation Mode）**                 |\n| --------- | ---------------------------- | ------------------------------------------------- |\n| **基本概念**  | 计数器的值与预设比较值比较，匹配时产生事件。       | 基于输出比较功能，周期性地生成脉宽调制（PWM）信号。计数器与比较值的关系决定引脚状态（高或低）。 |\n| **作用**    | 设置引脚状态或触发中断                  | 根据计数器值与比较值的关系周期性改变引脚状态。                           |\n| **用途**    | 触发定时器事件，控制外部硬件信号（如设置引脚为高或低）。 | 控制电机、LED亮度调节、电源管理等应用，需要调节占空比。                     |\n| **典型应用**  | 定时脉冲、事件触发、精确的定时控制            | 电机控制、LED亮度调节、信号调制                                 |\n| **周期性输出** | 否，输出比较通常产生单次信号或事件，不是周期性的。    | 是，生成周期性的波形。                                       |\n| **倾向目标**  | 生成事件（如中断）。                   | 生成周期性的波形信号。                                       |\n\n简而言之，输出比较更注重事件的触发，而PWM生成模式则专注于产生持续的周期性波形。\n\n#### 3.6.3. Q：何为强制输出？有啥用？\n\nA：强制输出模式（Forced Output Mode）是定时器的一种特殊输出控制模式，主要用于在定时器的某些条件下强制改变输出引脚的状态（例如设置为高或低）。这种模式可以在定时器产生的输出信号之外，强制控制引脚的状态。\n\n##### 3.6.3.1. 强制输出模式的工作原理：\n\n在强制输出模式下，定时器的输出信号不再完全依赖于定时器计数器和比较寄存器的常规操作（比如在 PWM 或输出比较模式下的信号波形）。你可以通过某些特定的条件或命令直接控制输出引脚的状态。例如，定时器可以在特定时刻将引脚强制设置为高或低状态。\n\t\n##### 3.6.3.2. 主要功能：\n\n- **强制设置输出引脚的状态**：在某些情况下，强制输出模式可以被用来直接控制输出引脚的状态，而无需依赖于定时器的正常计数和比较过程。\n- **安全控制和复位功能**：强制输出模式有时用于一些安全或复位操作，比如在硬件故障时通过强制输出信号来重置系统，或在特定条件下确保引脚处于某一状态。\n- **特定场景下的信号生成**：有时，强制输出模式被用来生成短暂的脉冲或特殊的状态，通常用于外部硬件的控制。\n\n##### 3.6.3.3. 工作模式：\n\n- **定时器强制输出高或低**：当定时器处于强制输出模式时，可以通过强制命令直接控制输出引脚状态，例如强制输出引脚保持高电平或低电平。\n- **常用的应用**：这种模式常用于一些特殊的信号要求，如在系统发生异常时通过定时器引脚来输出一个特定信号，以触发外部硬件或进行故障诊断。\n\n##### 3.6.3.4. 例子：\n\n在某些微控制器中，定时器的强制输出模式可以与“输出比较模式”结合使用，当定时器进入强制输出模式时，它会直接设置输出引脚为高或低，而不再受定时器的常规计数和比较值的控制。可以通过特定的触发条件或外部信号来激活强制输出模式，这通常用于控制需要在系统中立即做出响应的应用场景。**（通过软件切换）**\n\n##### 3.6.3.5. 总结：\n\n强制输出模式就是在特定情况下，强制定时器的输出引脚为高或低电平，忽略定时器的常规输出信号，常用于特殊的应用需求，如系统故障处理、硬件复位、特殊信号生成等。\n\n#### 3.6.4. Q：输入捕获的间接模式？\n\nA：间接模式较为复杂，捕获事件并不直接与计数器挂钩，而是通过某些条件或外部事件来触，具体来说，这种模式可能涉及定时器的某些附加功能（例如外部触发事件或特定的输入滤波器），这些功能可能会延迟捕获事件的实际记录。\n\n##### 3.6.4.1. 特点：\n\n- **间接捕获**：输入信号的变化并不是直接影响计数器，而是需要某些附加的条件或触发事件来保存捕获值。\n- **较复杂的控制逻辑**：非直接模式**可以结合更多外部事件和触发条件来决定何时捕获信号**，因此适用于更复杂的应用场景。\n- **滤波和去抖动**：非直接模式可以配合外部触发信号或滤波功能，适用于噪声较大的环境。\n\n##### 3.6.4.2. 以下是直接与非直接模式的比较\n\n| 特性        | 直接模式（Direct Mode）          | 非直接模式（Indirect Mode）    |\n| --------- | -------------------------- | ----------------------- |\n| **捕获方式**  | 信号变化直接触发捕获，捕获值立即存储         | 信号变化通过触发事件或附加条件触发捕获     |\n| **触发条件**  | 外部输入信号（上升沿/下降沿）直接触发捕获      | 外部事件、触发器或滤波器控制捕获事件的触发   |\n| **响应速度**  | 快速（通常实时捕获）                 | 相对较慢，可能需要额外条件来触发捕获      |\n| **应用场景**  | 适用于高频信号的实时捕获（如频率测量、脉冲宽度测量） | 适用于需要外部事件触发的场景，如外部信号同步等 |\n| **实现复杂度** | 简单，通常是硬件层面直接实现             | 需要额外的硬件配置和控制（如触发、滤波）    |\n\n#### 3.6.5. 参考\n\n- 👍👍👍ChatGPT\n- 👍👍👍[STM32-一文搞懂通用定时器捕获/比较通道-电子工程世界](https://news.eeworld.com.cn/mcu/ic565151.html)\n","tags":["STM32","CubeMX","嵌入式","Timer"],"categories":["嵌入式","配置功能"]},{"title":"CubeMX配置功能系列：Timer（上）","url":"/posts/16836/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 目录\n- [目录](#目录)\n- [1. 说明](#1-说明)\n- [2. 界面总览](#2-界面总览)\n- [3. LPTIM：没用过，用过后补充](#3-lptim没用过用过后补充)\n  - [3.1. 介绍](#31-介绍)\n  - [3.2. 支持的模式](#32-支持的模式)\n  - [3.3. 参考](#33-参考)\n- [4. RTC：也不咋用，用时补充](#4-rtc也不咋用用时补充)\n  - [4.1. 什么是RTC](#41-什么是rtc)\n  - [4.2. 功能简介](#42-功能简介)\n  - [4.3. 参考](#43-参考)\n\n\n## 1. 说明\n\n本文以STM32G4系列为例。供自己学习与记录且只做简单介绍。有一定基础的朋友可参考。\n\n--- \n\n## 2. 界面总览\n\n打开Timer的配置界面如图：\n![](Snipaste_2025-02-06_18-21-03.png)\n\n## 3. LPTIM：没用过，用过后补充\n\n### 3.1. 介绍\n\nLPTIM 是一个 16 位定时器，顾名思义他就是可以实现低功耗应用的一个特殊定时器。由于时钟源的多样性，LPTIM 能够在除待机模式以外的所有电源模式下保持运行。 即使没有内部时钟源， LPTIM 也能运行，鉴于这一点，可将其用作“脉冲计数器”，这种脉冲计数器在某些应用中十分有用。此外， LPTIM还能将系统从低功耗模式唤醒，因此非常适合实现“超时功能”，而且功耗极低。\n\nLPTIM 引入了一个灵活的时钟方案，该方案能够提供所需的功能和性能，同时还能最大程度地降低功耗。\n\nLPTIM时基单元包含一个16位自动重载计数器ARR，一个16位的递增计数器CNT，一个3位可编程预分频器可以采用8种分频系数（1、2、4、8、16、32、64、128）， 预分频器时钟源有多种可选，有内部时钟源： LSE、 LSI、 HSI 或 APB 时钟、外部时钟ULPTIM输入的外部时钟源（在没有 LP 振荡器运行的情况下工作，由脉冲计数器应用使用）。\n\n### 3.2. 支持的模式\n\n![](Snipaste_2025-02-06_18-22-29.png)\n![](Snipaste_2025-02-06_18-23-44.png)\n\n- 计数器模式：计数器可用于计算来自 Input1 的外部事件或用于计算内部时钟周期\n- 单次模式：在此模式下，当满足匹配条件时，输出可以切换高低电平（如果输出极性配置为高，则为低电平至高电平变化，反之亦然）\n-  编码器模式\n此外还有\n- 单脉冲模式\n- PWM 模式 \n-  超时模式：有效的边沿触发输入可复位定时器。第一个触发事件将启动计时器，任何连续触发事件将重置计数器并重新开始。\n\n### 3.3. 参考\n[【玩转STM32】：低功耗定时器LPTIM应用_stm32 lptim-CSDN博客](https://blog.csdn.net/qq_42965739/article/details/113532039)\n[32. LPTIM—低功耗定时器 — [野火]STM32 HAL库开发实战指南——基于H743_Pro_V 文档](https://doc.embedfire.com/mcu/stm32/h743prov/hal/zh/latest/book/LPTIM.html)\n\n\n## 4. RTC：也不咋用，用时补充\n\n### 4.1. 什么是RTC\n\n**RTC (Real Time Clock)**：实时时钟\n\n**RTC是个独立的定时器**。RTC模块拥有一个连续计数的计数器，在相应的软件配置下，可以提供时钟日历的功能。修改计数器的值可以重新设置当前时间和日期 RTC还包含用于管理低功耗模式的自动唤醒单元。\n\n在断电情况下 RTC仍可以独立运行 只要芯片的备用电源一直供电,RTC上的时间会一直走。\n\nRTC实质是一个掉电后还继续运行的定时器,从定时器的角度来看,相对于通用定时器TIM外设,它的功能十分简单,只有计时功能(也可以触发中断)。但其高级指出也就在于掉电之后还可以正常运行。\n\n两个 32 位寄存器包含二进码十进数格式 (BCD) 的秒、分钟、小时（ 12 或 24 小时制）、星期几、日期、月份和年份。此外，还可提供二进制格式的亚秒值。系统可以自动将月份的天数补偿为 28、29（闰年）、30 和 31 天。\n\n上电复位后，所有RTC寄存器都会受到保护，以防止可能的非正常写访问。\n\n无论器件状态如何（运行模式、低功耗模式或处于复位状态），只要电源电压保持在工作范围内，RTC使不会停止工作。\n\n### 4.2. 功能简介\n\n![](Snipaste_2025-02-06_18-46-47.png)\n\n- **激活时钟源**：**一般选用LSE**，RTC设备因为其独特的运行方式（即掉电依旧运行）使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响，资源消耗太大，小小的纽扣电池根本吃不消。没法保证RTC正常工作.所以RTC一般都时钟低速外部时钟LSE\n- **使能RTC日历**\n- **可编程的闹钟A/B**，如果设置了闹钟A/B的时间，则闹钟A/B设定时间会和当前日历时间对比，如果时间相等，会产生ALRA/BF事件\n- **周期唤醒**：可以使用RTC内部一个16位唤醒自动重载寄存器来实现，周期唤醒的时钟信号可以来自于更新日历的1Hz（ck_spre）信号，也可以使用RTC时钟的2/4/8/16分频后的时钟，设置该自动重载寄存器的值，**根据时钟频率向上计数，当计数溢出时发生周期唤醒事件**\n- **时间戳**\n- **Tamper**：入侵检测\n- **时钟校准**\n- **参考时钟检测？？？**\n\n### 4.3. </a>参考\n[How to calibrate the STM32's real-time clock (RTC) - STMicroelectronics Community](https://community.st.com/t5/stm32-mcus/how-to-calibrate-the-stm32-s-real-time-clock-rtc/ta-p/744958)\n[STM32CubeMX教程10 RTC 实时时钟 - 周期唤醒、闹钟A/B事件和备份寄存器_stm32cubemx rtc-CSDN博客](https://blog.csdn.net/lc_guo/article/details/135225854)\n[【STM32】RTC实时时钟，步骤超细详解，一文看懂RTC_rtc模块-CSDN博客](https://blog.csdn.net/as480133937/article/details/105026033)\n\n","tags":["STM32","CubeMX","嵌入式","Timer"],"categories":["嵌入式","配置功能"]},{"title":"相机控色","url":"/posts/50403/","content":"\n教程及截图来自b站： https://www.bilibili.com/video/BV1DQiyYkEJC/\n\n---\n\n## 色温（K）\n\n- 色温高：呈现暖色，色温低：呈现冷色（与环境色温是反的）\n- ![](Snipaste_2025-01-21_22-20-26.png)\n- `偏色`：拍摄时由于光线干扰，色温等因素影响，使得物体本身色彩受到干扰\n\t- 矫正：将相机色温数值调到与环境色温数值相同\n- 一些推荐色温 #拍摄技巧 \n\t- 冰天雪地、蓝调、夜晚、天空：冷色调（under 5000k）\n\t- 冬日暖阳、温暖、黄沙：暖色调（up 6000k）\n\n## 白平衡（WB）\n\n- 校正环境偏色。![](Snipaste_2025-01-21_22-31-07.png)\n- **一般使用白平衡自动或者直接自己校正色温**\n- 感觉平常可以直接白平衡自动，后期调啊。。\n\n## 根据主导色确定画面色温\n\n- 如果主导色偏暖，可以往暖色调色温\n- 如果主导色偏冷，可以往冷色调色温，使画面更具**氛围**\n- 注意：照片也**不一定要偏冷和偏暖**，偏色用于营造氛围，有些作品需要保证不要偏色，还原真实色彩\n\n## 白平衡偏移\n\n![](Snipaste_2025-01-21_23-10-03.png)\n\n![](Snipaste_2025-01-21_23-11-23.png)\n\n- 两大作用：\n\t- 画面氛围渲染\n\t- 控制颜色偏移的程度：解决调整色温导致一些细节的色彩不对，例如色温过高导致人像泛红，调整白平衡偏移往红色**反方向调**。","tags":["摄影基础","学习笔记","相机控色","白平衡"],"categories":["摄影学习"]},{"title":"构图","url":"/posts/40301/","content":"# 第一个教程\n以下图片与教程来自b站： https://www.bilibili.com/video/BV1pv411H78e\n\n---\n\n## 构图的核心\n\n1. 确认画面主体或主题\n2. 去掉画面中与主体无关的元素\n3. **加入**突出主题或主题表达的元素并合理摆放（利用抽象出的几何线条）\n4. 成功表达想表达的内容\n\n## 如何选择合适的取景范围？\n\n还是根据主题或主题......不确定可以多多试一下\n\n## 让画面更加吸引人的方法\n\n- 利用人眼的视觉流动： \n\t- 视觉凝聚：明暗、鲜艳暗淡、对比色、重复元素\n\t\t- ![](Snipaste_2025-01-19_21-52-29.png)\n\t\t- ![](Snipaste_2025-01-19_21-53-32.png)\n\t\t- ![](Snipaste_2025-01-19_21-54-29.png)\n- 视觉引导：\n\t- 引导线\n\t\t- ![](Snipaste_2025-01-19_21-55-44.png)\n\t- 视线\n\t\t- ![](Snipaste_2025-01-19_21-56-10.png)\n\t- 视觉控制\n\t\t- ![](Snipaste_2025-01-19_21-57-23.png)\n\n## 常用的构图技巧（要和上面的技巧综合运用）\n\n- 三分\n\t- ![](Snipaste_2025-01-19_21-59-29.png)\n- 居中（对称） 拍摄比较庄严肃穆的物体\n\t- ![](Snipaste_2025-01-19_22-00-43.png)\n- 三角形\n\t- ![](Snipaste_2025-01-19_22-01-27.png)\n- 前中后景层次构图\n\t- ![](Snipaste_2025-01-19_22-02-21.png)\n\n## 画面的平衡\n\n- 活用三分法、对称法：根据情况调整\n- 留白处点缀\n\t- ![](Snipaste_2025-01-19_22-10-09.png)\n\n---\n\n# 第二个教程\n以下教程与图片来自： https://www.bilibili.com/video/BV1eZCzYUEKD 偏向于人像\n\n---\n\n## 第一阶段：形式的构图\n\n- 居中构图：突出主题但容易平淡\n- 三分法\n\t- ![](Snipaste_2025-01-19_22-13-39%201.png)\n- 对角线：有张力、有线条感，**表达主体的延申感**\n\t- ![](Snipaste_2025-01-19_22-14-45.png)\n- 对称：均匀协调，稳定\n- 框架构图（视觉控制）\n- 引导构图：利用线条去引导，要引导去主体，不是随便引导\n\t- ![](Snipaste_2025-01-19_22-17-14.png)\n- 三角构图：并不局限于一个，可以拼凑多个\n\t- ![](Snipaste_2025-01-19_22-18-18.png)\n**但是，一定不要生搬硬套！！！**\n以下是一些错误例子\n- 盲目套用，没有突出拍摄的主体\n\t- ![](Snipaste_2025-01-19_22-20-48.png)\n\t- ![](Snipaste_2025-01-19_22-22-00.png)\n- 盲目前后景\n\t- ![](Snipaste_2025-01-19_22-23-02.png)\n- 前景太大：淡化主体\n\t- ![](Snipaste_2025-01-19_22-23-51.png)\n\n## 第二阶段：结构构图\n\n- 分析画面：点线面的运用，一些元素不再是元素本身，而是引导观看主体的工具\n\n- 根据画面内容，合理安排画面中的每个元素 而不是生搬硬套\n- 当画面主体是人时，人面朝的方向和视线也是隐形的线条，合理运用能引导画面整体走向\n\n## 第三阶段：忘掉构图，专注于画面内容与主题，返璞归真\n\n![](Snipaste_2025-01-19_22-38-26.png)\n![](Snipaste_2025-01-19_22-39-01.png)\n![](Snipaste_2025-01-19_22-39-21.png)\n如下面图片：其主旨更加丰富，而构图不那么明显\n![](Snipaste_2025-01-19_22-41-51.png)\n\n## 总结\n\n说到底，构图还是服从画面与内容，照片的意义，有时候不需要华丽的构图技巧和形式，简单，真实，有意义，能让观看者产生共鸣就够了。\n","tags":["摄影基础","学习笔记","构图"],"categories":["摄影学习"]},{"title":"影调控制","url":"/posts/55817/","content":"以下图片与教程来自b站： https://www.bilibili.com/video/BV1pv411H78e\n\n---\n\n## 什么是影调\n\n - 画面中的明暗\n - ![](Snipaste_2025-01-21_16-45-24.png)\n- ![](Snipaste_2025-01-21_16-54-04.png)\n\n## 影调的量化\n\n- 测光标尺：向左，低调，向右，高调。\n\t- 测光模式\n\t\t- ![](Snipaste_2025-01-21_17-00-29.png)\n\t\t- 拍月亮可以用点测光\n- 直方图\n\t- **判断是否过曝、欠曝**：被截断。在某一方向突然陡增\n\t\t- ![](Snipaste_2025-01-21_17-03-12.png)\n\t-  直方图可以用于判断影调，例如：\n\t\t- ![](Snipaste_2025-01-21_17-06-14.png)\n\n## 数码时代的最佳曝光方式\n\n- **向右曝光，但不是过曝**\n\t- 为了记录更多的画面细节，而在后期可以进一步调整\n\t- 让直方图右侧尽量贴近右边缘但是**不被截断**\n\t- 可以加一点EV（曝光补偿）\n\t- ![](Snipaste_2025-01-21_17-11-27%201.png)\n\n## 大光比情况下，平衡光比的多种应对方式\n\n- 如何定义大光比情况\n\t- 明暗反差很大，可以理解为最亮和最暗的反差\n\t- ![](Snipaste_2025-01-21_17-19-56.png)\n\t- ![](Snipaste_2025-01-21_17-20-33.png)\n\t- ![](Snipaste_2025-01-21_17-21-18.png)\n- 不同情况下的应对方式\n\t- 平衡光比是符合**肉眼看到的直观感觉**，而不是没有光比\n\t1. `曝光合成` ：拍摄多张不同曝光区间下的照片，后期合成到一起\n\t\t- 照片内容需要保持一致，使用稳定拍摄\n\t\t- 一些照片保留暗部细节，另一些保留亮部细节，后期合成一张HDR照片\n\t\t- 相机里有一个阶段曝光连拍功能\n\t2. `宁欠勿过，后期提亮` ：前期适当向左曝光，保护高光细节，但是也可能导致暗部细节无法还原\n\t3. `补光` ：多用于人物\n\t4. `拍摄剪影` ","tags":["摄影基础","学习笔记","影调控制"],"categories":["摄影学习"]},{"title":"机位掌控","url":"/posts/5778/","content":"\n教程及截图来自b站： https://www.bilibili.com/video/BV1DQiyYkEJC/\n\n## 什么是机位\n\n简而言之相机的位置。相机与模特的三维位置\n\n## 三维\n\n### 高度\n\n- 平视机位\n\t- 取决于取景框上的**中心对焦点**，应与中心对焦点**持平**\n\t- 优势：\n\t\t- 相比高低机位，更具真实感  适合严谨的情境 如证件照、人文纪实。![](Snipaste_2025-01-19_20-36-03.png)\n\t\t- 更容易产生情感共鸣，利于情绪传达，如上图就是个很好的例子。**突出人物情绪的关键**：利用**近景或特写**![](Snipaste_2025-01-19_20-49-10.png)\n\t\t- 小技巧： #拍摄技巧 \n\t\t\t- 上面的照片也没有完全持平哦，可以把相机稍微拉高或拉低，更能表现情绪状态\n\t\t\t- 那么高到什么地方，低到什么地方呢？**上下15度范围，避免成为高低机位的视觉观感**\n\t- 劣势：\n\t\t- 效果不惊艳：不要拍远、全、中景\n\t- 进一步拔高：\n\t\t- 强化：搞清楚想要表达的主题，使用技巧强化它\n\t\t- 规避：可以把不好看的人物五官利用机位的变化规避掉 口诀：**近大远小**\n- 高机位\n- 低机位\n\n### 角度\n\n- 正面\n- 侧面\n- 背面\n\n### 距离\n取景范围（景别）\n- 远\n\t- 即远景拍摄\n\t- ![](Snipaste_2025-01-19_17-41-06.png)\n- 全\n\t- 主体完整呈现于画面， 人物占比大\n\t- ![](Snipaste_2025-01-19_17-43-05.png)\n- 中\n\t- 取景范围为人物的膝盖以上或胸部以下\n- 近\n\t- 取景范围为人物的胸部以上或肩部以下\n- 特\n\t- 特写","tags":["摄影基础","学习笔记","机位掌控"],"categories":["摄影学习"]},{"title":"markdown渲染器测试","url":"/posts/50034/","content":"\n@[TOC]\n\n# Markdown 测试文本\n\n## 标题2\n\n这是一个段落，下面是**加粗**和*斜体*文本的示例。\n\n### 列表\n\n- 项目1\n- 项目2\n  - 子项目2.1\n  - 子项目2.2\n- 项目3\n\n### 有序列表\n\n1. 第一项\n\n2. 第二项\n\n3. 第三项\n\n### 链接\n\n[点击这里访问OpenAI](https://www.openai.com)\n\n### 图片\n\n![OpenAI logo](https://openai.com/favicon.ico)\n\n### 代码块\n\n```python\ndef hello_world():\n    print(\"Hello, World!\")\n```\n\n### 引用\n\n> \"我爱吃香肠\"\n\n### 表格\n\n| 名称   | 年龄 | 职业  |\n|--------|------|-------|\n| Alice  | 28   | 医生  |\n| Bob    | 34   | 工程师 |\n| Carol  | 25   | 设计师 |\n\n### 划线\n\n~~我被划了~~\n\n### 其他\n\n<mark>划重点，标记</mark>\n\n<details>\n<summary>可收起文本</summary>\n这是可收起文本. 可以包含任意元素, 比如 **粗体**, *斜体*,代码块\n\n```python\nprint(\"Hello, World!\")\n```\n</details> \n\n!!防剧透!!\n\n- [ ] TODO List ！渲染失败\n\nH~2~0\nx^2^\n\n脚注测试[^1]\n\n[^1]: 这是一个脚注解释\n\n#### hexo-admonition\n\n!!! note Hexo-admonition 插件使用示例\n    这是基于 hexo-admonition 插件渲染的一条提示信息。类型为 note，并设置了自定义标题。\n    \n    提示内容开头留 4 个空格，可以有多行，最后用空行结束此标记。\n\n\n\n!!! warning \"\"\n     This is warning without title.\n\n!!! todo \n    This is todo.\n\n!!! error\n    This is error.\n\n\n####  ~~hexo-tips~~ \n\n<details>\n\n<summary>自2025.09.07起不再使用，改用 admonition。</summary>\n\n:::warning\nwarning\n:::\n     \n:::danger\ndanger\n:::\n    \n:::tip\ntip\n:::\n    \n:::mention\nmention\n:::\n   \n:::recommend\nrecommend\n:::   \n\n:::note\nnote\n:::    \n\n:::info\ninfo\n:::     \n\n:::success\nsuccess\n:::\n\n:::error\nerror\n:::    \n\n:::bug\nbug\n:::   \n\n:::todo\ntodo\n:::  \n\n:::example\nexample \n:::   \n\n:::quote\nquote\n::: \n\n:::link\nlink\n:::\n\n:::code\ncode\n:::\n\n:::update\nupdate\n:::\n\n:::star\nstar\n:::\n\n:::time\ntime\n:::  \n\n</details>\n\n# 标题大小对比\n## 2级\n### 3级\n#### 4级\n##### 5级\n###### 6级","tags":["博客"],"categories":["其他"]},{"title":"曝光三要素","url":"/posts/27350/","content":"\n教程及截图来自b站： https://www.bilibili.com/video/BV1DQiyYkEJC/\n\n## 认识快门\n\n- 快门：控制接收光线的时间 时间长，进光量大，画面亮。\n- 在M档、快门优先档（S档）控制。\n- **快门影响物体的动态模糊。**\n\t- 在快门打开关闭时间内，所拍摄物体没有足够时间移动，那么所拍摄物体时静止的\n\t- 相反，若物体是运动的，则会把运动轨迹记录起来。\n![](Snipaste_2025-01-19_11-59-54.png)\n\n### 安全快门\n\n- 能保证画面清晰所使用的最低快门速度（手持拍摄）\n- 具体数值为焦距的倒数，例如50mm焦距，安全快门为：1/50s\n\n- 一些常规题材快门速度推荐（常用调整值）： #拍摄技巧 \n\t- 人文题材 新闻报道  **快门常用 1/125s**\n\t- 行人，跑动的小孩   **快门常用 1/500s**\n\n### 高速快门\n\n- 画面亮度会降低，可以清晰的拍摄高速运动的物体\n- 限制：场景光线强，否则画面非常暗\n\n- 使用高速快门拍摄的题材 #拍摄技巧  \n\t- ![](Snipaste_2025-01-19_12-16-50.png)\n\n\t- ![](Snipaste_2025-01-19_12-27-34.png)\n\n### 低速快门\n\n- 曝光的时间较长，画面中运动的物体的主题会留下运行的轨迹，会变得模糊，**同时画面的亮度会被提高。**\n- 一般需要稳定拍摄，手持的抖动对画面影响大\n\n - 使用低速快门的题材 #拍摄技巧 \n\t - ![](Snipaste_2025-01-19_13-32-09.png)\n\t\t- 对于摇拍的补充：利用相对静止的原理，跟随运动物体进行平行移动，可以实现拍摄物体清晰，而其他背景模糊，同样也可以使用相机连拍功能实现该效果\n\t- 瀑布水流拉丝效果： **快门常用 5~10s** 配合减光镜稳定拍摄（三脚架）。或者调整光圈f/22左右\n\t- 车轨 烟花：**快门常用 5~10s** 稳定拍摄（三脚架）。调整光圈f/16配合。\n\n### 快门优先（TV/S）\n\n- 只需调整快门速度\n- 为满足日常的 风光拍摄 和 运动摄影\n\n### 练习\n1. 高速运动的物体\n2. 追焦拍摄（摇拍）\n3. 车轨\n\n![快门的选择](Snipaste_2025-01-19_17-05-08.png)\n\n---\n\n## 认识光圈\n\n- 控制进光量的装置\n\n### 光圈影响进光量\n\n- ![](Snipaste_2025-01-19_15-49-45.png)\n- 不同的曝光状态：欠曝、过曝\n- **光圈会和快门速度一起影响进光量**\n\n### 光圈影响景深\n\n- ![](Snipaste_2025-01-19_15-55-04.png)\n- 光圈的运用： #拍摄技巧 \n\t- **大光圈的跑焦问题**。使用超大光圈镜头时，最好不要使用最大光圈去拍，降低一个挡位。\n\t- 有时**主题突出**使用大光圈\n\t\t- ![](Snipaste_2025-01-19_16-00-53.png)\n\t- 拍人像时**不要一味的使用景深效果**（为了突出主题而突出主体）：需要结合环境，有些情况需要环境配合或交代环境\n\t\t- ![](Snipaste_2025-01-19_16-04-53.png)\n\t- 有时需要**全局清晰**使用小光圈 表现大环境\n\t\t- ![](Snipaste_2025-01-19_16-06-22.png)\n### 最佳画质光圈\n\n- 一般在最大光圈缩小2~3档位\n\n### 光圈优先（AV/A）\n\n- 手动调整光圈\n- 满足于日常的人像拍摄、静物拍摄\n\n### 练习\n\n- 虚化效果的小花\n\n---\n\n## 认识感光度（ISO）\n\n- 感光器件对光的敏感程度\n- 控制亮度和成片质量\n- 数值越大，感光度高，那么画面亮\n\n### ISO影响画质（噪点）\n\n- ![](Snipaste_2025-01-19_16-38-20.png)\n\n - 感光度的运用 #拍摄技巧 \n\t - **对于ISO，其作用相当于给你一盏灯，在黑暗环境下我们需要打开灯看清画面，灯的功率有不同的瓦数。**\n\t - 通常情况\n\t\t - ![](Snipaste_2025-01-19_16-41-30.png)\n\t - 过暗环境 ISO太高导致噪点\n\t\t - 兼顾画质和画面：**补光** 闪光灯、常亮灯\n\t\t - 画面优先：提高ISO\n\t- 想要复古感，想要噪点：主动提高ISO\n\n---\n\n## 曝光三要素的结合使用\n\n![](Snipaste_2025-01-19_17-03-48.png)\n\n### 在一个阳光灿烂的中午拍摄有虚化效果的小花\n\n- 首先光圈要大一点，才有虚化效果，静止物体，不需要高速或低速快门，室外阳光天气光线充足，ISO调到最小\n- f/1.8 1/500 100\n- 没有大光圈，怎么办 #拍摄技巧 \n\t- 主体离背景足够远，也会有虚化效果\n- 感觉可以使用光圈A优先。。\n\n### 拍摄人在夜晚跑步\n\n- 夜晚环境较暗，使用较大光圈提高进光量，但是太大会跑焦，拍摄运动的物体，快门spee的快一点，但是快门太快画面太暗，于是调高感光度\n- f/2.8 1/250 800\n- 个人感觉可以使用快门S优先。。\n","tags":["摄影基础","学习笔记","曝光三要素"],"categories":["摄影学习"]}]
[{"title":"WSL-Archlinux安装后应该做什么？","url":"/posts/17327/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n- [1. 在WSL上安装Archlinux](#1-在wsl上安装archlinux)\n- [2. 更新系统](#2-更新系统)\n- [3. 基础配置](#3-基础配置)\n  - [3.1. 设置root密码](#31-设置root密码)\n  - [3.2. 创建普通用户并加入 `wheel` 组（方便后续 sudo 权限）：](#32-创建普通用户并加入-wheel-组方便后续-sudo-权限)\n  - [3.3. 编辑 sudo 权限](#33-编辑-sudo-权限)\n  - [3.4. 设定默认用户](#34-设定默认用户)\n  - [3.5. 设置语言和地区](#35-设置语言和地区)\n  - [3.6. AUR 支持](#36-aur-支持)\n  - [3.7. 关于换源](#37-关于换源)\n- [4. 个性化设置](#4-个性化设置)\n  - [4.1. 使用zsh替代bash](#41-使用zsh替代bash)\n  - [4.2. 使用oh-my-zsh为zsh提供插件服务](#42-使用oh-my-zsh为zsh提供插件服务)\n  - [4.3. 使用oh-my-posh为zsh提供主题](#43-使用oh-my-posh为zsh提供主题)\n\n\n## 1. 在WSL上安装Archlinux\n\n请参见—— [在 WSL 上安装 Arch Linux - Arch Linux 中文维基](https://wiki.archlinuxcn.org/wiki/%E5%9C%A8_WSL_%E4%B8%8A%E5%AE%89%E8%A3%85_Arch_Linux)\n\n## 2. 更新系统\n\n```bash\nsudo pacman -Syu\n```\n## 3. 基础配置\n\n### 3.1. 设置root密码\n```bash\npasswd\n```\n\n### 3.2. 创建普通用户并加入 `wheel` 组（方便后续 sudo 权限）：\n```bash\nuseradd -m -G wheel -s /bin/bash yourname\npasswd yourname\n```\n\n`-m`：自动创建用户目录\n`-G`：指定用户组\n`-s`：指定shell\n\n### 3.3. 编辑 sudo 权限\n安装 `sudo`，再启用 `wheel` 组：\n```bash\npacman -S sudo nano\n```\n\n```bash\nnano /etc/sudoers\n```\n\n去掉 `# %wheel ALL=(ALL:ALL) ALL` 前的注释\n\n!!! todo \"tip\"\n    前面带%(如%wheel)则表示这是一个用户组，不带则表示这是一个用户。\n\n\n### 3.4. 设定默认用户\n不能总是用root用户登录。\n首先确保该用户已被创建，然后将以下行添加到 `/etc/wsl.conf`：\n\n```\n[user]\ndefault=username\n```\n\n### 3.5. 设置语言和地区\n目的是正确显示中文字符\n```bash\nlocale-gen\necho \"LANG=en_US.UTF-8\" > /etc/locale.conf\n```\n\n请参见——[简体中文本地化 - Arch Linux 中文维基](https://wiki.archlinuxcn.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E6%9C%AC%E5%9C%B0%E5%8C%96)\n\n### 3.6. AUR 支持\n可以下载来自社区的软件包，这里选用AUR助手 yay\n选择一个指定目录然后执行：\n```bash\npacman -S git base-devel --needed  #<-这是基本的开发工具包，如gcc、make\ngit clone https://aur.archlinux.org/yay-bin.git\ncd yay-bin\nmakepkg -si # 构建包\n```\n`-s`：自动安装依赖\n`-i`：编译完成后自动安装生成的包\n\n请参见——[yay - Arch Linux 中文维基](https://wiki.archlinuxcn.org/wiki/Yay)\n\n### 3.7. 关于换源\n\n打开`WSL-setting`（直接在win11里搜索）的网络设置，将网络模式由`NAT` 改为 `mirror`， 则可直接继承宿主机的网络环境。在宿主机使用网络安全工具即可，因此暂时没有换源。\n\n## 4. 个性化设置\n\n### 4.1. 使用zsh替代bash\n\n```bash\nsudo pacman -S zsh\nchsh -s /bin/zsh # 改变默认shell\n```\n\n### 4.2. 使用oh-my-zsh为zsh提供插件服务\n```bash\nyay -S oh-my-zsh.git\n```\n\n安装完成后 可以在 `/usr/share/oh-my-zsh` 中查看主题文件和插件以及其提供的`zshrc`配置模板，直接使用配置模板。\n```bash\ncp /usr/share/oh-my-zsh/zshrc ~/.zshrc\n```\n\n进入`/usr/share/oh-my-zsh\\plugins`目录 安装自动补全与语法高亮插件（不自带）\n```bash\ngit clone https://github.com/zsh-users/zsh-autosuggestions\n```\n\n```bash\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git\n```\n\n在 `.zshrc` 里添加：\n```\nplugins=(git zsh-autosuggestions zsh-syntax-highlighting)\n```\n\n### 4.3. 使用oh-my-posh为zsh提供主题\n你也可以使用`oh-my-zsh`的主题，只不过我更喜欢`oh-my-posh`的主题\n\n```bash\nyay -S oh-my-posh-bin\n```\n\n同样，安装完成后 可以在 `/usr/share/oh-my-posh` 中查看主题文件，\n编辑`~/.zshrc`：\n```bash\n#注释掉ZSH_THEME=\"robbyrussell\"\neval \"$(oh-my-posh init zsh --config 'amro')\"\n```\n\n!!! error \"bug\"\n    建议不要使用类似于 `--config ~/.poshthemes/mytheme.omp.json`的选项，这可能会出现问题。\n\n\n重新加载：\n```bash\nsource ~/.zshrc\n```\n\n","tags":["WSL2","ArchLinux"],"categories":["Linux","ArchLinux"]},{"title":"POSIX IPC：System V 的继任者","url":"/posts/26506/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n- [1. POSIX IPC：System V 的继任者](#1-posix-ipcsystem-v-的继任者)\n  - [1.1. POSIX 消息队列](#11-posix-消息队列)\n    - [1.1.1. 消息队列属性](#111-消息队列属性)\n  - [1.2. POSIX 信号量](#12-posix-信号量)\n  - [1.3. POSIX 共享内存](#13-posix-共享内存)\n\n\n## 1. POSIX IPC：System V 的继任者\n\n**POSIX IPC**（Portable Operating System Interface）是一套新的 IPC 标准，旨在解决 **System V IPC** 的一些局限性。它提供了一套更统一、更现代的 API，使用**文件名**作为标识符，而不是 System V 的**键值**，这使得 IPC 资源的管理更加直观。\n\n### 1.1. POSIX 消息队列\n\n与 System V 消息队列类似，但 API 更简洁。\n\n- **特点**：\n\n    - **基于文件**：通过 `/dev/mqueue` 目录下的文件名来标识。\n\n    - **优先级**：支持消息优先级，高优先级的消息会被优先处理。\n\n    - **非阻塞模式**：可以设置消息队列为非阻塞模式，防止 `mq_send` 或 `mq_receive` 阻塞进程。\n\n- **使用**：\n\n    - **`mq_open()`**：创建或打开一个消息队列。\n\n    - **`mq_send()`**：发送消息。\n\n    - **`mq_receive()`**：接收消息。\n\n    - **`mq_close()`**：关闭消息队列。\n\n    - **`mq_unlink()`**：删除消息队列。\n\n#### 1.1.1. 消息队列属性\n\n在POSIX消息队列中，**消息队列属性**（`mq_attr`）是用来设置和获取消息队列的特性和参数的结构体。它的主要作用是控制消息队列的行为，例如最大消息数、消息大小等。`mq_attr`结构体包含了以下几个字段：\n```c\nstruct mq_attr {\n    long    mq_flags;      // 消息队列的标志\n    long    mq_maxmsg;     // 消息队列中最多可以容纳的消息数量\n    long    mq_msgsize;    // 队列中每条消息的最大大小\n    long    mq_curmsgs;    // 当前队列中的消息数\n};\n```\n\n1. `mq_flags`\n\n\t这个字段用于设置消息队列的标志。常见的标志有：\n\t\n\t- **`O_NONBLOCK`**：以非阻塞模式打开消息队列。这意味着如果消息队列为空，接收操作（`mq_receive()`）会立即返回，而不是阻塞等待。\n\t\n\t- **`O_RDWR`**：允许对消息队列进行读写操作。\n\t\n\t如果没有设置这些标志，消息队列将会默认阻塞模式操作。\n\n2. `mq_maxmsg`\n\n\t这个字段定义了消息队列可以容纳的最大消息数量。如果消息队列已经存满，且没有空间容纳新的消息，后续的消息发送（`mq_send()`）将会被阻塞，直到队列中有足够的空间。这个属性通常设置为你希望消息队列中能存储的消息个数。\n\n3. `mq_msgsize`\n\n\t此字段定义每条消息的最大字节数。在创建消息队列时，必须确保消息发送和接收操作的消息大小不会超过这个值。如果消息超过了这个大小，发送操作将返回错误。\n\n4. `mq_curmsgs`\n\n\t这个字段是一个只读属性，用于获取当前队列中的消息数量。它是一个动态更新的值，每次读取时会返回当前消息队列中实际存储的消息数。这个字段对应用程序来说很有用，尤其是在需要了解队列当前状态的场景。\n\n这个例子展示了两个不相关的进程如何通过 POSIX 消息队列进行通信。\n发送方(sender.c)：\n```c\n#include <stdio.h>\n#include <stdlib.h>          /* 动态内存管理及其他辅助功能如exit、abort */\n#include <string.h>\n#include <fcntl.h>           /* 提供 O_CREAT, O_RDWR 用于文件控制 */\n#include <sys/stat.h>        /* 文件属性操作 如chmod、umask */\n#include <mqueue.h>          /* 提供POSIX消息队列支持 */\n#include <unistd.h>          /* 提供POSIX接口 */\n\n#define MQ_NAME \"/my_mq\"\n\nint main() {\n    mqd_t mqd;\n    struct mq_attr attr;\n    char buffer[256];\n    const char *msg = \"Hello from sender!\";\n\n    // 设置消息队列属性\n    attr.mq_flags = 0;\n    attr.mq_maxmsg = 10;\n    attr.mq_msgsize = 256;\n    attr.mq_curmsgs = 0;\n\n    // 创建或打开消息队列\n    mqd = mq_open(MQ_NAME, O_CREAT | O_WRONLY, 0666, &attr);\n    if (mqd == (mqd_t)-1) {\n        perror(\"mq_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Sender: Sending message...\\n\");\n\n    // 发送消息，优先级为1\n    if (mq_send(mqd, msg, strlen(msg) + 1, 1) == -1) {\n        perror(\"mq_send\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 关闭消息队列描述符\n    mq_close(mqd);\n\n    printf(\"Sender: Message sent and mq closed.\\n\");\n    return 0;\n}\n```\n\n接收方(receiver.c)：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <mqueue.h>\n#include <unistd.h>\n\n#define MQ_NAME \"/my_mq\"\n\nint main() {\n    mqd_t mqd;\n    struct mq_attr attr;\n    char buffer[256 + 1];\n    unsigned int prio;\n\n    // 打开消息队列\n    mqd = mq_open(MQ_NAME, O_RDONLY);\n    if (mqd == (mqd_t)-1) {\n        perror(\"mq_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 获取消息队列属性\n    mq_getattr(mqd, &attr);\n\n    printf(\"Receiver: Waiting for message...\\n\");\n\n    // 接收消息\n    if (mq_receive(mqd, buffer, attr.mq_msgsize, &prio) == -1) {\n        perror(\"mq_receive\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Receiver: Received message: %s (Priority: %u)\\n\", buffer, prio);\n\n    // 关闭和删除消息队列\n    mq_close(mqd);\n    mq_unlink(MQ_NAME);\n\n    return 0;\n}\n```\n\n**编译和运行**： `gcc sender.c -o sender -lrt` `gcc receiver.c -o receiver -lrt` （需要链接实时库 `-lrt`） 先运行 `./sender`，再运行 `./receiver`。\n\n### 1.2. POSIX 信号量\n\n用于进程间的同步，功能与 System V 信号量类似，但提供了更简单的接口。\n\n- **特点**：\n\n    - **有名信号量**：通过一个文件名标识，可以用于非亲缘进程。\n\n    - **无名信号量**：常用于线程间的同步，存放在共享内存中，只能用于有亲缘关系的进程。\n\n- **使用**：\n\n    - **`sem_open()`**：创建或打开有名信号量。\n\n    - **`sem_wait()`**：原子性地减少信号量计数器，如果为0则阻塞。\n\n    - **`sem_post()`**：原子性地增加信号量计数器。\n\n    - **`sem_close()`**：关闭信号量。\n\n    - **`sem_unlink()`**：删除信号量。\n\n这个例子展示了如何使用 POSIX 信号量来同步两个进程对一个共享资源的访问。\n\n共享资源访问程序 (sem_client.c)：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>           /* For O_CREAT, O_RDWR */\n#include <sys/stat.h>        /* For mode constants */\n#include <semaphore.h>\n#include <unistd.h>\n\n#define SEM_NAME \"/my_semaphore\"\n\nint main() {\n    sem_t *sem;\n    int value;\n\n    // 打开信号量\n    sem = sem_open(SEM_NAME, 0); // O_CREAT is not needed here\n    if (sem == SEM_FAILED) {\n        perror(\"sem_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Client: Waiting to get semaphore...\\n\");\n\n    // P 操作：等待信号量，如果值为0则阻塞\n    if (sem_wait(sem) == -1) {\n        perror(\"sem_wait\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Client: Got the semaphore. Accessing shared resource...\\n\");\n    sleep(2); // 模拟访问共享资源\n\n    printf(\"Client: Finished. Releasing semaphore...\\n\");\n\n    // V 操作：释放信号量，计数器加1\n    if (sem_post(sem) == -1) {\n        perror(\"sem_post\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 关闭信号量\n    sem_close(sem);\n\n    return 0;\n}\n```\n\n信号量控制程序 (sem_main.c)：`\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <semaphore.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#define SEM_NAME \"/my_semaphore\"\n\nint main() {\n    sem_t *sem;\n    pid_t pid;\n\n    // 创建并初始化信号量，初始值为1\n    sem = sem_open(SEM_NAME, O_CREAT, 0666, 1);\n    if (sem == SEM_FAILED) {\n        perror(\"sem_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Main: Semaphore created and initialized to 1.\\n\");\n\n    // 创建一个子进程\n    pid = fork();\n    if (pid == 0) {\n        // 子进程运行另一个程序来访问信号量\n        execlp(\"./sem_client\", \"sem_client\", NULL);\n        perror(\"execlp\"); // 如果执行失败\n        exit(EXIT_FAILURE);\n    } else if (pid > 0) {\n        // 父进程也尝试访问信号量\n        sleep(1); // 确保子进程先运行\n        printf(\"Main: Waiting to get semaphore...\\n\");\n        sem_wait(sem);\n        printf(\"Main: Got the semaphore. Accessing shared resource...\\n\");\n        sleep(2);\n        printf(\"Main: Finished. Releasing semaphore...\\n\");\n        sem_post(sem);\n\n        wait(NULL); // 等待子进程结束\n\n        // 删除信号量\n        sem_unlink(SEM_NAME);\n        printf(\"Main: Child process finished. Semaphore unlinked.\\n\");\n    }\n\n    // 关闭信号量\n    sem_close(sem);\n\n    return 0;\n}\n```\n\n**编译和运行**： `gcc sem_client.c -o sem_client -lrt` `gcc sem_main.c -o sem_main -lrt` （同样需要链接实时库 `-lrt`） 运行 `./sem_main`。\n\n\n\n### 1.3. POSIX 共享内存\n\n和 System V 共享内存一样，都是最快的 IPC 方式，但 POSIX 版本使用了文件描述符。\n\n- **特点**：\n\n    - **基于文件**：通过 `shm_open` 创建或打开一个共享内存对象，返回一个文件描述符。\n\n    - **内存映射**：通过 `mmap()` 将文件描述符对应的内存映射到进程的地址空间。\n\n- **使用**：\n\n    - **`shm_open()`**：创建或打开共享内存对象。\n\n    - **`ftruncate()`**：调整共享内存对象的大小。\n\n    - **`mmap()`**：将共享内存映射到进程地址空间。\n\n    - **`munmap()`**：解除映射。\n\n    - **`shm_unlink()`**：删除共享内存对象。\n\n这个例子展示了两个进程如何通过 POSIX 共享内存来共享一块内存区域，并用一个信号量来同步。\n\n写入方 (shm_writer.c)\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <semaphore.h>\n#include <unistd.h>\n\n#define SHM_NAME \"/my_shm\"\n#define SEM_NAME \"/my_shm_sem\"\n#define SHM_SIZE 4096\n\nint main() {\n    int shm_fd;\n    void *ptr;\n    sem_t *sem;\n    const char *msg = \"Hello from shm writer!\";\n\n    // 创建/打开共享内存对象\n    shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);\n    if (shm_fd == -1) {\n        perror(\"shm_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 设置共享内存大小\n    ftruncate(shm_fd, SHM_SIZE);\n\n    // 将共享内存映射到进程地址空间\n    ptr = mmap(0, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);\n    if (ptr == MAP_FAILED) {\n        perror(\"mmap\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 创建/打开信号量，用于同步\n    sem = sem_open(SEM_NAME, O_CREAT, 0666, 0); // 初始值为0，表示不可访问\n    if (sem == SEM_FAILED) {\n        perror(\"sem_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Writer: Writing to shared memory...\\n\");\n    // 写入数据\n    sprintf(ptr, \"%s\", msg);\n\n    // V 操作：释放信号量，通知读者可以读取了\n    sem_post(sem);\n    printf(\"Writer: Data written and semaphore posted.\\n\");\n\n    // 关闭\n    sem_close(sem);\n    munmap(ptr, SHM_SIZE);\n    close(shm_fd);\n\n    return 0;\n}\n```\n\n读取方 (shm_reader.c)：\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <semaphore.h>\n#include <unistd.h>\n\n#define SHM_NAME \"/my_shm\"\n#define SEM_NAME \"/my_shm_sem\"\n#define SHM_SIZE 4096\n\nint main() {\n    int shm_fd;\n    void *ptr;\n    sem_t *sem;\n\n    // 打开共享内存对象\n    shm_fd = shm_open(SHM_NAME, O_RDONLY, 0666);\n    if (shm_fd == -1) {\n        perror(\"shm_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 将共享内存映射到进程地址空间\n    ptr = mmap(0, SHM_SIZE, PROT_READ, MAP_SHARED, shm_fd, 0);\n    if (ptr == MAP_FAILED) {\n        perror(\"mmap\");\n        exit(EXIT_FAILURE);\n    }\n\n    // 打开信号量\n    sem = sem_open(SEM_NAME, 0);\n    if (sem == SEM_FAILED) {\n        perror(\"sem_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Reader: Waiting for writer...\\n\");\n    // P 操作：等待信号量，直到有数据可用\n    sem_wait(sem);\n\n    printf(\"Reader: Data received: %s\\n\", (char *)ptr);\n\n    // 关闭和清理\n    sem_close(sem);\n    sem_unlink(SEM_NAME); // 删除信号量\n    munmap(ptr, SHM_SIZE);\n    close(shm_fd);\n    shm_unlink(SHM_NAME); // 删除共享内存对象\n\n    return 0;\n}\n```\n\n**编译和运行**： `gcc shm_writer.c -o shm_writer -lrt` `gcc shm_reader.c -o shm_reader -lrt` （同样需要链接实时库 `-lrt`） 先运行 `./shm_writer`，再运行 `./shm_reader`。\n\n\n\n","tags":["Linux","IPC","POSIX"],"categories":["Linux","内核编程"]},{"title":"深入浅出 Linux IPC：进程间通信的艺术","url":"/posts/46571/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n- [1. 为什么需要 IPC？](#1-为什么需要-ipc)\n- [2. 常见的 Linux IPC 机制](#2-常见的-linux-ipc-机制)\n  - [2.1. 管道（Pipes）](#21-管道pipes)\n  - [2.2. FIFO（命名管道）](#22-fifo命名管道)\n  - [2.3. 信号](#23-信号)\n    - [2.3.1. 信号的分类](#231-信号的分类)\n    - [2.3.2. 信号与 IPC 的关系](#232-信号与-ipc-的关系)\n    - [2.3.3. 信号的三种处理方式](#233-信号的三种处理方式)\n    - [2.3.4. 如何使用信号？](#234-如何使用信号)\n      - [2.3.4.1. 发送信号：`kill()` 函数](#2341-发送信号kill-函数)\n      - [2.3.4.2. 注册信号处理函数：`signal()` 和 `sigaction()`](#2342-注册信号处理函数signal-和-sigaction)\n  - [2.4. 信号集（Signal Set）和阻塞](#24-信号集signal-set和阻塞)\n    - [2.4.1. 信号集操作函数](#241-信号集操作函数)\n    - [2.4.2. 阻塞信号：`sigprocmask()`](#242-阻塞信号sigprocmask)\n  - [2.5. System V IPC (System V IPC)\\[^1\\]](#25-system-v-ipc-system-v-ipc)\n    - [2.5.1. 消息队列（Message Queues）](#251-消息队列message-queues)\n    - [2.5.2. 信号量（Semaphores）](#252-信号量semaphores)\n    - [2.5.3. 共享内存（Shared Memory）](#253-共享内存shared-memory)\n  - [2.6. IPC 总结与选择](#26-ipc-总结与选择)\n\n\n在 Linux 世界中，进程是独立的执行单元，拥有自己的地址空间。但很多时候，为了完成一个复杂的任务，不同的进程需要协同工作，交换数据。这时，我们就需要**进程间通信（IPC, Inter-Process Communication）**。IPC 就像是进程之间的一座桥梁，让它们能够相互“交谈”，共享信息。\n\n本文将带你深入了解 Linux 中常见的 IPC 机制，并以**使用为导向**，结合代码示例，让你能够快速掌握这些“通信”技术。\n\n## 1. 为什么需要 IPC？\n\n想象一个场景：你正在开发一个 Web 服务器。一个主进程负责监听网络请求，但处理这些请求非常耗时。如果主进程自己处理，服务器就会变得很慢，无法响应新的请求。一个更好的设计是，主进程每接收到一个请求，就创建一个新的子进程或将请求发送给一个工作进程池来处理。这样，主进程可以立即回去监听新的连接，而工作进程则专注于处理任务。\n\n在这个例子中，主进程需要将请求数据传递给工作进程。这就是 IPC 发挥作用的地方。\n\n## 2. 常见的 Linux IPC 机制\n\nLinux 提供了多种 IPC 机制，每种都有其独特的优缺点和适用场景。我们可以将它们分为两大类：**基于文件**和**基于内存**。\n\n### 2.1. 管道（Pipes）\n\n管道可能是最简单、最古老的 IPC 形式。它就像一个单向的“水管”，一端用于写入，另一端用于读取。\n\n- **特点**：\n\n    - **单向通信**：数据只能从一端流向另一端。\n\n    - **父子进程通信**：管道通常用于有亲缘关系的进程之间，比如父进程和子进程。\n\n    - **半双工**：虽然是单向，但如果创建两个管道，就可以实现双向通信。\n\n- **使用**：\n\n    - **`pipe()` 函数**：这是创建管道的核心函数。\n\n    ```c\n    #include <unistd.h>\n    int pipe(int pipefd[2]);\n    ```\n\n    `pipefd` 是一个包含两个文件描述符的数组，`pipefd[0]` 用于读取，`pipefd[1]` 用于写入。\n\n- **代码示例**：一个简单的父子进程通信。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/wait.h>\n\nint main() {\n    int pipefd[2];\n    pid_t pid;\n    char buf[20];\n    const char *msg = \"Hello from parent!\";\n\n    if (pipe(pipefd) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid > 0) { // 父进程\n        close(pipefd[0]); // 关闭读取端\n        write(pipefd[1], msg, strlen(msg) + 1);\n        close(pipefd[1]); // 关闭写入端，如果不关，子进程读端收不到EOF信号，则会一直读导致程序阻塞\n        wait(NULL);\n    } else { // 子进程\n        close(pipefd[1]); // 关闭写入端，如果不关\n        read(pipefd[0], buf, sizeof(buf));\n        printf(\"Child received: %s\\n\", buf);\n        close(pipefd[0]); // 关闭读取端\n    }\n\n    return 0;\n}\n```\n\n### 2.2. FIFO（命名管道）\n\n管道只能用于有亲缘关系的进程，那如果两个毫不相关的进程想通信怎么办？答案就是 **FIFO (First-In, First-Out)**，也叫**命名管道**。\n\n- **特点**：\n\n    - **文件系统路径**：它在文件系统中有一个路径名，不同于匿名管道。\n\n    - **非亲缘进程通信**：任意两个进程都可以通过这个路径名打开并通信。\n\n    - **单向**：和管道一样，FIFO 也是单向的，需要两个 FIFO 来实现双向通信。\n\n- **使用**：\n\n    - **`mkfifo()` 函数**或 **`mkfifo` 命令**：用来创建 FIFO。\n\n\n    ```c\n    #include <sys/types.h>\n    #include <sys/stat.h>\n    int mkfifo(const char *pathname, mode_t mode);\n    ```\n\n    - **`open()`, `read()`, `write()` 函数**：像操作普通文件一样来操作 FIFO。\n\n- **代码示例**：\n\n    - **`writer.c`**：\n\n    ```c\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <fcntl.h>\n    #include <sys/stat.h>\n    #include <unistd.h>\n\n    #define FIFO_NAME \"my_fifo\"\n\n    int main() {\n        int fd;\n        char *msg = \"Hello from writer!\";\n\n        mkfifo(FIFO_NAME, 0666);\n        fd = open(FIFO_NAME, O_WRONLY);\n        write(fd, msg, strlen(msg) + 1);\n        close(fd);\n        unlink(FIFO_NAME); // 删除命名管道文件\n        return 0;\n    }\n    ```\n\n    - **`reader.c`**：\n\n    ```c\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <fcntl.h>\n    #include <sys/stat.h>\n    #include <unistd.h>\n\n    #define FIFO_NAME \"my_fifo\"\n\n    int main() {\n        int fd;\n        char buf[20];\n\n        mkfifo(FIFO_NAME, 0666); // 保证文件存在\n        fd = open(FIFO_NAME, O_RDONLY);\n        read(fd, buf, sizeof(buf));\n        printf(\"Reader received: %s\\n\", buf);\n        close(fd);\n        return 0;\n    }\n    ```\n\n    你可以先运行 `writer.c`，再运行 `reader.c`。\n\n\n\n### 2.3. 信号\n\n**信号（Signal）** 是一种更轻量级、更异步的进程间通信和事件通知机制。它就像一个“软中断”，用来通知进程发生了某个事件。\n\n想象一下，你正在专注地工作，突然有人拍了你一下肩膀。你停下手中的活，转头看看发生了什么事，然后根据情况做出反应（比如，对方是同事，你可能和他聊两句；对方是领导，你可能马上站起来）。\n\n在 Linux 中，**信号**就是那个“拍肩膀”的动作。当一个进程收到一个信号时，它会暂停当前执行的任务，转而去处理这个信号，处理完后再恢复执行。\n\n- **发送者**：可以是内核（比如你按下 `Ctrl+C`，内核会发送 `SIGINT` 信号给前台进程）、也可以是其他进程（使用 `kill()` 函数）。\n\n- **接收者**：任何一个进程都可以接收信号。\n\n\n#### 2.3.1. 信号的分类\n\n信号有很多种，每种都有其特定的用途。常见的信号及其作用如下：\n\n|信号名称|默认行为|解释|\n|---|---|---|\n|**`SIGHUP` (1)**|终止进程|当终端关闭时发送给关联的进程。|\n|**`SIGINT` (2)**|终止进程|来自键盘中断，通常是 `Ctrl+C`。|\n|**`SIGQUIT` (3)**|终止并生成核心转储文件|来自键盘退出，通常是 `Ctrl+\\\\`。|\n|**`SIGKILL` (9)**|强制终止进程|无法被捕获、阻塞或忽略，强制杀死进程。|\n|**`SIGTERM` (15)**|终止进程|友好的终止请求，可以被捕获。`kill` 命令默认发送此信号。|\n|**`SIGCHLD`**|忽略|子进程终止或停止时发送给父进程。|\n|**`SIGSTOP`**|停止进程|无法被捕获、忽略，暂停进程。|\n|**`SIGCONT`**|继续进程|使停止的进程继续运行。|\n\n#### 2.3.2. 信号与 IPC 的关系\n\n- **异步通知**：信号是典型的异步 IPC 机制，它不像管道或共享内存那样传递数据，而是**传递事件信息**。\n\n- **轻量级**：相比于其他 IPC，信号的开销非常小。\n\n- **同步**：信号也可以用于同步目的，例如 `SIGCHLD` 信号常用于父进程等待子进程结束。\n\n\n理解信号，特别是信号集和阻塞的概念，对于编写健壮的多进程或多线程程序至关重要。它能让你更好地控制程序对外部事件的响应。\n\n\n#### 2.3.3. 信号的三种处理方式\n\n当进程收到一个信号时，它可以有三种处理方式：\n\n1. **执行默认动作（Default）**：大多数信号都有一个预定义的默认行为。例如，`SIGINT` 的默认行为就是终止进程。\n\n2. **忽略信号（Ignore）**：有些信号可以被忽略，即进程收到信号后不做任何处理。`SIGCHLD` 信号的默认行为就是忽略。\n\n3. **捕获信号（Catch）**：这是最灵活的方式。进程可以为某个信号注册一个**信号处理函数（Signal Handler）**。当信号到来时，进程会执行这个函数来处理信号，而不是执行默认动作。\n\n!!! caution\n    **注意**：`SIGKILL` 和 `SIGSTOP` 这两个信号是**不能被捕获、忽略或阻塞**的。它们是系统管理员强制终止或停止进程的“最后手段”。\n\n\n\n#### 2.3.4. 如何使用信号？\n\n##### 2.3.4.1. 发送信号：`kill()` 函数\n\n你可以使用 `kill()` 函数向另一个进程发送信号。\n\n```c\n#include <sys/types.h>\n#include <signal.h>\nint kill(pid_t pid, int sig);\n```\n\n- `pid`：目标进程的 ID。\n\n- `sig`：要发送的信号编号。\n\n\n##### 2.3.4.2. 注册信号处理函数：`signal()` 和 `sigaction()`\n\n- **`signal()` 函数**：这是最简单的注册方式，但它在不同系统上的行为可能不一致，不推荐在新代码中使用。\n\n- **`sigaction()` 函数**：这是 POSIX 标准推荐的方式，更强大，更可靠。\n\n\n```c\n#include <signal.h>\nint sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);\n```\n\n- `signum`：要捕获的信号编号。\n\n- `act`：指向 `struct sigaction` 结构体，该结构体定义了新的信号处理行为。\n\n- `oldact`：可选，用于保存旧的信号处理行为。\n\n\n**`struct sigaction` 结构体**：\n```c\nstruct sigaction {\n    void (*sa_handler)(int);  // 信号处理函数\n    sigset_t sa_mask;         // 信号集，在信号处理函数执行期间需要阻塞的信号\n    int sa_flags;             // 标志位\n};\n```\n\n### 2.4. 信号集（Signal Set）和阻塞\n\n当你在处理一个信号时，你可能不希望被其他信号打断。**信号集（`sigset_t`）** 就是用来管理一组信号的。通过操作信号集，你可以**阻塞（Block）** 某些信号，让它们在进程处理完当前任务后才被传递。\n\n#### 2.4.1. 信号集操作函数\n\n- **`sigemptyset()`**：初始化一个空的信号集。\n\n- **`sigaddset()`**：向信号集中添加一个信号。\n\n- **`sigdelset()`**：从信号集中删除一个信号。\n\n- **`sigismember()`**：检查一个信号是否在信号集中。\n\n\n#### 2.4.2. 阻塞信号：`sigprocmask()`\n\n`sigprocmask()` 函数用来设置进程的**信号阻塞掩码（Signal Mask）**。\n\n```c\n#include <signal.h>\nint sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\n```\n\n- `how`：指定如何修改信号阻塞掩码，有以下几种：\n\n    - `SIG_BLOCK`：将 `set` 中的信号添加到阻塞掩码中。\n\n    - `SIG_UNBLOCK`：将 `set` 中的信号从阻塞掩码中移除。\n\n    - `SIG_SETMASK`：将阻塞掩码设置为 `set`。\n\n- `set`：包含要阻塞或解除阻塞的信号集。\n\n- `oldset`：可选，用于保存旧的阻塞掩码。\n\n\n**示例**：在处理关键代码段时临时阻塞 `SIGINT`。\n\n```c\n#include <stdio.h>\n#include <signal.h>\n#include <unistd.h>\n\nvoid my_handler(int sig) {\n    printf(\"Caught signal %d\\n\", sig);\n}\n\nint main() {\n    sigset_t block_mask, old_mask;\n\n    // 1. 设置要阻塞的信号集\n    sigemptyset(&block_mask);\n    sigaddset(&block_mask, SIGINT);\n\n    // 2. 阻塞 SIGINT 信号\n    sigprocmask(SIG_BLOCK, &block_mask, &old_mask);\n\n    printf(\"SIGINT is blocked. Press Ctrl+C...\\n\");\n    sleep(10); // 在这10秒内，Ctrl+C不会终止进程\n\n    printf(\"Unblocking SIGINT...\\n\");\n    // 3. 解除阻塞，恢复旧的信号掩码\n    sigprocmask(SIG_SETMASK, &old_mask, NULL);\n\n    printf(\"SIGINT is unblocked. Press Ctrl+C again.\\n\");\n\n    // 4. 注册一个信号处理函数\n    struct sigaction sa;\n    sa.sa_handler = my_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sigaction(SIGINT, &sa, NULL);\n\n    while(1) {\n        printf(\"Running...\\n\");\n        sleep(1);\n    }\n\n    return 0;\n}\n```\n\n运行这段代码，你会看到在阻塞期间，`Ctrl+C` 无法终止进程。当解除阻塞后，`Ctrl+C` 才能触发信号处理函数。\n\n\n### 2.5. System V IPC (System V IPC)[^1]\n\nSystem V IPC 是 Linux 系统中一组更高级、更强大的 IPC 机制，包括消息队列、信号量和共享内存。它们都是**基于内核**的，需要一个唯一的键值（key）来标识。\n\n#### 2.5.1. 消息队列（Message Queues）\n\n消息队列就像一个链表，允许进程向其中添加消息或从中读取消息。\n\n- **特点**：\n\n    - **异步通信**：发送进程可以发送消息后立即返回，不需要等待接收进程。\n\n    - **带类型**：消息可以带有类型，接收进程可以只接收特定类型的消息。\n\n    - **存储在内核中**：即使发送进程结束，消息依然保留在队列中，直到被读取。\n\n- **使用**：\n\n    - **`ftok()`**：将文件路径和整数转换为一个唯一的 IPC 键值。\n\n    - **`msgget()`**：创建或获取一个消息队列。\n\n    - **`msgsnd()`**：发送消息。\n\n    - **`msgrcv()`**：接收消息。\n\n    - **`msgctl()`**：控制消息队列，如删除。\n\n\n#### 2.5.2. 信号量（Semaphores）\n\n信号量主要用于**同步**，控制对共享资源的访问。它本身不传递数据，而是作为一种“计数器”。\n\n- **特点**：\n\n    - **互斥和同步**：常用于实现互斥锁，确保同一时间只有一个进程访问共享资源。\n\n    - **原子操作**：信号量的操作（P/V操作）是原子的，不会被中断。\n\n- **使用**：\n\n    - **`semget()`**：创建或获取一组信号量。\n\n    - **`semop()`**：对信号量进行操作，如加/减计数。\n\n    - **`semctl()`**：控制信号量。\n\n\n#### 2.5.3. 共享内存（Shared Memory）\n\n共享内存是最高效的 IPC 方式。它允许两个或多个进程共享同一块物理内存。\n\n- **特点**：\n\n    - **最高效**：一旦映射到进程的地址空间，读写操作就像访问普通内存一样，不需要内核的参与。\n\n    - **需要同步**：由于多个进程同时访问，需要用**信号量**等机制来同步访问，防止数据竞争。\n\n- **使用**：\n\n    - **`shmget()`**：创建或获取一个共享内存段。\n\n    - **`shmat()`**：将共享内存段附加到进程的地址空间。\n\n    - **`shmdt()`**：将共享内存段从进程的地址空间分离。\n\n    - **`shmctl()`**：控制共享内存，如删除。\n\n### 2.6. IPC 总结与选择\n\n|机制|适用场景|优点|缺点|\n|---|---|---|---|\n|**管道**|有亲缘关系的进程|简单，易于使用|单向，仅限于亲缘进程|\n|**FIFO**|无亲缘关系的进程|可以在文件系统中命名，灵活|单向，需要同步，读写时有阻塞|\n|**消息队列**|异步通信，少量数据|消息带类型，无需同步|效率较低，有大小限制|\n|**信号量**|进程间同步，互斥|用于控制访问，防止竞争|不传递数据|\n|**共享内存**|大量数据传输|最高效，读写速度快|必须配合其他同步机制使用|\n\n**如何选择？**\n\n- 如果是父子进程之间少量数据的通信，**管道**是最佳选择。\n\n- 如果是两个不相关的进程，且数据量不大，**消息队列**是一个不错的方案。\n\n- 如果需要传输大量数据，且对性能要求极高，**共享内存**是首选，但**必须**结合**信号量**或其他同步机制。\n\n- 如果你只想解决资源访问的同步问题，**信号量**是专门为此设计的。\n\n\n了解这些 IPC 机制，就如同掌握了进程之间“沟通”的多种语言。在开发时，选择合适的“语言”能让你的程序更加健壮、高效。现在，你可以尝试用这些机制来解决你遇到的实际问题了！\n\n[^1]: 作了解，重点使用POSIX IPC。","tags":["Linux","IPC"],"categories":["Linux","内核编程"]},{"title":"Linux-Process","url":"/posts/43741/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n!!! info \"\"\n    AI 辅助创作\n\n\n在 Linux 编程中，**进程（Process）** 是操作系统分配资源和调度的基本单位。每个进程都有自己独立的内存空间、代码段、数据段和执行上下文。多个进程之间常常需要协作，这就涉及到 **进程间通信（IPC, Inter-Process Communication）**。本篇博客会系统介绍进程的基础操作，并对常见的 IPC 方式进行详细解释与示例，带你从零开始掌握。\n\n---\n\n## 1. 进程与 PID\n\n每个进程都会有一个唯一的 **进程号（PID）**，可以通过 `getpid()` 获取当前进程号，通过 `getppid()` 获取父进程号。这在调试和进程管理时非常重要。\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    printf(\"当前进程PID=%d, 父进程PID=%d\\n\", getpid(), getppid());\n    return 0;\n}\n```\n\n⚠️ 注意：如果父进程先退出，子进程会被 `init` 进程接管，`ppid` 会变为 1。\n\n## 2. 创建进程 — `fork()`\n\n`fork()` 是创建新进程的主要方式。它会复制当前进程（父进程）的大部分内容，生成一个几乎一模一样的子进程。\n\n```c\npid_t pid = fork();\n```\n\n- **在父进程中，`fork()` 返回子进程的 PID。**\n    \n- **在子进程中，`fork()` 返回 0。**\n    \n- 如果失败，返回 -1。\n    \n\n示例：\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        printf(\"[子进程] pid=%d, ppid=%d\\n\", getpid(), getppid());\n    } else if (pid > 0) {\n        printf(\"[父进程] pid=%d, 子进程pid=%d\\n\", getpid(), pid);\n    } else {\n        perror(\"fork 失败\");\n    }\n    return 0;\n}\n```\n\n!!! caution\n    - 子进程不会继承父进程的所有资源，例如文件锁。\n    \n    - `fork()` 之后，父子进程执行顺序不确定，需要通过 `wait()` 或其他机制控制。\n\n\n## 3. 程序替换 — `exec()` 系列\n\n子进程常常需要运行一个新的程序，这就需要 `exec()` 系列函数（如 `execlp`, `execvp` 等）。\n`exec` 系列函数的作用是：**用新的程序替换当前进程的代码段**，而进程的 PID、文件描述符（除非设置了 `FD_CLOEXEC`）等保持不变。它不会创建新进程，而是在当前进程内加载并运行新程序。\n### 常见函数\n\n`exec` 系列一共有 6 个常用函数，主要区别在于 **参数传递方式** 和 **是否依赖 PATH 环境变量**。\n\n|函数|参数传递方式|是否搜索 PATH|说明|\n|---|---|---|---|\n|`execl(path, arg0, arg1, ..., NULL)`|列表（逐个传参）|否|最常见，参数以不定长列表形式传递，最后必须以 `NULL` 结尾。|\n|`execv(path, argv[])`|数组|否|参数通过字符串数组传递，方便动态构造参数。|\n|`execlp(file, arg0, arg1, ..., NULL)`|列表|是|与 `execl` 类似，但会在 `PATH` 中搜索可执行文件。|\n|`execvp(file, argv[])`|数组|是|与 `execv` 类似，但会在 `PATH` 中搜索可执行文件。|\n|`execle(path, arg0, arg1, ..., NULL, envp[])`|列表|否|可以自定义环境变量，最后参数需提供 `envp`。|\n|`execve(path, argv[], envp[])`|数组|否|最底层的系统调用，其它 `exec` 函数最终都调用它。|\n\n说明：\n- `PATH`：系统环境变量\n- `path`：要执行的程序路径（可以是绝对路径，也可以是相对路径）。\n- `arg`：程序要输入的参数\n### 使用示例\n\n1. **execl：用绝对路径调用程序**\n\n```c\n#include <unistd.h>\n#include <stdio.h> \n\nint main() {     \nprintf(\"Before exec\\n\");     \nexecl(\"/bin/ls\", \"ls\", \"-l\", NULL);     \n// 只有 exec 调用失败时才会继续执行    \nperror(\"execl failed\");     \nreturn 1; }\n```\n\n2. **execvp：在 PATH 中搜索命令**\n    \n```c\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n    char *argv[] = {\"ls\", \"-a\", NULL};\n    execvp(\"ls\", argv);\n    perror(\"execvp failed\");\n    return 1;\n}\n```\n\n3. **execle：传入自定义环境变量**\n    \n```c\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n    char *envp[] = {\"MYVAR=HelloExec\", NULL};\n    execl(\"/usr/bin/env\", \"env\", NULL, envp);\n    perror(\"execle failed\");\n    return 1;\n}\n```\n\n### 注意事项\n\n- `exec` 系列 **不会返回**，除非调用失败。\n    \n- 若调用成功，原进程的代码和数据段会被新程序替换。\n    \n- **文件描述符默认继承**，可以用于在父进程中设置好管道/重定向，让子进程在 exec 后继续使用。\n    \n- 需要保证参数列表最后有 `NULL`，否则会引发不可预期错误。\n    \n\n## 4. 等待子进程 — `wait()` / `waitpid()`\n\n**父进程需要回收子进程退出时的资源，否则子进程会成为 僵尸进程（Zombie）。**\n\n这两个函数用于 **父进程等待子进程结束** 并**回收资源**，避免僵尸进程。\n\n### 1. wait()\n\n```c\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\npid_t wait(int *status);\n```\n\n- **参数**\n    \n    - `status`：指向整数的指针，用于存储子进程退出状态。如果不关心状态，可以传 `NULL`。\n        \n- **返回值**\n    \n    - 成功：返回结束的子进程 PID\n        \n    - 失败：返回 -1（例如没有子进程存在时）\n        \n- **使用示例**\n\n```c\n#include <stdio.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) { // 子进程\n        printf(\"Child running...\\n\");\n        return 42;\n    } else { // 父进程\n        int status;\n        pid_t cpid = wait(&status); // 等待子进程\n        if (WIFEXITED(status)) {   // 判断是否正常退出\n            printf(\"Child %d exited with code %d\\n\", cpid, WEXITSTATUS(status));\n        }\n    }\n    return 0;\n}\n```\n\n!!! caution   \n    - `wait()` 会阻塞父进程，直到任意一个子进程退出。\n        \n    - 如果父进程没有子进程，返回 -1 并设置 `errno = ECHILD`。\n        \n\n### 2. waitpid()\n\n```c\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\npid_t waitpid(pid_t pid, int *status, int options);\n```\n\n- **参数**\n    - `pid`：\n        \n        - `>0` ：等待指定 PID 的子进程\n            \n        - -1 ：等待任意子进程（功能类似 `wait()`）\n            \n        - 0 ：等待与调用进程同组的任意子进程\n            \n        - <-1：等待进程组 ID = |pid| 的任意子进程\n            \n    - `status`：指向整数的指针，用于保存退出状态\n        \n    - `options`：控制函数行为，常用值：\n        \n        - `0`：阻塞等待（默认行为）\n            \n        - `WNOHANG`：非阻塞，如果没有子进程退出立即返回 0\n            \n        - `WUNTRACED`：返回被暂停的子进程（收到 SIGSTOP）\n            \n        - `WCONTINUED`：返回继续运行的子进程（收到 SIGCONT）\n            \n- **返回值**\n    \n    - 成功：返回子进程 PID\n        \n    - 非阻塞且没有子进程退出：返回 0\n        \n    - 失败：返回 -1，并设置 `errno`\n        \n- **使用示例**\n    \n\n```c\n#include <stdio.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == 0) { // 子进程\n        sleep(2);\n        return 100;\n    } else { // 父进程\n        int status;\n        pid_t cpid;\n        while ((cpid = waitpid(pid, &status, WNOHANG)) == 0) {\n            printf(\"Child still running...\\n\");\n            sleep(1);\n        }\n        if (WIFEXITED(status)) {\n            printf(\"Child %d exited with code %d\\n\", cpid, WEXITSTATUS(status));\n        }\n    }\n    return 0;\n}\n```\n\n!!! caution \n    - `waitpid()` 可以实现 **非阻塞等待**，适合父进程同时管理多个子进程。\n        \n    - `WIFEXITED(status)` 判断子进程是否正常退出。\n        \n    - `WIFSIGNALED(status)` 判断子进程是否被信号终止。\n        \n    - 使用 `waitpid()` 可以精准回收指定子进程，避免僵尸进程积累。\n        \n\n!!! note \"tips\"\n    - 父进程只需要等待任意子进程 → 用 `wait()` 即可。\n    \n    - 父进程需要精确控制或非阻塞 → 用 `waitpid()`。\n    \n    - 调用前一定要理解 **阻塞 vs 非阻塞**，避免父进程被卡住。\n\n## 5. 进程退出 — `exit()` 与 `_exit()`\n\n- `exit()`：会刷新缓冲区，执行清理函数。\n    \n- `_exit()`：立即退出，不做清理，通常在子进程 `fork()` 后的错误处理中使用。\n    \n\n⚠️ 区别：`exit()` 适合普通退出，`_exit()` 适合在 `fork()` 后不希望影响父进程的环境时使用。\n\n!!! caution\n    - 子进程执行退出函数后，子进程结束并变为僵尸🧟，内核保留子进程在进程表中的部分信息（PID、退出码等）占用少量系统资源，但不会再运行。需要父进程调用wait释放子进程资源，净化僵尸，释放灵魂👻\n\n\n## 6. ps 命令简述\n\n### `ps` 命令的常见用法\n\n#### 1. 查看当前终端中的进程\n\n这是最简单的用法，不加任何选项，`ps` 命令只会显示当前终端会话中运行的进程。\n\n```bash\nps\n```\n\n运行后你可能会看到类似下面的输出：\n\n```bash\nPID TTY          TIME CMD\n1234 pts/0    00:00:00 bash\n5678 pts/0    00:00:00 ps\n```\n\n- **PID**：进程的唯一标识符（Process ID）。\n    \n- **TTY**：进程运行所在的终端。\n    \n- **TIME**：进程使用的 CPU 时间。\n    \n- **CMD**：启动进程的命令。\n    \n\n#### 2. 查看所有进程\n\n如果你想查看系统中所有用户的所有进程，可以使用 `-e` 选项（代表所有进程）或 `-a` 选项（代表所有进程，除了会话引导进程）。\n\n```bash\nps -e\n```\n\n或者使用 `-ef` 组合，这是最常用的组合之一，它提供了更详细的信息：\n\n```bash\nps -ef\n```\n\n- **UID**：启动进程的用户 ID。\n    \n- **PID**：进程 ID。\n    \n- **PPID**：父进程 ID。\n    \n- **C**：CPU 利用率。\n    \n- **STIME**：进程启动时间。\n    \n- **TTY**：进程所在的终端。\n    \n- **TIME**：进程使用的 CPU 时间。\n    \n- **CMD**：启动进程的命令。\n    \n\n#### 3. 查看用户进程\n\n如果你只想查看某个特定用户（例如 `root`）的进程，可以使用 `-u` 选项。\n\n```bash\nps -u root\n```\n\n#### 4. 通过管道和 `grep` 查找特定进程\n\n在实际工作中，你通常会需要查找某个特定的进程，比如 Nginx 或 MySQL。这时，`ps` 命令通常会配合 `grep` 命令一起使用。`grep` 可以从 `ps` 的输出中过滤出你想要的信息。\n\n例如，查找所有与 Nginx 相关的进程：\n\n```bash\nps -ef | grep nginx\n```\n\n这里的 `|` 是管道符，它的作用是将 `ps -ef` 命令的输出作为 `grep` 命令的输入。\n\n### `ps` 命令的常用选项总结\n\n| 选项   | 描述                   |\n| ---- | -------------------- |\n| -e   | 显示所有进程               |\n| -f   | 显示完整格式的列表            |\n| -a   | 显示所有进程（不包括会话引导进程）    |\n| -u   | 按用户过滤进程              |\n| -aux | 最经典的组合，显示所有用户的详细进程信息 |\n\n### 实际应用示例\n\n假设你想查看当前系统中 CPU 或内存占用最高的几个进程，`ps` 命令可以与 `head`、`sort` 等命令结合使用。\n\n**查看 CPU 占用最高的 5 个进程：**\n\n```bash\nps -aux --sort=-%cpu | head -n 6\n```\n\n这里的 `--sort=-%cpu` 表示按 CPU 占用率降序排列，`head -n 6` 则取前 6 行（包括标题行）。\n\n### 解析 `ps -aux` 命令的输出\n\n当你运行 `ps -aux` 命令时，你会看到一个包含多个列的表格。每一列都提供了关于进程的重要信息。下面是对这些列的详细解释：\n\n- **USER**：启动该进程的用户。\n    \n- **PID**：进程的唯一标识符（**P**rocess **ID**）。当你需要杀死一个进程时，通常会用到这个 ID。\n    \n- **%CPU**：进程在最近一段时间内使用的 **CPU** 占用率。\n    \n- **%MEM**：进程使用的 **物理内存** 占用率。\n    \n- **VSZ**：进程使用的虚拟内存大小（**V**irtual **S**ize），单位为千字节（KB）。\n    \n- **RSS**：进程使用的 **物理内存** 大小（**R**esident **S**et **S**ize），单位为千字节（KB）。\n    \n- **TTY**：进程运行所在的终端。如果显示 `?`，表示该进程没有关联的终端，通常是系统进程。\n    \n- **STAT**：进程的当前状态（**STAT**us）。这是一个非常重要的列，常用的状态码有：\n    \n    - **R**：正在运行（**R**unning）或可运行（**R**unnable）。\n        \n    - **S**：可中断的睡眠状态（**S**leeping）。\n        \n    - **D**：不可中断的睡眠状态（**D**isk sleep），通常表示进程正在等待 I/O 操作。\n        \n    - **Z**：僵尸进程（**Z**ombie），进程已终止，但其父进程还未对其进行善后处理。\n        \n    - **T**：停止（**S**topped），进程被信号停止。\n        \n    - **<**：高优先级进程。\n        \n    - **N**：低优先级进程。\n        \n- **START**：进程启动的时间。\n    \n- **TIME**：进程已经消耗的 **CPU 时间** 总量。这与 %CPU 不同，%CPU 是瞬时值，而 TIME 是累积值。\n    \n- **COMMAND**：启动该进程的完整命令，包括所有参数。\n    \n\n### 示例解析\n\n假设你运行 `ps -aux` 看到以下一行输出：\n\n```bash\nroot      1234  0.0  0.1 23456 1234 ?        S    Sep01  0:05 /usr/sbin/sshd -D\n```\n\n- **USER**：`root` 用户。\n    \n- **PID**：进程 ID 是 `1234`。\n    \n- **%CPU**：CPU 占用率是 `0.0%`。\n    \n- **%MEM**：内存占用率是 `0.1%`。\n    \n- **VSZ**：虚拟内存大小是 `23456 KB`。\n    \n- **RSS**：物理内存大小是 `1234 KB`。\n    \n- **TTY**：`?`，表示没有关联的终端。\n    \n- **STAT**：`S`，表示进程处于可中断的睡眠状态。\n    \n- **START**：启动时间是 `Sep01`。\n    \n- **TIME**：总 CPU 时间是 `0:05`（5秒）。\n    \n- **COMMAND**：完整的命令是 `/usr/sbin/sshd -D`，这是一个 SSH 服务守护进程。\n    \n\n通过这些信息，你可以快速了解一个进程是由谁运行的、它消耗了多少资源、处于什么状态，以及它是什么程序。这对于系统监控和故障排除非常有帮助。","tags":["Linux","内核","进程"],"categories":["Linux","内核编程"]},{"title":"Linux C标准IO操作","url":"/posts/45385/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n# 📌 C 标准库 I/O 函数（基于 `<stdio.h>`）\n\n## 1. 打开和关闭文件\n\n```c\n#include <stdio.h>  \nFILE *fopen(const char *filename, const char *mode); \nint fclose(FILE *stream);\n```\n\n- **fopen 参数 mode 常用值：**\n    \n    - `\"r\"`：只读（文件必须存在）\n        \n    - `\"w\"`：只写（不存在则创建，存在则清空）\n        \n    - `\"a\"`：追加写（不存在则创建）\n        \n    - `\"r+\"`：读写（必须存在）\n        \n    - `\"w+\"`：读写（不存在则创建，存在则清空）\n        \n    - `\"a+\"`：读写（追加模式）\n        \n\n---\n\n## 2. 读写字符\n\n```c\nint fgetc(FILE *stream);     // 读取一个字符\nint fputc(int c, FILE *stream);  // 写入一个字符\n```\n\n示例：\n\n```c\nchar c = fgetc(fp);\nfputc('A', fp);\n```\n\n---\n\n## 3. 读写字符串\n\n```c\nchar *fgets(char *s, int size, FILE *stream); // 读取一行（最多 size-1 个字符） \nint fputs(const char *s, FILE *stream);       // 写入字符串\n```\n\n示例：\n\n```c\nchar buf[100]; fgets(buf, sizeof(buf), fp); \nfputs(\"Hello\\n\", fp);\n```\n\n---\n\n## 4. 格式化 I/O\n\n```c\nint fprintf(FILE *stream, const char *format, ...);  // 格式化输出到文件 \nint fscanf(FILE *stream, const char *format, ...);   // 格式化读取\n```\n\n示例：\n\n```c\nfprintf(fp, \"name=%s age=%d\\n\", \"Tom\", 20); \nfscanf(fp, \"%s %d\", name, &age);\n```\n\n---\n\n## 5. 块读写（适合二进制文件）\n\n```c\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); \nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n```\n\n示例：\n\n```c\nint data[10]; fwrite(data, sizeof(int), 10, fp); // 写10个整数 \nfread(data, sizeof(int), 10, fp);  // 读10个整数\n```\n\n---\n\n## 6. 文件定位\n\n```c\nint fseek(FILE *stream, long offset, int whence);  // 移动文件指针\nlong ftell(FILE *stream);                         // 获取当前位置 \nvoid rewind(FILE *stream);                        // 回到开头`\n```\n\n`whence` 可取：\n\n- `SEEK_SET`：文件开头\n    \n- `SEEK_CUR`：当前位置\n    \n- `SEEK_END`：文件末尾\n    \n\n---\n\n## 7. 缓冲刷新\n\n```c\nint fflush(FILE *stream);  // 强制把缓冲区写入文件\n```\n\n常用于写日志，避免异常退出时丢数据。\n","tags":["Linux","IO","内核"],"categories":["Linux","内核编程"]},{"title":"Linux 系统IO编程","url":"/posts/7076/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n## 文件描述符：内核分发的身份证\n\n在 Linux 系统中，**文件描述符（File Descriptor，简称 FD）是一个核心概念，它是一个非负整数**，用于唯一标识一个已打开的文件。这个文件可以是普通文件、目录、网络套接字（socket），甚至是设备（如键盘、显示器）。\n\n文件描述符的设计主要有以下几个优点：\n\n1. **简化了 I/O 接口**：无论是读写本地文件，还是进行网络通信，开发者都可以使用一套统一的系统调用（`read`, `write`, `close` 等），而无需关心底层的具体类型。这种“一切皆文件”的设计哲学是 Linux 简洁和强大的体现。\n    \n2. **隔离了应用程序与内核**：应用程序只知道一个简单的整数，而不需要知道文件在磁盘上的物理位置，也不用关心内核是如何管理文件的。所有复杂的操作都由内核在幕后完成。\n    \n3. **管理系统资源**：内核通过文件描述符表来管理每个进程打开的文件。当一个进程结束时，内核可以根据这个表自动关闭所有打开的文件，避免资源泄露。\n\n文件描述符的几个重要特点：\n\n- **唯一性**：在一个进程中，每个打开的文件都有一个独一无二的文件描述符。\n\n- **非负整数**：文件描述符的值通常从 3 开始分配，因为 0、1、2 这三个描述符被系统预留给标准输入、标准输出和标准错误。\n    \n    - **0**：标准输入（`stdin`），通常是键盘。\n        \n    - **1**：标准输出（`stdout`），通常是显示器。\n        \n    - **2**：标准错误（`stderr`），也通常是显示器。\n        \n- **进程私有**：文件描述符是在进程内部使用的，不同进程的文件描述符互不影响。例如，进程 A 的文件描述符 3 和进程 B 的文件描述符 3 可能指向完全不同的文件。\n\n## 最基础的系统调用函数\n\n **Linux I/O 编程中常见的系统调用函数**，这些函数位于 **`unistd.h`**（以及 `fcntl.h` 等）中，是用户态和内核态交互的基础接口。\n\n### 1. `open`\n\n```c\n#include <fcntl.h>    // open flags\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nint open(const char *pathname, int flags);\nint open(const char *pathname, int flags, mode_t mode);\n```\n\n#### 作用\n\n打开或创建一个文件，返回一个 **文件描述符**（fd，整数），后续 I/O 都依赖它。\n#### 参数\n\n- `pathname`：文件路径。\n    \n- `flags`：打开方式，常用值：\n    \n    - `O_RDONLY`：只读\n        \n    - `O_WRONLY`：只写\n        \n    - `O_RDWR`：读写\n        \n    - `O_CREAT`：若文件不存在则创建，需要配合 `mode` 参数\n        \n    - `O_TRUNC`：打开时清空文件\n        \n    - `O_APPEND`：写时追加到文件尾部\n\n\t- `O_NOBLOCK`：非阻塞模式\n        \n- `mode`：创建文件时的权限（如 `0666`，受 umask 影响）。\n#### 返回值\n\n- 成功：文件描述符（非负整数）\n    \n- 失败：`-1`，并设置 `errno`\n\n---\n\n### 2. `write`\n\n```c\n#include <unistd.h>\n\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n#### 作用\n\n向文件（或设备）写入数据。\n#### 参数\n\n- `fd`：文件描述符\n    \n- `buf`：要写入的数据缓冲区指针\n    \n- `count`：要写入的字节数\n#### 返回值\n\n- 成功：实际写入的字节数（可能小于 `count`）\n    \n- 失败：`-1`\n#### 注意\n\n- 对于普通文件，通常会写入全部数据。\n    \n- 对于管道、socket 等，可能分多次写入，需要循环写。\n\n---\n\n### 3. `read`\n\n```c\n#include <unistd.h>\n  \nssize_t read(int fd, void *buf, size_t count);\n```\n#### 作用\n\n从文件（或设备）读取数据。\n#### 参数\n\n- `fd`：文件描述符\n    \n- `buf`：存放读出数据的缓冲区\n    \n- `count`：最大读取字节数\n#### 返回值\n\n- 成功：实际读取的字节数\n    \n    - `0` 表示到达文件结尾 (EOF)\n        \n- 失败：`-1`\n#### 注意\n\n- 实际读取字节数可能小于 `count`。\n    \n- 对于阻塞 I/O，如果没有数据，可能会挂起等待。\n\n---\n\n### 4. `lseek`\n\n```c\n#include <unistd.h>  \n\noff_t lseek(int fd, off_t offset, int whence);\n```\n\n#### 作用\n\n移动文件读写位置（文件指针）。\n#### 参数\n\n- `fd`：文件描述符\n    \n- `offset`：偏移量（可正可负）\n    \n- `whence`：偏移起始点\n    \n    - `SEEK_SET`：从文件开头\n        \n    - `SEEK_CUR`：从当前位置\n        \n    - `SEEK_END`：从文件末尾\n#### 返回值\n\n- 成功：新的文件偏移位置\n    \n- 失败：`-1`\n#### 注意\n\n- 常用来实现随机读写。\n    \n- 对某些设备文件可能不支持（如管道）。\n    \n\n---\n\n### 5. `close`\n\n```c\n#include <unistd.h>\n\nint close(int fd);\n```\n\n#### 作用\n\n关闭一个打开的文件描述符，释放内核资源。\n#### 参数\n\n- `fd`：文件描述符\n#### 返回值\n\n- 成功：`0`\n    \n- 失败：`-1`\n\n## 常见函数查找表\n\n| 函数      | 头文件                       | 功能                      | 主要参数                                                                        | 返回值                       | 常见用途                |\n| ------- | ------------------------- | ----------------------- | --------------------------------------------------------------------------- | ------------------------- | ------------------- |\n| `open`  | `<fcntl.h>`, `<unistd.h>` | 打开或创建文件，返回文件描述符         | `pathname`：路径`flags`：打开方式（如 `O_RDONLY`）`mode`：权限（如 `0644`，仅在 `O_CREAT` 时有效） | 成功：文件描述符 (≥0)失败：`-1`      | 打开文件/设备，获得 `fd`     |\n| `write` | `<unistd.h>`              | 向文件写入数据                 | `fd`：文件描述符`buf`：数据缓冲区`count`：要写入字节数                                         | 成功：实际写入字节数失败：`-1`         | 向文件、管道、socket 写数据   |\n| `read`  | `<unistd.h>`              | 从文件读取数据                 | `fd`：文件描述符`buf`：存放数据的缓冲区`count`：最大读取字节数                                     | 成功：实际读取字节数`0`：文件结尾失败：`-1` | 读取文件、键盘输入、网络数据      |\n| `lseek` | `<unistd.h>`              | 改变文件读写位置（文件指针）          | `fd`：文件描述符`offset`：偏移量`whence`：参考位置（`SEEK_SET`/`SEEK_CUR`/`SEEK_END`）       | 成功：新的偏移位置失败：`-1`          | 随机读写文件、获取文件大小       |\n| `close` | `<unistd.h>`              | 关闭文件描述符，释放资源            | `fd`：文件描述符                                                                  | 成功：`0`失败：`-1`             | 程序结束或文件不再使用时关闭      |\n| `sync`  | `<unistd.h>`              | 将内核缓冲区中所有修改过的数据（脏页）写入磁盘 | 无                                                                           | 无返回值                      | 全局刷新，影响所有文件，效率较低    |\n| `fsync` | `<unistd.h>`              | 将指定文件的缓存数据强制写入磁盘        | `fd`：文件描述符                                                                  | 成功：`0`，失败：`-1`            | 精确到单个文件，常用于数据库、日志写入 |\n|`pipe`   | `<unistd.h>`               |创建匿名管道，用于进程间通信|`int pipefd[2]`|成功：0，失败：-1|`pipefd[0]` 读端，`pipefd[1]` 写端|\n|`unlink` | `<unistd.h>`               |删除一个文件（目录用 `rmdir`）|`pathname`：文件路径|成功：0，失败：-1|实际删除在引用计数归零时发生|\n|`access` | `<unistd.h>`               |  检查文件是否存在及权限      |`pathname, mode`|成功：0，失败：-1 | `mode` 可取 `R_OK, W_OK, X_OK, F_OK`|\n\n\n## 对比C 标准库IO操作\n\n使用c标准库的IO操作，小量频繁读写的效率更高，因为其内部自带有缓冲区。\n这可以理解为在系统IO上有封装了一层，进行文件操作时写入C自带缓冲区，满足一定条件再调用系统IO，将缓冲区的内容写入IO缓存区，再到内核的页缓存区，最后到物理的磁盘。\n\n| 特性       | Linux 系统调用 I/O                            | C 标准库文件操作                                                          |\n| -------- | ----------------------------------------- | ------------------------------------------------------------------ |\n| **头文件**  | `<unistd.h>`, `<fcntl.h>`                 | `<stdio.h>`                                                        |\n| **函数示例** | `open`, `read`, `write`, `lseek`, `close` | `fopen`, `fread`, `fwrite`, `fseek`, `fclose`, `fprintf`, `fscanf` |\n| **返回值**  | 直接返回字节数、文件描述符等，或 `-1`                     | 返回 `FILE*` 指针，或 `EOF` 等错误码                                         |\n| **数据单位** | 以 **字节（byte）** 为单位                        | 以 **缓冲区 / 结构化数据** 为单位（有缓冲机制）                                       |\n| **缓冲**   | **无用户态缓冲**，直接在用户空间和内核空间间传递数据              | **带缓冲区**（stdio 库内部维护缓存，加速小块读写）                                     |\n| **层次**   | 操作系统内核提供的 **底层接口**                        | 基于系统调用的 **封装库函数**                                                  |\n| **灵活性**  | 可操作普通文件、设备文件、socket、管道                    | 主要操作普通文件和标准输入输出                                                    |\n| **可移植性** | 偏向 Unix/Linux 系统                          | 跨平台（符合 ANSI C 标准，Windows/Linux 通用）                                 |\n| **典型用途** | 驱动开发、系统编程、精确控制 I/O                        | 应用层文件读写、文本处理、快速开发                                                  |\n\n\n","tags":["Linux","IO","内核"],"categories":["Linux","内核编程"]},{"title":"MakeFile简明指南","url":"/posts/4341/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n\n</details>\n\n---\n\n在软件开发中，项目通常包含很多源文件，如果每次编译都手动敲命令，不仅繁琐，还容易出错。  \n**Makefile** 可以帮助我们自动化构建流程，大幅提升效率。本文将介绍 Makefile 的基础语法与常用用法。\n\n---\n\n- [1. 基础用法](#1-基础用法)\n- [2. 执行逻辑^1](#2-执行逻辑1)\n  - [2.1. 🔄 执行流程示意图](#21--执行流程示意图)\n- [3. 伪目标 .PHONY](#3-伪目标-phony)\n- [4. 变量](#4-变量)\n  - [4.1. 赋值符号](#41-赋值符号)\n- [5. 隐含规则与通配符](#5-隐含规则与通配符)\n- [6. 条件分支](#6-条件分支)\n  - [6.1. 语法](#61-语法)\n  - [6.2. 示例一：根据平台选择clean执行方式](#62-示例一根据平台选择clean执行方式)\n  - [6.3. 示例二：调试模式与发布模式](#63-示例二调试模式与发布模式)\n- [7. 函数](#7-函数)\n  - [7.1. `subst` —— 字符串替换](#71-subst--字符串替换)\n  - [7.2. `patsubst` —— 模式替换](#72-patsubst--模式替换)\n  - [7.3. `wildcard` —— 获取文件列表](#73-wildcard--获取文件列表)\n  - [7.4. `notdir` —— 去掉路径，只保留文件名](#74-notdir--去掉路径只保留文件名)\n  - [7.5. `dir` —— 获取路径部分](#75-dir--获取路径部分)\n  - [7.6. `basename` 、 `addsuffix` 和 `addprefix` —— 批量处理文件名](#76-basename--addsuffix-和-addprefix--批量处理文件名)\n  - [7.7. `shell` —— 执行 shell 命令](#77-shell--执行-shell-命令)\n- [8. 完整示例程序](#8-完整示例程序)\n\n\n## 1. 基础用法\n\n一个典型的规则格式如下：\n\n```make\ntarget: dependencies\n<TAB> command\n```\n\n- target：目标文件，比如可执行文件或中间文件。\n- dependencies：依赖文件（源文件、头文件等）。\n- command：生成目标所需要执行的命令（必须以 TAB 缩进 开头）。\n\n示例：\n```make\nmain.o: main.c\n\tgcc -c main.c -o main.o\n```\n\n!!! warning\n    由于makfile对空格、tab极其敏感，建议编写时打开编辑器的空格、tab显示，并避免不必要的空格，规范化书写。\n\n\n## 2. 执行逻辑[^1]\n\n当我们执行 `make` 时，大致流程如下：\n\n1. **解析 Makefile**\n   - `make` 会从当前目录寻找 `Makefile` 或 `makefile` 文件。\n   - 读取其中的规则、变量、伪目标等定义。\n\n2. **确定默认目标**\n   - 一般是文件中的第一个目标（例如 `app`）。\n   - 也可以通过命令行指定，例如：  \n```bash\nmake clean\n```\n\n3. **检查依赖关系**\n   - 从目标开始，逐层检查依赖文件是否存在、是否比目标文件更新。\n   - 如果依赖文件比目标文件“新”，说明目标需要重新生成。\n\n4. **执行命令**\n   - 对需要更新的目标，执行其规则中定义的命令。\n   - 命令必须以 **TAB 缩进** 开头。\n\n5. **递归构建**\n   - 如果依赖文件本身也是其他规则的目标，则会递归检查和执行。\n   - 直到所有依赖满足，才最终生成目标。\n\n6. **结束**\n   - 如果所有目标都已是最新，则 `make` 会提示：\n```\nmake: 'app' is up to date.\n```\n\n### 2.1. 🔄 执行流程示意图\n\n```text\n          make\n           │\n           ▼\n   读取并解析 Makefile\n           │\n           ▼\n   确定要构建的目标 (默认/指定)\n           │\n           ▼\n   检查目标的依赖文件\n           │\n    ┌──────┴────────┐\n    │               │\n依赖比目标旧      依赖比目标新/不存在\n    │               │\n目标已是最新    执行规则命令 → 生成新目标\n```\n\n!!! info \"tips\"\n    可以使用 make -f [makefile_name] 指定使用某个makefile文件。\n    \n    \n## 3. 伪目标 .PHONY\n\n有些目标不是实际文件，而只是一个操作，例如 `clean`。  \n这时建议使用 **.PHONY** 声明：\n\n```make\n.PHONY: clean  \nclean:  \n\trm -r  [filepath]\n```\n指定make目标文件：\n```make\nmake clean\n```\n\n## 4. 变量\n\nMakefile 支持变量，常用于保存编译器或编译选项。\n使用示例如下：\n```make\nCC = gcc\nCFLAGS = -Wall -g\n\napp: main.o utils.o\n\t$(CC) $(CFLAGS) main.o utils.o -o app\n\nmain.o: main.c\n\t$(CC) $(CFLAGS) -c main.c -o main.o\n\nutils.o: utils.c\n\t$(CC) $(CFLAGS) -c utils.c -o utils.o\n```\n\n### 4.1. 赋值符号\n\n- **=** \n\t我称之为最终赋值，同一个变量无论被赋值多次，永远取最后指定的值。\n示例：\n```make\nVIR_A = A\nVIR_B = $(VIR_A) B\nVIR_A = AA\n```\n最后VIR_B的值是AA B。\n- **:=**\n\t立即赋值，正常逻辑的赋值号，类似于c语言的赋值号。\n- **?=**\n\t如果变量在之前没有被赋值则赋值。\n\t可以理解为\n\t```\n\t#ifndef\n\t#define ...\n\t#endif\n\t```\n- **+=**\n\t追加赋值，将值追加到变量中。\n\n## 5. 隐含规则与通配符\n\nMake 内置了一些规则，可以用简写方式：\n- `$@`：目标文件名\n- `$<`：第一个依赖文件\n- `$^`：所有依赖文件\n\n`%` 表示可以匹配任意长度的字符串，用于定义一类文件的生成规则。例如：\n```make\n%.o: %.c     \n\tgcc -c $< -o $@\n```\n- 含义：\n    - `%.o` 表示所有以 `.o` 结尾的目标文件。\n    - `%.c` 表示所有以 `.c` 结尾的源文件。\n    - `$<` 是第一个依赖文件（这里是 `.c` 文件）。\n    - `$@` 是目标文件（这里是 `.o` 文件）。\n- 作用：这条规则表示，所有 `.c` 文件可以通过编译生成对应的 `.o` 文件。\n\n---\n\n`%` 可以匹配文件名的某一部分，用于简化规则。例如：\n```\nbuild/%: src/%     \n\tcp $< $@\n```\n- 含义：\n    - `build/%` 表示目标文件在 `build/` 目录下。\n    - `src/%` 表示依赖文件在 `src/` 目录下。\n    - `$<` 是依赖文件，`$@` 是目标文件。\n- 作用：这条规则表示，将 `src/` 目录下的文件复制到 `build/` 目录下。\n\n---\n\n在模式规则中，`%` 可以用于定义多个目标。例如：\n```\n%.a: %.b %.c     \n\tcat $^ > $@`\n```\n- 含义：\n    - `%.a` 是目标文件。\n    - `%.b` 和 `%.c` 是依赖文件。\n    - `$^` 表示所有依赖文件，`$@` 是目标文件。\n- 作用：这条规则表示，将 `.b` 和 `.c` 文件合并生成 `.a` 文件。\n\n---\n\n## 6. 条件分支\n\n在 Makefile 中，我们可以使用条件语句来根据不同情况执行不同规则或定义变量。常见的有 `ifeq`、`ifneq`、`ifdef`、`ifndef`。\n### 6.1. 语法\n```make\nifeq (条件1, 条件2)\n    # 当 条件1 == 条件2 时执行这里\nelse\n    # 否则执行这里\nendif\n\nifneq (条件1, 条件2)\n    # 当 条件1 != 条件2 时执行这里\nendif\n\nifdef 变量名\n    # 当变量已定义时执行这里\nendif\n\nifndef 变量名\n    # 当变量未定义时执行这里\nendif\n```\n\n### 6.2. 示例一：根据平台选择clean执行方式\n```make\n# 默认变量\nCC = gcc\n\n# 判断系统\nifeq ($(OS), Windows_NT)\n    RM = del\nelse\n    RM = rm -f\nendif\n\napp: main.o\n\t$(CC) main.o -o app\n\nclean:\n\t$(RM) *.o app\n```\n\n### 6.3. 示例二：调试模式与发布模式\n```make\n# 设置编译选项\nCFLAGS = -Wall\n\nifeq ($(MODE), debug)\n    CFLAGS += -g\nelse\n    CFLAGS += -O2\nendif\n\napp: main.o\n\t$(CC) $(CFLAGS) main.o -o app\n```\n使用方式：\n```bash\nmake MODE=debug   # 调试模式，带调试信息\nmake MODE=release # 默认优化模式\n```\n\n## 7. 函数\n\nMakefile 内置了许多函数，用来处理字符串、文件名、路径等。  \n常见函数格式为：\n\n```make\n$(函数名 参数1 参数2 ...)\n```\n\n下面介绍一些**常用函数**\n\n### 7.1. `subst` —— 字符串替换\n\n```make\n$(subst from,to,text)\n```\n\n- 功能：将 `text` 中的 `from` 替换为 `to`。\n    \n- 示例：\n\n```\nSRC = main.c utils.c \nOBJ = $(subst .c,.o,$(SRC)) \n\n# 结果：OBJ = main.o utils.o\n```\n\n---\n\n### 7.2. `patsubst` —— 模式替换\n\n```make\n$(patsubst pattern,replacement,text)\n```\n\n- 功能：更灵活的字符串替换，支持通配符 `%`。\n    \n- 示例：\n```make\nSRC = main.c utils.c test.c\nOBJ = $(patsubst %.c,%.o,$(SRC))\n\n# 结果：OBJ = main.o utils.o test.o\n```\n\n---\n\n### 7.3. `wildcard` —— 获取文件列表\n\n```make\n$(wildcard pattern)\n```\n\n- 功能：匹配符合模式的文件。\n    \n- 示例：\n```make\nSRC = $(wildcard *.c)\n# 结果：SRC = 当前目录下所有 .c 文件\n```\n\n---\n\n### 7.4. `notdir` —— 去掉路径，只保留文件名\n\n```make\nFILES = src/main.c src/utils.c\nNAMES = $(notdir $(FILES))\n# 结果：NAMES = main.c utils.c\n```\n---\n\n### 7.5. `dir` —— 获取路径部分\n\n```make\nFILES = src/main.c src/utils.c\nPATHS = $(dir $(FILES))\n# 结果：PATHS = src/ src/\n```\n\n---\n\n### 7.6. `basename` 、 `addsuffix` 和 `addprefix` —— 批量处理文件名\n\n```make\nFILES = main.c utils.c\n\n# 去掉后缀\nNAMES = $(basename $(FILES))\n# NAMES = main utils\n\n# 批量添加后缀\nOBJS = $(addsuffix .o,$(NAMES))\n# OBJS = main.o utils.o\n\n# 批量添加前缀\nOBJS = $(addprefix -I,$(NAMES))\n# OBJS = -Imain -Iutils\n```\n\n---\n\n### 7.7. `shell` —— 执行 shell 命令\n\n```make\nDATE = $(shell date +%Y-%m-%d)\n```\n\n这样可以在 Makefile 中直接使用系统命令的输出。\n\n## 8. 完整示例程序\n\n这是一个完整Makefile示例程序，用于将c语言程序编译为可执行的二进制bin文件。它可以制成镜像供SoC烧录。\n\n```make\n#0###########################################################\n\n# 设置目录变量，方便统一管理和修改\n# 当前根目录:\nROOT_DIR := .\n\n# 中间目标文件（.o）输出目录:\nBUILD_DIR := build\n\n# 最终生成的二进制文件（.bin）目录:\nBIN_DIR := bin\n\n# 工程名\nNAME := key\n\n# 指定链接脚本\nLDS = imx.lds\n\n#############################################################\n\n#1###########################################################\n\n# 自动查找 src/ 目录下的所有 .c 文件\nSRCS = $(shell find $(ROOT_DIR) -name \"*.c\")\n\n# 将 SRC中的 xxx.c 转换为 build/xxx.o\n# 同时添加 build/startup.o（汇编启动文件）\nOBJS = $(BUILD_DIR)/startup.o\nOBJS += $(patsubst %.c,$(BUILD_DIR)/%.o,$(SRCS))\n\n# 自动查找所有包含头文件的目录\nINC_DIRS = $(shell find $(ROOT_DIR) -type f -name \"*.h\" -exec dirname {} \\; | sort -u)\nINCLUDES = $(addprefix -I, $(INC_DIRS))\n\n#############################################################\n\n#2###########################################################\n\n# 设置编译工具（使用 ARM 的交叉编译工具链）\nCC := arm-none-eabi-\n\n# 编译器（用于 .c 和 .S 文件）:\nGCC := $(CC)gcc\n\n# 链接器:\nLD := $(CC)ld\n\n# 用于将 elf 转为 bin 格式:\nOBJCOPY := $(CC)objcopy\n\n# 用于反汇编\nOBJDUMP := $(CC)objdump\n\n# 编译选项（GCC 编译阶段）\n# -I：指定头文件搜索目录\n# -Wall：打开所有警告\n# -O2：优化等级 2（推荐用于 release）\n# -nostdlib：不链接标准库（适用于裸机）\n# -c：只编译，不链接\nGCC_FLAGS = $(INCLUDES) -Wall -nostdlib -c\n\n# 链接器选项\nLD_FLAGS = -T$(LDS)\n\n# 使用 objdump 工具对生成的 ELF 文件进行反汇编\n# -D：反汇编所有节（包括代码段、启动代码等）\n# -m arm：指定目标架构为 ARM\n# .elf：输入的可执行文件\n# > .dis：将反汇编结果输出为 .dis 文本文件\nOBJDUMP_FLAGS = -D -m arm $(BUILD_DIR)/$(NAME).elf > $(BUILD_DIR)/$(NAME).dis\n\n#############################################################\n\n#3###########################################################\n\n# 目标：生成最终的二进制文件 bin/$(NAME).bin\n$(BIN_DIR)/$(NAME).bin: $(OBJS)\n\t# 链接所有 .o 文件生成 elf 格式可执行文件\n    $(LD) $(LD_FLAGS) $(OBJS) -o $(BUILD_DIR)/$(NAME).elf\n\t# 反汇编 调试用\n    $(OBJDUMP) $(OBJDUMP_FLAGS)\n\t# 把 elf 文件转换为裸机二进制文件（无符号、无头信息）\n    $(OBJCOPY) -O binary -S $(BUILD_DIR)/$(NAME).elf $@\n \n# 编译汇编启动文件 startup.S，生成 build/startup.o\n$(BUILD_DIR)/startup.o: startup.S\n\t# 注意 startup.S 是汇编文件，用 gcc 编译也可以，默认会调用汇编器\n    $(GCC) $(GCC_FLAGS) $< -o $@\n\n# 编译每个 .c 文件到 build/xxx.o\n# $@：目标文件（例如 build/main.o）\n# $<：依赖的源文件（例如 src/main.c）\n$(BUILD_DIR)/%.o: %.c\n\t# 修复由于没有文件夹报错\n    mkdir -p $(dir $@)\n    $(GCC) $(GCC_FLAGS) -c $< -o $@\n\n#############################################################\n\n.PHONY: clean\nclean:\n    rm -r $(BUILD_DIR)/* $(BIN_DIR)/*\n```\n\n一个更通用的模板\n```make\n# 通用 Makefile 模板\n\n# 1. 编译器及选项\nCC      := gcc             # C 编译器 (可改成 g++)\nCFLAGS  := -Wall -O2       # 编译参数\nLDFLAGS :=                 # 链接参数 (库路径)\nLDLIBS  := -lm             # 依赖的库 (-lpthread, -lrt 等)\n\n# 2. 目录结构\nSRC_DIR := src             # 源码目录\nOBJ_DIR := build           # 目标文件目录\nBIN_DIR := bin             # 可执行文件目录\n\n# 3. 自动收集源文件\nSRCS := $(wildcard $(SRC_DIR)/*.c)\nOBJS := $(patsubst $(SRC_DIR)/%.c,$(OBJ_DIR)/%.o,$(SRCS))\nTARGET := $(BIN_DIR)/app   # 生成的可执行文件名\n\n# 4. 默认目标\nall: $(TARGET)\n\n# 5. 链接规则\n$(TARGET): $(OBJS) | $(BIN_DIR)\n\t$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)\n\n# 6. 编译规则\n$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c | $(OBJ_DIR)\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n# 7. 目录生成\n$(OBJ_DIR) $(BIN_DIR):\n\tmkdir -p $@\n\n# 8. 清理\n.PHONY: clean run\nclean:\n\trm -rf $(OBJ_DIR) $(BIN_DIR)\n\n# 9. 运行 (可选)\nrun: all\n\t./$(TARGET)\n\n```\n\n[^1]: 仅作了解\n\n","tags":["MakeFile"],"categories":["Linux","项目管理"]},{"title":"交叉编译器相关知识梳理","url":"/posts/27939/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n</details>\n\n---\n\n\n\n"},{"title":"关于Linux开发板与上位机的连接方式","url":"/posts/32814/","content":"<details>\n\n<summary>版权信息</summary>\n\n!!! warning\n    本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n</details>\n\n---\n\n!!! info\n    本文旨在记录自己的IMX6ULL开发板上位机连接的过程。~~为什么感觉是后端这一块呢？~~\n\n## 前提条件\n\n!!! note \"设备\"\n    装有Debian/Ubuntu系统的、安装了ssh服务的、带有网络设备及驱动的开发板\n\n!!! note \"工具\"\n    MobaXterm工具\n\n!!! todo\n    目前使用的上位机是Win11平台，后续再研究Linux平台。\n\n## 基本操作\n\n### 查询设备网络连接状态及ip地址\n`ifconfig` 命令\n\n### 连接测试\n`ping` 命令\n\n### 动态分配ip/主动申请ip地址\n```bash\nudhcpc -i eth0\n```\n\n**`udhcpc`**\n- 全称是 _Micro DHCP Client_，是 BusyBox 提供的一个轻量级 DHCP 客户端工具。\n- 它会向局域网里的 DHCP 服务器（比如路由器、主机上的 Internet Connection Sharing 服务）发送请求，请求一个 IP 地址。\n\n**`-i eth0`**\n- 指定要使用的网络接口，这里是 `eth0`（开发板上的以太网网卡）。\n- 如果你用的是其他网卡（比如 `eth1` 或 `enp0s3`），需要改成对应名字。\n\n成功的话，它会显示类似：\n```bash\nudhcpc: sending discover\nudhcpc: sending select for 192.168.137.2\nudhcpc: lease of 192.168.137.2 obtained, lease time 86400\n```\n这表示网卡已经从 DHCP 服务器那里拿到了 IP（这里是 `192.168.137.2`）。如果没有 DHCP 服务器响应，就会一直 `sending discover`，说明没有可分配 IP。\n\n### 手动设置设备ip地址\n\n```bash\nifconfig eth0 192.168.10.2 netmask 255.255.255.0 up\n```\n\n`up` 指启用\n\n### 查询ssh是否开启\n\n```bash\nsudo systemctl status ssh\n```\n\n### 开启ssh服务\n\n```bash\nsystemctl start ssh\n```\n或\n```bash\n/etc/init.d/ssh start\n```\n\n### ssh远程连接\n\n```bash\nssh [username]@[ip-addr/hostname]\n```\n\n### 通过MobaXterm连接\n填好即可。\n![](Snipaste_2025-09-07_19-20-07.png)\n\n`hostname` 可以输入同名指令查看。\n\n## 方式一：无线网络连接\n\n!!! note \"优点\"\n    无线通信。\n\n\n!!! error \"缺点\"\n    延迟可能较高。\n\n\n### 同一网络下\n\n在同一网段下（连接同一个WIFI），通过ssh建立连接。简简单单。\n\n### 不同网络下\n\n!!! todo\n    待补充。\n\n## 方式二：通过网线与Win电脑连接\n\n!!! note \"优点\"\n    延迟低。\n\n\n!!! error \"缺点\"\n    有线通信。\n\n### 点对点通信（无需共享电脑网络）\n\n!!! note \"优点\"\n    操作简单。\n\n\n!!! error \"缺点\"\n    开发板不能共享电脑网络。\n\n将开发板网口和电脑网口用网线连接，进入电脑`网络和Internet`设置，选择`以太网`\n\nip分配改为手动，ip地址可以分配为`192.168.10.1`\n掩码为`255.255.255.0`\n![](Snipaste_2025-09-07_19-29-57.png)\n\n开发板端同样指定ip地址和掩码，须在同一网段，例如`192.168.10.7` 。这样两个设备就能互相找到了。\n再在电脑上进行ping测试。能ping通用ssh/MobaXterm连接即可。\n\n### 点对点通信并共享电脑网络（电脑成网关）\n\n!!! note \"优点\"\n    开发板不仅可以与电脑建立通信，还能共享电脑网络。\n\n\n!!! error \"缺点\"\n    操作较复杂。\n\n电脑通过wifi连接网络，通过以太网接口连接开发板。\n在电脑控制面板>网络和Internet>网络和共享中心 右侧更改适配器设置，双击无线网卡设备（连接网络的那个设备）选择属性> 共享选项卡 勾选 \n![](Snipaste_2025-09-07_19-41-42.png)\n\n提示：\n![](Snipaste_2025-09-07_19-41-53.png)\n\n意思是：当该功能被启用时，你的LAN口 ip地址 自动被设置为 `192.168.137.1`，要通过这个LAN口连接网络的设备需将自己ip地址设置为动态获取，也就是在开发板执行前面的动态获取ip地址的命令。\n\n当开发版成功获取到ip地址后，则可以正常建立连接。","tags":["Linux","网络","通信"],"categories":["Linux","记录"]},{"title":"无聊随便打点字","url":"/posts/7593/","content":"\n---\n\n# 和时间赛跑 林清玄\n\n读小学的时候，我的外祖母去世了。外祖母生前最疼爱我。我无法排除自己的忧伤，每天在学校的操场上一圈一圈地跑着，跑得累倒在地上，扑在草坪上痛哭。\n\n那哀痛的日子持续了很久，爸爸妈妈也不知道如何安慰我。他们知道与其欺骗我说外祖母睡着了，还不如对我说实话：外祖母永远不会回来了。\n\n“什么是永远不会回来了呢？”我问。\n\n“所有时间里的事物，都永远不会回来了，你的昨天过去了，它就永远变成昨天，你再也不能回到昨天了。爸爸以前和你一样小，现在再也不能回到你这么小的童年了。有一天你会长大，你也会像外祖母一样老，有一天你度过了你的所有时间，也会像外祖母一样永远不能回来了。”爸爸说。\n\n爸爸等于给我说了一个谜，这个谜比“一寸光阴一寸金，寸金难买寸光阴”还让我感到可怕，比“光阴似箭，日月如梭”更让我有一种说不出的滋味。\n\n以后，我每天放学回家，在庭院时看着太阳一寸一寸地沉进了山头，就知道一天真的过完了。虽然明天还会有新的太阳，但永远不会有今天的太阳了。\n\n我看到鸟儿飞到天空，它们飞得多块呀。明天它们再飞过同样的路线，也永远不是今天了。或许明天飞过这条路线的，不是老鸟，而是小鸟了。\n\n时间过得飞快，使我的小心眼不只是着急，还有悲伤。有一天我放学回家，看到太阳快落山了，就下决心说：“我要比太阳更快地回家。”我狂奔回去，站在庭院里喘气的时候，看到太阳还露着半边脸，我高兴地跳起来。那一天我跑赢了太阳。以后我常做这样的游戏，有时和太阳赛跑，有时和西北风比赛，有时一个暑假的作业，我十天就做完了。那时我三年级，常把哥哥五年级的作业拿来做。每一次比赛胜过时间，我就快乐得不知道怎么形容。\n\n后来二十年里，我因此受益无穷。虽然我知道人永远跑不过时间，但是可以比原来跑快一步，如果加把劲，有时可以快好几步。那几步虽然很小很小，用途却很大很大。\n\n如果将来我有什么要教给孩子，我会告诉他：假若你一直和时间赛跑，你就可以成功。\n\n# 秋天的怀念 史铁生\n\n双腿瘫痪后，我的脾气变得暴怒无常。望着望着天上北归的雁阵，我会突然把面前的玻璃砸碎；听着听着李谷一甜美的歌声，我会猛地把手边的东西摔向四周的墙壁。母亲就悄悄地躲出去，在我看不见的地方偷偷地听着我的动静。当一切恢复沉寂，她又悄悄地进来，眼边红红的，看着我。“听说北海的花儿都开了，我推你去走走。”她总是这么说。母亲喜欢花，可自从我双腿瘫痪后，她侍弄的那些花都死了。“不，我不去！”我狠命地捶打这两条可恨的腿，喊着：“我活着有什么劲！”母亲扑过来抓住我的手，忍住哭声说：“咱娘儿俩在一块儿，好好儿活……”可我却一直都不知道，她的病已经到了那步田地。后来妹妹告诉我，她常常肝疼得整宿整宿翻来覆去地睡不了觉。\n\n那天我又独自坐在屋里，看着窗外的树叶“唰唰啦啦”地飘落。母亲进来了，挡在窗前：“北海地菊花开了，我推着你去看看吧。”她憔悴的脸上现出央求般的神色。“什么时候？”你要是愿意，就明天？“她说。我的回答已经让她喜出望外了。”好吧，就明天。“我说。她高兴得一会坐下，一会站起：”那就赶紧准备准备。“”唉呀，烦不烦？几步路，有什么好准备的！“她也笑了，坐在我身边，絮絮叨叨地说着”看完菊花，咱们就去‘仿膳’，你小时候最爱吃那儿的豌豆黄儿。还记得那回我带你去北海吗？你偏说那杨树花是毛毛虫，跑着，一脚踩扁一个……“她忽然不说了。对于”跑“和”踩“一类的字眼儿。她比我还敏感。她又悄悄出去了。\n\n她出去了。就再也没回来。\n\n邻居们把她抬到车上时，她还在大口大口地吐着鲜血。我没想到她已经病成那样。看着三轮车远去，也绝没有想到那竟是永远的诀别。\n\n邻居的小伙子背着我去看她的时候，她正艰难地呼吸着，像她那一生艰难的生活。别人告诉我，他昏迷前的最后一句话是：”我那个有病的儿子和我那个未成年的女儿……“\n\n又是秋天，妹妹推着我去北海看了菊花。黄色的花淡雅、白色的花高洁、紫红色的花热烈而深沉，泼泼洒洒，秋风中正开的烂漫。我懂得母亲没有说完的话，妹妹也懂。我俩在一块儿，要好好儿活……","categories":["其他"]},{"title":"I-MX6ULL的中断实验（下）","url":"/posts/33465/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## C语言下中断模块\n\n### 核心思路：\n每个中断对象包含：1个中断处理函数和需要传入的参数——一个函数指针+一个未定义类型指针。所以将中断对象打包成一个结构体：\n```c\n/* 定义中断处理函数原型 */\ntypedef void (*sys_irq_handler_t)(unsigned int id, void *para);\n\n/* 定义中断函数结构体 */\ntypedef struct _sys_irq_handle{\n    sys_irq_handler_t irqHandler;\n    void* usrPara;\n}sys_irq_handle_t;\n```\n\n指定一个默认中断处理函数：\n```c\n/* 定义默认中断处理函数 */\nstatic void default_irqHandler(unsigned int id, void *para){\n    while(1);\n}\n```\n\n将所有中断对象归入一个表中，按中断id索引：\n```c\n#define NUM_OF_IT_VECTORS 160\nstatic sys_irq_handle_t irqTable[NUM_OF_IT_VECTORS];\n```\n\n后续可能涉及到中断嵌套，因此定义一个中断嵌套计数器：\n```c\nstatic unsigned int irqNesting; //中断嵌套计数器\n```\n\n初始化中断对象表：\n```c\n/* 初始化中断处理表 */\nstatic void sys_iqrTable_init(void){\n    unsigned char i = 0;\n    irqNesting = 0; //中断嵌套计数器\n    for(i = 0; i< NUM_OF_IT_VECTORS; i++){\n        irqTable[i].irqHandler = default_irqHandler;\n        irqTable[i].usrPara = NULL;\n    }\n}\n```\n\n在上一节中，我们实现了当进入中断时跳入一个名为`system_irqhandler`的函数处理中断。因此我们需要定义该函数：\n```c\n/// @brief 中断处理函数\n/// @param gicciar 寄存器gicciar的值\n/// @note 进入irq中断后自动调用\nvoid system_irqhandler(unsigned int gicciar){ \n    uint32_t id = gicciar & 0x3ff; //从gicciar寄存器中读取中断id号（0~9位 故& 0x3ff）\n    /* 安全检查 */\n    if(id == 1023 || id >= NUM_OF_IT_VECTORS) return; //1023即没有中断，即0~9位全为1\n    irqNesting++;\n    /* 开始处理 */\n    irqTable[id].irqHandler(id, irqTable[id].usrPara);\n    irqNesting--;\n}\n```\n\n我们不可能只用默认中断处理函数，肯定要自己自定义，自定义完处理函数后，将该函数注册给中断对象，因此我们需要一个用于注册的函数：\n```c\n/// @brief 用于注册你自定义的中断处理函数\n/// @param irq_id 你为哪个中断写好了处理函数，写入id\n/// @param handler 你写的处理函数的地址\n/// @param para 要传入的参数\nvoid register_irqHandler(IRQn_Type irq_id, sys_irq_handler_t handler, void *para){\n    irqTable[irq_id].irqHandler = handler;\n    irqTable[irq_id].usrPara = para;\n}\n```\n\n\n## 配置gpio外部中断\n\n通过原理图可知，应配置为上升沿触发。\n\n### 配置GPIO_ICR寄存器\n寄存器用于指定触发方式——上升沿触发。\n我的开发板应指定GOIO5_ICR1_icr1 为 10。\n\n### 配置GPIO_IMR寄存器\n该寄存器用于使能中断。\n我的开发板应指定GPIO5_IMR_imr1 为 1——UNMASKED\n\n## 中断后清除中断标志位\n参考手册中指出，处理完中断后，需清除GPIO_ISR寄存器的相应位。\n需要注意的是**通过对该位写1清除。**\n\n## GIC 配置\n\njust like NVIC... you must know cubemx right？\n\n### 使能相应的中断ID\nGPIO5_1对应的中断id为74\n![](Snipaste_2025-08-24_23-51-22.png)\n但是注意这段话：\n![](Snipaste_2025-08-24_23-53-41.png)\n\n告诉我们前面还有32个中断接到了CPU的接口 所以中断ID为 74+32 = 106。\n\n### 配置中断优先级\n\n## 注册中断处理函数\n","tags":["嵌入式","Linux"],"categories":["Linux","记录"]},{"title":"I-MX6ULL的中断实验（上）","url":"/posts/32440/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n:::info\n学习笔记记录，非教程。\n:::\n\n- [1. Cortex-A7中断系统](#1-cortex-a7中断系统)\n  - [1.1. Cortex-A中断向量表](#11-cortex-a中断向量表)\n  - [1.2. 中断向量表偏移](#12-中断向量表偏移)\n  - [1.3. GIC v2中断控制器](#13-gic-v2中断控制器)\n    - [1.3.1. GIC 的主要功能](#131-gic-的主要功能)\n    - [1.3.2. 核心结构](#132-核心结构)\n    - [1.3.3. 核心原理（简单版）](#133-核心原理简单版)\n  - [1.4. 中断号](#14-中断号)\n- [2. 添加中断向量表](#2-添加中断向量表)\n- [3. 复位中断函数的编写](#3-复位中断函数的编写)\n  - [3.1. 操作CP15协处理器](#31-操作cp15协处理器)\n  - [3.2. 中断向量表偏移](#32-中断向量表偏移)\n  - [3.3. 设置sp指针](#33-设置sp指针)\n  - [3.4. 清除.bss段](#34-清除bss段)\n- [4. IRQ中断函数的编写](#4-irq中断函数的编写)\n  - [4.1. 保存中断现场（防止破坏原任务状态）](#41-保存中断现场防止破坏原任务状态)\n  - [4.2. 从 GIC（通用中断控制器）读取中断号](#42-从-gic通用中断控制器读取中断号)\n  - [4.3. 切换到 SVC 模式执行 C 语言中断处理函数](#43-切换到-svc-模式执行-c-语言中断处理函数)\n  - [4.4. 结束中断并恢复现场](#44-结束中断并恢复现场)\n- [5. 整个启动文件](#5-整个启动文件)\n\n\n## 1. Cortex-A7中断系统\n\n### 1.1. Cortex-A中断向量表\nCortex-A中断向量[^1]表有8个中断，其中重点关注IRQ。Cortex-A的中断向量表需要用户自己去定义。\n\n![](Snipaste_2025-08-11_21-20-27.png)\n\n各中断的简单介绍：\n![](Snipaste_2025-08-11_21-27-07.png)\n\n其中IRQ中断为非向量中断，所有中断共享同一入口，再软件判断来源。\n大概是这样：\n![](Snipaste_2025-08-11_21-27-26.png)\n\n### 1.2. 中断向量表偏移\n\n通过设置中断向量表偏移，指定中断向量表的地址。\n\n### 1.3. GIC v2中断控制器\n\n类似于STM32的NVIC，CortexA7使用 GIC v2 作为中断控制器，比NVIC更强大因为GIC能处理多核的中断。\n#### 1.3.1. GIC 的主要功能\n\n1. **收集中断**  \n    接收来自外设和 CPU 内部的各种中断请求（SPI、PPI、SGI）。\n2. **优先级管理**  \n    按优先级裁定哪个中断先被处理。\n3. **目标选择**  \n    把中断发给指定的 CPU 核，或广播给多个核。\n4. **中断屏蔽与使能**  \n    软件可选择屏蔽某个中断或所有中断。\n5. **确认与结束**  \n    CPU 核心在处理前向 GIC 确认（acknowledge），处理完向 GIC 报告结束（end of interrupt）。\n#### 1.3.2. 核心结构\n\nARM GIC 主要由两部分组成：\n- **Distributor（分发器）**  \n    负责接收所有外设中断，决定送到哪一个 CPU。\n- **CPU Interface（CPU 接口）**  \n    每个 CPU 核对应一个接口，负责和 Distributor 通信，接收/确认/结束中断。\n\n#### 1.3.3. 核心原理（简单版）\n\nGIC 的核心流程基本就是三步：\n1. **接收中断请求**  \n    外设（SPI）、特定 CPU 相关的中断（PPI）、核间中断（SGI）都送进 GIC。  \n2. **仲裁优先级 + 选择目标 CPU**  \n    - 比较中断优先级（Priority）        \n    - 检查中断是否被屏蔽（Enable Mask）    \n    - 根据目标 CPU 配置（Target CPU Mask）决定发给谁    \n3. **通知 CPU → CPU 响应 → 完成汇报**\n    - 发信号到目标 CPU 接口 \n    - CPU 读取中断号（acknowledge）并执行 ISR   \n    - ISR 结束后 CPU 通知 GIC（end of interrupt）\n\n### 1.4. 中断号\n中断的 ID Card。\n![](Snipaste_2025-08-11_21-54-28.png)\n\n\n## 2. 添加中断向量表\n\n- **向量表的“表项”是指令，不是纯地址。**\n    \n- 每个向量入口的指令都指向某个具体的处理函数（Reset_Handler、IRQ_Handler 等）。\n    \n- 当发生异常，CPU 硬件会取指执行入口指令 → `ldr pc, =xxx` → 跳到真正的处理函数。\n    \n\n这样，**只要依次写好这些跳转指令，后续再告诉cpu这些指令在哪个位置，就等于告诉 CPU“各种异常该去哪”**。\n\n:::danger\n**中断向量表必须按固定顺序来定义**，顺序是由 ARM 硬件架构规定的，不是随便排列的。这样CPU才能正确处理不同的异常\n:::\n\n```asm\n/* 设置中断向量表，当中断来时，CPU就会执行对应指令 */\n\n    /* 顺序不能改变，名字可以改变！ */\n\n    ldr pc, =Reset_Handler      /* 复位中断                     */  \n\n    ldr pc, =Undefined_Handler  /* 未定义中断                    */\n\n    ldr pc, =SVC_Handler        /* SVC(Supervisor)中断        */\n\n    ldr pc, =PrefAbort_Handler  /* 预取终止中断                   */\n\n    ldr pc, =DataAbort_Handler  /* 数据终止中断                   */\n\n    ldr pc, =NotUsed_Handler    /* 未使用中断                    */\n\n    ldr pc, =IRQ_Handler        /* IRQ中断                    */\n\n    ldr pc, =FIQ_Handler        /* FIQ(快速中断)未定义中断           */\n```\n\n## 3. 复位中断函数的编写\n\n### 3.1. 操作CP15协处理器\n\n**关闭I、D Cache 和MMU**\n\n<details>\n\n<summary>为什么要这样做？</summary>\n\nCP15 是 Cortex-A 系列处理器的 **系统控制寄存器集**，其中 **SCTLR（System Control Register, c1）** 控制了处理器的一些核心行为，例如：\n\n| 位   | 功能                              |\n| --- | ------------------------------- |\n| M   | MMU 使能位（Memory Management Unit） |\n| C   | 数据缓存使能位                         |\n| I   | 指令缓存使能位                         |\n| A   | 对齐检查（Alignment）使能               |\n| Z   | 缓存清零 / 压缩乘法指令                   |\n| V   | 高速异常向量表                         |\n| …   | 其他一些调试、异常行为控制                   |\n\n在复位后，SCTLR 寄存器的初始值不一定是你想要的运行状态。不同的 SoC 或板级支持包可能默认值不同，有些位可能 **默认启用某些功能但不适合裸机启动阶段**。\n\n在裸机启动阶段，你通常需要：\n\n1. **禁用 MMU 和缓存**：\n    \n    - 在初始化页表和内存映射前，启用 MMU 会导致访问非法地址或产生未定义行为。\n    - 数据缓存如果没有正确初始化，可能会导致数据写入内存不一致。\n        \n2. **关闭对齐检查**：\n    \n    - 对齐检查在裸机启动阶段可能会导致异常，因为启动代码可能使用非对齐访问。\n        \n3. **保证指令执行顺序一致**：\n    \n    - SCTLR 的某些位会影响指令缓存和流水线行为。\n    - 在系统初始化阶段，确保缓存和 MMU关闭可以让你更容易调试和保证代码执行顺序。\n        \n4. **统一系统行为**：\n    \n    - 不同芯片可能在复位后 SCTLR 寄存器的默认值不同。\n    - 显式初始化可以保证启动代码在各种芯片上行为一致。\n\n如果不重置这些位可能的风险：\n\n- **访问未定义**：\n    \n    - 如果 MMU 默认启用但页表未初始化，访问内存可能触发数据异常。\n        \n- **数据不一致**：\n    \n    - 缓存启用但未正确设置缓存策略，读写内存可能得到错误数据。\n        \n- **异常频发**：\n    \n    - 对齐检查默认启用，而启动代码中可能有非对齐访问，导致异常。\n        \n- **调试困难**：\n    \n    - 程序执行行为不确定，难以定位启动问题。\n\n\n</details>\n\n代码如下：\n```asm\n* 禁用MMU、cache、对齐检查等，配置适合裸机启动的环境，这样的启动代码移植性更好 */\n\n    mrc     p15, 0, r0, c1, c0, 0     /*  读取CP15系统控制寄存器   */\n\n    bic     r0,  r0, #0x1000          /*  清除第12位（I位）禁用 I Cache  */\n\n    bic     r0,  r0, #0x4             /*  清除第 2位（C位）禁用 D Cache  */\n\n    bic     r0,  r0, #0x2             /*  清除第 1位（A位）禁止严格对齐   */\n\n    bic     r0,  r0, #0x800           /*  清除第11位（Z位）分支预测   */\n\n    bic     r0,  r0, #0x1             /*  清除第 0位（M位）禁用 MMU   */\n\n    mcr     p15, 0, r0, c1, c0, 0     /*  将修改后的值写回CP15寄存器   */\n```\n\n### 3.2. 中断向量表偏移\n\n访问CP15 VBAR（Vector Base Address Register）寄存器，该寄存器是专门指定中断向量表偏移首地址的。\n- `dsb`（Data Synchronization Barrier）保证所有数据访问指令执行完再继续。\n- `isb`（Instruction Synchronization Barrier）保证新的 VBAR 设置马上生效，不会被 CPU 指令流水线里的旧指令影响。\n\n```asm\n/* 访问CP15 VBAR寄存器 设置中断向量表偏移 */\n\n    ldr r0, =0x80000000\n\n    dsb\n\n    isb /* 数据同步指令 */\n\n    mcr p15, 0, r0, c12, c0, 0\n\n    dsb\n\n    isb\n```\n\n### 3.3. 设置sp指针\n\n内核工作在不同模式下，User模式和是Sys模式共用sp寄存器，而其他模式是独享一个sp寄存器。\n- ARMv7-A 每个异常模式都有自己的栈指针寄存器，如果不设置，进入该模式时可能破坏未知内存。\n- 给每种模式单独分配内存空间，可以防止中断嵌套、函数调用等操作时栈互相冲突。\n\n\n### 3.4. 清除.bss段\n\n<details>\n\n<summary>bss段是什么？</summary>\n\n在编译链接后，程序的内存布局通常分为几个主要段：\n\n- **.text**：存放代码（只读）。\n    \n- **.data**：存放已初始化的全局/静态变量（初始值不为 0）。\n    \n- **.bss**：存放**未初始化的**或者**初始化为 0** 的全局/静态变量。\n\n`.bss` 只在运行时需要分配内存，编译产物中不占用存储空间（只是记录了大小），这样可以减少可执行文件体积。\n\n</details>\n\n<details>\n\n<summary>为什么要这样做？</summary>\n\n根据 **C 语言标准**：\n\n> 所有未显式初始化的全局变量、静态变量在程序开始执行前必须被初始化为 0。\n\n这意味着：\n\n- 如果 `bss` 段中的内容不是全 0，程序可能会读到**随机的旧内存内容**。\n    \n- 硬件上，RAM 启动后可能是**杂乱的值**（上电状态、上次运行残留、调试器写入等）。\n    \n\n因此，**启动代码（crt0 或汇编 startup.s）通常会在 `main()` 之前清零 bss 段**，保证所有这些变量是干净的 0。\n\n</details>\n\n```asm\n/* 清除bss段 防止未初始化变量等数据访问错误 */\n\n    ldr r0, =__bss_start\n\n    ldr r1, =__bss_end\n\n    mov r2, #0\n\nbss_clear:          /* ia: increse after */\n\n    stmia r0!, {r2} /* stmia: 从r0所存地址开始，将r2的值写入该地址，写入后地址自动递增 */\n\n    cmp r0, r1\n\n    ble bss_clear /* less & equal */\n```\n\n\n## 4. IRQ中断函数的编写\n\n\n<details>\n\n<summary>中断函数实现了什么？（详细版）</summary>\n\n### 4.1. 保存中断现场（防止破坏原任务状态）\n\n一旦 CPU 进入 IRQ 模式，中断处理代码首先：\n\n- 把 `lr`（中断返回地址）、`r0`~`r3`、`r12` 等易被破坏的寄存器压栈保存。\n    \n- 保存 `SPSR`（中断进入时的 CPSR 状态），以便中断结束时恢复原任务的运行状态。\n    \n\n**目的**：防止中断服务过程破坏被中断的程序的寄存器内容和运行状态。\n\n---\n\n### 4.2. 从 GIC（通用中断控制器）读取中断号\n\n- 读取 **GICC_IAR**（Interrupt Acknowledge Register）寄存器。\n    \n- 这个寄存器会返回当前触发的中断 ID（是哪一个外设触发的 IRQ）。\n    \n\n**目的**：确定是哪个具体中断源发生了 IRQ。\n\n---\n\n### 4.3. 切换到 SVC 模式执行 C 语言中断处理函数\n\n- ARMv7-A 的 IRQ 模式不适合直接运行通用 C 代码（栈、寄存器不统一），所以这里切到 SVC 模式。\n    \n- 在 SVC 模式下调用 `system_irqhandler`（C 写的总中断处理函数）。\n    \n- `system_irqhandler` 会根据中断号去调用具体外设的中断处理例程。\n    \n\n**目的**：统一用 SVC 模式的栈和环境执行中断逻辑，方便用 C 语言写 ISR 分发器。\n\n---\n\n### 4.4. 结束中断并恢复现场\n\n- 切回 IRQ 模式。\n    \n- 向 GIC 写 **EOIR**（End of Interrupt Register），通知 GIC 这个中断处理完成，可以接收新的中断。\n    \n- 从栈中弹出寄存器和 `SPSR`，恢复进入中断前的状态。\n    \n- 用 `subs pc, lr, #4` 返回到中断发生前的指令位置继续运行。\n    \n\n**目的**：\n\n- 告诉中断控制器“我处理完了”。\n    \n- 让 CPU 完整回到被打断的程序，像中断没发生一样继续执行。\n\n</details>\n\n省流版：\n当一个程序在 **SVC 模式** 下运行时，如果来了 IRQ：\n1. CPU 自动切到 IRQ 模式。\n2. 把 **SVC 模式的 CPSR** 存进 **IRQ 模式的 SPSR**。\n3. 把返回地址放进 IRQ 模式的 LR。\n4. 开始执行 IRQ 模式的向量入口代码（也就是 `IRQ_Handler`）。\nirq_handler:\n- 保存现场\n- 查中断号\n- 切换到svc模式 调用用c语言编写的中断分发函数 根据中断号分发到中断处理函数 来执行中断处理\n- 结束中断、恢复现场\nps： 最后一行subs指令有点抽象。。。。。。。。\n\n\n## 5. 整个启动文件\n\n```asm\n.global _start\n/* 以下两个变量在链接脚本中定义 */\n.global __bss_start\n.global __bss_end\n_start:\n    @ /* 1.设置处理器模式为SVC模式(其实CotexA内核上电默认即为SVC模式故不需要写) */\n    @ mrs r0, cpsr                /* 读取cpsr到r0 */\n    @ bic r0, r0, #0x1f           /* bic bit-clear位清零 */          \n    @                             /* 等同于R0 = R0 & (~Operand2) 这个操作数2自己推算*/\n    @                             /* 现在这个操作相当于将r0的前5位清零了 */\n    @ orr r0, r0, #0x13           /* orr 按位或 */\n    @ msr cpsr, r0                /* 写入cpsr */  \n    /* 设置中断向量表，当中断来时，CPU就会执行对应指令 */\n    /* 顺序不能改变，名字可以改变！ */\n    ldr pc, =Reset_Handler      /* 复位中断                     */  \n    ldr pc, =Undefined_Handler  /* 未定义中断                    */\n    ldr pc, =SVC_Handler        /* SVC(Supervisor)中断        */\n    ldr pc, =PrefAbort_Handler  /* 预取终止中断                   */\n    ldr pc, =DataAbort_Handler  /* 数据终止中断                   */\n    ldr pc, =NotUsed_Handler    /* 未使用中断                    */\n    ldr pc, =IRQ_Handler        /* IRQ中断                    */\n    ldr pc, =FIQ_Handler        /* FIQ(快速中断)未定义中断           */\nReset_Handler:  \n    cpsid i                           /* Change Processor State Interrupt or abort Disable irq */\n\n    /* 禁用MMU、cache、对齐检查等，配置适合裸机启动的环境，这样的启动代码移植性更好 */\n    mrc     p15, 0, r0, c1, c0, 0     /*  读取CP15系统控制寄存器   */\n    bic     r0,  r0, #0x1000          /*  清除第12位（I位）禁用 I Cache  */\n    bic     r0,  r0, #0x4             /*  清除第 2位（C位）禁用 D Cache  */\n    bic     r0,  r0, #0x2             /*  清除第 1位（A位）禁止严格对齐   */\n    bic     r0,  r0, #0x800           /*  清除第11位（Z位）分支预测   */\n    bic     r0,  r0, #0x1             /*  清除第 0位（M位）禁用 MMU   */\n    mcr     p15, 0, r0, c1, c0, 0     /*  将修改后的值写回CP15寄存器   */\n    /* 访问CP15 VBAR寄存器 设置中断向量表偏移 */\n    ldr r0, =0x80000000\n    dsb\n    isb /* 数据同步指令 */\n    mcr p15, 0, r0, c12, c0, 0\n    dsb\n    isb\n    /* 清除bss段 防止未初始化变量等数据访问错误 */\n    ldr r0, =__bss_start\n    ldr r1, =__bss_end\n    mov r2, #0\nbss_clear:          /* ia: increse after */\n    stmia r0!, {r2} /* stmia: 从r0所存地址开始，将r2的值写入该地址，写入后地址自动递增 */\n    cmp r0, r1\n    ble bss_clear /* less & equal */  \n    /* 设置各个模式下的栈指针，\n     * 注意：IMX6UL的堆栈是向下增长的！\n     * 堆栈指针地址一定要是4字节地址对齐的！！！\n     * DDR范围:0X80000000~0X9FFFFFFF\n     */\n    /* 进入IRQ模式 */\n    mrs r0, cpsr\n    bic r0, r0, #0x1f   /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  */\n    orr r0, r0, #0x12   /* r0或上0x13,表示使用IRQ模式                   */\n    msr cpsr, r0        /* 将r0 的数据写入到cpsr_c中                    */\n    ldr sp, =0x80600000 /* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB */\n    /* 进入SYS模式 */\n    mrs r0, cpsr\n    bic r0, r0, #0x1f   /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  */\n    orr r0, r0, #0x1f   /* r0或上0x13,表示使用SYS模式                   */\n    msr cpsr, r0        /* 将r0 的数据写入到cpsr_c中                    */\n    ldr sp, =0x80500000 /* 设置SYS模式下的栈首地址为0X80400000,大小为2MB */\n    /* 进入SVC模式 */\n    mrs r0, cpsr\n    bic r0, r0, #0x1f   /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  */\n    orr r0, r0, #0x13   /* r0或上0x13,表示使用SVC模式                   */\n    msr cpsr, r0        /* 将r0 的数据写入到cpsr_c中                    */\n    ldr sp, =0X80400000 /* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */\n    cpsie i             /* 打开全局中断 */\n    /* 跳转到main函数 */\n    b main\n/* 未定义中断 */\nUndefined_Handler:\n    ldr r0, =Undefined_Handler\n    bx r0\n/* SVC中断 */\nSVC_Handler:\n    ldr r0, =SVC_Handler\n    bx r0\n/* 预取终止中断 */\nPrefAbort_Handler:\n    ldr r0, =PrefAbort_Handler  \n    bx r0\n/* 数据终止中断 */\nDataAbort_Handler:\n    ldr r0, =DataAbort_Handler\n    bx r0  \n/* 未使用的中断 */\nNotUsed_Handler:\n    ldr r0, =NotUsed_Handler\n    bx r0  \n/* IRQ中断！重点！！！！！ */\nIRQ_Handler:\n    /* 保护现场 */\n    push {lr}                   /* 保存lr地址 */\n    push {r0-r3, r12}           /* 保存r0-r3，r12寄存器 */\n    mrs r0, spsr                /* 读取spsr寄存器 */\n    push {r0}                   /* 保存spsr寄存器 */ \n\n    /* 读取GIC控制器基地址 */\n    mrc p15, 4, r1, c15, c0, 0 /* 从CP15的C0寄存器内的值到R1寄存器中\n                                * 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49\n                                * Cortex-A7 Technical ReferenceManua.pdf P68 P138\n                                */                          \n    add r1, r1, #0X2000         /* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 */\n    /* 查询中断号 */\n    ldr r0, [r1, #0XC]          /* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，\n                                 * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据\n                                 * 这个中断号来绝对调用哪个中断服务函数\n                                 */\n    push {r0, r1}               /* 保存r0,r1 */\n    cps #0x13                   /* 进入SVC模式，允许其他中断再次进去 */\n    push {lr}                   /* 保存SVC模式的lr寄存器 */\n    ldr r2, =system_irqhandler  /* 加载C语言中断处理函数到r2寄存器中*/\n    blx r2                      /* 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 */\n    pop {lr}                    /* 执行完C语言中断服务函数，lr出栈 */\n    cps #0x12                   /* 进入IRQ模式 */\n    pop {r0, r1}                \n    str r0, [r1, #0X10]         /* 中断执行完成，写EOIR，相当于确认中断执行完成 */\n    pop {r0}                        \n    msr spsr_cxsf, r0           /* 恢复spsr */\n    pop {r0-r3, r12}            /* r0-r3,r12出栈 */\n    pop {lr}                    /* lr出栈 */\n    subs pc, lr, #4             /* 将lr-4赋给pc */\n/* FIQ中断 */\nFIQ_Handler:\n    ldr r0, =FIQ_Handler    \n    bx r0\nloop:\n    b loop\n```\n\n\n[^1]: 中断向量，英文名为Interrupt Vector，在早期计算机体系结构里，“vector”常被用作“指针/地址索引”的意思，所以”向量“实际上就是地址指针的意思。","tags":["嵌入式","Linux"],"categories":["Linux","记录"]},{"title":"I-MX6ULL主频与时钟配置实验","url":"/posts/33477/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n:::info\n学习笔记记录，非教程。\n:::\n\n\n## 系统时钟浅析\n\n### 7路PLL\n\n为了方便生成时钟，6从24MHz晶振生出来7路PLL。这7路PLL中有的又生出来PFD。\n- `PLL1`：ARM PLL供给ARM内核。\n- `PLL2`：sysytem PLL，528MHz，528_PLL，此路PLL分出了4路PFD，分别为PLL2_PFD0~PFD3\n- `PLL3`: USB1 PLL，480MHz 480_PLL，此路PLL分出了4路PFD，分别为PLL3_PFD0~PFD3。\n- `PLL4`: Audio PLL，主供音频使用。\n- `PLL5`: Video PLL，主供视频外设，比如RGB LCD接口，和图像处理有关的外设。\n- `PLL6`：ENET PLL，主供网络外设。\n- `PLL7`: USB2_PLL ,480MHz，无PFD。\n\n详见 IMX6ULL参考手册 Chapter 18 Clock Controller Module (CCM)\n\n附 时钟树图：\nt形为多路选择器\n\n![](Snipaste_2025-08-06_22-02-07.png)\n![](Snipaste_2025-08-06_22-03-45.png)\n\n\n### 要初始化的PLL和PFD\n\n- PLL1，\n- PLL2，以及PLL2_PFD0~PFD3.\n- PLL3以及PLL3_PFD0~PFD3.\n其他需要时再设置。\n一般按照时钟树里面的值进行设置。\n\n## 具体配置\n\n### 系统主频的配置\n\n根据时钟树来设定系统主频。具体时钟配置的说明可以参见 IMX6ULL参考手册 18.5.1.5\nCCM internal clock generation \n下图为时钟切换器 （CCM_CLK_SWITCHER） 控制输出的示意图。\n\n![](Snipaste_2025-08-07_10-00-08.png)\n\n1. 要设置ARM内核主频为528MHz，设置CACRR寄存器的ARM_PODF位为2分频，然后设置PLL1=1056MHz即可。CACRR的bit3~0为ARM_PODF位，可设置0~7，分别对应1~8分频。应该设置CACRR寄存器的ARM_PODF=1。\n\n2. 切换时钟源。PLL1输出为pll1_sw_clk。pll1_sw_clk有两路可以选择，分别为pll1_main_clk，和step_clk，通过CCSR寄存器的pll1_sw_clk_sel位(bit2)来选择。为0的时候选择pll1_main_clk，为1的时候选额step_clk。\n\n3. 在修改PLL1的时候，也就是设置系统时钟的时候需要给6ULL一个临时的时钟，也就是step_clk。在修改PLL1的时候需要将pll1_sw_clk切换到step_clk上。\n\n4. 设置step_clk。Step_clk也有两路来源，由CCSR的step_sel位(bit8)来设置，为0的时候设置step_clk为osc=24MHz。为1的时候不重要，不用。\n\n5. 时钟切换成功以后就可以修改PLL1的值。\n\n6. 通过CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位(bit6~0)来设置PLL1的频率，公式为：\n\n\t\tOutput = fref*DIV_SEL/2  1056=24*DIV_SEL/2=>DIEV_SEL=88。\n\t\t\n\t\t设置CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位=88即可。PLL1=1056MHz\n\t\t\n\t\t还要设置CCM_ANALOG_PLL_ARM寄存器的ENABLE位(bit13)为1，也就是使能输出。\n\n7. 在切换回PLL1之前，设置置CACRR寄存器的ARM_PODF=1！！切记。\n\n### 其他PLL设置\n\nPLL2和PLL3。PLL2固定为528MHz，PLL3固定为480MHz。\n\n1. 初始化PLL2_PFD0~PFD3。寄存器CCM_ANALOG_PFD_528用于设置4路PFD的时钟。比如PFD0= 528 * 18 / PFD0_FRAC。 设置PFD0_FRAC位即可。比如PLL2_PFD0=352M=528 *  18 / PFD0_FRAC，因此FPD0_FRAC=27。\n2. 同理初始化PLL3_PFD0~PFD3\n\n## 外设时钟\n\nAHB_CLK_ROOT、PERCLK_CLK_ROOT以及IPG_CLK_ROOT。\n\n因为PERCLK_CLK_ROOT和IPG_CLK_ROOT要用到AHB_CLK_ROOT，所以我们要初始化AHB_CLK_ROOT。\n\n### AHB_CLK_ROOT的初始化\n\nAHB_CLK_ROOT=132MHz。\n\n设置CBCMR寄存器的PRE_PERIPH_CLK_SEL位，设置CBCDR寄存器的PERIPH_CLK_SEL位0。设置CBCDR寄存器的AHB_PODF位为2，也就是3分频，因此396/3=132MHz。\n\n### IPG_CLK_ROOT初始化\n\n设置CBCDR寄存器IPG_PODF=1，也就是2分频。\n\n### PERCLK_CLK_ROOT初始化\n\n设置CSCMR1寄存器的PERCLK_CLK_SEL位为0，表示PERCLK的时钟源为IPG。\n\n\n## 这篇文章写得很不错,摘录一些\n\n[【嵌入式Linux】i.MX6ULL 时钟树——理论分析-CSDN博客](https://blog.csdn.net/Beihai_Van/article/details/139868239)\n\n### 总结PFD配置寄存器:\n\nCCM_ANALOG_PFD_528n 寄存器控制着 i.MX 6ULL 处理器中四个分数分频器的配置，包括时钟门控、稳定性状态和分数分频值。这些分频器用于生成不同频率的时钟信号，以满足各种外设的需求。\n\n1. CLKGATE 位 (Clock Gate): 时钟门控\n- 作用: CLKGATE 位控制着对应 PFD 的时钟信号是否被开启或关闭。\n- 值:\n\t- 0: 时钟信号开启，PFD 正常工作，可以输出分频后的时钟信号。\n\t- 1: 时钟信号关闭，PFD 处于关闭状态，不输出时钟信号。\n- 目的:\n\t- 省电: 当某个外设不需要时钟信号时，可以通过设置 CLKGATE 位为 1 来关闭该 PFD 的时钟，从而减少功耗。\n\t- 控制时钟信号: 在某些情况下，可能需要动态地控制某个外设的时钟信号，例如在系统启动或进入低功耗模式时。\n2. STABLE 位 (Stable): 稳定性状态\n\n- 作用: STABLE 位指示对应 PFD 的输出时钟信号是否已经稳定。\n- 值:\n\t当新的分数分频值生效时，位域的值会反转（从 0 变为 1 或从 1 变为 0）。这个反转就像一个信号，表明分频器已经完成调整。\n- 目的:\n\t- 诊断: STABLE 位是一个只读位，用于诊断 PFD 的稳定性。\n\t- 确保时钟信号质量: 在修改 PFD 的分数分频值后，需要等待 STABLE 位反转，才能确保输出的时钟信号稳定可靠。\n\n### i.MX6U 芯片 PLL 时钟详解\n\ni.MX6U 芯片拥有多个 PLL（Phase-Locked Loop，锁相环）模块，用于生成各种频率的时钟信号，为芯片内部的不同模块和外设提供时钟源。下面整理了 i.MX6U 芯片的 7 个主要 PLL：\n\n1. ARM_PLL (PLL1)\n\t- 用途: 为 ARM 内核提供时钟信号。\n\t- 倍频: 可编程，最高可倍频至 1.3GHz。\n\t- 特点: ARM 内核的运行速度直接取决于此 PLL 的输出频率。\n2. 528_PLL (PLL2)\n\t- 用途: 为系统总线、内部逻辑单元、DDR 接口、NAND/NOR 接口等提供时钟源。\n\t- 倍频: 固定 22 倍频，不可编程。\n\t- 输出频率: 24MHz * 22 = 528MHz。\n\t- 特点: 该 PLL 以及其生成的 4 路 PFD (PLL2_PFD0~PLL2_PFD3) 是 i.MX6U 内部系统总线的核心时钟源。\n3. USB1_PLL (PLL3)\n\t- 用途: 主要用于 USB1PHY，但也可作为其他外设的时钟源。\n\t- 倍频: 固定 20 倍频。\n\t- 输出频率: 24MHz * 20 = 480MHz。\n\t- 特点: 该 PLL 以及其生成的 4 路 PFD (PLL3_PFD0~PLL3_PFD3) 可用于多种外设。\n4. USB2_PLL (PLL7)\n\t- 用途: 为 USB2PHY 提供时钟信号。\n\t- 倍频: 固定 20 倍频。\n\t- 输出频率: 24MHz * 20 = 480MHz。\n\t- 特点: 虽然序号标为 4，但实际是 PLL7。\n5. ENET_PLL (PLL6)\n\t- 用途: 用于生成网络所需的时钟信号。\n\t- 倍频: 固定 20+5/6 倍频。\n\t- 输出频率: 24MHz * (20+5/6) = 500MHz。\n\t- 特点: 可在此 PLL 的基础上生成 25/50/100/125MHz 的网络时钟。\n6. VIDEO_PLL (PLL5)\n\t- 用途: 用于显示相关外设，例如 LCD。\n\t- 倍频: 可调整，输出范围在 650MHz~1300MHz。\n\t- 分频: 可选 1/2/4/8/16 分频。\n\t- 特点: 可根据显示设备的需求调整输出频率和分频比。\n7. AUDIO_PLL (PLL4)\n\t- 用途: 用于音频相关外设。\n\t- 倍频: 可调整，输出范围在 650MHz~1300MHz。\n\t- 分频: 可选 1/2/4 分频。\n\t- 特点: 可根据音频设备的需求调整输出频率和分频比。\n总结:\n\ni.MX6U 芯片通过多个 PLL 模块，生成各种频率的时钟信号，为芯片内部的不同模块和外设提供时钟源。每个 PLL 的倍频和分频都可以根据需要进行配置，以满足不同外设的需求。\n"},{"title":"I-MX6ULL开发板C语言运行环境搭建并点灯","url":"/posts/2969/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n:::info\n学习笔记记录，非教程。\n:::\n\n## C语言运行环境搭建\n\n前面我们讲解了如何用汇编语言编写 LED 灯实验，但是实际开发过程中汇编用的很少，大部分都是 C 语言开发，汇编只是用来完成 C 语言环境的初始化。本文我们就来学习如何用汇编来完成 C 语言环境的初始化工作，然后从汇编跳转到 C 语言代码里面去。\n\n### 设置处理器模式\n\n对于Cortex-A处理器，有多种运行模式，例如User模式、中断模式等。除用户（User）模式为非特权模式，其余均为特权模式，特权模式下程序可以访问所有系统资源，还有自己独有的寄存器组，而非特权模式下访问受限。\n\n![](Snipaste_2025-07-28_17-13-11.png)\n\n而现在我们需要将处理器模式设置为SVC模式。\n这就需要了解到内核寄存器组中的CPSR寄存器，其低四位为处理器运行模式控制位。\n\n![](Snipaste_2025-07-28_17-16-59.png)\n\n![](Snipaste_2025-07-28_17-19-33%201.png)\n\n![](Snipaste_2025-07-28_17-20-27.png)\n\n设置CPSR寄存器的bit4-0，也就是M[4:0]为10011=0X13。读写状态寄存器需要用到 MRS[^1] 和 MSR[^2] 指令。MRS将CPSR寄存器数据读出到通用寄存器里面，MSR指令将通用寄存器的值写入到CPSR寄存器里面去。\n\n为啥不用SDR、LDR？因为这他妈属于处理器内部自己在传输数据，而不是从寄存器与存储器！而且它只能操作通用寄存器。\n\n![](Snipaste_2025-07-28_17-26-03.png)\n\n### 设置sp寄存器\n\n也就是栈的起始地址。\nSp可以指向内部RAM，也可以指向DDR，我们将其指向DDR。Sp设置到哪里？512MB的范围0x80000000~0x9FFFFFFF。栈大小，0x200000=2MB，很大大大大了。\n\n再提一嘴，由于NXP给我们提供的SDK包里面有初始化DDR等一系列操作，所以这里我们可以方便的设置sp寄存器，其他处理器（启动方式设置为DDR的情况下）如果没有初始化DDR，还需要先初始化DDR。\n\n这里再说一下栈的特性，有点抽象……\n- 向上增长：即从低地址往高地址增长。以此判断即可。\n- 向下增长：从高地址往低地址增长。\n- 栈底：栈的起始位置。根据定义，如果是向下增长的，那么栈底为高地址。以此类推。\n- 栈顶：程序运行时sp指针所指示的位置，不断变化。\n处理器栈增长方式，对于A7而言是向下增长的。设置sp指向0x80200000。\n\n\n\n### 跳转到C语言\n\n使用b指令，跳转到C语言函数，比如main函数。\n\n其实我们在stm32的启动文件中也可以看到这些操作，提一嘴……\n\n## 实操\n\n我的文件结构长这样：\n```\nproject/\n├── Makefile、lds\n├── src/\n│   └── main.c\n├── inc/\n│   └── main.h\n├── build/\n└── bin/\n```\n\n同时为了学习makefile，makefile就写得比较复杂：\n注意makefile文件对缩进、空格非常敏感！\n```Makefile\n# 设置目录变量，方便统一管理和修改\n# 源代码目录:\nSRC_DIR := src\n# 头文件目录:\nINC_DIR := inc\n# 中间目标文件（.o）输出目录:\nBUILD_DIR := build\n# 最终生成的二进制文件（.bin）目录:\nBIN_DIR := bin\n\n# 设置编译工具（使用 ARM 的交叉编译工具链）\n# 编译器（用于 .c 和 .S 文件）:\nCC = arm-none-eabi-gcc\n# 链接器:\nLD = arm-none-eabi-ld\n# 用于将 elf 转为 bin 格式:\nOBJCOPY = arm-none-eabi-objcopy\n\n# 编译选项（GCC 编译阶段）\n# -I：指定头文件搜索目录\n# -Wall：打开所有警告\n# -nostdlib：不链接标准库（适用于裸机）\n# -c：只编译，不链接\nGCC_FLAGS = -I$(INC_DIR) -Wall -nostdlib -c\n\n# 链接器选项\n# -Ttext=0x80000000：设置代码段的起始地址（你设备上运行程序的入口地址）\n# -e _start：显式设置程序入口点（防止链接器猜测）\nLD_FLAGS = -Timx.lds\n\n# 自动查找 src/ 目录下的所有 .c 文件\nSRCS = $(wildcard $(SRC_DIR)/*.c)\n\n# 将 src/xxx.c 转换为 build/xxx.o\n# 例如：src/main.c → build/main.o\n# 同时添加 build/startup.o（汇编启动文件）\n# 这里注意是按顺序链接的，所以startup一定要在第一个否则链接到的地址不对（查看反汇编可知）\nOBJS = $(BUILD_DIR)/startup.o\nOBJS += $(patsubst $(SRC_DIR)/%.c,$(BUILD_DIR)/%.o,$(SRCS))\n\n# 目标：生成最终的二进制文件 bin/ledc.bin\n$(BIN_DIR)/ledc.bin: $(OBJS)\n# 链接所有 .o 文件生成 elf 格式可执行文件\n    $(LD) $(LD_FLAGS) $(OBJS) -o $(BUILD_DIR)/ledc.elf\n# 反汇编 调试用\n    arm-none-eabi-objdump -D -m arm $(BUILD_DIR)/ledc.elf > $(BUILD_DIR)/ledc.dis\n# 把 elf 文件转换为裸机二进制文件（无符号、无头信息）\n    $(OBJCOPY) -O binary -S $(BUILD_DIR)/ledc.elf $@\n\n# 编译汇编启动文件 startup.S，生成 build/startup.o\n$(BUILD_DIR)/startup.o: startup.S\n# 注意 startup.S 是汇编文件，用 gcc 编译也可以，默认会调用汇编器\n    $(CC) $(GCC_FLAGS) $< -o $@\n\n# 编译每个 .c 文件到 build/xxx.o\n# $@：目标文件（例如 build/main.o）\n# $<：依赖的源文件（例如 src/main.c）\n$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c\n    $(CC) $(GCC_FLAGS) $< -o $@\n\n.PHONY: clean\nclean:\n    rm $(BUILD_DIR)/*.o $(BUILD_DIR)/*.elf $(BIN_DIR)/*.bin $(BUILD_DIR)/*.dis\n```\n\nmain.c\n```c\n#include \"main.h\"\n\nvoid clk_enable(void){\n    LED_CLK_REG = 0xffffffff;\n}\n\nvoid led_init(void){\n    LED_MUX_REG = 0x5;          //复用为GPIO1_IO4\n    LED_PAD_REG = 0x10b0;       //设置电气属性\n    LED_GPIO_DIR_REG = 0x10;    //io4设置为输出\n}\n\nint main(void){\n    clk_enable();\n    led_init();\n    LED_GPIO_DATA_REG = 0x0;      //输出为低电平\n    while(1);\n    return 0;\n}\n```\n\nmain.h\n```c\n#ifndef __MAIN_H_  \n#define __MAIN_H_\n\n#define LED_CLK_REG *((volatile unsigned int*)0x020c406c)\n#define LED_MUX_REG *((volatile unsigned int*)0x020e006c)\n#define LED_PAD_REG *((volatile unsigned int*)0x020e02f8)\n#define LED_GPIO_DIR_REG *((volatile unsigned int*)0x0209c004)\n#define LED_GPIO_DATA_REG *((volatile unsigned int*)0x0209c000)\n\n#endif\n```\n\nstartup.S\n```asm\n  \n.global _start\n\n_start:\n\n    @ /* 1.设置处理器模式为SVC模式(其实CotexA内核上电默认即为SVC模式故不需要写) */\n    @ mrs r0, cpsr                /* 读取cpsr到r0 */\n    @ bic r0, r0, #0x1f           /* bic bit-clear位清零 */          \n    @                             /* 等同于R0 = R0 & (~Operand2) 这个操作数2自己推算*/\n    @                             /* 现在这个操作相当于将r0的前5位清零了 */\n    @ orr r0, r0, #0x13           /* orr 按位或 */\n\n    @ msr cpsr, r0                /* 写入cpsr */\n    @下面这段是重置CP15寄存器的一些位，好像加了更保险一些。目前还没弄明白，但是实测不需要也可以运行。\n    @ mrc     p15, 0, r0, c1, c0, 0     /*读取CP15系统控制寄存器   */\n    @ bic     r0,  r0, #0x1000     /*  清除第12位（I位）禁用 I Cache  */\n    @ bic     r0,  r0, #0x4     /*  清除第 2位（C位）禁用 D Cache  */\n    @ bic     r0,  r0, #0x2             /*  清除第 1位（A位）禁止严格对齐   */\n    @ bic     r0,  r0, #0x800     /*  清除第11位（Z位）分支预测   */\n    @ bic     r0,  r0, #0x1             /*  清除第 0位（M位）禁用 MMU   */\n    @ mcr     p15, 0, r0, c1, c0, 0     /*  将修改后的值写回CP15寄存器   */\n\n    /* 2.设置sp寄存器 */\n    ldr sp, =0x80100000         /* 栈大小1M */\n    \n    /* 3.跳转到main函数 */\n    b main\nloop:\n    b loop\n```\n\n链接脚本：\n```lds\n\nENTRY(_start)\nSECTIONS {\n    . = 0x80000000;\n    \n    . = ALIGN(4);\n    .text :\n    {\n        build/startup.o\n        *(.text)\n    }\n\n    . = ALIGN(4);\n    .rodata : \n    {\n        *(.rodata*)\n    }\n    \n    . = ALIGN(4);\n    .data : \n    {\n        *(.data)\n    }\n\n    . = ALIGN(4);\n    __bss_start = .;  \n    .bss :\n    {\n        *(.bss)\n        *(COMMON)\n    }\n    __bss_end = .;\n }\n\n```\n\n[^1]: **M**ove to **R**egister from **S**pecial register.  加载到通用寄存器\n[^2]: **M**ove to **S**pecial register from **R**egister.  恢复到特殊寄存器","tags":["嵌入式","Linux"],"categories":["Linux","记录"]},{"title":"浅析IMX镜像文件结构","url":"/posts/undefined/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n:::info\n学习笔记记录，非教程。\n:::\n\n## 当使用内部BootROM启动时，发生了什么？\n\n当我们通过设置BOOT_MODE[1:0]为内部启动模式时，即芯片通过执行内部的bootROM固有的代码来启动，在此模式下，芯片会执行内部的 boot ROM 代码，这段 boot ROM 代码会进行硬件初始化(一部分外设)，然后从 boot 设备(就是存放代码的设备、比如 SD/EMMC、NAND)中将代码拷贝出来复制到指定的 RAM 中，一般是 DDR。\n\n- 设置内核时钟为396MHz。使能MMU和Cache，使能L1cache、L2 cache、MMU，目的就为了加速启动。\n- 从BOOT_CFG设置的外置存储中，读取image，然后做相应的处理。\n\n![](Snipaste_2025-07-14_19-59-23.png)![](Snipaste_2025-07-14_20-01-17.png)\n其中内存管理单元（Memory Management Unit）用于将物理地址翻译为虚拟内存地址，以及通过虚拟内存访问实际物理内存。而初始化高速缓存则是加速数据访问。\n\n## 镜像文件结构\n\n在上一节[【点灯大师】点亮I.MX6ULL开发板的LED灯](https://blog.godmao.top/posts/43400/)提到过，通过汇编生成的bin文件并不能直接使用，还需要添加额外的头文件信息。我们使用VSCODE（需要扩展hex-editor）打开生成的img文件，这个文件是上一节我们使用`mkimage.sh`生成的。我们可以先查看一下这个sh文件方便理解：\n我们只截取通过sd卡启动的配置参数：\n```shell\nelif [ \"$1\" == \"sd\" ]; then\n    ../bin/$IMG_BUILDER --combine base_addr=0x80000000 ivt_offset=0x400 app_offset=0x2000 dcd_file=dcd.bin app_file=sdk20-app.bin ofile=sdk20-app.img image_entry_point=0x80002000\n```\n\n可以看到，该脚本为我们默认设置的基址为0x80000000，也就是绝对的起始地址，在此基础上，偏移app_offset即为应用程序的起始地址。因此程序的起始地址（bin的起始地址）为0x80002000，ivt表则是偏移了1024字节，0x400。\n![](Snipaste_2025-07-14_21-25-46.png)\n接下来我们看img文件的内容：\n![](Snipaste_2025-07-14_21-34-13.png)","tags":["Linux","boot"],"categories":["Linux","记录"]},{"title":"【点灯大师】点亮I.MX6ULL开发板的LED灯","url":"/posts/43400/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n:::info\n学习笔记记录，非教程。\n:::\n\n- [1. 汇编LED原理分析](#1-汇编led原理分析)\n- [2. 初始化流程](#2-初始化流程)\n  - [2.1. STM32的大致IO初始化流程](#21-stm32的大致io初始化流程)\n  - [2.2. I.MX6ULL IO初始化](#22-imx6ull-io初始化)\n- [3. 汇编语言实现](#3-汇编语言实现)\n- [4. 链接与格式转换](#4-链接与格式转换)\n  - [4.1. 链接](#41-链接)\n  - [4.2. 格式转换](#42-格式转换)\n- [5. 使用官方SDK包生成镜像文件](#5-使用官方sdk包生成镜像文件)\n- [6. 安装SDK包](#6-安装sdk包)\n  - [6.1. build SDK](#61-build-sdk)\n  - [6.2. 生成镜像文件](#62-生成镜像文件)\n- [7. 烧录到SD卡](#7-烧录到sd卡)\n- [8. 达成成就【点灯大师】](#8-达成成就点灯大师)\n- [9. 参考资料](#9-参考资料)\n\n\n## 1. 汇编LED原理分析\n\n为什么不像STM32那样直接使用c语言？\n\n答：因为ST已经为你用汇编写好了初始化过程，比如初始化时钟等等外设，初始化Ram，设置sp指针，配置好c语言运行环境等等。而一般这些一块CortexA架构的板子是不提供的。\n\n所以我们要使用汇编：\n\n1. 初始化一些SOC外设。\n2. 初始化DDR[^1]。\n>这个I.MX6U倒是不需要。I.MX内部的ROM存放了自己编写的启动代码，这些启动代码可以读取DDR配置信息，并完成其的初始化。\n3. 设置sp指针，一般指向DDR，设置好C语言运行环境。\n\n\n## 2. 初始化流程\n\n> 具体原理、寄存器详细位讲解可以看正点原子的Linux驱动开发指南。\n\n这里我们对比STM32的IO初始化流程来学习I.MX的初始化流程\n\n### 2.1. STM32的大致IO初始化流程\n1. 使能时钟\n2. 设置IO复用，复用为GPIO\n3. 配置GPIO的电气属性\n4. 使用GPIO——利用控制寄存器设置GPIO的输入输出功能\n\n### 2.2. I.MX6ULL IO初始化\n\n同样的，IO的使用分为两个部分，CONFIG和CONTROL\n\nCONFIG部分，I.MX的每个IO都有两个寄存器来配置，分别是多路复用寄存器（IOMUXC_SW_MUX_CTL_PAD_XX_XX）和配置电气特性的寄存器（IOMUXC_SW_PAD_CTL_PAD_XX_XX）它们在命名的第三个字段加以区分。我们可以查阅正点原子的Linux驱动开发指南以及官方的参考手册查看每一位的意义。\n\nCONTROL部分，也有各种寄存器，来控制IO的各个功能，比如*GPIOx_DR*寄存器就是控制输入输出的高低电平，共有32位，每一位控制第x组IO各个引脚的高低电平。\n\n使能时钟，CCGR0~CCGR6这7个寄存器控制着6ULL所有外设时钟的使能。（参考《I.MX6UL 参考手册》的第 18 章“Chapter 18: ClockController Module(CCM)”）\n\n总结一下，I.MX6ULL的初始化一个IO流程如下：\n\n1. 使能时钟，CCGR0~CCGR6这7个寄存器控制着6ULL所有外设时钟的使能。为了简单，设置CCGR0~CCGR6这7个寄存器全部为0XFFFFFFFF，相当于使能所有外设时钟。\n2. IO复用，将寄存器IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03的bit3~0设置为0101=5，这样GPIO1_IO03就复用为GPIO。\n3. 寄存器IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03是设置GPIO1_IO03的电气属性。包括压摆率、速度、驱动能力、开漏、上下拉等。\n4. 配置GPIO功能，设置输入输出。设置GPIO1_GDIR寄存器bit3为1，也就是设置为输出模式。设置GPIO1_DR寄存器的bit3，为1表示输出高电平，为0表示输出低电平。\n\n## 3. 汇编语言实现\n\n在了解上述内容后我们可以正式开始写代码了，在Linux环境下新建`led.s`汇编文件。\n内容可以参考如下\n```asm\n/* 点亮led汇编代码 */\n\n.global _start @全局标号\n\n_start:\n\n@1.使能时钟\n    @查找原理图和参考手册可知，LED1连接GPIO1-io4，GPIO1的时钟属于CCM_CCGR1 CG13（26-27位）\n\nldr r0, =0x020c406c @将寄存器地址加载到r0\nldr r1, =0xFFFFFFF  @为了方便打开全部时钟，相应的功耗也有所增加\nstr r1, [r0] @将r1中的值存入以r0中的值为地址的寄存器中\n  \n2.设置io引脚复用为gpio\n  \nldr r0, =0x020e006c @将寄存器地址加载到r0\nmov r1, #5 @将寄存器要设置的值加载到r1\nstr r1, [r0]\n\n\n@3.设置io电气属性\n\n    /*\n\n     * bit0     SRE压摆率       0       disable\n\n     * bit5:3   DSE io驱动能力  110     R0/6\n\n     * bit7:6   speed          10      100MHz\n\n     * bit11    ODE 开路输出     0      disable\n\n     * bit12    PKE 使能pull/keeper 1   enable\n\n     * bit13    PUE pull or keeper 0   keeper\n\n     * bit15:14 上下拉电阻       00      100K下拉\n\n     * bit16    HYS             0       disable\n\n     */\n\nldr r0, =0x020e02f8\nldr r1, =0x10b0 @将寄存器要设置的值加载到r1\nstr r1, [r0]\n \n@4.设置GPIO功能\n    @设置为输出 GDIR寄存器\n\nldr r0, =0x0209c004\nmov r1, #16\nstr r1, [r0] @将GPIO1组的第4个io口设置为输出模式\n\n    @设置为输出低电平 DR寄存器\n\nldr r0, =0x0209c000\nmov r1, #0\nstr r1, [r0] @将GPIO1组的第4个io口设置为输出低电平  \n\n@5.防止CPU进入未知状态\n\n    @写入死循环\nloop:\n    b loop\n    \n/* Finally! END! */\n```\n\n\n## 4. 链接与格式转换\n\n> 默认已安装了`arm-linux-gnueabihf`编译套件\n\n### 4.1. 链接\n使用命令\n```zsh\narm-linux-gnueabihf-ld -Ttext 0X80000000 led.o -o led.elf\n```\n上述命令中-Ttext 就是指定链接起始地址，“-o”，我理解为output，指定链接生成的 elf 文件名，这里我们命名为 led.elf。上述命令执行完以后就会在工程目录下多一个 led.elf 文件。\n这个elf相当于win中的exe，是一个可执行文件。\n\n### 4.2. 格式转换\n使用命令\n```zsh\narm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin\n```\n上述命令中，“-O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出，\n选项“-S”表示不要复制源文件中的重定位信息和符号信息，“-g”表示不复制源文件中的调试\n信息。\n至此我们终于等到了想要的东西—led.bin 文件。\n但是 I.MX6U 不能直接烧写编译生成的.bin 文件，我们需要在.bin 文件前面添加一些头信息构成满足 I.MX6U 需求的最终可烧写文件，I.MX6U 的最终可烧写文件组成如下：\n1. Image vector table，简称 IVT，IVT 里面包含了一系列的地址信息，这些地址信息在\nROM 中按照固定的地址存放着。\n2. Boot data，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。\n3. Device configuration data，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置。\n4. 用户代码可执行文件，比如 led.bin。\n## 5. 使用官方SDK包生成镜像文件\n\n!!你不会以为我要用正点原子或者野火提供的镜像制作软件吧孩子!!\n\n此步所需软件：\n:::success\n- NXP SDK_2.2_MCIM6ULL\n:::\n\n第二个可从NXP官网获取。\n## 6. 安装SDK包\n使用共享文件夹将“SDK_2.2_MCIM6ULL_RFP_Linux.run” 拷贝到Linux下，存放位置自定。用chmod添加权限。然后运行.run文件生成SDK，linux下的源文件命令如下：\n```zsh\n./SDK_2.2_MCIM6ULL_RFP_Linux.run\n```\n\n### 6.1. build SDK\n此步所需软件：\n:::success\n- gcc-arm-none-eabi交叉编译套件\n- cmake\n:::\n在Linux环境下，\n添加临时环境变量，执行以下命令：\n```zsh\nexport ARMGCC_DIR=/usr\n```\n进入工程文件**SDK_2.2_MCIM6ULL/boards/evkmcimx6ull/demo_apps/hello_world/armgcc** 运行build_ddr_release.sh脚本\n```zsh\n./build_ddr_release.sh\n```\n\n###  6.2. 生成镜像文件\n进入工程文件**SDK_2.2_MCIM6ULL/tools/imgutil/evkmcimx6ull**\n查看readme.txt 查看使用教程\nreadme.txt内容如下：\n```txt\n   IMGUTIL User Guide\n  \n   ======================================\n   \n   1. Build SDK2.0 application\n   2. Copy built binary (.bin file) to imgutil/<board> folder and rename to sdk20-app.bin\n   3. In imgutil/<board> folder, run mkimage.sh in mingw32 shell to get bootable image file sdk20-app.img\n       a. If the image is built with ram link file, use \"mkimage.sh ram\" to make the bootable image.\n       b. If the image is built with flash link file, use \"mkimage.sh flash\" to make the bootable XIP image.\n       c. If the image is built with ram link file and want to boot from MicroSD card, use \"mkimage.sh sd\" to make the bootable image.\n\n   ======================================\n```\n\n大致意思：\n1. build SDK（前面已经做了）\n2. 复制你要制作为镜像的bin文件到对应的设备文件夹并将复制的bin文件改名为`sdk20-app.bin`\n> 我们的板子是imx6ull，故复制到当前文件夹\n3. 使用 mkimage.sh+参数 来制作镜像 参数指定启动方式，有：\n\t-  ram\n\t- flash\n\t- sd\n参数我们使用sd。\n\n```zsh\n./mkimage sd\n```\n\n运行后，生成了`sdk20-app.img`文件\n\n## 7. 烧录到SD卡\n\n由于我使用的是WSL环境，WSL访问USB比较不方便所以改在win下烧录。\n\n此步所需软件：\n:::success\n- Win32DiskImager\n:::\n\n此步非常简单，将生成的img文件传到win文件夹下，使用Win32DiskImager软件烧录到连接到win的SD卡。\n\n\n## 8. 达成成就【点灯大师】\n\n将SD卡插入imx6ull，设置启动方式为SD卡，具体设置需参考你板子的硬件原理图，比如我的：\n![](Snipaste_2025-06-30_00-49-08.png)\n成功点亮！\n![](WIN_20250630_00_50_53_Pro.jpg)\n\n\n## 9. 参考资料\n\n- 《【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.81》\n- [[野火]嵌入式Linux驱动开发实战指南——基于i.MX6ULL系列 — [野火]嵌入式Linux驱动开发实战指南——基于i.MX6ULL系列 文档](https://doc.embedfire.com/linux/imx6/driver/zh/latest/index.html)\n- 《IMX6ULL参考手册》\n\n[^1]: Double Data Rate SDRAM 双倍数据速率同步动态随机存储器","tags":["嵌入式","Linux"],"categories":["Linux","记录"]},{"title":"Shell脚本流程控制简明指南","url":"/posts/21870/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n- [1. 条件判断语句 if/else](#1-条件判断语句-ifelse)\n  - [1.1. 基本语法：](#11-基本语法)\n  - [1.2. 示例：](#12-示例)\n- [2. 判断符号说明](#2-判断符号说明)\n- [3. case 分支结构](#3-case-分支结构)\n  - [3.1. 语法：](#31-语法)\n  - [3.2. 示例：](#32-示例)\n- [4. for 循环](#4-for-循环)\n  - [4.1. 遍历列表：](#41-遍历列表)\n  - [4.2. 使用 C 风格语法：](#42-使用-c-风格语法)\n- [5. while 循环](#5-while-循环)\n  - [5.1. 基本语法：](#51-基本语法)\n  - [5.2. 示例：](#52-示例)\n- [6. until 循环](#6-until-循环)\n- [7. 跳出循环：break 和 continue](#7-跳出循环break-和-continue)\n\n\nShell 脚本不仅可以批量处理命令任务，还拥有完整的流程控制语法结构，包括条件判断、循环与分支等逻辑控制结构。本文将简明介绍 Shell 的基本流程控制语法，适用于 bash 环境。\n\n## 1. 条件判断语句 if/else\n\n### 1.1. 基本语法：\n\n```shell\nif [ 条件 ]; then\n    命令1\nelif [ 条件 ]; then\n    命令2\nelse\n    命令3\nfi\n```\n写成一行：\n```shell\nif [ ]; then ; fi\n```\n\n### 1.2. 示例：\n\n```shell\nread -p \"请输入一个数字: \" num\nif [ \"$num\" -gt 0 ]; then\n    echo \"正数\"\nelif [ \"$num\" -lt 0 ]; then\n    echo \"负数\"\nelse\n    echo \"零\"\nfi\n```\n\n---\n\n## 2. 判断符号说明\n\n|条件表达式|含义|\n|---|---|\n|`-eq`|等于（整数）|\n|`-ne`|不等于|\n|`-gt`|大于|\n|`-lt`|小于|\n|`-ge`|大于等于|\n|`-le`|小于等于|\n|`-z str`|字符串是否为空|\n|`-n str`|字符串是否非空|\n|`str1 = str2`|字符串相等|\n|`-f file`|是否为普通文件|\n|`-d dir`|是否为目录|\n\n> 注意：`[` 和 `]` 要有空格；变量最好加引号防止空值。\n\n## 3. case 分支结构\n\n用于多个条件的匹配处理。\n\n### 3.1. 语法：\n\n```shell\ncase $变量 in\n    模式1)\n        命令 ;;\n    模式2)\n        命令 ;;\n    *)\n        默认命令 ;;\nesac\n```\n\n### 3.2. 示例：\n\n```shell\nread -p \"请输入选项[a/b/c]: \" choice\ncase $choice in\n    a) echo \"你选择了A\" ;;\n    b) echo \"你选择了B\" ;;\n    c) echo \"你选择了C\" ;;\n    *) echo \"无效选项\" ;;\nesac\n```\n\n## 4. for 循环\n\n### 4.1. 遍历列表：\n\n```shell\nfor var in 值1 值2 值3; do\n    命令\ndone\n```\n\n```shell\nfor name in Alice Bob Charlie; do\n    echo \"Hello, $name\"\ndone\n```\n### 4.2. 使用 C 风格语法：\n\n```bash\nfor ((i=1; i<=5; i++)); do\n    echo \"第 $i 次\"\ndone\n```\n\n## 5. while 循环\n\n### 5.1. 基本语法：\n\n```shell\nwhile [ 条件 ]; do\n    命令\ndone\n```\n### 5.2. 示例：\n\n```shell\ni=1\nwhile [ $i -le 5 ]; do\n    echo \"循环第 $i 次\"\n    ((i++))\ndone\n```\n\n## 6. until 循环\n\n与 `while` 相反：**条件为假时执行**\n\n```shell\ni=1\nuntil [ $i -gt 5 ]; do\n    echo \"第 $i 次\"\n    ((i++))\ndone\n```\n\n## 7. 跳出循环：break 和 continue\n\n```shell\nfor ((i=1;i<=10;i++)); do\n    if [ $i -eq 5 ]; then\n        break   # 提前结束循环\n    fi\n    echo $i\ndone\n```\n\n```shell\nfor ((i=1;i<=5;i++)); do\n    if [ $i -eq 3 ]; then\n        continue   # 跳过当前循环\n    fi\n    echo $i\ndone\n```","tags":["Linux","shell"],"categories":["Linux","Shell"]},{"title":"shell脚本入门","url":"/posts/27290/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n作为linux嵌入式开发，掌握一些shell脚本的基础是必要的。\n\n- [1. shell脚本的写法](#1-shell脚本的写法)\n- [2. shell脚本的一些基本用法](#2-shell脚本的一些基本用法)\n  - [2.1. 输入参数](#21-输入参数)\n  - [2.2. 整形运算](#22-整形运算)\n  - [2.3. test命令](#23-test命令)\n    - [2.3.1. 文件测试](#231-文件测试)\n    - [2.3.2. 字符串比较](#232-字符串比较)\n    - [2.3.3. 数值比较](#233-数值比较)\n    - [2.3.4. 逻辑操作符](#234-逻辑操作符)\n  - [2.4. 条件判断](#24-条件判断)\n- [3. 拓展：shell脚本中`$`的作用](#3-拓展shell脚本中的作用)\n  - [3.1. 变量引用](#31-变量引用)\n  - [3.2. 命令替换](#32-命令替换)\n  - [3.3. 位置参数和特殊变量](#33-位置参数和特殊变量)\n  - [3.4. 算术扩展](#34-算术扩展)\n  - [3.5. 字符串操作和默认值处理](#35-字符串操作和默认值处理)\n\n\n\n\n## 1. shell脚本的写法\nshell是个纯文本文件，命令从上而下，一行一行开始执行，shell脚本的扩展名为.sh\n第一行：\n```shell\n#！/bin/bash\n```\n表示使用bash\n\n## 2. shell脚本的一些基本用法\n\n### 2.1. 输入参数\n`read`常用选项：\n- -a array 将输入的值作为数组赋值\n- -d delim 指定输入结束的标识符\n- -p prompt 在输入前打印提示信息\n- -t timeout 设置超时时间\n- -e 在输入的时候可以使用命令补全\n- -s silent 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。\n\n---\n\n### 2.2. 整形运算\n 使用`$[]`进行算数扩展\n```shell\nread -p \"two num: \" num1 num2\necho \"$num1 + $num2 = $[num1 + num2]\"\n```\n\n---\n\n### 2.3. test命令\n\n用于查看文件是否存在、权限等信息。可以对数值、字符、文件三方面测试，**返回布尔值**\n格式：\n```shell\ntest EXPRESSION\n# 或\n[ EXPRESSION ]  # 注意方括号内必须有空格\n```\n\n#### 2.3.1. 文件测试\n\n| 操作符 | 描述      | 示例                     |\n| --- | ------- | ---------------------- |\n| -e  | 文件是否存在  | `[ -e file.txt ]`      |\n| -f  | 是普通文件   | `[ -f /path/to/file ]` |\n| -d  | 是目录     | `[ -d /path/to/dir ]`  |\n| -r  | 可读      | `[ -r file.txt ]`      |\n| -w  | 可写      | `[ -w file.txt ]`      |\n| -x  | 可执行     | `[ -x script.sh ]`     |\n| -s  | 文件大小 >0 | `[ -s logfile ]`       |\n| -L  | 是符号链接   | `[ -L symlink ]`       |\n\n#### 2.3.2. 字符串比较\n\n| 操作符                | 描述    | 示例                       |\n| ------------------ | ----- | ------------------------ |\n| -z STRING          | 字符串为空 | `[ -z \"$var\" ]`          |\n| -n STRING          | 字符串非空 | `[ -n \"$var\" ]`          |\n| STRING1 = STRING2  | 字符串相等 | `[ \"$var1\" = \"$var2\" ]`  |\n| STRING1 != STRING2 | 字符串不等 | `[ \"$var1\" != \"$var2\" ]` |\n\n#### 2.3.3. 数值比较\n\n|操作符|描述|示例|\n|---|---|---|\n|-eq|等于|`[ \"$a\" -eq \"$b\" ]`|\n|-ne|不等于|`[ \"$a\" -ne \"$b\" ]`|\n|-gt|大于|`[ \"$a\" -gt \"$b\" ]`|\n|-ge|大于或等于|`[ \"$a\" -ge \"$b\" ]`|\n|-lt|小于|`[ \"$a\" -lt \"$b\" ]`|\n|-le|小于或等于|`[ \"$a\" -le \"$b\" ]`|\n\n#### 2.3.4. 逻辑操作符\n\n`test` 支持逻辑组合：\n\n|操作符|描述|示例|\n|---|---|---|\n|!|逻辑非|`[ ! -f \"$file\" ]`|\n|-a|逻辑与|`[ \"$a\" -eq 1 -a \"$b\" -eq 2 ]`|\n|-o|逻辑或|`[ \"$a\" -eq 1 -o \"$b\" -eq 2 ]`|\n\n**现代推荐写法**：使用 `&&` 和 `||` 替代 `-a` 和 `-o`，更符合 POSIX 标准\n\n---\n\n### 2.4. 条件判断\n\n:::warning\n和 Java、PHP 等语言不一样，sh 的流程控制不可为空\n:::\n\n**这个我单独开一篇算了....**\n\n## 3. 拓展：shell脚本中`$`的作用\n\n在 Shell 中，`$` 是一个非常核心的符号，主要用于**变量引用**、**命令替换**、**参数访问**、**字符串操作**等。下面按不同用途分类说明：\n### 3.1. 变量引用\n\n`$变量名` 用于获取变量的值：\n\n```shell\nname=\"lemon\"\necho $name     # 输出: lemon\n```\n\n```shell\necho ${name}world   # 输出: lemonworld\n```\n\n### 3.2. 命令替换\n\n`$(command)` 会执行 `command` 命令，并将其标准输出结果替换为字符串：\n\n```shell\necho \"Today is $(date)\"\n# 输出: Today is Wed Jun 18 17:00:00 CST 2025\n```\n\n等价于旧式：`` `command` ``\n\n### 3.3. 位置参数和特殊变量\n\nShell 脚本中 `$` 也用于获取传入脚本的参数或特殊含义变量：\n\n|表达式|含义|\n|---|---|\n|`$0`|脚本名|\n|`$1` ~ `$9`|脚本参数（第1~9个）|\n|`$@`|所有参数（独立）|\n|`$*`|所有参数（整体）|\n|`$#`|参数个数|\n|`$$`|当前脚本/进程的 PID|\n|`$?`|上一个命令的返回值|\n|`$!`|最近一个后台进程的 PID|\n\n示例：\n```shell\n#!/bin/bash\n\necho \"【\\$0】：脚本名称：$0\"\necho \"【\\$1】：第一个参数：$1\"\necho \"【\\$2】：第二个参数：$2\"\necho \"【\\$#】：参数总数：$#\"\n\necho \"【\\$@】：所有参数（逐个显示）\"\nfor arg in \"$@\"; do\n    echo \"  - $arg\"\ndone\n#  或echo \"【\\$@】：所有参数:\" \"$@\"\necho \"【\\$*】：所有参数（整体显示）\"\nfor arg in \"$*\"; do\n    echo \"  - $arg\"\ndone\n\necho \"【\\$$】：当前脚本的 PID 是：$$\"\n\n# 模拟一个命令并查看返回值\necho \"执行 ls 命令：\"\nls > /dev/null\necho \"【\\$?】：上一个命令的退出状态码：$?\"\n\n# 模拟后台命令并查看其 PID\nsleep 5 &\necho \"【\\$!】：最近一个后台任务的 PID 是：$!\"\n\n```\n\n\n常见问题：`${@}`与 `${*}`的区别\n\n| 表达式      | 解释                                |\n| -------- | --------------------------------- |\n| `\"${@}\"` | 把每个参数**作为独立字符串**处理，适合 for 循环      |\n| `\"${*}\"` | 把所有参数当作**一个整体字符串**处理，若带引号会合并成一个参数 |\n\n### 3.4. 算术扩展\n\n用 `$(())` 或 `$[]` 进行算术运算：\n\n```bash\na=5\nb=3\necho $[a + b]  # 输出: 8\n```\n\n### 3.5. 字符串操作和默认值处理\n\n支持 `:-`, `:=`, `:+`, `:?` 等操作：\n\n```shell\necho ${var:-default}   # var未定义则使用\"default\"\n```\n\n\n","tags":["Linux","shell"],"categories":["Linux","Shell"]},{"title":"Ubuntu下连接文件","url":"/posts/36626/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n在 Linux 系统中，我们常常需要在不同位置引用同一个文件，或者希望通过某种方式为某个文件设置别名。这时候，文件“连接（Link）”机制就派上用场了。本文将详细介绍 Linux 下的硬链接（Hard Link）与符号链接（Symbolic Link，又称软链接）的概念、区别以及实际用法。\n\n---\n\n## 📌 一、什么是文件连接？\n\nLinux 中的“连接”指的是为某个文件创建一个别名或指针，使你可以通过多个路径访问同一个文件内容。\n\n连接分为两种类型：\n\n- **硬链接（Hard Link）**\n- **符号链接（Symbolic Link 或 Soft Link）**\n\n---\n\n## 🔗 二、硬链接（Hard Link）\n\n### 1. 概念\n\n硬链接是文件系统中的一种机制，它为**同一个 inode（索引节点）** 创建多个目录项。多个硬链接本质上是“平等的”，互为镜像。\n\n### 2. 特点\n\n- 同一个 inode 号，表示指向同一个文件内容。\n- 删除其中一个链接不会影响其他链接。\n- 不支持对目录创建硬链接（为避免环形结构）。\n- 只能对同一文件系统内的文件创建。\n\n### 3. 创建命令\n\n```bash\nln 源文件 目标文件\n```\n\n### 4.实验\n查看链接数\n```bash\nls -l\n```\n\n第二列显示的数字表示链接数（包括自己）。\n\n![](Snipaste_2025-06-14_21-30-04.png)\n可见其所占用的存储空间是相同的，说明它们本质是相同的，指向同一incode，删除链接源文件，其他文件依然可以运行。\n例如：\n```bash\nrm hello\n./ hello2\n```\n依然正常输出\n\n---\n\n## 三、符号链接（Symbolic Link / Soft Link）\n\n### 1. 概念\n\n符号链接类似 Windows 的快捷方式，它是一个**特殊类型的文件**，包含了另一个文件的路径。\n\n### 2. 特点\n\n- 是一个独立的文件，有自己的 inode。\n- 链接路径，而非直接指向数据块。\n- 删除源文件会导致符号链接失效（变成“悬挂链接”或“死链接”）。\n- 可跨文件系统，也可指向目录。\n\n:::bug\n**请使用绝对路径，否则拷贝文件到另一目录时会失去软连接**\n:::\n### 3. 创建命令\n\n```bash\nln -s 源文件 目标链接名\n```\n\n### 4. 实验\n\n拷贝文件保留软链接\n```bash\ncp -d [源] [目的]\n```\n\n当使用相对路径时：\n![](Snipaste_2025-06-14_21-42-53.png)\n![](Snipaste_2025-06-14_21-48-24.png)\n使用绝对路径：\n![](Snipaste_2025-06-14_21-54-29.png)\n\n---\n\n## 🆚 四、硬链接 vs 符号链接\n\n|特性|硬链接（Hard Link）|符号链接（Symbolic Link）|\n|---|---|---|\n|是否有独立 inode|否|是|\n|是否可跨文件系统|否|是|\n|是否可链接目录|否|是（需管理员权限）|\n|删除原文件后|内容仍保留|链接失效（悬挂链接）|\n|作用|多个文件名共享内容|文件快捷方式|\n\n---\n\n## 🧪 五、补充\n\n### 查找所有指向同一 inode 的文件\n\n```bash\nfind . -inum <inode号>\n```\n\n### 查找所有死链接\n\n```bash\nfind . -xtype l\n```\n---\n\n## ✅ 六、总结\n\n| 关键点  | 硬链接       | 符号链接       |\n| ---- | --------- | ---------- |\n| 安全性  | 内容冗余，较安全  | 容易产生死链接    |\n| 灵活性  | 不支持跨系统和目录 | 灵活，可指向任意路径 |\n| 适用场景 | 本地备份，核心文件 | 快捷方式，快捷访问  |\n","tags":["Linux","链接文件"],"categories":["Linux","Ubuntu"]},{"title":"踩坑记录：WSL下对u盘格式化修改后在win下连接u盘发现盘内内容未改变","url":"/posts/20676/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n## 问题描述\n我将USB读卡器插入microSD卡（该SD卡此前刷入过micropython固件包），并将其连接至电脑，接着我在win系统下，在SD卡目录下创建了一个文件wtf.txt，然后打开WSL，使用usbip将该u盘共享，在WSL下，u盘能正确读取、挂载，我在WSL重新对这个u盘使用fdisk重新分区，mkfs重新格式化为FAT32文件系统，并且在WSL下touch了一个新文件hi.txt，使用sync同步，然后使用usbipd的命令断开连接，接入win系统后，wtf.txt居然还在，再次将u盘接入WSL，发现hi.txt也在，也就是说，同样的SD卡，两个系统读到的东西却不一样，这是怎么回事？\n按照网上的主流方法，尝试过编译内核添加usb驱动支持，手动安装usbip工具都不管用。\n## 问题解决\n在使用fdisk分区时，我发现如下警告：\n```text\nThe device contains hybrid MBR -- writing GPT only.\n```\n\n在询问chatgpt后，弄清了这条警告的含义：\n1. **磁盘中检测到 Hybrid MBR**：即使之前格式化或重分区过，它仍可能保留有旧的混合结构。\n2. **当前正尝试用 GPT 格式重写该磁盘**：工具会忽略 MBR 部分，只写入纯 GPT。    \n\n**Hybrid MBR（混合主引导记录）** 是一种兼容机制，它允许一个磁盘同时拥有：\n- 一部分 **MBR（传统 BIOS 启动支持）**\n- 一部分 **GPT（用于现代系统的分区方案）**\n\n这种结构通常用于让 **使用 GPT 分区的磁盘**仍然可以在一些只识别 MBR 的系统中启动，比如旧版 BIOS 系统。\n\n我突然想起来这个SD卡不就是之前用于引导启动micropython固件的吗，所以存在混合结构，而正是这样的混合结构，是使得在win下，系统读到的是MBR分区表，Linux下读到的是GPT分区表，这就像 SD 卡前面贴着两张标签纸（MBR 和 GPT）：\n- Windows 看标签 A，就看到旧文件\n- Linux 看标签 B，就看到新文件\n- 它们根本没在“同一张纸”上操作\n\n于是我按照GPT提供的方法，使用命令彻底清除磁盘前部（包括 MBR & GPT）：\n```bash\nsudo dd if=/dev/zero of=/dev/sdd bs=1M count=10\nsync\n```\n完全抹除了旧的结构信息，再次重复分区、格式化、挂载、创建文件等操作，这下两个系统读取到的文件就同步了😍！\n\n## 特别感谢\n\n- [ChatGPT](https://chatgpt.com/)!，AI改变世界啊~\n- 我自己！\n","tags":["Linux","踩坑记录"],"categories":["Linux","记录"]},{"title":"Ubuntu下文件权限管理","url":"/posts/10180/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n在命令行界面下，输入命令\n```bash\ncd /dev\nls -l\n```\n\n得到输出如下：\n\n![](Snipaste_2025-06-14_17-39-42.png)\n\n每列释义如下：\n\n| 列   | 示例值            | 含义说明                                 |\n| --- | -------------- | ------------------------------------ |\n| 1   | `crw-rw----`   | 文件类型与权限（c 表示字符设备；接下来是用户/组/其他的读写执行权限） |\n| 2   | `1`            | 硬链接数量（对于设备文件通常是1）                    |\n| 3   | `root`         | 文件（或设备）的所有者                          |\n| 4   | `root`         | 所属用户组                                |\n| 5   | `188, 0`       | 主设备号和次设备号（**仅对设备文件存在**，表示对应驱动和设备）    |\n| 6   | `Jun 14 16:45` | 最后修改时间                               |\n| 7   | `ttyUSB0`      | 文件名（这里是设备名）                          |\n\n## 主次设备号\n主设备号（Major Number）\n- 决定了这个文件对应哪个**驱动程序**。\n- 比如所有的 `ttyUSBx` 设备可能都由主设备号 188 对应的驱动处理。\n\n次设备号（Minor Number）\n- 由主设备号指定的驱动程序使用，用于区分同一驱动管理下的不同设备。\n- 比如 `ttyUSB0` 是第一个设备，`ttyUSB1` 是第二个，以此类推。\n\n## 文件权限位详解\n第一列是文件权限位，每位释义如下：\n\n| 位次   | 含义           | 示例    | 说明                                |\n| ---- | ------------ | ----- | --------------------------------- |\n| 1    | 文件类型         | `-`   | `-` 普通文件、`d` 目录、`l` 软链接、`c` 字符设备等 |\n| 2-4  | 所有者权限（user）  | `rwx` | 读（r）、写（w）、执行（x）                   |\n| 5-7  | 用户组权限（group） | `r-x` |                                   |\n| 8-10 | 其他人权限（other） | `r--` |                                   |\n权限字符：\n\n| 字符  | 含义                          |\n| --- | --------------------------- |\n| `r` | 可读（read）：可以读取文件内容或列出目录内容    |\n| `w` | 可写（write）：可以修改文件内容或添加/删除目录项 |\n| `x` | 可执行（execute）：可执行程序或进入目录     |\n| `-` | 没有该权限                       |\n\n## 文件权限修改\n\n### 一、`chmod` 命令概述\n\n用于更改文件或目录的权限，支持 **符号法** 和 **数字法**。\n\n---\n\n### 二、权限基础\n\n|权限字符|权限含义|对文件作用|对目录作用|\n|---|---|---|---|\n|`r`|读权限|可读取内容|可列出目录文件|\n|`w`|写权限|可修改内容|可创建/删除文件|\n|`x`|执行权限|可执行|可进入目录|\n\n---\n\n### 三、符号法（Symbolic Mode）\n\n#### 语法\n\n```bash\nchmod [对象][操作][权限] 文件名\n```\n#### 对象（权限归属）\n\n|符号|含义|\n|---|---|\n|`u`|所有者|\n|`g`|所属组|\n|`o`|其他用户|\n|`a`|所有人（ugo）|\n\n#### 操作符\n\n|符号|含义|\n|---|---|\n|`+`|添加权限|\n|`-`|删除权限|\n|`=`|赋予权限（替换）|\n\n#### 示例\n\n```bash\nchmod u+x file.sh     # 给所有者添加执行权限\nchmod g-w file.txt    # 移除组的写权限\nchmod o=r file.txt    # 其他人只读\nchmod a+x run.sh      # 所有人添加执行权限\n```\n\n---\n\n### 四、数字法（Octal Mode）\n\n#### 权限与数字映射\n\n|权限|数值|含义|\n|---|---|---|\n|`---`|0|无权限|\n|`--x`|1|执行|\n|`-w-`|2|写|\n|`-wx`|3|写 + 执行|\n|`r--`|4|读|\n|`r-x`|5|读 + 执行|\n|`rw-`|6|读 + 写|\n|`rwx`|7|全部权限|\n 相当于以二进制对应的十进制来表示，这点应该不陌生。\n#### 示例\n\n```bash\nchmod 755 script.sh    # 所有者全部权限，其他用户读+执行\nchmod 644 note.txt     # 所有者读写，其他人只读\nchmod 700 secret.txt   # 只有所有者有权限\n```\n\n---\n\n### 五、递归权限修改\n\n```bash\nchmod -R 755 myfolder     # 递归修改目录及其下所有文件/子目录权限\n```\n\n---\n\n### 六、使用 find 批量设置权限\n\n```bash\nfind . -type f -exec chmod 644 {} \\;   # 设置所有文件权限\nfind . -type d -exec chmod 755 {} \\;   # 设置所有目录权限\n```\n\n---\n\n### 七、常见目录权限推荐\n\n|目录|推荐权限|含义说明|\n|---|---|---|\n|`/home/用户名`|`700`|仅用户本人访问|\n|`/tmp`|`1777`|所有人可写，Sticky 位保护|\n|网站目录|`755`|其他人可访问但不可修改|\n\n---\n\n### 八、特殊权限简述（可选）\n\n|权限|作用|示例|\n|---|---|---|\n|SUID|执行程序时使用文件所有者权限|`chmod u+s`|\n|SGID|同上，应用于组|`chmod g+s`|\n|Sticky|只能删除自己文件（多用于/tmp）|`chmod +t`|\n\n---\n","tags":["Linux","Ubuntu","文件系统"],"categories":["Linux","Ubuntu"]},{"title":"Ubuntu下磁盘管理","url":"/posts/30265/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n前面我们成功让WSL读取到Win系统的USB设备，下面来学习WSL下磁盘的管理。\n\n## 磁盘和目录的容量查询命令\n\n`df` ：查看文件系统使用量，主要查看文件系统的使用量。\n`du` ：评估文件系统的磁盘使用量，主要查看单个文件大小。\n`lsblk` ：*List Block Devices* 列出系统中SSD、U盘等存储设备的信息\n## 磁盘的挂载卸载\n\n还记得前面提到的[Ubuntu文件系统结构](https://blog.godmao.top/posts/7417/)吗？想要读取u盘里的文件，需要把u盘挂载在某个目录下才能访问。\n\n### 什么是挂载？\n挂载就是“**把设备上的文件系统接入Linux的目录结构中**”。\n- Linux 的目录结构是一个**统一的树形结构**（根目录 `/` 是起点）。\n- 所有的文件、文件夹、设备访问，都要通过这个统一的目录树。\n- 当你插入一个U盘时，它本身是一个独立的文件系统（如FAT32），Linux不会自动将其连接进目录树，除非你明确地**挂载**它。\n\n### 为什么Linux要挂载？Windows为什么不需要？\n**Linux设计哲学：**\n- Linux源于Unix，追求“一切皆文件”，统一的目录结构。\n- 所有设备都必须通过`/dev/xxx`表示为一个文件，然后挂载到某个目录（如`/mnt/usb`）才可以访问。\n**Windows的方式：**\n- Windows是“盘符式”的，每个设备有独立的盘符（如`E:\\`, `F:\\`），操作系统会**自动识别并挂载**。\n- 挂载过程对用户是透明的，但其实系统内部也在完成挂载，只是隐藏了细节。\n所以：**Windows系统也挂载，只是自动化并且用盘符表示；Linux则更显式且灵活**。\n\n### Linux下如何手动挂载u盘？\n\n如果是U盘可以挂载在`/dev/media/`目录或`/dev/mnt/`目录\n#### 1.查看u盘设备名\n在使用usbipd使WSL读取到u盘后，运行如下命令：\n```bash\nlsblk\n```\n\n会看到类似这样的输出：\n```\nsdb      8:16   1  29.8G  0 disk\n├─sdb1   8:17   1  10.0G  0 part\n├─sdb2   8:18   1   9.8G  0 part\n└─sdb3   8:19   1  10.0G  0 part\n```\n这里 `sdb1` 是U盘的分区名。磁盘可能有很多分区嘛。\n\n#### 2.为每个分区创建挂载点目录\n```bash\nsudo mkdir -p /mnt/usb1 /mnt/usb2 /mnt/usb3\n```\n\n#### 3.逐个挂载\n```bash\nsudo mount /dev/sdb1 /mnt/usb1\nsudo mount /dev/sdb2 /mnt/usb2\nsudo mount /dev/sdb3 /mnt/usb3\n```\n如果某个分区的文件系统不是自动识别的（报错），你可以指定类型挂载，例如：\n```bash\nsudo mount -t vfat /dev/sdb1 /mnt/usb1\nsudo mount -t ext4 /dev/sdb2 /mnt/usb2\nsudo mount -t ntfs /dev/sdb3 /mnt/usb3\n```\n如果不清楚类型运行如下命令可以查看：\n```bash\nsudo blkid /dev/sdb1 /dev/sdb2 /dev/sdb3\n```\n\n### 卸载\n```bash\nsudo umount /mnt/usb1\nsudo umount /mnt/usb2\nsudo umount /mnt/usb3\n```\n\n## 磁盘分区\n\n### fdisk命令常用选项\n| 命令 | 含义                     | 功能说明                                     |\n|------|--------------------------|----------------------------------------------|\n| `m`  | help                     | 显示所有可用命令                             |\n| `p`  | print                    | 显示当前分区表                               |\n| `n`  | new                      | 创建一个新分区（主分区或逻辑分区）           |\n| `d`  | delete                   | 删除一个已有分区                             |\n| `t`  | type                     | 修改分区的类型 ID                            |\n| `l`  | list                     | 列出所有分区类型 ID                         |\n| `a`  | toggle bootable          | 切换分区的启动标志（设置/取消可引导分区）   |\n| `w`  | write                    | 写入分区表并退出                             |\n| `q`  | quit                     | 不保存更改，直接退出                         |\n| `g`  | gpt                      | 创建新的 GPT 分区表                          |\n| `o`  | dos                      | 创建新的空白 DOS (MBR) 分区表                |\n| `v`  | verify                   | 验证分区表的完整性                           |\n| `x`  | expert                   | 进入专家模式（用于高级操作）                 |\n### 用fdisk打开要分区的磁盘\n```bash\nsudo fdisk /dev/sde\n```\n\n:::warning\n千万不要误选，否则可能破坏你的数据。\n:::\n\n### 删除分区\n```bash\nCommand (m for help): p        ← 查看当前分区情况（确认要删哪个）\nCommand (m for help): d        ← 删除分区\nPartition number (1,2,...): 2  ← 选择你要删除的分区编号（比如 2 表示 /dev/sdb2）\nCommand (m for help): w        ← 保存更改并退出\n```\n\n### 创建分区\n```bash\nCommand (m for help): n\n```\n\n![](Snipaste_2025-06-12_17-21-39.png)\n\n1：分区编号，直接回车接受默认编号。\n2：起始扇区，默认值通常合适，直接回车即可。\n3：结束扇区 or 分区大小，可以输入：扇区编号（直接回车使用剩余空间）或者手动输入大小（例如：`+1G`、`+512M`）\n\n### 写出\n保存并退出。\n```bash\nCommand (m for help): w\n```\n\n## 格式化分区\n当用 `fdisk` 创建完一个分区后，这个分区只是“逻辑划分好了”，但**还不能使用**，必须要**格式化（创建文件系统）**才能真正读写数据。\n\n### 为什么要格式化？\n格式化的本质是：\n\n> **在分区上写入特定的文件系统结构**（如 ext4、FAT32、NTFS 等）。\n\n只有这样，操作系统才知道如何在这块区域内组织、存储和查找文件。\n\n### 1.选择格式化类型\n| 文件系统  | 说明                               |\n| ----- | -------------------------------- |\n| ext4  | Linux常用，性能稳定，支持大文件               |\n| vfat  | FAT32，兼容Windows/Mac/Linux，不支持大文件 |\n| ntfs  | Windows常用，Linux可读写（需驱动）          |\n| exfat | 新型通用格式，支持大文件，跨平台兼容性好             |\n### 2.执行格式化命令\n*make file system* -type\n```bash\nsudo mkfs.vfat -f 32 /dev/sde2\n```\n没有mkfs的先安装，不然报错：\n```\nfailed to execute mkfs.vfat: No such file or directory\n```\n安装：\n```bash\nsudo apt update\nsudo apt install dosfstools\n```\n\n### 检查\n可以输入命令：\n```bash\nsudo blkid /dev/sde1 /dev/sde2\n```\n检查type\n输出：\n```\nsde1: UUID=\"FBD5-E06C\" BLOCK_SIZE=\"512\" TYPE=\"vfat\" PARTUUID=\"3b15f93b-f163-491d-9f0f-94be96692beb\"\nsde2: UUID=\"FC22-7890\" BLOCK_SIZE=\"512\" TYPE=\"vfat\" PARTUUID=\"248a2fdb-2255-4a7a-802e-e5a11bb87c53\"\n```\n","tags":["Linux","Ubuntu","磁盘管理"],"categories":["Linux","Ubuntu"]},{"title":"WSL下连接USB设备","url":"/posts/13715/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n⭐⭐⭐本文参考自微软官方WSL文档——[连接 USB 设备 | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/connect-usb)\n\n由于WSL不提供本机连接USB设备的支持，因此需要安装开源项目usbipd-win来支持USB的共享连接。\n\n## 什么是usbpid？\nusbipd 是一个**用于管理 USB/IP（USB over IP）服务的命令行工具**，可以在 Windows 下使用。 USB/IP 是一种协议，允许**通过网络共享USB 设备**。 usbipd工具允许用户在 Windows 上共享 USB 设备，使其他计算机能够通过网络访问这些设备。\n\n## 安装 USBIPD-WIN 项目\n1. 转到 [usbipd-win 项目的最新发布页面](https://github.com/dorssel/usbipd-win/releases)。\n2. 选择 .msi 文件，该文件将下载安装程序。 （你可能会收到一条警告，要求你确认你信任此下载）。\n3. 运行下载 usbipd-win_x.msi 安装程序文件。\n\n这将安装：\n- 名为 `usbipd` 的服务，（显示名称：USBIP 设备主机）。 可以使用 Windows 中的服务应用检查此服务的状态。\n- 命令行工具 `usbipd`。 此工具的位置将添加到 PATH 环境变量。\n- 名为 `usbipd` 的防火墙规则，用于允许所有本地子网连接到服务。 可修改此防火墙规则以微调访问控制。\n\n4. 若要附加 USB 设备，请运行以下命令。 （不再需要使用提升的管理员提示。确保 WSL 命令提示符处于打开状态，以使 WSL 2 轻型 VM 保持活动状态。 **请注意，只要 USB 设备连接到 WSL，Windows 将无法使用它。** 一旦连接到 WSL，任何在 WSL 2 上运行的发行版都可以使用该 USB 设备。 请确认设备是否已连接 `usbipd list`。 在 WSL 提示符下，运行 `lsusb` 以验证 USB 设备是否已列出，并且可以使用 Linux 工具与之交互。\n\n```powershell\nusbipd attach --wsl --busid <busid>\n```\n\n5. 打开 Ubuntu（或首选 WSL 命令行），并使用以下命令列出附加的 USB 设备：\n\n```bash\nlsusb\n或者\nlsblk -f\n```\n\n若没有找到命令，则先下载`usbutils`\n![](Snipaste_2025-06-12_00-11-23.png)\n```bash\nsudo apt install usbutils\n```\n\n可以看到已经成功读取到u盘，并且能够使用普通 Linux 工具与之交互。 根据应用程序，可能需要配置 udev 规则，以允许非根用户访问设备。\n![](Snipaste_2025-06-12_00-18-59.png)\n6. 在 WSL 中使用设备后，可以物理断开 USB 设备的连接，或者从 PowerShell 运行以下命令：\n\n```powershell\nusbipd detach --busid <busid>\n```\n\n\n","tags":["Linux","USB","WSL2"],"categories":["Linux","WSL2"]},{"title":"Ubuntu文件系统结构","url":"/posts/7417/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\nUbuntu文件系统结构清单。\n<!--more-->\n\n> 万物皆文件\n\n**仅作学习记录。**\n\n| 目录          | 说明                                                  |\n| ----------- | --------------------------------------------------- |\n| `/`         | 根目录，是所有文件和目录的起点。                                    |\n| `/bin`[^1]  | 存放系统启动和运行所需的基本命令（如 `ls`, `cp`, `mv`）。               |\n| `/boot`     | 启动相关文件，如内核 (`vmlinuz`)、引导加载器配置等。                    |\n| `/dev`      | 包含所有设备（驱动）文件（如硬盘、终端、USB 设备）。                        |\n| `/etc`      | 系统配置文件目录（如网络、用户、服务配置）。                              |\n| `/home`     | 每个普通用户的主目录（如 `/home/alice`）。                        |\n| `/lib`      | 存放系统程序所需的共享库文件。                                     |\n| `/lib64`    | 存放64位系统的共享库（与 `/lib` 类似）。                           |\n| `/media`    | 可移动设备挂载点（如U盘、CD-ROM）。                               |\n| `/mnt`      | 临时挂载文件系统的目录，供管理员使用。                                 |\n| `/opt`      | 为第三方软件提供安装位置。                                       |\n| `/proc`     | 虚拟文件系统，内核和进程信息以文件形式展现（如 `/proc/cpuinfo`）。存放系统运行的信息？ |\n| `/root`     | `root` 用户的主目录（注意：不是 `/`）。                           |\n| `/run`      | 存放运行时数据，如系统启动后生成的PID文件或Socket文件。                    |\n| `/sbin`     | 存放系统管理类命令，仅供 `root` 用户使用（如 `reboot`, `fsck`）。       |\n| `/srv`      | 存放提供服务的数据（如网站、FTP 服务器数据）。                           |\n| `/sys`      | 虚拟文件系统，表示内核设备结构，供 `udev` 和其他工具使用。                   |\n| `/tmp`      | 存放临时文件（系统重启后清空）。                                    |\n| `/usr`      | 多数用户空间程序和库的安装目录。                                    |\n| `/usr/bin`  | 非必要基本命令（大部分用户程序）的位置。                                |\n| `/usr/sbin` | 系统管理命令的位置，供管理员使用。                                   |\n| `/usr/lib`  | `/usr/bin` 和 `/usr/sbin` 程序所用库文件。                   |\n| `/var`      | 可变数据文件（如日志、缓存、邮件、数据库文件等）。                           |\n\n[^1]:Faker VS Bin 你蹲我的意思吗\n","tags":["Linux","Ubuntu","文件系统"],"categories":["Linux","Ubuntu"]},{"title":"Linux常用的命令总结","url":"/posts/37616/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\nLinux下常用的命令清单及补充。\n<!--more-->\n\n**仅作学习记录。**\n\n| 命令         | 说明                 | 使用格式                   |\n| ---------- | ------------------ | ---------------------- |\n| `ls`       | 列出目录内容             | `ls [选项] [目录]`         |\n| `cd`       | 改变当前目录             | `cd [目录]`              |\n| `pwd`      | 显示当前工作目录           | `pwd`                  |\n| `cp`       | 复制文件或目录            | `cp [选项] 源文件 目标文件`     |\n| `mv`       | 移动文件或目录，重命名文件      | `mv [选项] 源文件 目标文件`     |\n| `rm`       | 删除文件或目录            | `rm [选项] 文件`           |\n| `touch`    | 创建空文件              | `touch 文件名`            |\n| `mkdir`    | 创建目录               | `mkdir [选项] 目录名`       |\n| `rmdir`    | 删除空目录              | `rmdir 目录名`            |\n| `chmod`    | 更改文件或目录权限          | `chmod [选项] 权限 文件`     |\n| `chown`    | 更改文件或目录的所有者        | `chown 用户:组 文件`        |\n| `chgrp`    | 更改文件或目录的所属组        | `chgrp 组 文件`           |\n| `cat`      | 查看文件内容             | `cat 文件名`              |\n| `more`     | 分页显示文件内容           | `more 文件名`             |\n| `less`     | 分页显示文件内容（支持上下翻页）   | `less 文件名`             |\n| `head`     | 查看文件开头部分           | `head [选项] 文件`         |\n| `tail`     | 查看文件尾部部分           | `tail [选项] 文件`         |\n| `find`     | 查找文件或目录            | `find [路径] [选项] [表达式]` |\n| `grep`     | 文本搜索               | `grep [选项] \"模式\" 文件`    |\n| `tar`      | 压缩或解压文件            | `tar [选项] [文件]`        |\n| `gzip`     | 压缩文件               | `gzip 文件名`             |\n| `gunzip`   | 解压.gz文件            | `gunzip 文件名.gz`        |\n| `zip`      | 压缩文件               | `zip [选项] 压缩包 文件`      |\n| `unzip`    | 解压.zip文件           | `unzip 压缩包`            |\n| `df`       | 查看文件系统磁盘空间使用情况     | `df [选项]`              |\n| `du`       | 查看目录或文件的磁盘使用情况     | `du [选项] 文件/目录`        |\n| `top`      | 查看系统进程状态           | `top`                  |\n| `ps`       | 查看进程状态             | `ps [选项]`              |\n| `kill`     | 终止进程               | `kill [选项] 进程号`        |\n| `pstree`   | 以树形结构显示进程          | `pstree`               |\n| `free`     | 查看内存使用情况           | `free [选项]`            |\n| `uname`    | 查看系统信息             | `uname [选项]`           |\n| `ifconfig` | 配置网络接口             | `ifconfig [网络接口]`      |\n| `ip`       | 查看或配置网络            | `ip [选项]`              |\n| `ping`     | 测试网络连接             | `ping [选项] 地址`         |\n| `scp`      | 安全复制文件             | `scp 源文件 用户@主机:目标`     |\n| `rsync`    | 同步文件和目录            | `rsync [选项] 源 目标`      |\n| `wget`     | 从网络下载文件            | `wget [选项] URL`        |\n| `curl`     | 与网络交互（下载、上传文件等）    | `curl [选项] URL`        |\n| `alias`    | 创建命令别名             | `alias 别名='命令'`        |\n| `history`  | 查看命令历史             | `history`              |\n| `man`      | 查看命令手册             | `man 命令名`              |\n| `echo`     | 输出字符串到终端           | `echo \"文本\"`            |\n| `tee`      | 从标准输入读取，并将其内容输出到文件 | `命令 \\| tee 文件`         |\n| `cut`      | 按列切割文件内容           | `cut -d 分隔符 -f 列 文件`   |\n| `awk`      | 强大的文本处理工具          | `awk '条件 {动作}' 文件`     |\n| `sed`      | 流编辑器，处理文本数据        | `sed 's/模式/替换文本/' 文件`  |\n| `tr`       | 转换字符               | `tr '旧字符' '新字符' < 文件`  |\n| `wc`       | 统计文件字数、行数、字节数等     | `wc [选项] 文件`           |\n| `whoami`   | 查看当前用户             | `whoami`               |\n| `sudo`     | 以超级用户身份执行命令        | `sudo 命令`              |\n| `exit`     | 退出终端或当前Shell会话     | `exit`                 |\n| `file`     | 文件类型查看命令           |  `file 文件路径`           |\n\n## ls\n-a 列出全部\n-l 以列展示\n\n## ranger\n一个终端文件管理器（Vim风格）\n\n| 操作        | 快捷键                |\n| --------- | ------------------ |\n| 向上/向下     | 方向键                |\n| 进入目录或打开文件 | `l / Enter`        |\n| 返回上一级目录   | 方向键                |\n| 创建新文件     | `:touch filename`  |\n| 创建新目录     | `:mkdir dirname`   |\n| 删除文件/目录   | `D` 然后确认           |\n| 重命名       | `cw`               |\n| 复制        | `yy`（复制）+ `pp`（粘贴） |\n| 剪切        | `dd`（剪切）+ `pp`（粘贴） |\n| 预览文件内容    | 自动或按 `i`           |\n| 搜索文件名     | `/关键词`             |\n| 退出        | `q` 或 `:q`         |\n\n## grep\n-r  递归子目录\n-l  列出文件内容符合指定的样式的文件名称。\n-i  不区分大小写\n-n 字符串在哪一行 \n\n## du\n-s 只显示指定目录总大小 \n-h 以单位k、m、g显示\n\n## tar\n-c 创建新归档，压缩\n-x 从归档中解出文件，解压缩\n-j 使用bzip2压缩格式\n-z 使用gzip压缩格式\n-v 打印命令执行过程\n-f 以什么名字归档\n\n","tags":["Linux","命令"],"categories":["Linux"]},{"title":"如何优雅的在win上运行Linux","url":"/posts/26155/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n 在 Windows 和 Linux 之间切换开发环境是一件让人头疼的事。幸运的是，WSL（Windows Subsystem for Linux）为我们提供了一种优雅的解决方案：**在 Windows 上原生运行 Linux**，无需虚拟机或双系统。本文将带你优雅地入门 WSL，从安装到使用，让你轻松拥有双系统的快乐而不牺牲效率。\n\n## 一、WSL 是什么？\n\nWSL（Windows Subsystem for Linux）是微软提供的一种兼容层，使你可以直接在 Windows 上运行 Linux 用户空间环境。当前主流版本是 **WSL 2**，它使用轻量虚拟化技术，提供完整的 Linux 内核和更好的性能。那么它有什么好处呢？\n- Linux 、Windows文件共享。你可以在Windows的文件资源管理器上处理Linux子系统的文件\n- 命令混用，在Windows里可以运行Liunx命令，在Linux里可以运行Windows程序\n- 显卡直通，在AI训练方面非常方便\n等等....\n\n## 二、准备工作\n\n:::success\n- Windows 10（版本 2004 及以上，推荐 21H2 或更高）\n- 或 Windows 11（原生支持 WSL 2）\n:::\n本文以win11为例。\n### 开启必要功能\n在搜索栏搜索 `启动或关闭window功能`\n![](Snipaste_2025-06-07_23-29-33%201.png)\n开启如下两项：\n- 适用于Linux的Windows子系统\n- 虚拟机平台\n![](Snipaste_2025-06-07_23-32-13.png)\n然后**重启以使更改生效**。\n如果是win11的话重启后可以看到文件资源管理器中有个Linux\n![](Snipaste_2025-06-07_23-36-31.png)\n## 安装Linux子系统\n\n:::warning\nwin11原生支持WSL2，如果没有安装WSL，可以点击这个链接安装\n[Windows Subsystem for Linux - Microsoft Apps](https://apps.microsoft.com/detail/9p9tqf7mrm4r?ocid=pdpshare&hl=en-us&gl=US)\n:::\n\n这里提供两种方法安装WSL2：\n\n### 直接安装发行版\n\n打开下面的链接：\n[旧版 WSL 的手动安装步骤 | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-1---enable-the-windows-subsystem-for-linux)\n直接下载想要的系统的发行版：\n![](Snipaste_2025-06-08_00-08-42.png)\n\n下载下来后将文件后缀改为`.zip`,解压缩\n![](Snipaste_2025-06-08_00-11-46.png)\n\n解压后，选择x64版本，同样的方法，继续解压\n![](Snipaste_2025-06-08_00-14-29.png)\n\n解压后，复制如下两个文件到你想要安装的指定目录\n![](Snipaste_2025-06-08_00-14-53.png)\n\n例如我的是`E:\\Linux\\Ubuntu-24.04LTS`\n\n在目录下双击运行exe文件，自此安装完成。\n![](Snipaste_2025-06-08_00-18-01.png)\n### 命令行安装（不推荐）\n\n不推荐原因如下：\n- 此方法下安装的Linux子系统默认安装在c盘，无法更改安装路径，想要迁移比较麻烦。\n- 由于服务器原因，下载很慢，需要一些上网技巧才能流畅下载。\n\n打开cmd命令提示符窗口，输入如下命令：\n```shell\nwsl --update\nwsl --install\n```\n等待安装成功。默认安装Ubuntu系统。\n也可以指定版本\n输入\n```shell\nwsl --list --online\n```\n可以查看当前可安装的发行版。\n![](Snipaste_2025-06-08_00-01-29%201.png)\n比如安装Debian，直接输入\n```shell\nwsl --install Debian\n```\n等待安装完成即可。\n\n**安装完成后提示输入用户名和密码，注意密码输入是不显示的。**\n\n\n### 开始使用\n💡如果你的电脑只有那种丑丑的简陋的命令行工具，可以在微软商店下载一个`Windows Terminal Preview`获得更好的体验\n![](Snipaste_2025-06-08_00-21-38.png)\n\n### 常用命令速查\n| 命令                                     | 功能                |\n| -------------------------------------- | ----------------- |\n| `wsl`                                  | 启动默认 Linux 发行版    |\n| `wsl -l -v`                            | 查看已安装的发行版和 WSL 版本 |\n| `wsl --set-version <发行版> 2`            | 将指定发行版升级到 WSL 2   |\n| `wsl --set-default-version 2`          | 设置默认启动Linux版本     |\n| `wsl -d <发行版>`                         | 启动指定发行版           |\n| `wsl --shutdown`                       | 关闭所有正在运行的 WSL 实例  |\n| `wsl --unregister <发行版>`               | 卸载发行版             |\n| `wsl --export Ubuntu ubuntu.tar`       | 对子系统进行备份与恢复 【导出】  |\n| `wsl --import <自定义名> <目标路径> <.tar源路径>` | 对子系统进行读取/恢复  【导入】 |\n## 启动\n可以使用命令行启动（见上表）也可在`Windows Terminal Preview`下直接点击\n![](Snipaste_2025-06-08_00-26-24.png)\n即可打开~\n\n## 换源\n这里使用清华源\n[ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror](https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/)\n有详细的使用介绍，根据自己的版本选择文件路径以及格式复制粘贴即可，以Ubuntu24.04为例：\n使用命令\n```shell\nsudo nano /etc/apt/sources.list.d/ubuntu.sources\n```\n进入编辑页面后，先把原来的配置源删除，再粘贴。\n![](Snipaste_2025-06-08_13-50-00.png)\n然后按`Ctrl+O` `Enter` `Ctrl+x`退出 （\"^\"指Ctrl \"M\"指Alt）\n退出后使用命令 \n```shell\nsudo apt update\n```\n更新软件包数据库。\n最后使用\n```shell\nsudo apt upgrade\n```\n升级软件包。\n\n## 退出系统\n`Windows Terminal Preview`下，直接叉掉Linux命令行窗口即可退出\n或在Linux命令行窗口直接使用命令\n```shell\nexit\n```\n推出后等待几秒可以输入\n```shell\nwsl -l -v\n```\n查看Liunx状态：是停止\n![](Snipaste_2025-06-08_14-16-16.png)\n还可以使用 \n```shell\nwsl --shutdown\n```\n一次性关闭所有运行的实例。\n## 卸载系统\n使用命令\n```shell\nwsl --unregister <发行版名>\n```\n即可卸载\n\n## C/C++ 环境搭建\n\n比较简单，默认的 Ubuntu 软件源包含了一个软件包组，名称为 \"build-essential\",它包含了 GNU 编辑器集合，GNU 调试器，和其他编译软件所必需的开发库和工具。  \n想要安装开发工具软件包，直接\n```shell\nsudo apt install build-essential\n```\n验证\n```shell\ngcc -v\ng++ -v\ngdb -v\n```\n 有一个没有的话 单独安装一下即可\n```shell\n sudo apt install gdb\n```\n## 推荐玩法\n### VScode插件\n使用 WSL 作为开发环境，结合 VS Code 的 **Remote - WSL 插件**，在 Windows 中编辑、WSL 中运行。\n直接下载插件\n![](Snipaste_2025-06-08_14-28-45.png)\n在Linux终端打开某个文件夹 然后使用命令即可在Linux环境下运行VScode\n```shell\ncode .\n```\n\n![](Snipaste_2025-06-08_14-31-11.png)\n还可以直接使用VScode终端输入Linux命令。\n![](Snipaste_2025-06-08_14-43-03.png)\n\n## 推荐安装\n\n`ranger`：文件管理器\n`usbipd`：共享usb","tags":["Linux","WSL2"],"categories":["Linux","WSL2"]},{"title":"[自用]16届烂桥杯嵌入式赛道模块代码整理","url":"/posts/44982/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n##  时间片轮询调度\n\n```c\n\nuint8_t TaskCount = 0;//用于记录任务数量\n\ntypedef enum {\n\trun,wait,stop\n}TaskStatus;//任务状态\n\ntypedef struct {\n\tuint8_t TaskRunTime;\n\tuint8_t TaskTimer;\n\tTaskStatus Status;\n\tvoid (*FC)();\n}TaskStrust;//任务信息块：注意两点1.注意Timer和runtime的数据类型为uchar，最大为255 2.时间片为2ms\nTaskStrust TaskList[]={0};\n\nvoid OS_Init(TIM_HandleTypeDef* htim){\n\tHAL_TIM_Base_Start_IT(htim);\n\tTaskCount = sizeof(TaskList)/sizeof(TaskList[1]);\n\tif(TaskCount > MAX_TASK) while(1);\n}\n\nvoid OS_IT_Run(void){\n\tuint8_t i;\n\tfor(i = 0;i < TaskCount;i++){\n\t\tif(TaskList[i].Status == wait){\n\t\t\tif(++TaskList[i].TaskTimer >= TaskList[i].TaskRunTime){\n\t\t\t\tTaskList[i].TaskTimer = 0;\n\t\t\t\tTaskList[i].Status = run;\n\t\t\t}\t\t\n\t\t}\n\t}\n\n}\n//自带死循环，主函数里运行\nvoid OS_Run(void){\n\tuint8_t j = 0;\n\twhile(1){\n\t\tif(TaskList[j].Status == run){\n\t\t\tTaskList[j].FC();\n\t\t\tTaskList[j].Status = wait;\n\t\t}\n\t\tif(++j >= TaskCount) j = 0;\n\t}\n}\n```\n\n## 频率测量\n\n核心思路：\n\n1/（（这一次的计数值-上一次记录的计数值）x （1/时钟频率））= 时钟频率/（记录差值）\n\n\n```c\ntypedef struct {\n    uint8_t i;//记录当前是第几次。\n    int former;//前一次记录的计数值\n    int now;//现在记录的计数值\n    int result;//频率结果\n    uint8_t ElapsedTime;//定时器溢出次数\n}FreqInfo;\n\nreqInfo F1 = {0};\nFreqInfo F2 = {0};\n\n//启动频率测量\nvoid Freq_Start(void){\n    HAL_TIM_Base_Start_IT(&htim3);//对应F1\n    HAL_TIM_IC_Start_IT(&htim3,TIM_CHANNEL_1);\n    HAL_TIM_Base_Start_IT(&htim8);//对应F2\n    HAL_TIM_IC_Start_IT(&htim8,TIM_CHANNEL_1);\n}\n\nstatic void Freq_Measure(FreqInfo* Fx,TIM_HandleTypeDef *htim){\n    if(Fx->i == 0){\n        Fx->result = 1000000/(Fx->now - Fx->former);\n        __HAL_TIM_ENABLE(htim);\n    }\n}\n\nvoid Freq_Fuc(void){\n    Freq_Measure(&F1,&htim3);\n\tFreq_Measure(&F2,&htim8);\n}\n\t\n//中断\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim){\n\n    if(htim->Instance == TIM3){\n        switch(F1.i){\n            case 0: \n                F1.former = HAL_TIM_ReadCapturedValue(&htim3,TIM_CHANNEL_1) + 65535 * F1.ElapsedTime;\n                F1.i = 1;\n                break;\n            case 1:\n                F1.now = HAL_TIM_ReadCapturedValue(&htim3,TIM_CHANNEL_1) + 65535 * F1.ElapsedTime;\n                __HAL_TIM_DISABLE(&htim3);\n                F1.ElapsedTime = 0;\n                F1.i = 0;\n                break;\n            default:break;\n        }\n    }\n\n    else if(htim->Instance == TIM8){\n        switch(F2.i){\n            case 0:\n                F2.former = HAL_TIM_ReadCapturedValue(&htim8,TIM_CHANNEL_1) + 65535 * F2.ElapsedTime;\n                F2.i = 1;\n                break;\n            case 1:\n                F2.now = HAL_TIM_ReadCapturedValue(&htim8,TIM_CHANNEL_1) + 65535 * F2.ElapsedTime;\n                __HAL_TIM_DISABLE(&htim8);\n                F2.ElapsedTime = 0;\n                F2.i = 0;\n                break;\n            default:break;\n        }\n    }\n}\n\n//在溢出中断中记录溢出次数\n\n```\n\n## 共享变量\n```c\n#include \"SharedData.h\"\n\n//初始化\nstatic Data1 shareddata1 = {0,0};\n\n//获取Data1指针的接口\nData1* get_shared_data(void) {\n    return &shareddata1;\n}\n\n```\n## 按键\n```c\nuint8_t KeyBit(void){\n    uint8_t keybit = 0x00;\n    //读取B1的电平状态并把他左移到bit0位\n    keybit |= HAL_GPIO_ReadPin(B1_GPIO_Port,B1_Pin) << 0;\n    //同上\n    keybit |= HAL_GPIO_ReadPin(B2_GPIO_Port,B2_Pin) << 1;\n    keybit |= HAL_GPIO_ReadPin(B3_GPIO_Port,B3_Pin) << 2;\n    keybit |= HAL_GPIO_ReadPin(B4_GPIO_Port,B4_Pin) << 3;\n    return keybit;\n}\n\nvoid task_Key(void){\n\tstatic uint8_t Trg,Cont;\n    unsigned char ReadData = KeyBit() ^ 0x0f;   \t// 取反：在没有按键按下的情况下，其始终为0x00\n    Trg = ReadData & (ReadData ^ Cont);             // 2\n    Cont = ReadData; \n    if(Trg && Cont){};\n    if(Trg && Cont == 0){};\n}\n```\n\n## LCD\n引脚初始化为全低就行\n\n## LED\nLD口 为 PD2 低电平不允许写入，高电平允许写入。\n```c\n#include \"LED.h\"\n#include \"SharedData.h\"\n\nuint16_t LD_state = 0;  //记录LD各位状态\nuint16_t LD_state_before = 0; \n\nvoid LED_init(void){\n\tHAL_GPIO_WritePin(LD1_GPIO_Port,GPIO_PIN_All,GPIO_PIN_SET);\n\tHAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_SET);\n\tHAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_RESET);\n}\n\nvoid LED_lightLD(uint8_t LDnum){\n\t\t\n\tLD_state |= (LD1_Pin << LDnum); //其他位不变，需要改变的位变为1\n\t\t\n\t\n}\n\nvoid LED_closeLD(uint8_t LDnum){ \n\n\tLD_state &= ~(LD1_Pin << LDnum); //其他位不变，需改变的位变为0\n\t\n}\n\n\nvoid Call_ChangeLD(void(*fc)(uint8_t),uint8_t LDnum){\n\t\n\tLDnum -= 1;\n\tfc(LDnum);\n\tif(LD_state_before != LD_state){\n\t\tHAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(LD1_GPIO_Port,GPIO_PIN_All,GPIO_PIN_SET);\n\t\tHAL_GPIO_WritePin(LD1_GPIO_Port,LD_state,GPIO_PIN_RESET);\n\t\tHAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_RESET);\n\t\tLD_state_before = LD_state;\n\t}\n\telse return;\n\t\n}\n\nvoid LED_Fuc(void){\n\n\tif(Read_Show_index(0)) {\n\t\tCall_ChangeLD(LED_closeLD,1);\n\t\tCall_ChangeLD(LED_lightLD,2);\n\t}\n\telse {\t\n\t\tCall_ChangeLD(LED_closeLD,2);\n\t\tCall_ChangeLD(LED_lightLD,1);\n\t}\n\tif(Read_Show_index(1)){\n\t\tCall_ChangeLD(LED_lightLD,8);\n\t}\n\telse Call_ChangeLD(LED_closeLD,8);\n\t\n}\n```\n\n## 串口重定向与数据处理\n```c\n#define BUFFER_SIZE 50\n#define CMDNUM 6\n\n\nvoid TF1(void);\nvoid TF2(void);\nvoid PF1(void);\nvoid PF2(void);\nvoid returnF1(void);\nvoid returnF2(void);\n\n\nchar rx_DataBuffer[BUFFER_SIZE] = {0};\nchar tx_DataBuffer[BUFFER_SIZE] = {0};\nchar cmd[BUFFER_SIZE] = {0};\n\nuint16_t tx_len = 0;  // 当前缓冲区数据长度\nuint8_t tx_busy = 0;  // 发送状态标志\n\nuint8_t rx_handle = 0; //处理接收数据标志\nuint8_t rx_len = 0;\n\ntypedef struct{\n    uint8_t* cmd_str;\n    void (*fc)();\n}cmdinfo;\n\n\ncmdinfo cmdlist[] = {\n    {\"TF1\",TF1},\n    {\"TF2\",TF2},\n    {\"PF1\",PF1},\n    {\"PF2\",PF2},\n    {\"F1\",returnF1},\n    {\"F2\",returnF2}\n};\n\nvoid TheUART_start(void){\n    HAL_UARTEx_ReceiveToIdle_DMA(&huart1,(uint8_t*)rx_DataBuffer,0x0f);\n}\n\nvoid TheUART_dma_transmit(void)\n{\n    // 如果 DMA 还在忙，则不启动新的传输\n    if (tx_busy) return;\n\n    tx_busy = 1;  // 标记为发送中\n    HAL_UART_Transmit_DMA(&huart1,(uint8_t*)tx_DataBuffer,tx_len-1);//-1为了防止傻逼烂桥杯的验证程序不通过\n}\n\n\nint fputc(int ch, FILE *f)\n{\n    // 确保缓冲区不会溢出\n    if (tx_len < BUFFER_SIZE - 1)\n    {\n        tx_DataBuffer[tx_len++] = (uint8_t)ch;\n    }\n\n    // 如果遇到换行符，或者缓冲区接近满，就启动 DMA 发送\n    // 注意咯，如果缓冲区没满的情况下，只有检测到/n才会触发DMA的发送。所以在缓\n    // 冲区没满的情况下，如果你想要发送字符串\"abc\"，printf(\"abc\")是没用的，\n    // printf(\"abc\\n\")才有用哦。\n\n    \n    if (ch == '\\n' || tx_len >= BUFFER_SIZE - 1)\n    {\n        TheUART_dma_transmit();\n    }\n\n    return ch;\n}\n\n\nvoid TheUART_HandleRxdata(void){\n\n    if(rx_handle == 1){\n\n        uint8_t i = 0;\n        strcpy(cmd,rx_DataBuffer);\n        cmd[rx_len] = '\\0';\n        if(!Read_Show_index(1)){\n            other();\n            rx_len = 0;\n            rx_handle = 0;\n            TheUART_start();\n            return;\n        }\n        for(i = 0;i < CMDNUM;i++){\n            if(strcmp((const char*)cmd,(const char*)cmdlist[i].cmd_str) == 0){\n                cmdlist[i].fc();\n                rx_len = 0;\n                rx_handle = 0;\n                TheUART_start();\n                return;\n            }\n        }\n        other();\n        rx_len = 0;\n        rx_handle = 0;\n        TheUART_start();\n    }\n    else return;\n}\n\n//命令函数\nvoid TF1(void){\n\n}\n\nvoid TF2(void){\n\n}\n\nvoid PF1(void){\n\n}\n\nvoid PF2(void){\n\n}\n\nvoid returnF1(void){\n\n}\n\nvoid returnF2(void){\n\n}\n\nvoid other(void){\n}\n\n//中断\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)\n{\n    if(huart->Instance == USART1)  // 确保是目标串口\n    {\n        tx_len = 0;  // 清空缓冲区\n        tx_busy = 0; // 标记为可用\n    }\n}\n\nvoid HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size){\n\n    if(huart->Instance == USART1){\n        rx_len = Size;\n        rx_handle = 1;\n    }\n\n}\n```\n\n## ADC：使用定时器TRGO信号触发ADC转换\n```c\ndouble ADC_Data = .0;\n\nvoid ADCFuc_Init(ADC_HandleTypeDef *hadc){\n    HAL_ADCEx_Calibration_Start(hadc,ADC_SINGLE_ENDED);//校准\n    HAL_ADC_Start_IT(hadc);\n}\n\n\nchar ADCFuc_ReturnResult(void){\n    double result = ADC_Data;\n    result = (result / 4095.0) * 3.3;\n}\n\n\n//中断-------------------------------------------------------------//\nvoid HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc){\n\n    if(hadc->Instance == ADC2){\n        ADC_Data = HAL_ADC_GetValue(&hadc2);\n    }\n}\n```\n\n## at24c02\n```c\ninclude \"i2c_hal.h\"\n\n#define COMMAND_W   0xA0\n#define COMMAND_R   0xA1\n\nvoid at24c02_Init(void){\n    I2CInit();\n}\n\n/// @brief at24c02写数据\n/// @param address 要写入的地址\n/// @param data 要写入的数据\nvoid at24c02_Write(uint8_t address,uint8_t data){\n    \n    I2CStart();\n\n    I2CSendByte(COMMAND_W);\n    I2CWaitAck();\n\n    I2CSendByte(address);\n    I2CWaitAck();\n\n    I2CSendByte(data);\n    I2CWaitAck(); \n\n    I2CStop();\n}\n\n/// @brief at24c02读数据\n/// @param address 要读数据的地址\n/// @return 读出的数据\nuint8_t at24c02_Read(uint8_t address){\n    uint8_t data = 0;\n    I2CStart();\n\n    I2CSendByte(COMMAND_W);\n    I2CWaitAck();\n\n    I2CSendByte(address);\n    I2CWaitAck();\n\n    I2CStart();//不释放总线的情况下重启通信，发送读命令。\n\n    I2CSendByte(COMMAND_R);\n    I2CWaitAck();\n\n    data = I2CReceiveByte();\n    I2CSendNotAck();//通知从机不再发送数据\n\n    I2CStop();\n\n    return data;\n}   \n\n```\n\n## 韩信在干嘛？韩信在偷塔！能做到吗？哇他出了一个名刀·司命！猫雷！\n挂一张梦老师保佑！\n![](https://tiebapic.baidu.com/forum/w%3D580%3B/sign=770517cb7fdbb6fd255be52e391faa18/8326cffc1e178a829fdedc90b003738da977e824.jpg?tbpicau=2025-04-12-05_1fd40d1758be922db3d2562ec3e230c3)","tags":["蓝桥杯"],"categories":["嵌入式","程序架构"]},{"title":"hexo主题Klise-enhanced使用文档","url":"/posts/20333/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n## 说明\n\n本主题是根据dewjonh的hexo主题[Klise](https://github.com/dewjohn/hexo-theme-Klise)改的，我非常喜欢这款主题，但是由于此主题原作者好像不再维护，对hexo的现版本（2024）的适配不太好，于是便自己修修补补用着🙂但是由于我没有太多的精力分配在前端上，所以有些代码可能有些不专业，希望各位大佬见谅并指正。当然如果有任何bug请尽管issue，我会尽力修复！\n\n## 主题概览\n\n![](Snipaste_2025-04-06_15-26-39.png)\n\n![](Snipaste_2025-04-06_15-27-19.png)\n\n![](Snipaste_2025-04-06_15-27-54.png)\n\n你可以查看[demo](https://im.godmao.top/)或[我的博客](https://im.godmao.top/)来阅览主题效果。\n\n## 相较于原版有何改动\n\n- 😢把scss全编译为css了，只有一个main.css文件，包含了所有的渲染样式....不过不用担心我注释了嘻嘻🤓\n- 将原主题的深色模式进一步适配，并修改了一些元素的显示风格。\n## 使用方法\n\n### 首先，\n你需要下载一个字数统计插件:\n```bash\nnpm install hexo-wordcount --save\n```\n\n如果不想要下载或无法下载成功，你也可以放弃字数统计功能。前往主题文件夹下的`layout\\post.ejs`删除\n```ejs\n字数: <span class=\"post-count\"><%= wordcount(page.content) %></span>\n\n预计阅读时间: <span class=\"post-count\"><%= min2read(page.content) %>min</span>\n```\n两行。\n\n### 然后，\n安装主题文件\n```bash\ngit clone https://github.com/g0dmao/hexo-theme-Klise-enhanced.git\n```\n\n将主题根目录的`_config.hexo-theme-Klise-enhanced.yml`移动到博客根目录。你可以打开该文件进行主题的一些配置。\n\n在博客配置文件`_config.yml`中启用主题。\n\n### 最后，\nenjoy！\n\n## 个性化部分\n\n### 自定义背景\n打开主题文件夹下的`source\\css\\main.css`在头部修改，可以自定义明暗模式下不同的背景，已做好注释。\n\n### 当网页失去焦点时标签页标题的显示文字\n打开主题文件夹下的`layout\\layout.ejs` 修改document.title即可。\n```html\n<script defer>\n\n  document.addEventListener('visibilitychange', function () {\n\n  if (document.visibilityState == 'hidden') {\n\n      normal_title = document.title;\n\n      document.title = '点一下';\n\n  } else document.title = normal_title;\n\n});\n\n</script>\n```\n### 可选\n你可以安装如下插件获得更好的浏览体验。\n#### hexo-renderer-markdown-it-plus\n不使用自带的md渲染器。使用markdown-it渲染器，丰富的插件提供更好的md浏览体验。\n\n####  hexo-tips\n在文章中生成各种提示卡片，此主题已做好适配。\n\n#### hexo-blog-encrypt\n文章加密插件。\n\n## 可能的问题\n\n### tags、categories页面显示不正确\n首先检查页面的路径设置是否正确。若正确则试着在相应页面的`index.md` 里添加type和layout标签：\n![](Snipaste_2025-04-06_16-18-33.png)\ntags页面 type、layout 为tags。\ncategories页面 type、layout 为 categories。","tags":["网页","hexo主题"],"categories":["web前端"]},{"title":"从c底层到嵌入式驱动开发的学习参考路线","url":"/posts/25619/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n以下是专为 **嵌入式Linux驱动开发工程师** 设计的 **学习路线**，整合了目标、重点、时间分配、书籍推荐和实战建议，力求清晰高效。由`deepseekR1`生成。\n\n---\n\n### **一、学习路线总图**\n```mermaid\ngraph LR\n  A[C语言+硬件] --> B[操作系统+驱动基础] --> C[驱动专项+内核机制] --> D[实战深化]\n```\n\n---\n\n### **二、分阶段详解**\n#### **阶段1：C语言与硬件交互（1-2个月）**\n**目标**：  \n- 掌握C语言底层操作能力，理解程序如何直接控制硬件。  \n\n**核心内容**：\n\n| **知识点**         | **必要程度** | **深入程度**       | **推荐书籍/资源**             |\n|--------------------|--------------|--------------------|------------------------------|\n| 指针与内存管理     | ★★★★★        | 理解内存布局       | 《C程序设计语言》（K&R）      |\n| 结构体与位操作     | ★★★★☆        | 能操作寄存器       | 《嵌入式C语言自我修养》        |\n| 汇编基础           | ★★★☆☆        | 阅读简单汇编       | 《ARM Cortex-M权威指南》       |\n| 编译流程（GCC）    | ★★★★☆        | 熟悉预处理-链接    | CSAPP第3章                    |\n| 硬件交互（GPIO）   | ★★★★☆        | 裸机程序开发       | STM32官方手册                 |\n\n**实践项目**：  \n1. 用STM32直接操作寄存器点亮LED（无需库函数）。  \n2. 用C实现内存池分配器（模拟`malloc/free`）。  \n\n**工具**：  \n- **STM32CubeIDE**：调试裸机程序。  \n- **objdump**：反汇编查看代码生成。  \n\n**对Linux的用处**：  \n- 理解驱动中 **寄存器映射**（如`ioremap`）。  \n- 诊断 **内存越界** 和 **硬件访问错误**。  \n\n---\n\n#### **阶段2：操作系统核心+驱动基础（2-3个月）**\n**目标**：  \n- 理解操作系统核心机制，入门Linux驱动开发。  \n\n**核心内容**：  \n\n| **知识点**         | **必要程度** | **深入程度**       | **推荐书籍/资源**             |\n|--------------------|--------------|--------------------|------------------------------|\n| 进程与线程         | ★★★☆☆        | 理解上下文切换     | 《操作系统导论》（OSTEP）     |\n| 虚拟内存           | ★★★★☆        | 页表工作原理       | 《深入理解计算机系统》第9章   |\n| 中断与异常         | ★★★★☆        | 中断处理流程       | 《Linux设备驱动程序》（LDD3） |\n| 内核模块开发       | ★★★★★        | 字符设备驱动       | LDD3第3章                    |\n| 设备树（DT）       | ★★★★☆        | 解析硬件配置       | 内核文档《Device Tree Usage》 |\n\n**实践项目**：  \n1. 编写虚拟字符设备驱动（实现`read`/`write`）。  \n2. 为LED驱动添加设备树支持（`.dts`文件配置）。  \n\n**工具**：  \n- **QEMU**：模拟ARM设备运行Linux。  \n- **dmesg**：查看内核日志。  \n\n**对Linux的用处**：  \n- 掌握驱动开发框架（`file_operations`）。  \n- 理解 **设备树** 如何解耦硬件配置。  \n\n---\n\n#### **阶段3：驱动专项+内核机制（3-6个月）**\n**目标**：  \n- 精通主流驱动开发技术，深入内核核心机制。  \n\n**核心内容**：  \n\n| **知识点**         | **必要程度** | **深入程度**       | **推荐书籍/资源**             |\n|--------------------|--------------|--------------------|------------------------------|\n| GPIO/I2C/SPI驱动   | ★★★★★        | 完整驱动开发       | 《精通Linux设备驱动程序开发》 |\n| 中断处理           | ★★★★★        | 顶半部/底半部      | 内核源码`drivers/irqchip`     |\n| 内核同步机制       | ★★★★☆        | 自旋锁/RCU         | 《Linux内核设计与实现》第5章  |\n| DMA与内存管理      | ★★★☆☆        | 缓存一致性         | 内核文档《DMA-API-HOWTO》     |\n| 电源管理           | ★★★☆☆        | suspend/resume     | 内核文档《Power Management》  |\n\n**实践项目**：  \n1. 为树莓派开发I2C传感器驱动（如BMP280）。  \n2. 实现带中断的按键驱动（`request_irq`）。  \n\n**工具**：  \n- **逻辑分析仪**：抓取SPI/I2C时序。  \n- **perf**：分析驱动性能瓶颈。  \n\n**对Linux的用处**：  \n- 掌握真实硬件驱动开发流程。  \n- 理解内核 **并发控制** 和 **中断优化**。  \n\n---\n\n#### **阶段4：实战深化（持续学习）**\n**目标**：  \n- 参与真实项目，解决复杂问题。  \n\n**核心内容**：  \n\n| **知识点**         | **必要程度** | **深入程度**       | **推荐资源**                 |\n|--------------------|--------------|--------------------|------------------------------|\n| 内核子系统         | ★★★★☆        | 输入/IIO子系统     | 内核源码`drivers/input`       |\n| 调试与调优         | ★★★★☆        | ftrace/kgdb        | 内核文档《ftrace使用指南》    |\n| 社区贡献           | ★★★☆☆        | 提交内核补丁       | LKML（Linux内核邮件列表）     |\n\n**实践项目**：  \n1. 为开源驱动修复Bug（如内核Bugzilla中的简单问题）。  \n2. 优化驱动性能（减少中断延迟或内存占用）。  \n\n**工具**：  \n- **git**：管理内核代码修改。  \n- **checkpatch.pl**：检查代码规范。  \n\n**对Linux的用处**：  \n- 积累真实项目经验，提升工程能力。  \n- 理解Linux内核社区的协作方式。  \n\n---\n\n### **三、时间分配建议**\n| **阶段**               | **建议时长** | **核心目标**                     | **时间占比** |\n|------------------------|--------------|----------------------------------|--------------|\n| C语言与硬件交互        | 1-2个月      | 裸机操作寄存器                   | 15%          |\n| 操作系统+驱动基础      | 2-3个月      | 字符设备驱动+设备树              | 30%          |\n| 驱动专项+内核机制      | 3-6个月      | GPIO/I2C/中断驱动开发            | 40%          |\n| 实战深化               | 持续         | 项目经验+社区贡献                | 15%          |\n\n---\n\n### **四、驱动开发工程师核心能力**\n1. **硬件能力**：  \n   - 阅读芯片手册（如时钟配置、寄存器定义）。  \n   - 使用示波器调试I2C/SPI通信问题。  \n\n2. **内核能力**：  \n   - 编写符合内核编码规范（`checkpatch.pl`）的代码。  \n   - 理解设备模型（总线/设备/驱动）。  \n\n3. **调试能力**：  \n   - 分析内核Oops和Panic日志。  \n   - 使用`trace-cmd`跟踪函数调用链。  \n\n---\n\n### **五、学习建议与避坑**\n1. **必做**：  \n   - 每天阅读内核驱动源码（如`drivers/gpio`）。  \n   - 用真实硬件（树莓派/BeagleBone）替代仿真。  \n\n2. **避免**：  \n   - 沉迷自制操作系统内核（除非目标为内核研发）。  \n   - 过早研究编译器后端优化（如LLVM Pass）。  \n\n3. **捷径**：  \n   - 直接参考内核中类似驱动的实现（如`drivers/i2c/busses/i2c-bcm2835.c`）。  \n   - 参与开源社区（从文档改进开始）。  \n\n---\n\n### **六、驱动开发面试常见问题**\n- **基础问题**：  \n  - 解释`platform_driver`和`platform_device`的作用。  \n  - 自旋锁为什么不能在睡眠场景使用？  \n\n- **实战问题**：  \n  - 如何为一个新硬件编写设备树节点？  \n  - 驱动中出现`Unable to handle kernel paging request`如何调试？  \n\n---\n\n按此路线，**12-18个月** 可达到嵌入式Linux驱动工程师的入职要求。**记住：驱动开发的本质是“用软件精确描述硬件行为”**，保持对硬件的敏感度是关键！","tags":["嵌入式","学习路线"],"categories":["嵌入式"]},{"title":"Kelly McGonigal, Ph.D.《自控力》第四章阅读感悟","url":"/posts/57146/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。摘录自微信读书。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n# 04 容忍罪恶：为何善行之后会有恶行？\n\n## 警惕“放纵许可”\n\n>  不是每一次自控力失效都是因为真的失去了控制。有时，我们是有意识地选择了在诱惑面前屈服。\n\n>  我们要思考一下，这整个过程如何削弱了我们的动力，乐观精神如何允许我们放纵自己，为什么觉得自己品德高尚反而是通往罪恶的快速通道。每一次我们都会发现，放弃抵抗是一种选择，而且并非不可避免。了解我们是如何给自己许可的，能让我们学会如何不离正轨。\n\n>  当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。\n\n>  当你做善事的时候，你会感觉良好。这就意味着，你更可能相信自己的冲动。而冲动常常会允许你做坏事。\n\n>  他们只是被自己之前良好的行为所蒙蔽，没看到这些决定会带来的伤害而已。\n\n>  如果你去锻炼了就说自己很“好”，没去锻炼就说自己很“坏”，那么你很可能因为今天去锻炼了，明天就不去了。\n\n>  简单说来，只要我们的思想中存在正反两方，好的行为就总是允许我们做一点坏事。\n\n>  他们这样为自己辩解：“我已经这么好了，应该得到一点奖励。”这种对补偿的渴望常常使我们堕落。因为我们很容易认为，纵容自己就是对美德最好的奖励。我们忘记了自己真正的目标，向诱惑屈服了。\n\n>  如果按照这个荒谬的逻辑，我们可以把所有的自我放纵都变成引以为傲的事。（信用卡账单会让你产生负罪感吗？怎么会呢，起码你没有因为要付账单而去抢银行！）\n\n>  我们通常相信本能，只有当需要解释自己的判断时，我们才寻求逻辑。\n\n>  因为过去的善行而感觉良好，这让你为今后的纵容找到了借口。当你觉得自己像个圣人的时候，纵容自己的念头听起来没什么错。它听起来很正确，就像是你应得的一样。如果你自控的唯一动力就是成为一个足够好的人，那么每当你自我感觉良好的时候，你就会放弃自控。\n\n>  它让我们相信，放弃节食、打破预算、多抽根烟这些不良行为都是对自己的“款待”。这很疯狂，但对大脑来说，它有可怕的诱惑力，能让你把“想做的事”变成“必须做的事”。\n\n>  我们用大吃甜食、熬夜晚睡、信用卡负债来判断自己是善还是恶。但是，这些事无法真正体现什么是罪恶，什么是美德。当我们从道德的角度思考自己面对的意志力挑战时，我们就失去了自我判断能力，看不到这些挑战有助于我们得到自己想要的东西\n\n>  进步可能让我们放弃曾经为之奋斗的东西。\n\n>  当你取得进步的时候，你的大脑就停止了思维进程，而这个进程正是推动你追求长远目标的关键。然后，那个放纵自我的声音就会响起来，你就会转而关注那些还没有得到满足的目标。心理学家称之为“目标释放”。你曾努力克制的目标会变得更加强大，诱惑也会变得更加难以抵挡。\n\n>  但关注进步确实会让我们离成功越来越远。\n\n>  在大多数情况下，我们总在寻找停下来的理由。\n\n>  你不应该想着“我做到了，好了，现在我可以做点我真正想做的事了！”应该想着“我做这件事是因为我想要……”\n\n>  记住我们为什么会拒绝诱惑，这是个很有效的办法。\n\n>  所谓的奖励看起来更像对目标的威胁，屈服于诱惑的感觉并不好。记住理由还有助于你发现并抓住机遇，以便完成目标。\n\n>  下一回，当你发现自己在用曾经的善行给现在的放纵作辩护时，停下来想一想，你当时为什么能拒绝诱惑。\n\n## 明日复明日、拖延\n\n>  这很好地解释了，我们想到未来的选择时，就会很容易犯下大错。我们不断期望明天能作出和今天不同的选择，但这种期望是错误的\n\n>  这种乐观精神让我们能在今天放纵自己——尤其是当你确信自己下次不会作出同样选择的时候。\n\n>  如果我们现在表现糟糕，却用对未来的乐观期待来掩饰它，那么还不如一开始就不要设定这个目标。\n\n>  帮助人们克服这种“明日复明日”的想法。当你想改变某种行为的时候，试着减少行为的变化性，而不是减少那种行为。\n\n>  我们都希望说服自己，我们想要的东西并没有那么坏。正如你将要看到的，我们迫切想给诱惑我们的对象加以道德标准，好让我们在放纵自己的时候毫无负罪感。\n\n## 警惕“光环效应”\n\n>  当我们想获得放纵许可的时候，我们会寻找任何一个美德的暗示，为自己放弃抵抗作辩护。\n\n>  只要使你放纵的东西和使你觉得品德高尚的东西同时出现，就会产生光环效应。\n\n>  你会不会因为关注一个事物最有益的品质，而允许自己沉溺于它？\n\n>  当“光环效应”影响到你的意志力挑战时，你需要找到最具体的测量标准（比如卡路里、花费、消耗或浪费的时间），以此判断这个选择是否和你的目标相符。\n\n>  只要某些事让我们觉得自己尽力了，不用再担心那些问题了，我们就会蜂拥而上。而一旦我们的罪恶感和焦虑消失了，我们就会觉得可以重新开始一贯浪费的生活方式了。\n\n>  从本质上看，道德许可就是一种身份危机。我们之所以会奖励自己的良好行为，是因为我们内心深处认为，真正的自己想做坏事。从这点来看，每次自控都是一种惩罚，只有放纵自我才是奖励。但我们为什么一定要这样看待自己呢？想要走出“道德许可”的陷阱，我们就要知道，那个想变好的自己才是真正的自己，想按核心价值观生活的自己。如此一来，我们就不会认为那个冲动、懒散、容易受诱惑的自己是“真正”的自己了。\n\n>  如果只按照“正确”和“错误”来判断做过的事，而不是牢记我们真正想要的东西，就会带来与目标相抵触的冲动，并允许我们做出妨碍自己的行为。想要做到始终如一，我们就需要认同目标本身，而不是我们做善事时的光环。\n\n## 思考\n\n这一章对我来说帮助很大，我就一直陷入了完成目标->放纵这样的怪圈。实际上，对所做的事加以道德标准，也就是用”好“与”坏“衡量一件事其实是一个思维陷阱。如果这样做，你就会为自己的放纵找到理由——我都做了这么多”好“事了，偶尔做做”坏“事也不要紧。我们很容易认为，纵容自己就是对美德最好的奖励。我们忘记了自己真正的目标，向诱惑屈服了。本章还提到了两个有意思的观点：”进步可能让我们放弃曾经为之奋斗的东西“、”道德高尚之人更可能走上犯罪道路“，这两个观点也可以用”道德许可“加以解释。所以我们不应该为自己做过的”好“事而蒙蔽双眼，那只是一件事，而无任何属性!!别引申到坏事!!。\n\n而”光环效应“则是对”道德许可“的延申，它指出如果使你放纵的东西和使你觉得品德高尚的东西同时出现，这会更让你放纵得无负罪感，你会不会因为关注一个事物最有益的品质，而允许自己沉溺于它？比如，你的目标是学习一下午，而你却捣鼓了一天你的博客，你会说”好吧其实捣鼓博客也学习到了很多东西“，而你真正得目标却被忽视。\n\n关于拖延问题，我们总是会高估明天的自己。认为明天的自己是完美的，我们想到未来的选择时，就会很容易犯下大错。我们不断期望明天能作出和今天不同的选择，但这种期望是错误的。如果你今天表现”糟糕“，那么明天大概率也是一样的。如何克服这种问题呢？当你想改变某种行为的时候，试着减少行为的变化性，而不是减少那种行为。比如你抽烟，今天抽一包，那你明天也抽一包，后天也抽一包，这样每支烟就不仅仅代表着今天的这一支，你还会联想到：我的天哪，我今天抽完明天还要抽这么多，这太可怕了。然后你就有意识的减少吸烟频率。但是我感觉这种方法对我来说没什么用。只作记录\n\n凯利博士告诉我们如何真正地看待问题。如果只按照“正确”和“错误”来判断做过的事，而不是牢记我们真正想要的东西，就会带来与目标相抵触的冲动，并允许我们做出妨碍自己的行为。**想要做到始终如一，我们就需要认同目标本身，而不是我们做善事时的光环。**\n\n**我们之所以会奖励自己的良好行为，是因为我们内心深处认为，真正的自己想做坏事。从这点来看，每次自控都是一种惩罚，只有放纵自我才是奖励。但我们为什么一定要这样看待自己呢？** 想要走出“道德许可”的陷阱，我们就要知道，那个想变好的自己才是真正的自己，想按核心价值观生活的自己。如此一来，我们就不会认为那个冲动、懒散、容易受诱惑的自己是“真正”的自己了。\n","tags":["阅读感悟","自控力"],"categories":["阅读"]},{"title":"三行代码实现按键的长短按检测","url":"/posts/862/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 话不多说直接上代码\n\n```c\nuchar cont,trg;    //triger触发 continue连续\nvoid KeyScan()\n{\n\tuchar ReadData =  PINB^0xff;\n\ttrg = ReadData & (ReadData^cont);\n\tcont = ReadData;\n}\n```\n\n就完事了，灰常的amzing啊。\n\n## 尝试理解\n\n首先我们要理解`PINB`，这里的`PINB`指的是我们的单片机GPIOB的所有Pin的端口数据，而每个端口的数据（高/低——1/0）对应1个bit位。例如某单片机有八个端口只有端口0为高，其余皆为低，则PINB=0000 0001。在STM32Hal库中，我们可以这样实现：\n```c\nuint8_t KeyBit(void){\n    uint8_t keybit = 0x00;\n    //读取B1的电平状态并把他左移到bit0位\n    keybit |= HAL_GPIO_ReadPin(B1_GPIO_Port,B1_Pin) << 0;\n    //同上\n    keybit |= HAL_GPIO_ReadPin(B2_GPIO_Port,B2_Pin) << 1;\n    keybit |= HAL_GPIO_ReadPin(B3_GPIO_Port,B3_Pin) << 2;\n    keybit |= HAL_GPIO_ReadPin(B4_GPIO_Port,B4_Pin) << 3;\n    return keybit; \n\n}\n```\n\n### 取反\n\n第一行代码就相当于是取反操作，使没有按键按下时data始终为0x00。\n\n注意，不一定就是异或0xff，按照上面的hal库方法，你的PINB变量实际上只有四位有效位，为了让没有按键按下时data为0x00，我们异或0x0f即可，或者将keybit初始化为0xf0然后异或0xff；而有时GPIO输入接了下拉，没有输入的情况本来就是0，这时就不需要再取反。反正就是要让它没有按键按下时等于0x00。\n\n<details>\n\n<summary>点击即看异或真值表</summary>\n\n与0异或不变，与1异或取反\n\n| A   | B   | A ⊕ B |\n| --- | --- | ----- |\n| 0   | 0   | 0     |\n| 0   | 1   | 1     |\n| 1   | 0   | 1     |\n| 1   | 1   | 0     |\n\n</details>\n\n### 单击按下\n\n第一次PB0按下的情况  \n端口数据原本为0xfe，ReadData读端口并且取反，变为 0x01 （第一行）。\n因为这是第一次按下，所以Cont是上次的值，应为为0。与0异或不改变原有值，那么第二行执行的实际是：\n```\nTrg = 0x01 & (0x01^0x00) = 0x01  \n``` \n\n将cont赋值\n\n```\nCont = ReadData = 0x01\n```\n结果就是：\n- ReadData ＝ 0x01\n- Trg ＝ 0x01\n- Cont ＝ 0x01\n\n### 按下后还没有完全松开（引申到长按）\n\n此时程序依然在执行。\n- 第一行：不变，依然为0x01。\n- 第二行：操作为——把检测到的按下按钮对应的bit为给置0了，让Trg等于0了\n- 第三行：不变，依然为0x01。\n\n我们可以看到唯一变了的地方就是Trg被置0了。\n\n### 完全松开\n很好理解，肯定全为0x00了。\n\n### 笔者的思考\n\n该代码的核心思路我认为是用三种不同的数据内容代表不同的三种情况（未按下、单按、长按）按照这种思路，我们甚至还可以扩展。\n\n`ReadData`存储原始的端口电平数据，不能改变。后续的两个数据都会基于这个原始数据。\n`Trg` 用于按键触发。`ReadData`中有bit位有上升沿时，Trg会记录这个上升沿：只有bit从0变为1，Trg才会置1。按下判断的条件是：`Trg`、`Cont`均为1。\n`Cont` 用于长按。长按的判断条件是：`Trg`为0的情况下`Cont`依然为1。\n\n这样的思路让我联想到了3-8译码器的巧妙设计，通过3个值的输入，可以得到8个值的输出，用3个值就可以为8个不同的情况进行处理。\n\n## 在STM32中使用\n\n附上我的使用方法，我使用的是[时间片轮询架构](http://im.godmao.top/posts/39448/)。\n\n```c\n\n#define B1 0x01\n\n#define B2 0x02\n\n#define B3 0x04\n\n#define B4 0x08\n\nuint8_t KeyBit(void){\n\n    uint8_t keybit = 0x00;\n\n    //读取B1的电平状态并把他左移到bit0位\n    keybit |= HAL_GPIO_ReadPin(B1_GPIO_Port,B1_Pin) << 0;\n    //同上\n    keybit |= HAL_GPIO_ReadPin(B2_GPIO_Port,B2_Pin) << 1;\n    keybit |= HAL_GPIO_ReadPin(B3_GPIO_Port,B3_Pin) << 2;\n    keybit |= HAL_GPIO_ReadPin(B4_GPIO_Port,B4_Pin) << 3;\n\n    return keybit;\n\n}\n\nvoid KeyFuc(void){//按键逻辑\n\n    static uint8_t i = 0;                           //长按时间计数器\n\n    //核心代码：三行代码完成按键单、长按检测\n\n    unsigned char ReadData = KeyBit() ^ 0x0f;       // 取反：在没有按键按下的情况下，其始终为0x00\n\n    Trg = ReadData & (ReadData ^ Cont);             // 2\n\n    Cont = ReadData;                                // 3                        \n\n    if(Trg && Cont){//单击逻辑      \n\n        switch(Trg){                            \n\n            case B4: Key4_Fuc();break;\n\n            case B3: Key3_Fuc();break;          \n\n            case B2: Key2_Fuc();break;          \n\n            case B1: Key1_Fuc();break;  \n\n            default: break;\n\n        }\n\n    }\n\n    if(Cont && 0 == Trg) i++;//以下为长按逻辑\n    else i = 0;\n    \n    if(i >= 20){\n        i = 0;\n\n        switch(Cont)\n        {\n\n            case B3: Key3_Fuc_Preesed();break;\n\n            default: break;\n\n        }\n\n    }\n\n  \n\n}\n\n```\n\n## 关于消抖问题\n\n~~不知道为什么，按理来说是需要消抖的，但是实际跑起来的时候没有消抖也非常稳，，，可能是我的按键检测任务执行间隔比较长？~~\n\n--- \n\n2025.03.28 补充修改：如果使用时间片轮询调度，理论上如果按键扫描任务执行间隔时间较长，是不用消抖的。这就解释了为什么我的程序没有消抖也那么稳！例如，假设你设置的时间片调度间隔是 100ms，如果按键每次扫描时是 100ms 执行一次，假设按键抖动的周期是 10ms，那么每次扫描时按键就已经稳定了。这样，按键的物理状态变化就不太可能被误判为多个状态变化，因为时间间隔本身已经足够长。当然代价是 **会牺牲按键响应速度，以及无法应用快速连按的按键逻辑**\n\n--- \n\n关于消抖我还没有实际上机跑过，但是也写一下，Deepseek写的：\n\n```c\n#define DEBOUNCE_TIME 1 //消抖时间参数，根据时间片的时间来设定\n\ntypedef enum {\n    KEY_STATE_IDLE,//空闲\n    KEY_STATE_PRESSED,//按下\n    KEY_STATE_RELEASED//松开\n} KeyState;\n\nKeyState key_state = KEY_STATE_IDLE;\n\nuint16_t debounce_timer = 0;\n\nvoid KeyScan() {\n    uchar ReadData = PINB ^ 0xff;\n    uchar new_trg = ReadData & (ReadData ^ cont);\n\n    switch (key_state) {\n        case KEY_STATE_IDLE:\n            if (new_trg != 0) { // 检测到按键变化\n                key_state = KEY_STATE_PRESSED;\n                debounce_timer = DEBOUNCE_TIME;\n            }\n            break;\n\n        case KEY_STATE_PRESSED:\n            if (debounce_timer > 0) {\n                debounce_timer --;\n            } else {\n                if (ReadData == (PINB ^ 0xff)) { // 确认按键状态\n                    trg = new_trg;\n                    cont = ReadData;\n\t\t    if(trg && cont){\n\t\t\t/*写单击逻辑*/\n\t\t    }\n                    key_state = KEY_STATE_RELEASED;\n                } else {\n                    key_state = KEY_STATE_IDLE;\n                }\n            }\n            break;\n\n        case KEY_STATE_RELEASED:\n            if (new_trg == 0) { // 等待按键释放\n                key_state = KEY_STATE_IDLE;\n            }\n            break;\n    }\n}\n```\n\n","tags":["程序架构","按键检测"],"categories":["嵌入式","程序架构"]},{"title":"嵌入式模块化设计中的数据共享优化方案","url":"/posts/58440/","content":"\n<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 问题的提出\n\n在嵌入式项目中，模块化每个功能有利于管理和理清开发思路，但是，当我们需要将模块联动起来的时候，需要一些必要的变量以实现两个模块之间的互相配合，最常见的方法是使用全局变量，但这样做使模块间耦合性[^1]大大提高了。\n\n## 有什么更好的方案吗\n\n有的兄弟有的。只不过要牺牲一些效率（需要通过接口访问）。我们可以为共享变量建立一个专门的.c/.h文件，例如`SharedData.c/.h`。\n这个文件集中管理模块间的共享变量。这样做结构清晰，每个模块**只依赖 `SharedData.h`，而不是彼此依赖**\\ \n同时我们通过两种方法使需要访问变量的模块成功读取或修改变量：\n- 结构体封装+指针传递\n- 通过函数提供读取和修改的接口\n\n## 结构体封装+指针传递\n\n:::recommend\n\n- 共享变量较多时非常好用。\n- **隐藏全局变量**，外部模块无法直接访问共享数据而是通过指针，安全性高。\n- 更好扩展。\n- 方便，无需为每个变量都写函数接口以提供修改与读取。\n- **访问速度快**。\n\n:::\n\n### .h文件\n```c\n#ifndef SHARED_DATA_H\n#define SHARED_DATA_H\n\ntypedef struct {\n    int sensor_value;\n    int motor_speed;\n} SharedData;\n\n// 只提供获取指针的接口，而不是直接暴露变量\nSharedData* get_shared_data(void);\n\n#endif\n```\n\n### .c文件\n\n```c\n#include \"shared_data.h\"\n\nstatic SharedData system_data = {0, 0}; // 只在本文件可见\n\nSharedData* get_shared_data() {\n    return &system_data;\n}\n```\n\n### 在其他模块中使用\n\n```c\n#include \"shared_data.h\"\n\nvoid moduleA_update() {\n    SharedData *data = get_shared_data();\n    data->sensor_value += 10;\n}\n```\n\n:::warning\n\n不推荐将**接收共享变量的指针的变量**定义为全局变量。尽管这样会方便一些。**指针可能被多个模块修改**，导致指向无效地址（增加 bug 风险）。推荐在每个函数内部通过接口访问变量。如果一定要这样做，请一定避免空指针（记住初始化指针）\n\n:::\n\n使用全局指针示例：\n```c\nstatic SharedData *data;  // 仅限当前文件访问\n\nvoid moduleA_init() {\n    data = get_shared_data();//避免空指针\n}\n```\n\n## 通过函数提供读取和修改的接口\n\n:::recommend\n\n- **灵活访问变量。你可以严格控制对数据的访问，如只读、避免非法值写入等；同时也可以自定义访问方法，如按位读取。非常的好用。**\n- 可扩展性强。\n\n:::\n\n:::error\n\n- 代码冗长，调用花销稍大。\n- 变量太多时需要为每个变量都写接口，太麻烦。所以才要和上面的方法联合起来使用，只为必要的变量编写接口，其余通过第一种方法访问。\n\n:::\n\n### .h文件\n\n```c\n#ifndef SHARED_DATA_H\n#define SHARED_DATA_H\n\nvoid setSensorValue(int value);\nint getSensorValue();\n\nvoid setMotorSpeed(int speed);\nint getMotorSpeed();\n\n#endif\n\n```\n\n### .c文件\n\n```c\n#include \"shared_data.h\"\n\nstatic int sensor_value = 0;\nstatic int motor_speed = 0;\n\nvoid setSensorValue(int value) {\n    if (value >= 0) {  // 限制非法值\n        sensor_value = value;\n    }\n}\n\nint getSensorValue() {\n    return sensor_value;\n}\n\nvoid setMotorSpeed(int speed) {\n    if (speed >= 0) {\n        motor_speed = speed;\n    }\n}\n\nint getMotorSpeed() {\n    return motor_speed;\n}\n\n```\n\n### 在其他模块中使用\n\n```c\n#include \"shared_data.h\"\n\nvoid moduleA_update() {\n    setSensorValue(getSensorValue() + 10);\n}\n```\n\n## 联合起来\n\n将两种方式联合起来使用——大部分变量，我们使用指针接口访问即可；如果有些变量需要一些个性化要求，我们为这些变量编写定制的接口就好。\n\n## 挖坑\n\n降低耦合性的方法还有使用单例模式，以及RTOS中的消息/事件机制。后续研究。\n\n[^1]: 代码耦合性（Coupling）是指模块或组件之间的依赖程度。如果代码耦合性很高，模块之间会紧密依赖，导致代码难以维护、扩展和测试。\n\n","tags":["嵌入式","程序架构","降低耦合"],"categories":["嵌入式","程序架构"]},{"title":"串口重定向的非阻塞方法","url":"/posts/18285/","content":"\n<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 常用方式\n\n有时我们需要串口打印信息到上位机，最便捷的方法是重定向 `printf()`，网上的常用方法如下：\n\n```c\n\nint fputc(int ch, FILE *f){    \n\tHAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xffff);\n    \n\treturn ch;   \n}\n\nint fgetc(FILE *f){\n    \n\tuint8_t ch = 0;\n\t    \n\tHAL_UART_Receive(&huart1, &ch, 1, 0xffff);\n\t    \n\treturn ch;   \n}\n\n```\n\n### 这样做的缺点\n\n- 这是 **阻塞模式**，每次 `printf()` 都要等待数据发送完毕，影响 CPU 执行效率。\n- 如果数据较多，会降低实时性，阻塞主循环。\n\n## 使用非阻塞的方式：灵活运用DMA\n\n我们使用DMA非阻塞发送。具体步骤如下：\n\n### 1. 定义缓冲区。\n\n根据fputc()的特性（这里先按下不表），使用 DMA 发送时，`printf()` 需要先把数据存到 **一个缓冲区**，然后一次性使用 DMA 发送出去。\n\n```c\n\n#define TX_BUFFER_SIZE 256  // 发送缓冲区大小\nuint8_t uart_tx_buffer[TX_BUFFER_SIZE];  // 串口发送缓冲区\nvolatile uint16_t tx_len = 0;  // 当前缓冲区数据长度\nvolatile uint8_t tx_busy = 0;  // 发送状态标志\n\n```\n\n### 2. 重定向 `fputc()`，使用缓冲区\n\n```c\n\nint fputc(int ch, FILE *f)\n{\n    // 确保缓冲区不会溢出\n    if (tx_len < TX_BUFFER_SIZE - 1)\n    {\n        uart_tx_buffer[tx_len++] = (uint8_t)ch;\n    }\n\n    // 如果遇到换行符，或者缓冲区接近满，就启动 DMA 发送\n    // 注意咯，如果缓冲区没满的情况下，只有检测到/n才会触发DMA的发送。所以在缓\n    // 冲区没满的情况下，如果你想要发送字符串\"abc\"，printf(\"abc\")是没用的，\n    // printf(\"abc\\n\")才有用哦。\n    if (ch == '\\n' || tx_len >= TX_BUFFER_SIZE - 1)\n    {\n        uart_dma_transmit();\n    }\n\n    return ch;\n}\n\n\n```\n\n### 3. 定义DMA 发送函数\n\n```c\n\nvoid uart_dma_transmit(void)\n{\n    // 如果 DMA 还在忙，则不启动新的传输\n    if (tx_busy) return;\n\n    tx_busy = 1;  // 标记为发送中\n    HAL_UART_Transmit_DMA(&huart1, uart_tx_buffer, tx_len);\n}\n\n```\n\n### 4. DMA 传输完成回调\n\n```c\n\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)\n{\n    if (huart->Instance == USART1)  // 确保是目标串口\n    {\n        tx_len = 0;  // 清空缓冲区\n        tx_busy = 0; // 标记为可用\n    }\n}\n\n```\n\n\n## 一些疑惑的解答\n\nQ: 茂神茂神，你的说的非阻塞方式的确很不错，但是还是太吃操作了，我就不能直接在 `fputc()`里写 `HAL_UART_Transmit_DMA`吗？\\\n\\\nA: 可以的兄弟可以的。`fputc()` 是发送一个字符对吧，理论上我们只需要把DMA传输的字节数改为1就行了对吧？nonono，首先DMA是非阻塞的对吧，也就是激活了它，他就只管发，不管你完没完成，你都可以再次激活它，如果像你这样做，当发送字符流时大概率是这种情况：\n> `fputc()`打电话给DMA的秘书说我要发这个字符，然后他就认为我已经给DMA说了叫它发送这个字符啦，所以这个字符就发出去啦，剩下就不关我的事啦。结果DMA秘书看到DMA此时还在忙于上次发送，于是判断DMA为`HAL_BUSY`没有办法把字符交给DMA。这个字符信息就丢失了。。。。","tags":["STM32","嵌入式","程序架构","串口"],"categories":["嵌入式","程序架构"]},{"title":"CubeMX配置功能系列：iic","url":"/posts/58129/","content":"\n<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 说明\n由于前面已经详细介绍了iic通信协议（详见[通信协议：iic [ g0dMa0's Blog ]](https://im.godmao.top/posts/55329/)），这里主要就硬件iic在cubemx中的配置作介绍。\n\n## 通道设置\n![](Snipaste_2025-03-12_14-59-01.png)\n哈哈没想到吧，iic通道不止支持iic协议，孩子。\\\nSMBus-系统管理总线，是iic的扩展。利用系统管理总线，设备可提供制造商信息，告诉系统它的型号/部件号，保存暂停事件的状态，报告不同类型的错误，接收控制参数，和返回它的状态。SMBus为系统和电源管理相关的任务提供控制总线。\\\nSMBus 为系统和电源管理这样的任务提供了一条控制总线，使用 SMBus 的系统，设备之间发送和接收消息都是通过 SMBus，而不是使用单独的控制线，这样可以节省设备的管脚数。\\  \n所以它与iic的区别很明显了，一个是该总线上连接设备自身可以控制总线(I2C，速率较高)，想干嘛就干嘛；另一个是设备之间可以通过它来传送信息，但是速率比较慢，比如用在检测各元件状态并更新硬件设置引脚等，同时廉价是它的优点。\\\n\\\n**SMBus-Alert**是一个带中断线的可选信号，用于那些希望扩展他们的控制能力而牺牲一个引脚的设备。SMBALERT和SCL和SDA信号一样，是一种线与信号。SMBALERT通常和SMBus广播呼叫地址一起使用。与SMBus有关的消息为2字节。**单一的从设备可以通过SMBALERT发信号给主机表示它希望进行通信**，这可通过设置I2C_CR1寄存器上的ALERT位实现。主机处理该中断并通过提醒响应地址ARA(Alert Response Address，地址值为0001100x)访问所有SMBALERT设备。只有那些将SMBALERT拉低的设备能应答ARA。此状态是由 I2C_SR1寄存器中的SMBALERT状态标记来标识的。主机执行一个修改过的接收字节操作。由从发送设备提供的7位设备地址被放在字节的7个最高位上，第八个位可以是0或1。如果多个设备把SMBALERT拉低，最高优先级设备(最小的地址)将在地址传输期间通过标准仲裁赢得通信权。在确认从地址后，此设备不得再拉低它的SMBALERT，如果当信息传输完成后，主机仍看到SMBALERT低，就知道需要再次读ARA。没有执行SMBALERT信号的主机可以定期访问ARA。有关SMBus提醒模式的更多详细资料，请参考2.0版的SMBus规范。**说白了还是通信，只不过是从机与从机的通信** \\\n我先忽略系统管理总线协议。专注于iic。\n## 主模式设置\n![](Snipaste_2025-03-12_17-56-13.png)\n\n### Custom Timing\n这个牛逼了，iiC通信依赖于特定的时序参数，如时钟频率、高低电平时间等。STM32CubeMX通常提供预定义的时序配置，适用于常见场景。但在某些情况下，预定义配置可能无法满足需求，这时就需要手动调整时序参数。\n\n通过“Custom Timing”，你可以根据具体需求调整以下参数：\n\n1. **SCL时钟频率**：设置SCL时钟的频率。    \n2. **SCL高低电平时间**：分别设置SCL高电平和低电平的持续时间。   \n3. **数据建立和保持时间**：设置数据在时钟边沿前后的稳定时间。\n4. **起始和停止条件时间**：设置起始和停止条件的持续时间。\n#### 使用场景\n- **非标准I2C设备**：某些设备可能需要特定的时序。\n- **优化性能**：在高噪声环境中，调整时序可以提高通信稳定性。  \n- **调试**：在调试时，手动调整时序有助于排查问题。\n#### 配置步骤\n1. 在CubeMX中启用I2C外设。\n2. 选择“Custom Timing”选项。\n3. 手动输入所需的时序参数。\n4. 生成代码并验证配置。\n#### 注意事项\n- 确保时序参数符合I2C规范和设备要求。\n- 错误的配置可能导致通信失败或损坏设备。\n通过“Custom Timing”，你可以更灵活地配置I2C通信，满足特定需求。\n#### 看完以后发现我还是不会用啊，，，，，\n\n### Timing \n这个是和上面那个一起用的，我猜是把Timing这个设定值写入某个寄存器里，然后这个寄存器的不同位控制着不同的时序参数，如高低电平时间什么的。没有深究。因为估计也不会用自定义时序。\n![](Snipaste_2025-03-12_18-39-27.png)\n自定义时序enable 后的界面如上图所示。\n\n### RiseTime/FallTime/Coefficient of Digital Filter\n控制iic上升沿/下降沿的时间，iic对于上下降沿的时间是有要求的。\\\n数字滤波器系数。不启用设置为0，启用则可设置为1-15，表示1-15个iic外设时钟。\\\n这三个参数要遵循一套非常复杂的时序计算方法的，也和对应的外设有关系，在设置前也要阅读相关的外设资料。此处暂且不展开。\n\n### Analog Filter\n模拟滤波器。\n\n## 从模式设置\n### Clock No Stretch Mode\n**IIC时钟拉伸(Clock stretching)**：\\\n有时候低速从机可能由于上一个请求还没处理完，无法继续接收主机的后续请求，**即主机的数据传输速率超过了从机的处理能力**。这种情况下，从机可以进行时钟拉伸来要求主机暂停传输数据 。通常时钟都是由主机提供的，从机只是在SDA上读数据或者发数据。\n时钟拉伸则是从机在主机释放SCL后，将SCL主动拉低并保持，此时要求主机停止在SCL上产生脉冲以及在SDA上发送数据，直到从机释放SCL（SCL为高电平）。之后主机便可以继续正常的数据传输了。可见时钟拉伸实际上是利用了时钟同步的机制，只是时钟由从机产生。 如果系统中存在这种低速从机并且从机实现了时钟拉伸，主机必须能够处理这种情况，**实际上大部分从机设备中不包含SCL驱动器的，因此无法拉伸时钟。**\n\n### Primary Address Length selection\n从设备地址长度 置从设备的地址是7bit还是10bit。大部分为7bit。\n\n### General call address\n**通用广播地址是为了寻址总线上所有设备。** 如果一个设备不需要使用广播功能，可以不响应广播。如果设备需要使用广播功能，则它在检测到广播地址后发送响应，并作为从机接收读取总线上发送的数据。主机不知道总线上有多少从机发送响应。**总线上所有可以响应广播的从机读取广播地址后的第二个及后面的字节。** 不能处理这些广播数据的从机通过不发送响应的方式忽略它。同样地，**如果有一个或一个以上的从机发送响应，则主机就检测不到总线上其它没有响应的设备。** 广播消息的含义总是定义在第二个字节。\n![](65d333b522f92fae6584d6d5cccc4de9.jpeg)\n<details>\n\n<summary>以下内容需要的时候再看</summary>\n\n有两种可能情况：\n\n- 最低位“B”为0\n- 最低位“B”为1\n\n- “B”为0，第二个字节包括以下定义：\n0000 0110（06h）：复位并通过硬件写内容到从机的可编程部分。所有可以响应此类广播的从机，收到此两字节后，进行复位并进入它们地址的可编程部分。注意确保设备在加电后不会将SDA或SCL拉低，因为这些低电平会阻塞总线；\n0000 0100（04h）：通过硬件写内容到从机的可编程部分，作用类似（06h），但设备不会复位；\n0000 0000（00h）：这个不应该作为第二个字节用。\n编程时序参考相应设备的DATASHEET。\\\n\n- “B”为1，两字节广播定义为“硬件广播”。主机在编程后，可以发送既定的从机地址到总线上，构成两字节序列的“硬件广播”。主机可能并不知道总线上从机的地址，它只能通过硬件广播的方式，将自身地址通知给系统。\n硬件广播的第二个字节的前七位包括主机的地址。总线上的智能设备如微控制器，读取此地址并接收主机发送的其它信息。如果主机也可以作为从机使用，则以上读取的主机地址实际上也就是（切换主从模式后的）从机地址。在系统中，一种可能是系统复位后设备由主机发送模式切换到从机接收模式，这时由系统主机先告诉硬件主机数据应送往的从机地址，这样当硬件主机发送数据时就可以直接向指定从机（地址）发送数据了。\n如下所示：\n\n</details>\n\n![](e76a7cecc118d861220014786be3e39b.jpeg)\n\n### Dual Address Acknowledged\n双地址确认。允许从机响应两个不同的地址。有啥用？？？？\n\n### Primary slave address\n从设备初始地址。不用填。\n\n\n## 参考资料\n- ⭐⭐⭐[I2C详解（二）_i2c general call-CSDN博客](https://blog.csdn.net/sternlycore/article/details/85759475)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n- [IIC设备驱动程序（六）————SMBus协议-CSDN博客](https://blog.csdn.net/yangguoyu8023/article/details/71440688)\n- [【STM32F030开发日志/评测/笔记】+（1）STM32F0处理器I2C时间配... - STM32团队 ST意法半导体中文论坛](https://shequ.stmicroelectronics.cn/thread-571931-1-1.html)\n- ⭐⭐⭐[【STM32】HAL库 STM32CubeMX教程十二---IIC(读取AT24C02 )_hal iic-CSDN博客](https://blog.csdn.net/as480133937/article/details/105259075)\n","tags":["STM32","CubeMX","嵌入式","iic"],"categories":["嵌入式","CubeMX配置功能"]},{"title":"通信协议：iic","url":"/posts/55329/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 说明\n\niic作为当今嵌入式应用中最常见的串行通信协议之一!!我愿将其与UART和SPI并称三幻神!!，是对于嵌入式开发者是最基本的要求，因为老是会忘记iic协议的一些细节，故作记录。\n\n## iic简介\n\n**IIC(Inter－Integrated Circuit)总线**是一种由NXP（原PHILIPS）公司开发的两线式串行总线，用于连接微控制器及其外围设备。**是一种半双工同步的低速通信协议**。多用于主控制器和从器件间的主从通信，在小数据量场合使用，传输距离短，任意时刻只能有一个主机等特性。\\\n\\\nIC使用两根信号线进行通信：一根时钟线SCL，一根数据线SDA。IIC将SCL处于高时SDA拉低的动作作为开始信号，SCL处于高时SDA拉高的动作作为结束信号；传输数据时，SDA在SCL低电平时改变数据，在SCL高电平时保持数据，每个SCL脉冲的高电平传递1位数据。\n\n## 主要特性\n\n- IC用2根信号线通信：串行数据线 SDA、串行时钟线 SCL；\n- IIC总线上所有器件的SDA、SCL引脚输出驱动都为**开漏(OD) 结构**，通过外接上拉电阻实现总线上所有节点SDA、SCL信号的线与逻辑关系；\n- 总线上的所有设备通过软件寻址且具有唯一的地址（7位或10位）。7位“从机专用地址码”，其高4位为由生产厂家制定的设备类型地址，低3位为器件引脚定义地址（由使用者定义）；10位地址不常见；\n- 任何时刻都只存在简单的主从关系，按数据传输的方向，主机可以是主发送器或主接收器；\n- 支持多主机。在总线上存在多个主机时，通过冲突检测和仲裁机制防止多个主机同时发起数据传输时存在的冲突；\n- IIC总线上所有器件都具有“自动应答”功能，保证数据传输的正确性； **主机和从机的区别在于对SCL的发送权，只有主机才能发送SCL**；\n- IIC总线允许挂载最多的设备数量取决于总线上最大电容值，一般为400pf（Hs模式100pf）\n\n支持的传输速率：\n\n| 模式                     | 速度      |\n| ---------------------- | ------- |\n| 标准模式（Standard Mode）    | 100kb/s |\n| 快速模式（Fast Mode）        | 400kb/s |\n| 增强快速模式（Fast Mode Plus） | 1Mb/s   |\n| 高速模式（High Speed Mode）  | 3.4Mb/s |\n| 极速模式（Ultra-FastMode）   | 5Mb/s   |\n\n## 硬件结构\n\n### 总线结构\nIIC使用两根信号线进行通信，要求两根线都使用 **开漏输出接上拉电阻** 的配置，以此实现总线上所有节点SDA、SCL信号的**线与**逻辑关系。\nRp电阻的取值有一定的要求，太小会导致灌入电流过大，使’低’数据不稳定，甚至损坏端口；太大会导致信号上升缓慢，使得数据传输出错。在不同应用场景及供电电压下有不同的取值要求。 \n![](79b9189018381624841758e3ade6e477.png)\n\n### 仲裁机制\n\n#### 开漏输出\n开漏输出回顾：当输入为高电平时，三级管导通，输出为低电平。输入为低电平，输出不确定，在这种情况下，如果使用强上拉，则可以输出高电平。开漏输出是实现”线与“的一种方案。\n#### 线与\n多个开漏输出连接在一起时，只要有一个输入为低电平，那么总体表现为低电平（处于低电平的那个io口把vdd流向Vout的电流引走了）。\n![](Snipaste_2025-03-11_20-01-18.png)\n\n“线与“使得总线上不会出现数据冲突，实现了总线的仲裁控制。总线的控制权会交给最后一个输出低电平的设备，其它设备（输出高）通过检测总线上的电平状态（状态低），对比与自己输出状态不一致，则自动退出对总线的控制请求，从而防止了总线上的数据冲突。\n\n## 🌟时序逻辑\n### 数据有效性\nscl为高电平期间，为数据采集期，所以sda上的数据此时一定要保持稳定哦~\n![](6c89c55012485f151df1a9fb48843d3f.jpeg)\n\n### 开始与结束信号\n有设备想要sda总线控制权时，会主动把sda拉低。平时sda为高。\n- **开始信号（START/S）：** **SCL为高时**，SDA从高到低的跳变产生开始信号 。\n- **结束信号（STOP/P）  ：** **SCL为高时**，SDA从低到高的跳变产生结束信号。\n- **重复开始信号（ReSTART/Sr）：** 在结束时不给出STOP信号，而以一个时钟周期内再次给出开始信号作为替代。\n![](f749a6ab4f928522a99db173fd504647.png)\n\n### 传输格式（字节格式）\nSDA数据线上的每个字节**必须是8位**，对于每次传输的**字节数没有限制**。每个字节（8位）数据传送完后紧跟着应答信号（ACK，第9位）。数据的先后顺序为：**高位在前** 。\n![](d3bbca378362c28829cee243a8497ef7.png)\n\n### ACK信号\n\n协议规定数据传输过程必须包含应答（ACK）。接收器通过应答告知发送的字节已被成功接收，之后发送器可以进行下一个字节的传输。所以主机产生数据传输过程用了9个时钟。发送器在应答时钟周期内释放对SDA总线的控制，这样 **接收器** 可以通过将SDA线拉低告知发送器：数据已被成功接收。(谁接收，谁发送应答信号)!!发送端对接收端说：我他妈要给你发数据了，收到货他妈回复一下0!!\n应答信号分为两种：  \n1. 当第9位(应答位)为 **低电平** 时，为 **ACK**  （Acknowledge）   信号  \n2. 当第9位(应答位)为 **高电平** 时，为 **NACK**（Not Acknowledge）信号\n\n主机发送数据，从机接收时，ACK信号由从机发出。当在SCL第9位时钟高电平信号期间，如果SDA仍然保持高电平，则主机可以直接产生STOP条件终止以后的传输或者继续ReSTART开始一个新的传输 !!此时主机发现事情不对，我他妈辛辛苦苦给你发的货你连句回应都没有，主机可以选择不发了，或者继续用爱发电发发发 大声发！来财，来~我是憋佬仔!!\\\n\\\n从机发送数据，主机读取数据时，ACK信号由主机给出。主机响应ACK表示还需要再接收数据，而当主机接收完想要的数据后，通过发送NACK告诉从机读取数据结束、释放总线。随后主机发送STOP命令，将总线释放，结束读操作。!!从机这个fw，纯添狗级别的、麦当劳级别的、ATM级别的。主机叫一直叫从机爆金币，从机真就一直爆，榨干从机了就直接把他甩了他妈的!!\n\n### 7bit完整传输示意图\n![](f313f22e0c7bc962ff6e9e5afc2bbc95.png)\n\n没错前7位是地址，发完地址发送读/写命令，然后发送端交出sda控制权，等待接收端的应答信号。如果从机没有给出ACK应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由master来决定如何处理（STOP或ReSTART）。\n\n### 从机发，主机收的情况\n主机对向从机读取数据时，方式同发送数据有所不同，要多一次通信过程。\n主机需要先向从机发送一次信号，告诉从机”我要读取数据“，然后**重开一次通信**[^1]，等待从机主动返回数据。\n![](Snipaste_2025-03-11_20-50-32.png)\n\n### 10bit传输\n随着IIC设备日益增多，7位的从机地址逐渐不能满足使用，于是从机地址从7位扩充到了10位。7位和10位地址的设备可以共存于同一个I2C总线系统互不冲突，展现了良好的兼容性。\\\n10-bit 地址的IIC设备需要 2-Byte 来传输从设备地址信息，所以采用了这样的设计：第一个字节为 11110 + 地址高两位(第10、9bit) + 读写控制位，第二个字节为从设备地址低8位，除此之外与7-bit设备相同。（因为 “1111 0xx” 为 IIC 中特地保留的16个特殊指令地址中的一个，所以7-bit设备不会响应该首字节的呼叫，只有10-bit设备会响应，从而实现良好兼容。!!好样的，iic👍👍👍为你骄傲!!）\n直接贴图了\n写\n![](5569e1d0e47921103fe2d9d5b8ce83f9.jpeg)\n读\n![](dee04bba6b887b740ab122eac9bc37bf.jpeg)\n注意第一帧都是write哦。\n\n## 参考文章 \n- ⭐⭐⭐[基础通信协议之 IIC (I2C) 详细讲解_i2c通信的详细讲解-CSDN博客](https://blog.csdn.net/qq_39829913/article/details/104718185)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n- [二十、I2C总线仲裁机制 - 轻轻的吻 - 博客园](https://www.cnblogs.com/yuanqiangfei/p/15781416.html)\n- [GPIO推挽与开漏输出的“线与“特性 - 知乎](https://zhuanlan.zhihu.com/p/638360051)\n\n[^1]: 重复启动信号（Repeated Start）是一种特殊的操作，**它允许在不释放总线的情况下从写模式切换到读模式**。这种方式可以避免总线被其他设备占用，或者防止主设备发送 STOP 信号后，其他设备试图接管总线。","tags":["嵌入式","iic","通信协议"],"categories":["嵌入式","通信协议"]},{"title":"CubeMX配置功能系列：ADC（下）","url":"/posts/55933/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 目录\n- [目录](#目录)\n- [1. 输入模式](#1-输入模式)\n  - [1.1. 单端输入](#11-单端输入)\n  - [1.2. 差分输入](#12-差分输入)\n- [2. 继续看config部分](#2-继续看config部分)\n  - [2.1. 通用设置部分：](#21-通用设置部分)\n  - [2.2. ADC 设置部分：](#22-adc-设置部分)\n    - [2.2.1. ClockPre...](#221-clockpre)\n    - [2.2.2. Resolusion](#222-resolusion)\n    - [2.2.3. Data Ali...](#223-data-ali)\n    - [2.2.4. Gain Com...](#224-gain-com)\n    - [2.2.5. Scan Conversion Mode](#225-scan-conversion-mode)\n    - [2.2.6. End Of Conversion Selection](#226-end-of-conversion-selection)\n    - [2.2.7. Low Power Auto Wait](#227-low-powerautowait)\n    - [2.2.8. Continuous Conversion Mode](#228-continuous-conversion-mode)\n    - [2.2.9. Discontinuous Conversion Mode](#229-discontinuous-conversion-mode)\n    - [2.2.10. DMA Continuous Requests](#2210-dma-continuous-requests)\n    - [2.2.11. Overrun behaviour](#2211-overrun-behaviour)\n    - [2.2.12. Conversion Data Managerment Mode（H7）](#2212-conversion-data-managerment-modeh7)\n  - [2.3. 规则转换模式](#23-规则转换模式)\n    - [2.3.1. Enable Regular Conversions](#231-enable-regular-conversions)\n    - [2.3.2. Enable Regular Oversamping（不常用）](#232-enable-regular-oversamping不常用)\n    - [2.3.3. Oversamping Right Shift（不常用）](#233-oversamping-right-shift不常用)\n    - [2.3.4. Number Of Conversion](#234-number-of-conversion)\n    - [2.3.5. External Trigger Conversion Soure（触发转换的外部来源）](#235-external-trigger-conversion-soure触发转换的外部来源)\n    - [2.3.6. External Trigger Conversion Edge（触发转换的外部沿）](#236-external-trigger-conversion-edge触发转换的外部沿)\n    - [2.3.7. Rank](#237-rank)\n    - [2.3.8. Offset Number](#238-offset-number)\n  - [2.4. 然后是注入转换模式](#24-然后是注入转换模式)\n    - [2.4.1. 规则通道：](#241-规则通道)\n    - [2.4.2. 注入通道：](#242-注入通道)\n  - [2.5. 最后是可爱的看门小狗🥰~](#25-最后是可爱的看门小狗)\n- [3. 参考函数](#3-参考函数)\n- [4. 参考博客](#4-参考博客)\n\n\n## 1. 输入模式\n我们打开cubemx的配置，配置通道时有如下选择：分别是差分输入和单端输入。\n![](Snipaste_2025-03-09_19-30-43.png)\n\n### 1.1. 单端输入\n\n单端输入方式优点就是简单，缺点是如果VIN受到干扰，由于GND电位始终是0V，所以最终采样值也会随着干扰而变化。采样值=VIN（叠加干扰值 ）- 0V\n\n如图所示，单端输入只有一个输入引脚ADCIN，使用公共地GND作为电路的返回端，ADC的采样值=ADCIN电压-GND的电压(0V)。这种输入方式优点就是简单，缺点是如果vin受到干扰，由于GND电位始终是0V，所以最终ADC的采样值也会随着干扰而变化。\n![](8c60645887a08582fd0cd8f9cba6b8da.png)\n\n### 1.2. 差分输入\n\n差分受到的干扰是差不多的，输入的共模干扰，在输入时会被减掉，从而降低了干扰，缺点就是接线复杂一些。\n\n差分信号 优点：易分辨小信号、抗干扰EMS强；缺点:双线\n\n而差分输入比单端输入多了一根线，最终的ADC采样值=(ADCIN电压)-(ADCIN-电压)，由于通常这两根差分线会布在一起，所以他们受到的干扰是差不多的，输入共模干扰，在输入ADC时会被减掉，从而降低了干扰，缺点就是接线复杂一些。而且需要VIN+和VIN-两路反相的输入信号。\n\n差分输入的是将两个输入端的差值作为信号，这样可以免去一些误差，比如你输入一个1V的信号可电源有偏差实际输入要大0.1.就可以用差分输入1V和2V一减就把两端共有的那0.1误差剪掉了。单端输入无法去除这类误差。\n\n![](Snipaste_2025-03-09_19-43-28.png)\n\n## 2. 继续看config部分\n\n![](Snipaste_2025-03-09_19-45-21.png)\n![](Snipaste_2025-03-09_19-45-32.png)\n\n### 2.1. 通用设置部分：\n- 当只启用1个ADC时，只能选择**独立模式**，如果使用双ADC并要求同步的话，则会有更多选择。双重ADC同步模式，两个ADC同时采集一个或多个通道，可以提高采样率。这个双ADC同步模式的选择先不作记录了！\n### 2.2. ADC 设置部分：\n#### 2.2.1. ClockPre...\n时钟预分频，双时钟域架构。目的是让ADC达到稳定的工作频率[^1]（异步时钟模式（Asynchronous clock mode，基于PLL2P时钟）同步时钟模式（Synchronous clock mode，基于AHB时钟）有些型号的单片机则是直接从时钟树专门分出了一个ADC时钟频率配置。\n![](Snipaste_2025-03-09_20-30-53.png)\n\n#### 2.2.2. Resolusion\n分辨率。不再赘诉。请见上篇\n\n#### 2.2.3. Data Ali...\n数据对齐。不再赘诉。请见上篇\n\n#### 2.2.4. Gain Com... \n增益补偿：对所有转换后的数据进行增益补偿。每次转换后，数据根据增益补偿对采样后的数据进行变换。\n\n#### 2.2.5. Scan Conversion Mode\n扫描模式。不再赘诉。请见上篇\n\n#### 2.2.6. End Of Conversion Selection\n转换结束标志选择：指定转换结束后是否产生EOS中断或单次转换结束事件标志（EOC）。有End of single conversion（EOC） 与 End of sequence of conversion（EOS）两种选择。这两个事件会触发中断与DMA。\\\n\\\n在多通道转换过程中，如果选择了End of sequence of conversion，会在一组数据转换完成后发出EOS标志，如下图所示。如果不选，则不会置位该标志。\n![](Snipaste_2025-03-09_20-42-09.png)\n选择EOS目的是等所有通道转换完毕后，产生中断后将全部数据取出来，或者使用DMA将全部数据取出来。\n\n#### 2.2.7. Low Power Auto Wait\n低功耗自动延迟等待模式，可选参数为 ENABLE 和 DISABLE，当使能时，仅当一组内所有之前的数据已处理完毕时，才开始新的转换，适用于低频应用。**该模式仅用于 ADC 的轮询模式，不可用于 DMA 以及中断。**\n\n#### 2.2.8. Continuous Conversion Mode\n是否启用连续转换。不再赘诉。请见上篇 **若想使用ADC+DMA的话，必须先使能连续转换模式**。\n\n#### 2.2.9. Discontinuous Conversion Mode\n间断模式，再赘诉一下。这里的不连续含义是指每次触发进行一个子组的转换，跟Continuous Conversion Mode的连续含义不一样。例如使能了该配置，该参数的下方就立马出现Number Of Discontinuous Conversions，如果它设为2，且ADC1使能了通道1，2，5，7，10，11的话，那么第一次触发ADC1采样时，就会采样通道1与通道2的值，再一次触发ADC1采样的话，就会采样通道5与通道7值，如此类推。值得注意的是，Continuous Conversion Mode与Discontinuous Conversion Mode不能同时使能，两者不能共存。\n\n#### 2.2.10. DMA Continuous Requests\nDMA连续请求：指定 DMA 请求是否以一次性模式执行(当达到转换次数时，DMA 传输停止)或在连续模式下(DMA 传输无限制，无论转换的数量)。[^2]\n- 不使能：在这种模式下，每次有新的转换数据可用时，ADC都会生成一个DMA传输请求，一旦DMA到达最后一个DMA传输，即使转换已经再次开始，ADC也会停止生成DMA请求，适合转换固定数量数据的情况。\n- 使能：在这种模式下，每当数据寄存器中有新的转换数据可用时，即使DMA已经到达最后一次DMA传输，ADC也会生成DMA传输请求。这允许在循环模式下配置DMA来处理连续的模拟输入数据流。\n\n#### 2.2.11. Overrun behaviour\n溢出处理：用于配置ADC转换数据未及时读取，造成溢出时的处理。\n- Overrun data preserved:保留旧数据，丢弃和丢失新的转换。\n- Overrun data overwritten:数据寄存器被最后一次转换的结果覆盖，之前未读的数据丢失\n![](Snipaste_2025-03-09_21-17-16.png)\n\n#### 2.2.12. Conversion Data Managerment Mode（H7）\n转换数据管理模式。不使用DMA的话，不使用DFSDM数字滤波器做后期处理的话，选择Regular Conversion data stored in DR register only即可。其实就是选择存放转换完成的模拟量数据的地方而已。\n\n### 2.3. 规则转换模式\n\n#### 2.3.1. Enable Regular Conversions\n使能规则转换。使能它才能采集各个通道上的模拟量。\n\n#### 2.3.2. Enable Regular Oversamping（不常用）\n使能规则过采样。\n![](Snipaste_2025-03-10_14-20-12.png)\n\n#### 2.3.3. Oversamping Right Shift（不常用）\n过采样右移。**过采样器能将累加的采样值进行右移**。有什么用？比如过采样设置15，那么将采集16个值进行累加。接着配置右移动4位的话，相当于将刚才的累加值除以16，得到平均值。不需要在程序里求平均了。当然，如果大家喜欢在程序里求平均值也是可以的。\n\n#### 2.3.4. Number Of Conversion\n转换通道数。根据ADC配置的通道数来选择。有多少转换通道就设置几。\n\n#### 2.3.5. External Trigger Conversion Soure（触发转换的外部来源）\n选择触发转换的来源：\n- Regular Conversion launched by software （软件触发）\n- Timer 1 Capture Compare 1 event （定时器1捕获比较事件1）\n- … （各种定时器触发来源）\n一般使用软件触发就行。\n\n#### 2.3.6. External Trigger Conversion Edge（触发转换的外部沿）\n选择定时器触发时，需要进一步选择触发的沿。选择软件触发时，该项为None。\nTrigger detection on the rising edge（上升沿）\nTrigger detection on the falling edge（下降沿）\nTrigger detection on the rising and falling edge（上升与下降沿）\n\n#### 2.3.7. Rank\n![](Snipaste_2025-03-10_14-29-51.png)\n\n- Channel：选择采样的通道。\n-  Sampling Time：采样时间。配置多少个时钟周期，建议采样时间尽量长一点，以获得较高的准确度。总的转换时间=采样时间+逐次逼近时间（TSAR）。[^3]\n逐次逼近参考时间：请查阅相关数据手册。\n这是一个参考：\n![](Snipaste_2025-03-10_14-31-52.png)\n\n#### 2.3.8. Offset Number\n偏移序号？？不懂。\n\n### 2.4. 然后是注入转换模式\n我们看到，在选择了ADC的相关通道引脚之后，在模拟至数字转换器中有两个通道：注入通道与规则通道。规则通道至多16个，注入通道至多4个。\n\n#### 2.4.1. 规则通道：\n规则通道相当于你正常运行的程序，看它的名字就可以知道，很规矩，就是正常执行程序。\n#### 2.4.2. 注入通道：\n注入通道可以打断规则通道，听它的名字就知道不安分，如果在规则通道转换过程中，有注入通道进行转换，那么就要先转换完注入通道，等注入通道转换完成后，再回到规则通道的转换流程。类似于中断。\n![](Snipaste_2025-03-10_14-43-22.png)\n\n### 2.5. 最后是可爱的看门小狗🥰~\n当被ADC转换的模拟电压值低于低阈值或高于高阈值时，便会产生中断。阈值的高低值由ADC_LTR和ADC_HTR配置。\n可以防止读取到的电压值超量程或者低于量程，也可以监控CPU温度，防止温度过高，反正是用处多多。\n\n## 3. 参考函数\n```c\n//开启ADC 3种模式 ( 轮询模式 中断模式 DMA模式 )\nHAL_ADC_Start(&hadcx);       //轮询模式开启ADC\nHAL_ADC_Start_IT(&hadcx);       //中断轮询模式开启ADC\nHAL_ADC_Start_DMA(&hadcx);       //DMA模式开启ADC\n\n//关闭ADC 3种模式 ( 轮询模式 中断模式 DMA模式 )\nHAL_ADC_Stop();\nHAL_ADC_Stop_IT();\nHAL_ADC_Stop_DMA();\n\n//ADC校准函数 ：F4系列不支持\nHAL_ADCEx_Calibration_Start(&hadcx);      \n\n//读取ADC转换值\nHAL_ADC_GetValue();\n\n//等待转换结束函数.第一个参数为哪个ADC,第二个参数为最大等待时间\nHAL_ADC_PollForConversion(&hadc1, 50);\n\n//ADC中断回调函数\nHAL_ADC_ConvCpltCallback();\n\n//转换完成后回调，DMA模式下DMA传输完成后调用\n\n//规则通道及看门狗配置\nHAL_ADC_ConfigChannel(); //配置规则组通道\nHAL_ADC_AnalogWDGConfig();\n```\n\n\n\n## 4. 参考博客\n有星星的是我觉得写的很好的博客。\n- ⭐⭐⭐[STM32H743-梳理ADC模数转换器在CubeMX上的配置_overrun behaviour-CSDN博客](https://blog.csdn.net/wallace89/article/details/117048846)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n- ⭐⭐⭐[STM32CubeIde ADC配置详解_end of conversion selection-CSDN博客](https://blog.csdn.net/demonneverhunts/article/details/135155881)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n- ⭐⭐⭐[【STM32】HAL库 STM32CubeMX教程九---ADC_cubemx adc-CSDN博客](https://blog.csdn.net/as480133937/article/details/99627062)\n- [ADC的单端输入、伪差分输入、差分输入区别？_差分adc-CSDN博客](https://blog.csdn.net/chenhuanqiangnihao/article/details/122086308)\n\n\n[^1]:ADC的工作频率需要查阅相关数据手册,工作频率太高会导致转换无法完成。\n[^2]: 在连续模式下，DMA 必须配置为循环模式。否则，当达到 DMA 缓冲区最大指针时将触发溢出。\n[^3]: 时间可以用ADC时钟周期来衡量。例如12bitADC的逐次逼近时间为12.5个ADC时钟周期\n","tags":["STM32","CubeMX","ADC","嵌入式"],"categories":["嵌入式","CubeMX配置功能"]},{"title":"Hello World","url":"/posts/16107/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"CubeMX配置功能系列：ADC（上）","url":"/posts/9852/","content":"\n<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 目录\n- [目录](#目录)\n- [1. 说明](#1-说明)\n- [2. Analog-to-Digital Converter简介](#2-analog-to-digital-converter简介)\n- [3. STM32里的ADC是如何进行转换的？](#3-stm32里的adc是如何进行转换的)\n  - [3.1. 数据对齐](#31-数据对齐)\n  - [3.2. 具体说明：](#32-具体说明)\n- [4. ADC的转换模式](#4-adc的转换模式)\n  - [4.1. 关于是否要持续转换](#41-关于是否要持续转换)\n  - [4.2. 如果有多个通道](#42-如果有多个通道)\n- [5. 参考博客](#5-参考博客)\n\n## 1. 说明\n\nADC作为对我来说不怎么用的功能，记录一下很有必要。本文以*STM32G4*系列为例。供自己学习与记录且只做简单介绍。有一定基础的朋友可参考。\n\n## 2. Analog-to-Digital Converter简介\n\n模拟到数字转换器，简称ADC。将连续的模拟信号转换为数字信号。\n\n## 3. STM32里的ADC是如何进行转换的？\n\n采用的是SAR（逐次逼近）的方法。通过二分比较使数字量逼近真实的模拟信号量。\\\n\\\n一般stm32中的ADC储存转换结果的寄存器有效位为12位，也可以说该ADC的分辨率为12位。模拟量经过转换后与数字量是线性关系[^1]，0x000代表测量最小值。0xfff代表测量最大值（即参考电压值）。\n\n### 3.1. 数据对齐\n\n尽管分辨率为12位，也是放在16位寄存器里的，那么就涉及数据对齐的问题。\n- 若12位数据是右对齐的，即结果为0x0???，这样得到的结果直接就是转换结果。\n- 若选择左对齐，即结果为0x???0，相当于`0x0???<<4`!!不会有人觉得是左移1位吧!! 我们都知道右移四位相当于乘以2^4^，比实际数据增大了16倍。那么我们为什么还需要左对齐呢？有时我们对分辨率要求不高，只需大概判断，所以我们用左对齐取出寄存器的高8位，相当于舍弃4位转换精度，降为8位分辨率。\n### 3.2. 具体说明：\n\n例如，我们需要测量模拟量为0.9V 过程如下[^2]：\n\n1. 通过GPIO口采样待测电压到电容上。\n2. 切断与待测信号的连接，将待测电压保持在电容上。\n3. 我们从最高位开始 ?000-0000-0000 ，我们知道 1000-0000-0000 刚好对应十进制2048，根据线性关系2048刚好对应参考电压的一半。所以这里相当于将参考电压值的一半1.65v与待测电压比较。如果待测电压没有1.65v高，就将最高位置0。我们就知道待测电压对应在0~2048之间。此时我们就要和1024比较，1024二进制表示为 0100-0000-0000，刚好是次高位置1的情况。以此类推，直到12位全部比较完，就能确定哪些位是1哪些位是0。\n\n\n\n## 4. ADC的转换模式\n### 4.1. 关于是否要持续转换\n1. 单次转换模式：ADC只执行一次转换；\n2. 连续转换模式：转换结束之后马上开始新的转换；\n### 4.2. 如果有多个通道\n1. 扫描模式：ADC扫描被规则通道和注入通道选中的所有通道，在每个组的每个通道上执行单次转换。在每个转换结束时，这一组的下一个通道被自动转换。如果设置了CONT位（开启了连续转换模式），转换不会在选择组的最后一个通道上停止，而是再次从选择组的第一个通道继续转换。\n2. 间断模式：触发一次，转换一个通道，再触发，再转换。在所选转换通道循环，由触发信号启动新一轮的转换，直到转换完成为止。\n\n## 5. 参考博客\n给星星的是我觉得写得很好的博客。\n- ⭐⭐⭐[【STM32】HAL库 STM32CubeMX教程九---ADC_cubemx adc-CSDN博客](https://blog.csdn.net/as480133937/article/details/99627062)\n\n[^1]: 以12位分辨率ADC为例，参考电压3.3v：电压值y=转换结果x·3.3/4096.\n[^2]:  参考电压3.3v，12位精度","tags":["STM32","CubeMX","ADC","嵌入式"],"categories":["嵌入式","CubeMX配置功能"]},{"title":"单片机（伪）多任务处理：时间片轮询法","url":"/posts/39448/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 引入\n\n在新手刚刚入门时，通常使用的程序架构为裸机、顺序执行。也就是说把所有的功能放在一个`while(1)`死循环中然后单片机不断循环执行。有必要的话会加上一些中断用来处理一些紧急事件或者外部的信号，构成经典的前后台系统。但是这样做有什么弊端呢？这是我在我踩过坑后意识到的：\n\n1. 有些程序完全不需要频繁执行，比如LED的刷新，按键的检测等。放在死循环中执行对CPU比较浪费。\n2. 随着功能的增多或者代码变得复杂你会感觉到程序越写越困难，循环中的功能模块有时需要和中断联动，各个模块之间也有可能需要联动起来。即使使用状态机也力不从心...\n3. 勉勉强强完成了任务，后期的维护也变得相当的麻烦。\n\n踩过坑后的我痛定思痛：准备以后写程序都请出RTOS这个大手子。但是后来我又发现 有时你想要实现的功能刚好介于复杂与不复杂之间...咋理解呢，就是说用顺序执行，复杂了点，用RTOS吧好像也没必要...毕竟移植还是挺麻烦的。当然还有就是RTOS体量过大，有些单片机吃不下，或者吃下了但是也撑的吃不下自己写的代码了!!属于是小鸟胃这一块，不过目前我还没遇到过，我用的单片机基本上属于大卫戴这一块!!\n\n## 时间片轮询法\n\n为了优化上面这些问题，大佬们于是提出了一种基于时间片的裸机开发架构，我们可以利用一个定时器提供心跳，不断的进行计数。然后当定时时间一到，那么就可以开始执行相应的任务了。\n\n### Talk is cheap，Show me the code.\n\n首先是.h头文件\n```c\n#ifndef __OS_H__\n#define __OS_H__\n\n//任务状态\ntypedef enum TaskStatus\n{\n    wait,run,stop\n\n}TaskStatus;//等待运行、正在运行、停止运行\n\n\n//任务信息块\ntypedef struct\n{\n\n    uint16_t    TaskTimer;    //用于计时\n\n    uint16_t    TaskRunTime;  //每隔多少时间运行一次\n\n    TaskStatus  Status;       //任务状态\n\n    void (*FC)();             //任务函数指针\n\n}TaskStruct;\n\n  \nvoid OSInit(TIM_HandleTypeDef htim);//初始化设置，这里是用的STM32hal库\n\nvoid OS_IT_RUN(void);//放在提供心跳的定时器中断里运行\n\nvoid OS_Run(void);//主函数里运行的\n \n#endif\n```\n\n然后是.c\n```c\n/**\n\n  ******************************************************************************\n\n  * @file           : OS.c\n\n  * @brief          : 任务函数、OS内核\n\n  ******************************************************************************\n\n  */\n\n#include \"OS.h\"\n\n/* 任务声明------------------------------------------------------------------*/\n\nvoid A(void);\nvoid B(void);\nvoid C(void);\n\n/* -------------------------------------------------------------------------*/\n\n/* 任务清单配置---------------------------------------------------------------*/\n\nuint8_t TaskCount = 0;//记录任务数量  \n\nTaskStruct TaskList[] = {\n\n    {0,5,run,A},\n\n    {0,10,wait,B},\n\n    {0,3,wait,C},\n\n};//任务清单\n\n/* -------------------------------------------------------------------------*/\n\n  \n  \n\n/* 任务同步所需公共变量--------------------------------------------------------*/\n\n/* -------------------------------------------------------------------------*/\n\n  \n  \n\n/* OS 主功能代码--------------------------------------------------------------*/\n\nvoid OSInit(TIM_HandleTypeDef htim){//可以根据自己的需求重新写\n\n    HAL_TIM_Base_Start_IT(&htim);                       //打开定时器\n\n    TaskCount = sizeof(TaskList)/sizeof(TaskList[0]);   //利用sizeof计算数组长度的方法可得到任务数量\n\n}\n\n  \n//放在中断中执行\nvoid OS_IT_RUN(void){\n\n    uint8_t i;\n\n    for(i=0;i<TaskCount;i++){              //遍历所有循环\n\n        if(TaskList[i].Status == wait){    //当任务wait状态，执行以下步骤\n\n            if(++TaskList[i].TaskTimer >= TaskList[i].TaskRunTime){\n            //计时，并判断是否到达定时时间                 \n            //如果到了定时时间，则将任务挂起，并复位计时（也可以执行完后复位，效果一样）\n                TaskList[i].TaskTimer = 0;\n\n                TaskList[i].Status = run;\n            }\n\n        }\n\n    }\n\n}\n\n  \n\n//放在main函数中执行，自带死循环，用于执行任务\nvoid OS_Run(void){\n\n    uint8_t j=0;\n\n    while(1){\n\n        if(TaskList[j].Status == run){                  //判断一个任务是否为run状态\n\n            TaskList[j].FC();                           //执行该任务函数\n\n            TaskList[j].Status = wait ;                 //取消任务的run状态\n\n        }\n\n        if(++j>=TaskCount)j=0;                          //不断循环遍历所有任务\n\n        /* 这里可以定义空闲任务 */\n\n    }\n\n}\n\n  \n\n/* -------------------------------------------------------------------------*/\n```\n\n**按照分而治之的思想，完全可以把任务函数重新写在一个task.c文件中，这样更加简洁美观**。\n采用上面的代码，个人认为比为每个功能函数提供一个flag，时间到达后将任务标志为置位。然后在main函数的循环中检查标志位状态（类似状态机）那种方法要方便。避免了一些重复的工作。\n\n### 什么意思\n\n比如我有三个功能：\n- A：5ms执行一次 \n- B：10ms执行一次\n- C：3ms执行一次\n\n我们随机提拔一个定时器作为心跳时钟，说白了就是掐表的嘛。这个定时器一般使用基本定时器性价比高一点。这个定时器每隔1ms就叫一下，我们可以决定ABC在上电时候时是否执行，或者上电后延迟一个自己的任务周期再执行。比如我们设定上电时：仅A执行。如果我们忽略代码的执行时间，那么程序就是这么运行的：\n\n`A-1ms-1ms-1ms(C)-1ms-1ms(A)-1ms(C)-1ms-1ms-1ms(C)-1ms(A、B)--------`\n\n如果上一个功能模块已经执行完了，但下一个功能模块的定时时间还没到，便会产生空闲时间，这那些1ms后没有括号的就是CPU的空闲段。同样可以像RTOS那样把空闲时间给空闲任务。\n注意当前延时了多少时间是一个函数执行完就直接开始计算的，我之前就理解为了一个时间片只有一个函数执行。实际上不是的。\n\n## 这样的方法有什么不足？\n\n1. 首先，像这样的丐版RTOS，实时性并没有真正的RTOS高，不是说执行就执行，会有一些延迟。\n2. **如果某个任务运行时间超过一个时间片，它可能会一直占用CPU，导致后面的任务无法及时执行，从而影响系统的响应时间。然后一整个就乱了。** ~~但是个人感觉如果实时性要求不高，也无伤大雅🤔~~\n\n比如时间片为1ms。A运行时间为2ms，每隔4ms执行一次。B运行时间不计，每隔3ms运行一次。\n\n（A1ms-1ms）-1ms(B)-1ms(A1ms-1ms)(B)-1ms-1ms(A1ms([^1])-1ms)(B[^2])-----\n\n[^1]: 这里该执行B了，但由于A抢占CPU，无法执行。\n[^2]: 这次B实际上隔了4ms才执行\n\n## 参考文章\n\n- [嵌入式裸机设计思想——时间片轮裸机开发架构+状态机+定时器调度机制_基于状态机制 定时器-CSDN博客](https://blog.csdn.net/qq_63922192/article/details/132746564)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n- [STM32裸机-时间片任务轮询_时间片轮询-CSDN博客](https://blog.csdn.net/weixin_44843021/article/details/117490107)遵循 [CC 4.0 BY-SA](http://creativecommons.org/licenses/by-sa/4.0/) 版权协议\n","tags":["嵌入式","程序架构","单片机","多任务"],"categories":["嵌入式","程序架构"]},{"title":"属于自己的引导页","url":"/posts/38456/","content":"## 网站截图\n\n![](Snipaste_2025-03-01_13-57-17.png)\n\n## 感谢\n\n网站整体的代码架构和设计思路都基于[Zyyo](https://zyyo.net/)的个人主页，这是GitHub项目地址：[ZYYO666/homepage: 我的个人主页，homepage,个人引导页,简约主页,个人导航](https://github.com/ZYYO666/homepage)\n\n很多css动画来自codepen里的大佬，我自己稍加修改！以下为部分网页使用的：\n- [时钟](https://codepen.io/graphilla/details/zEZKpN)\n- [列表收起与展开](https://codepen.io/dannymoerkerke/details/wBwYzRe)\n- [hello world动画](https://codepen.io/yoannhel/details/DMzjog)\n\n## 后记\n\n放寒假，在家实在无聊，看到各路大佬都有一个属于自己blog，便有了建一个自己的blog的想法。于是了解到了hexo ，然后各种抄能力🤓也算是搭好了自己的一个博客并托管在了GitHub，结果没想到还不够过瘾，想知道完全从0开始搭一个静态网页是什么体验，于是又在边搞边学的情况下整了个这个引导页，学习到了html和css（没有js，js全是抄的...🥹~~好吧其实部分源码架构也是抄的，毕竟也可以学习一下大佬写代码的结构~~）\n\n## TO DO\n\n- [ ]  适配黑夜模式\n- [ ]  适配移动端","tags":["网页","web"],"categories":["web前端"]},{"title":"CubeMX配置功能系列：Timer（下）","url":"/posts/48581/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 1. 目录\n- [1. 目录](#1-目录)\n- [2. 说明](#2-说明)\n- [3. TIM 各种模式详解](#3-tim-各种模式详解)\n\t- [3.1. 从模式](#31-从模式)\n\t\t- [3.1.1. 简介](#311-简介)\n\t\t- [3.1.2. 复位模式（RM）](#312-复位模式rm)\n\t\t- [3.1.3. 门控模式（GM）](#313-门控模式gm)\n\t\t- [3.1.4. 触发模式（TM）](#314-触发模式tm)\n\t\t- [3.1.5. 外部时钟模式1](#315-外部时钟模式1)\n\t\t- [3.1.6. 一个示例](#316-一个示例)\n\t\t- [3.1.7. 参考](#317-参考)\n\t- [3.2. 编码器模式](#32-编码器模式)\n\t- [3.3. 触发源](#33-触发源)\n\t- [3.4. 时钟源](#34-时钟源)\n\t- [3.5. 主模式](#35-主模式)\n\t\t- [3.5.1. 比较与捕获](#351-比较与捕获)\n\t- [3.6. 一些疑惑的地方](#36-一些疑惑的地方)\n\t\t- [3.6.1. Q：`output compare no output`是什么模式？好矛盾的名字。。。](#361-qoutput-compare-no-output是什么模式好矛盾的名字)\n\t\t- [3.6.2. Q：输出比较和PWM生成模式有何区别与联系？](#362-q输出比较和pwm生成模式有何区别与联系)\n\t\t- [3.6.3. Q：何为强制输出？有啥用？](#363-q何为强制输出有啥用)\n\t\t\t- [3.6.3.1. 强制输出模式的工作原理：](#3631-强制输出模式的工作原理)\n\t\t\t- [3.6.3.2. 主要功能：](#3632-主要功能)\n\t\t\t- [3.6.3.3. 工作模式：](#3633-工作模式)\n\t\t\t- [3.6.3.4. 例子：](#3634-例子)\n\t\t\t- [3.6.3.5. 总结：](#3635-总结)\n\t\t- [3.6.4. Q：输入捕获的间接模式？](#364-q输入捕获的间接模式)\n\t\t\t- [3.6.4.1. 特点：](#3641-特点)\n\t\t\t- [3.6.4.2. 以下是直接与非直接模式的比较](#3642-以下是直接与非直接模式的比较)\n\t\t- [3.6.5. 参考](#365-参考)\n\n\n## 2. 说明\n\n本文以STM32G4系列为例。供自己学习与记录且只做简单介绍。有一定基础的朋友可参考。\n\n--- \n\n## 3. TIM 各种模式详解\n\n如下为一个高级定时器的配置页面\n![](CubeMX配置功能系列：Timer（上）/Snipaste_2025-02-22_14-10-44.png)\n\n### 3.1. 从模式\n\n可配置功能\n![](CubeMX配置功能系列：Timer（上）/Snipaste_2025-02-22_14-14-22.png)\n\n#### 3.1.1. 简介\n\n定时器的从模式控制器可以对计数器实现哪些控制或影响呢？从模式控制器检测到触发输入信号时，可以对定时器进行如下操作而控制或影响计数器的工作：\n\n1. 对计数器复位\n2. 启动或停止计数器的计数动作\n3. 使能计数器模块的工作\n4. 通过触发信号为计数器提供时钟源\n\n#### 3.1.2. 复位模式（RM）\n\n主定时器出现信号后：从定时器计数器复位并产生一个中断。\n\n不妨以计数器向上计数为例，将它配置在复位从模式。比方说当计数器计数到某个数据的时候，来了个触发信号，计数器不再继续往上计数，而是重新归0后开始计数。当然，计数器的实际复位操作与触发沿之间往往会有个小的延时，这是由于触发信号作为有效触发脉冲的话，还需要经过定时器内的同步电路确认。\n\n关于处于复位模式下的定时器，有两点提醒：\n\n1. 只要有复位触发脉冲出现，计数器就会被复位重置。复位次数取决于触发脉冲次数。\n2. 工作在复位模式下的定时器，其使能需靠软件代码实现，即使能定时器的CEN@TIMx_CR1位。\n\n#### 3.1.3. 门控模式（GM）\n\n主定时器出现信号后：从定时器计数器开始工作\n\n主定时器信号结束后：从定时器计数器停止工作并产生中断\n\n#### 3.1.4. 触发模式（TM）\n\n主定时器出现信号后：从定时器计数器开始工作，并且不会停止。\n\n触发模式主定时器只是提供了一个启动从定时器开始时间的控制，并不会有其他效果，触发从模式下，触发信号具有相当于软件使能计数器的作用，即置位CEN@TIMx_CR1，这也是它最大最明显的特征。\n\n#### 3.1.5. 外部时钟模式1\n\n外部时钟模式1从模式比较特别，当计数器的时钟源来自触发信号时，此时定时器就工作在外部时钟1从模式，此时触发信号扮演着双角色，即**触发信号**与**时钟信号**。\n\n比如，我们可以使用来自ETR脚的滤波信号ETRF作为触发信号并担当计数器的时钟源。\n\n#### 3.1.6. 一个示例\n\nQ：开启两个定时器，定时器2与定时器3，均作pwm输出，定时器3的pwm输出跟随定时器2的pwm输出。\n如何做才能又准又稳定还不占用cpu资源？\n\n大致思路：定时器2的ch2输出，并将ch2的OC2REF作为从定时器3的TRGO，并通过主从对应表，找到相应的ITRx，当出现上升沿或下降沿时，会触发从定时器的开启。应将定时器3配置为触发模式（Trigger Mode）\n\n#### 3.1.7. 参考\n\n- 👍👍👍[【话说定时器系列】之三：STM32定时器的信号触发与主从模式-电子工程世界](https://news.eeworld.com.cn/mcu/ic634774.html)\n- [stm32定时器从模式解析_stm32定时器主从模式-CSDN博客](https://blog.csdn.net/weixin_44748127/article/details/123726458)\n\n### 3.2. 编码器模式\n\n对于编码器模式，它是针对编码器应用的一个特定从模式，应用时注意使用定时器的通道1、通道2引进编码器脉冲，这里不赘述。\n\n\n### 3.3. 触发源\n\n![](Snipaste_2025-02-22_14-34-20.png)\n\n结合原理图，我们可以知道定时器可由触发源触发启动。\n\n\n### 3.4. 时钟源\n\n分为内部时钟和外部触发（外界其他信号源），不再赘诉。\n\n\n### 3.5. 主模式\n\n这是通道1的可配置功能：\n![](Snipaste_2025-02-22_15-02-04.png)\n![](Snipaste_2025-02-22_15-02-14.png)\n\n细讲一下\n#### 3.5.1. 比较与捕获\n\n捕获\n\n什么是捕获？\n\n所谓捕获就是通过检测捕获通道上的边沿信号。在边沿信号发生跳变（比如上升沿/下降沿）的时候，将当前定时器的值(TIMx_CNT)存放到对应的通道的捕获/比较寄存器(TIMx_CCR)里面，完成一次捕获。\n\nSTM32支持一下捕获模式：\n\n1. 输入捕获模式\n2. PWM输入模式\n\n输入捕获模式可以用来测量脉冲宽度或者测量频率。下图是输入捕获测量高电平脉宽的原理，假定定时器工作在向上计数模式，图中 t1~t2 时间，就是需要测量的高电平时间。\n![](20220309022442146.png)\n测量方法如下：首先设置定时器通道x为上升沿捕获，这样，t1 时刻，就会捕获到当前的 CNT 值，然后立即清零 CNT，并设置通道x下降沿捕获，这样到 t2 时刻，又会发生捕获事件，得到此时的 CNT 值，记为CCRx2。这样，根据定时器的计数频率，我们就可以算出 t1~t2 的时间，从而得到高电平脉宽。\n\n比较\n\n什么是比较？\n\n所谓比较就是计数器的值和与装载的值进行比较，**和外部的信号没关系**。\n\nSTM32支持一下比较模式：\n\n1. 强制输出模式\n2. 输出比较模式\n3. **PWM模式**\n4. 单脉冲模式\n\n### 3.6. 一些疑惑的地方\n\n#### 3.6.1. Q：`output compare no output`是什么模式？好矛盾的名字。。。\n\nA：`Output Compare No Output`意味着该定时器的输出比较（Output Compare）功能已经启用，但它不会实际输出到引脚上。具体来说，定时器的输出比较功能通常是用来生成定时信号（比如 PWM 或捕获信号）。如果你选择`Output Compare No Output`，这表示：\n\n1. **输出比较功能启用**：定时器仍然会根据设置的比较值（比如定时器计数器和比较寄存器的匹配）产生一个事件。\n2. **不输出到引脚**：虽然比较功能可以触发中断或设置状态，但是并没有配置定时器的输出引脚（比如一个 PWM 信号）去响应这些事件。这种配置适用于只需要定时器功能（比如触发中断）而不需要具体的硬件输出。\n\n`Output Compare No Output`就是配置定时器的输出比较功能，不去生成实际的引脚信号，可能只是用来**触发事件**或**控制中断**。\n\n#### 3.6.2. Q：输出比较和PWM生成模式有何区别与联系？\n\nA：输出比较（Output Compare）和 PWM 生成模式（PWM Generation Mode）虽然都依赖于定时器的输出比较功能，但它们的应用场景和工作方式有所不同。下面是它们之间的主要区别与联系：\n\n| **模式**    | **输出比较（Output Compare）**     | **PWM 生成模式（PWM Generation Mode）**                 |\n| --------- | ---------------------------- | ------------------------------------------------- |\n| **基本概念**  | 计数器的值与预设比较值比较，匹配时产生事件。       | 基于输出比较功能，周期性地生成脉宽调制（PWM）信号。计数器与比较值的关系决定引脚状态（高或低）。 |\n| **作用**    | 设置引脚状态或触发中断                  | 根据计数器值与比较值的关系周期性改变引脚状态。                           |\n| **用途**    | 触发定时器事件，控制外部硬件信号（如设置引脚为高或低）。 | 控制电机、LED亮度调节、电源管理等应用，需要调节占空比。                     |\n| **典型应用**  | 定时脉冲、事件触发、精确的定时控制            | 电机控制、LED亮度调节、信号调制                                 |\n| **周期性输出** | 否，输出比较通常产生单次信号或事件，不是周期性的。    | 是，生成周期性的波形。                                       |\n| **倾向目标**  | 生成事件（如中断）。                   | 生成周期性的波形信号。                                       |\n\n简而言之，输出比较更注重事件的触发，而PWM生成模式则专注于产生持续的周期性波形。\n\n#### 3.6.3. Q：何为强制输出？有啥用？\n\nA：强制输出模式（Forced Output Mode）是定时器的一种特殊输出控制模式，主要用于在定时器的某些条件下强制改变输出引脚的状态（例如设置为高或低）。这种模式可以在定时器产生的输出信号之外，强制控制引脚的状态。\n\n##### 3.6.3.1. 强制输出模式的工作原理：\n\n在强制输出模式下，定时器的输出信号不再完全依赖于定时器计数器和比较寄存器的常规操作（比如在 PWM 或输出比较模式下的信号波形）。你可以通过某些特定的条件或命令直接控制输出引脚的状态。例如，定时器可以在特定时刻将引脚强制设置为高或低状态。\n\t\n##### 3.6.3.2. 主要功能：\n\n- **强制设置输出引脚的状态**：在某些情况下，强制输出模式可以被用来直接控制输出引脚的状态，而无需依赖于定时器的正常计数和比较过程。\n- **安全控制和复位功能**：强制输出模式有时用于一些安全或复位操作，比如在硬件故障时通过强制输出信号来重置系统，或在特定条件下确保引脚处于某一状态。\n- **特定场景下的信号生成**：有时，强制输出模式被用来生成短暂的脉冲或特殊的状态，通常用于外部硬件的控制。\n\n##### 3.6.3.3. 工作模式：\n\n- **定时器强制输出高或低**：当定时器处于强制输出模式时，可以通过强制命令直接控制输出引脚状态，例如强制输出引脚保持高电平或低电平。\n- **常用的应用**：这种模式常用于一些特殊的信号要求，如在系统发生异常时通过定时器引脚来输出一个特定信号，以触发外部硬件或进行故障诊断。\n\n##### 3.6.3.4. 例子：\n\n在某些微控制器中，定时器的强制输出模式可以与“输出比较模式”结合使用，当定时器进入强制输出模式时，它会直接设置输出引脚为高或低，而不再受定时器的常规计数和比较值的控制。可以通过特定的触发条件或外部信号来激活强制输出模式，这通常用于控制需要在系统中立即做出响应的应用场景。**（通过软件切换）**\n\n##### 3.6.3.5. 总结：\n\n强制输出模式就是在特定情况下，强制定时器的输出引脚为高或低电平，忽略定时器的常规输出信号，常用于特殊的应用需求，如系统故障处理、硬件复位、特殊信号生成等。\n\n#### 3.6.4. Q：输入捕获的间接模式？\n\nA：间接模式较为复杂，捕获事件并不直接与计数器挂钩，而是通过某些条件或外部事件来触，具体来说，这种模式可能涉及定时器的某些附加功能（例如外部触发事件或特定的输入滤波器），这些功能可能会延迟捕获事件的实际记录。\n\n##### 3.6.4.1. 特点：\n\n- **间接捕获**：输入信号的变化并不是直接影响计数器，而是需要某些附加的条件或触发事件来保存捕获值。\n- **较复杂的控制逻辑**：非直接模式**可以结合更多外部事件和触发条件来决定何时捕获信号**，因此适用于更复杂的应用场景。\n- **滤波和去抖动**：非直接模式可以配合外部触发信号或滤波功能，适用于噪声较大的环境。\n\n##### 3.6.4.2. 以下是直接与非直接模式的比较\n\n| 特性        | 直接模式（Direct Mode）          | 非直接模式（Indirect Mode）    |\n| --------- | -------------------------- | ----------------------- |\n| **捕获方式**  | 信号变化直接触发捕获，捕获值立即存储         | 信号变化通过触发事件或附加条件触发捕获     |\n| **触发条件**  | 外部输入信号（上升沿/下降沿）直接触发捕获      | 外部事件、触发器或滤波器控制捕获事件的触发   |\n| **响应速度**  | 快速（通常实时捕获）                 | 相对较慢，可能需要额外条件来触发捕获      |\n| **应用场景**  | 适用于高频信号的实时捕获（如频率测量、脉冲宽度测量） | 适用于需要外部事件触发的场景，如外部信号同步等 |\n| **实现复杂度** | 简单，通常是硬件层面直接实现             | 需要额外的硬件配置和控制（如触发、滤波）    |\n\n#### 3.6.5. 参考\n\n- 👍👍👍ChatGPT\n- 👍👍👍[STM32-一文搞懂通用定时器捕获/比较通道-电子工程世界](https://news.eeworld.com.cn/mcu/ic565151.html)\n","tags":["STM32","CubeMX","嵌入式","Timer"],"categories":["嵌入式","CubeMX配置功能"]},{"title":"CubeMX配置功能系列：Timer（上）","url":"/posts/16836/","content":"<details>\n\n<summary>版权信息</summary>\n\n:::warning\n\n本文章为博主原创文章。遵循 [CC 4.0 BY-SA](https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans) 版权协议，转载请附上原文出处链接和本声明。\n\n:::\n\n</details>\n\n---\n\n## 目录\n- [目录](#目录)\n- [1. 说明](#1-说明)\n- [2. 界面总览](#2-界面总览)\n- [3. LPTIM：没用过，用过后补充](#3-lptim没用过用过后补充)\n  - [3.1. 介绍](#31-介绍)\n  - [3.2. 支持的模式](#32-支持的模式)\n  - [3.3. 参考](#33-参考)\n- [4. RTC：也不咋用，用时补充](#4-rtc也不咋用用时补充)\n  - [4.1. 什么是RTC](#41-什么是rtc)\n  - [4.2. 功能简介](#42-功能简介)\n  - [4.3. 参考](#43-参考)\n\n\n## 1. 说明\n\n本文以STM32G4系列为例。供自己学习与记录且只做简单介绍。有一定基础的朋友可参考。\n\n--- \n\n## 2. 界面总览\n\n打开Timer的配置界面如图：\n![](Snipaste_2025-02-06_18-21-03.png)\n\n## 3. LPTIM：没用过，用过后补充\n\n### 3.1. 介绍\n\nLPTIM 是一个 16 位定时器，顾名思义他就是可以实现低功耗应用的一个特殊定时器。由于时钟源的多样性，LPTIM 能够在除待机模式以外的所有电源模式下保持运行。 即使没有内部时钟源， LPTIM 也能运行，鉴于这一点，可将其用作“脉冲计数器”，这种脉冲计数器在某些应用中十分有用。此外， LPTIM还能将系统从低功耗模式唤醒，因此非常适合实现“超时功能”，而且功耗极低。\n\nLPTIM 引入了一个灵活的时钟方案，该方案能够提供所需的功能和性能，同时还能最大程度地降低功耗。\n\nLPTIM时基单元包含一个16位自动重载计数器ARR，一个16位的递增计数器CNT，一个3位可编程预分频器可以采用8种分频系数（1、2、4、8、16、32、64、128）， 预分频器时钟源有多种可选，有内部时钟源： LSE、 LSI、 HSI 或 APB 时钟、外部时钟ULPTIM输入的外部时钟源（在没有 LP 振荡器运行的情况下工作，由脉冲计数器应用使用）。\n\n### 3.2. 支持的模式\n\n![](Snipaste_2025-02-06_18-22-29.png)\n![](Snipaste_2025-02-06_18-23-44.png)\n\n- 计数器模式：计数器可用于计算来自 Input1 的外部事件或用于计算内部时钟周期\n- 单次模式：在此模式下，当满足匹配条件时，输出可以切换高低电平（如果输出极性配置为高，则为低电平至高电平变化，反之亦然）\n-  编码器模式\n此外还有\n- 单脉冲模式\n- PWM 模式 \n-  超时模式：有效的边沿触发输入可复位定时器。第一个触发事件将启动计时器，任何连续触发事件将重置计数器并重新开始。\n\n### 3.3. 参考\n[【玩转STM32】：低功耗定时器LPTIM应用_stm32 lptim-CSDN博客](https://blog.csdn.net/qq_42965739/article/details/113532039)\n[32. LPTIM—低功耗定时器 — [野火]STM32 HAL库开发实战指南——基于H743_Pro_V 文档](https://doc.embedfire.com/mcu/stm32/h743prov/hal/zh/latest/book/LPTIM.html)\n\n\n## 4. RTC：也不咋用，用时补充\n\n### 4.1. 什么是RTC\n\n**RTC (Real Time Clock)**：实时时钟\n\n**RTC是个独立的定时器**。RTC模块拥有一个连续计数的计数器，在相应的软件配置下，可以提供时钟日历的功能。修改计数器的值可以重新设置当前时间和日期 RTC还包含用于管理低功耗模式的自动唤醒单元。\n\n在断电情况下 RTC仍可以独立运行 只要芯片的备用电源一直供电,RTC上的时间会一直走。\n\nRTC实质是一个掉电后还继续运行的定时器,从定时器的角度来看,相对于通用定时器TIM外设,它的功能十分简单,只有计时功能(也可以触发中断)。但其高级指出也就在于掉电之后还可以正常运行。\n\n两个 32 位寄存器包含二进码十进数格式 (BCD) 的秒、分钟、小时（ 12 或 24 小时制）、星期几、日期、月份和年份。此外，还可提供二进制格式的亚秒值。系统可以自动将月份的天数补偿为 28、29（闰年）、30 和 31 天。\n\n上电复位后，所有RTC寄存器都会受到保护，以防止可能的非正常写访问。\n\n无论器件状态如何（运行模式、低功耗模式或处于复位状态），只要电源电压保持在工作范围内，RTC使不会停止工作。\n\n### 4.2. 功能简介\n\n![](Snipaste_2025-02-06_18-46-47.png)\n\n- **激活时钟源**：**一般选用LSE**，RTC设备因为其独特的运行方式（即掉电依旧运行）使用HSE分频时钟或者LSI的时候,在主电源VDD掉电的情况下,这两个时钟来源都会受到影响，资源消耗太大，小小的纽扣电池根本吃不消。没法保证RTC正常工作.所以RTC一般都时钟低速外部时钟LSE\n- **使能RTC日历**\n- **可编程的闹钟A/B**，如果设置了闹钟A/B的时间，则闹钟A/B设定时间会和当前日历时间对比，如果时间相等，会产生ALRA/BF事件\n- **周期唤醒**：可以使用RTC内部一个16位唤醒自动重载寄存器来实现，周期唤醒的时钟信号可以来自于更新日历的1Hz（ck_spre）信号，也可以使用RTC时钟的2/4/8/16分频后的时钟，设置该自动重载寄存器的值，**根据时钟频率向上计数，当计数溢出时发生周期唤醒事件**\n- **时间戳**\n- **Tamper**：入侵检测\n- **时钟校准**\n- **参考时钟检测？？？**\n\n### 4.3. </a>参考\n[How to calibrate the STM32's real-time clock (RTC) - STMicroelectronics Community](https://community.st.com/t5/stm32-mcus/how-to-calibrate-the-stm32-s-real-time-clock-rtc/ta-p/744958)\n[STM32CubeMX教程10 RTC 实时时钟 - 周期唤醒、闹钟A/B事件和备份寄存器_stm32cubemx rtc-CSDN博客](https://blog.csdn.net/lc_guo/article/details/135225854)\n[【STM32】RTC实时时钟，步骤超细详解，一文看懂RTC_rtc模块-CSDN博客](https://blog.csdn.net/as480133937/article/details/105026033)\n\n","tags":["STM32","CubeMX","嵌入式","Timer"],"categories":["嵌入式","CubeMX配置功能"]},{"title":"相机控色","url":"/posts/50403/","content":"\n教程及截图来自b站： https://www.bilibili.com/video/BV1DQiyYkEJC/\n\n---\n\n## 色温（K）\n\n- 色温高：呈现暖色，色温低：呈现冷色（与环境色温是反的）\n- ![](Snipaste_2025-01-21_22-20-26.png)\n- `偏色`：拍摄时由于光线干扰，色温等因素影响，使得物体本身色彩受到干扰\n\t- 矫正：将相机色温数值调到与环境色温数值相同\n- 一些推荐色温 #拍摄技巧 \n\t- 冰天雪地、蓝调、夜晚、天空：冷色调（under 5000k）\n\t- 冬日暖阳、温暖、黄沙：暖色调（up 6000k）\n\n## 白平衡（WB）\n\n- 校正环境偏色。![](Snipaste_2025-01-21_22-31-07.png)\n- **一般使用白平衡自动或者直接自己校正色温**\n- 感觉平常可以直接白平衡自动，后期调啊。。\n\n## 根据主导色确定画面色温\n\n- 如果主导色偏暖，可以往暖色调色温\n- 如果主导色偏冷，可以往冷色调色温，使画面更具**氛围**\n- 注意：照片也**不一定要偏冷和偏暖**，偏色用于营造氛围，有些作品需要保证不要偏色，还原真实色彩\n\n## 白平衡偏移\n\n![](Snipaste_2025-01-21_23-10-03.png)\n\n![](Snipaste_2025-01-21_23-11-23.png)\n\n- 两大作用：\n\t- 画面氛围渲染\n\t- 控制颜色偏移的程度：解决调整色温导致一些细节的色彩不对，例如色温过高导致人像泛红，调整白平衡偏移往红色**反方向调**。","tags":["摄影基础","学习笔记","相机控色","白平衡"],"categories":["摄影学习"]},{"title":"构图","url":"/posts/40301/","content":"# 第一个教程\n以下图片与教程来自b站： https://www.bilibili.com/video/BV1pv411H78e\n\n---\n\n## 构图的核心\n\n1. 确认画面主体或主题\n2. 去掉画面中与主体无关的元素\n3. **加入**突出主题或主题表达的元素并合理摆放（利用抽象出的几何线条）\n4. 成功表达想表达的内容\n\n## 如何选择合适的取景范围？\n\n还是根据主题或主题......不确定可以多多试一下\n\n## 让画面更加吸引人的方法\n\n- 利用人眼的视觉流动： \n\t- 视觉凝聚：明暗、鲜艳暗淡、对比色、重复元素\n\t\t- ![](Snipaste_2025-01-19_21-52-29.png)\n\t\t- ![](Snipaste_2025-01-19_21-53-32.png)\n\t\t- ![](Snipaste_2025-01-19_21-54-29.png)\n- 视觉引导：\n\t- 引导线\n\t\t- ![](Snipaste_2025-01-19_21-55-44.png)\n\t- 视线\n\t\t- ![](Snipaste_2025-01-19_21-56-10.png)\n\t- 视觉控制\n\t\t- ![](Snipaste_2025-01-19_21-57-23.png)\n\n## 常用的构图技巧（要和上面的技巧综合运用）\n\n- 三分\n\t- ![](Snipaste_2025-01-19_21-59-29.png)\n- 居中（对称） 拍摄比较庄严肃穆的物体\n\t- ![](Snipaste_2025-01-19_22-00-43.png)\n- 三角形\n\t- ![](Snipaste_2025-01-19_22-01-27.png)\n- 前中后景层次构图\n\t- ![](Snipaste_2025-01-19_22-02-21.png)\n\n## 画面的平衡\n\n- 活用三分法、对称法：根据情况调整\n- 留白处点缀\n\t- ![](Snipaste_2025-01-19_22-10-09.png)\n\n---\n\n# 第二个教程\n以下教程与图片来自： https://www.bilibili.com/video/BV1eZCzYUEKD 偏向于人像\n\n---\n\n## 第一阶段：形式的构图\n\n- 居中构图：突出主题但容易平淡\n- 三分法\n\t- ![](Snipaste_2025-01-19_22-13-39%201.png)\n- 对角线：有张力、有线条感，**表达主体的延申感**\n\t- ![](Snipaste_2025-01-19_22-14-45.png)\n- 对称：均匀协调，稳定\n- 框架构图（视觉控制）\n- 引导构图：利用线条去引导，要引导去主体，不是随便引导\n\t- ![](Snipaste_2025-01-19_22-17-14.png)\n- 三角构图：并不局限于一个，可以拼凑多个\n\t- ![](Snipaste_2025-01-19_22-18-18.png)\n**但是，一定不要生搬硬套！！！**\n以下是一些错误例子\n- 盲目套用，没有突出拍摄的主体\n\t- ![](Snipaste_2025-01-19_22-20-48.png)\n\t- ![](Snipaste_2025-01-19_22-22-00.png)\n- 盲目前后景\n\t- ![](Snipaste_2025-01-19_22-23-02.png)\n- 前景太大：淡化主体\n\t- ![](Snipaste_2025-01-19_22-23-51.png)\n\n## 第二阶段：结构构图\n\n- 分析画面：点线面的运用，一些元素不再是元素本身，而是引导观看主体的工具\n\n- 根据画面内容，合理安排画面中的每个元素 而不是生搬硬套\n- 当画面主体是人时，人面朝的方向和视线也是隐形的线条，合理运用能引导画面整体走向\n\n## 第三阶段：忘掉构图，专注于画面内容与主题，返璞归真\n\n![](Snipaste_2025-01-19_22-38-26.png)\n![](Snipaste_2025-01-19_22-39-01.png)\n![](Snipaste_2025-01-19_22-39-21.png)\n如下面图片：其主旨更加丰富，而构图不那么明显\n![](Snipaste_2025-01-19_22-41-51.png)\n\n## 总结\n\n说到底，构图还是服从画面与内容，照片的意义，有时候不需要华丽的构图技巧和形式，简单，真实，有意义，能让观看者产生共鸣就够了。\n","tags":["摄影基础","学习笔记","构图"],"categories":["摄影学习"]},{"title":"影调控制","url":"/posts/55817/","content":"以下图片与教程来自b站： https://www.bilibili.com/video/BV1pv411H78e\n\n---\n\n## 什么是影调\n\n - 画面中的明暗\n - ![](Snipaste_2025-01-21_16-45-24.png)\n- ![](Snipaste_2025-01-21_16-54-04.png)\n\n## 影调的量化\n\n- 测光标尺：向左，低调，向右，高调。\n\t- 测光模式\n\t\t- ![](Snipaste_2025-01-21_17-00-29.png)\n\t\t- 拍月亮可以用点测光\n- 直方图\n\t- **判断是否过曝、欠曝**：被截断。在某一方向突然陡增\n\t\t- ![](Snipaste_2025-01-21_17-03-12.png)\n\t-  直方图可以用于判断影调，例如：\n\t\t- ![](Snipaste_2025-01-21_17-06-14.png)\n\n## 数码时代的最佳曝光方式\n\n- **向右曝光，但不是过曝**\n\t- 为了记录更多的画面细节，而在后期可以进一步调整\n\t- 让直方图右侧尽量贴近右边缘但是**不被截断**\n\t- 可以加一点EV（曝光补偿）\n\t- ![](Snipaste_2025-01-21_17-11-27%201.png)\n\n## 大光比情况下，平衡光比的多种应对方式\n\n- 如何定义大光比情况\n\t- 明暗反差很大，可以理解为最亮和最暗的反差\n\t- ![](Snipaste_2025-01-21_17-19-56.png)\n\t- ![](Snipaste_2025-01-21_17-20-33.png)\n\t- ![](Snipaste_2025-01-21_17-21-18.png)\n- 不同情况下的应对方式\n\t- 平衡光比是符合**肉眼看到的直观感觉**，而不是没有光比\n\t1. `曝光合成` ：拍摄多张不同曝光区间下的照片，后期合成到一起\n\t\t- 照片内容需要保持一致，使用稳定拍摄\n\t\t- 一些照片保留暗部细节，另一些保留亮部细节，后期合成一张HDR照片\n\t\t- 相机里有一个阶段曝光连拍功能\n\t2. `宁欠勿过，后期提亮` ：前期适当向左曝光，保护高光细节，但是也可能导致暗部细节无法还原\n\t3. `补光` ：多用于人物\n\t4. `拍摄剪影` ","tags":["摄影基础","学习笔记","影调控制"],"categories":["摄影学习"]},{"title":"机位掌控","url":"/posts/5778/","content":"\n教程及截图来自b站： https://www.bilibili.com/video/BV1DQiyYkEJC/\n\n## 什么是机位\n\n简而言之相机的位置。相机与模特的三维位置\n\n## 三维\n\n### 高度\n\n- 平视机位\n\t- 取决于取景框上的**中心对焦点**，应与中心对焦点**持平**\n\t- 优势：\n\t\t- 相比高低机位，更具真实感  适合严谨的情境 如证件照、人文纪实。![](Snipaste_2025-01-19_20-36-03.png)\n\t\t- 更容易产生情感共鸣，利于情绪传达，如上图就是个很好的例子。**突出人物情绪的关键**：利用**近景或特写**![](Snipaste_2025-01-19_20-49-10.png)\n\t\t- 小技巧： #拍摄技巧 \n\t\t\t- 上面的照片也没有完全持平哦，可以把相机稍微拉高或拉低，更能表现情绪状态\n\t\t\t- 那么高到什么地方，低到什么地方呢？**上下15度范围，避免成为高低机位的视觉观感**\n\t- 劣势：\n\t\t- 效果不惊艳：不要拍远、全、中景\n\t- 进一步拔高：\n\t\t- 强化：搞清楚想要表达的主题，使用技巧强化它\n\t\t- 规避：可以把不好看的人物五官利用机位的变化规避掉 口诀：**近大远小**\n- 高机位\n- 低机位\n\n### 角度\n\n- 正面\n- 侧面\n- 背面\n\n### 距离\n取景范围（景别）\n- 远\n\t- 即远景拍摄\n\t- ![](Snipaste_2025-01-19_17-41-06.png)\n- 全\n\t- 主体完整呈现于画面， 人物占比大\n\t- ![](Snipaste_2025-01-19_17-43-05.png)\n- 中\n\t- 取景范围为人物的膝盖以上或胸部以下\n- 近\n\t- 取景范围为人物的胸部以上或肩部以下\n- 特\n\t- 特写","tags":["摄影基础","学习笔记","机位掌控"],"categories":["摄影学习"]},{"title":"markdown渲染器测试","url":"/posts/50034/","content":"\n@[TOC]\n\n# Markdown 测试文本\n\n## 标题2\n\n这是一个段落，下面是**加粗**和*斜体*文本的示例。\n\n### 列表\n\n- 项目1\n- 项目2\n  - 子项目2.1\n  - 子项目2.2\n- 项目3\n\n### 有序列表\n\n1. 第一项\n\n2. 第二项\n\n3. 第三项\n\n### 链接\n\n[点击这里访问OpenAI](https://www.openai.com)\n\n### 图片\n\n![OpenAI logo](https://openai.com/favicon.ico)\n\n### 代码块\n\n```python\ndef hello_world():\n    print(\"Hello, World!\")\n```\n\n### 引用\n\n> \"我爱吃香肠\"\n\n### 表格\n\n| 名称   | 年龄 | 职业  |\n|--------|------|-------|\n| Alice  | 28   | 医生  |\n| Bob    | 34   | 工程师 |\n| Carol  | 25   | 设计师 |\n\n### 划线\n\n~~我被划了~~\n\n### 其他\n\n<mark>划重点，标记</mark>\n\n<details>\n<summary>可收起文本</summary>\n这是可收起文本. 可以包含任意元素, 比如 **粗体**, *斜体*,代码块\n\n```python\nprint(\"Hello, World!\")\n```\n</details> \n\n!!防剧透!!\n\n- [ ] TODO List ！渲染失败\n\nH~2~0\nx^2^\n\n脚注测试[^1]\n\n[^1]: 这是一个脚注解释\n\n#### hexo-admonition\n\n!!! note Hexo-admonition 插件使用示例\n    这是基于 hexo-admonition 插件渲染的一条提示信息。类型为 note，并设置了自定义标题。\n    \n    提示内容开头留 4 个空格，可以有多行，最后用空行结束此标记。\n\n\n\n!!! warning \"\"\n     This is warning without title.\n\n!!! todo \n    This is todo.\n\n!!! error\n    This is error.\n\n\n####  ~~hexo-tips~~ \n\n<details>\n\n<summary>自2025.09.07起不再使用，改用 admonition。</summary>\n\n:::warning\nwarning\n:::\n     \n:::danger\ndanger\n:::\n    \n:::tip\ntip\n:::\n    \n:::mention\nmention\n:::\n   \n:::recommend\nrecommend\n:::   \n\n:::note\nnote\n:::    \n\n:::info\ninfo\n:::     \n\n:::success\nsuccess\n:::\n\n:::error\nerror\n:::    \n\n:::bug\nbug\n:::   \n\n:::todo\ntodo\n:::  \n\n:::example\nexample \n:::   \n\n:::quote\nquote\n::: \n\n:::link\nlink\n:::\n\n:::code\ncode\n:::\n\n:::update\nupdate\n:::\n\n:::star\nstar\n:::\n\n:::time\ntime\n:::  \n\n</details>\n\n# 标题大小对比\n## 2级\n### 3级\n#### 4级\n##### 5级\n###### 6级","tags":["博客"],"categories":["其他"]},{"title":"曝光三要素","url":"/posts/27350/","content":"\n教程及截图来自b站： https://www.bilibili.com/video/BV1DQiyYkEJC/\n\n## 认识快门\n\n- 快门：控制接收光线的时间 时间长，进光量大，画面亮。\n- 在M档、快门优先档（S档）控制。\n- **快门影响物体的动态模糊。**\n\t- 在快门打开关闭时间内，所拍摄物体没有足够时间移动，那么所拍摄物体时静止的\n\t- 相反，若物体是运动的，则会把运动轨迹记录起来。\n![](Snipaste_2025-01-19_11-59-54.png)\n\n### 安全快门\n\n- 能保证画面清晰所使用的最低快门速度（手持拍摄）\n- 具体数值为焦距的倒数，例如50mm焦距，安全快门为：1/50s\n\n- 一些常规题材快门速度推荐（常用调整值）： #拍摄技巧 \n\t- 人文题材 新闻报道  **快门常用 1/125s**\n\t- 行人，跑动的小孩   **快门常用 1/500s**\n\n### 高速快门\n\n- 画面亮度会降低，可以清晰的拍摄高速运动的物体\n- 限制：场景光线强，否则画面非常暗\n\n- 使用高速快门拍摄的题材 #拍摄技巧  \n\t- ![](Snipaste_2025-01-19_12-16-50.png)\n\n\t- ![](Snipaste_2025-01-19_12-27-34.png)\n\n### 低速快门\n\n- 曝光的时间较长，画面中运动的物体的主题会留下运行的轨迹，会变得模糊，**同时画面的亮度会被提高。**\n- 一般需要稳定拍摄，手持的抖动对画面影响大\n\n - 使用低速快门的题材 #拍摄技巧 \n\t - ![](Snipaste_2025-01-19_13-32-09.png)\n\t\t- 对于摇拍的补充：利用相对静止的原理，跟随运动物体进行平行移动，可以实现拍摄物体清晰，而其他背景模糊，同样也可以使用相机连拍功能实现该效果\n\t- 瀑布水流拉丝效果： **快门常用 5~10s** 配合减光镜稳定拍摄（三脚架）。或者调整光圈f/22左右\n\t- 车轨 烟花：**快门常用 5~10s** 稳定拍摄（三脚架）。调整光圈f/16配合。\n\n### 快门优先（TV/S）\n\n- 只需调整快门速度\n- 为满足日常的 风光拍摄 和 运动摄影\n\n### 练习\n1. 高速运动的物体\n2. 追焦拍摄（摇拍）\n3. 车轨\n\n![快门的选择](Snipaste_2025-01-19_17-05-08.png)\n\n---\n\n## 认识光圈\n\n- 控制进光量的装置\n\n### 光圈影响进光量\n\n- ![](Snipaste_2025-01-19_15-49-45.png)\n- 不同的曝光状态：欠曝、过曝\n- **光圈会和快门速度一起影响进光量**\n\n### 光圈影响景深\n\n- ![](Snipaste_2025-01-19_15-55-04.png)\n- 光圈的运用： #拍摄技巧 \n\t- **大光圈的跑焦问题**。使用超大光圈镜头时，最好不要使用最大光圈去拍，降低一个挡位。\n\t- 有时**主题突出**使用大光圈\n\t\t- ![](Snipaste_2025-01-19_16-00-53.png)\n\t- 拍人像时**不要一味的使用景深效果**（为了突出主题而突出主体）：需要结合环境，有些情况需要环境配合或交代环境\n\t\t- ![](Snipaste_2025-01-19_16-04-53.png)\n\t- 有时需要**全局清晰**使用小光圈 表现大环境\n\t\t- ![](Snipaste_2025-01-19_16-06-22.png)\n### 最佳画质光圈\n\n- 一般在最大光圈缩小2~3档位\n\n### 光圈优先（AV/A）\n\n- 手动调整光圈\n- 满足于日常的人像拍摄、静物拍摄\n\n### 练习\n\n- 虚化效果的小花\n\n---\n\n## 认识感光度（ISO）\n\n- 感光器件对光的敏感程度\n- 控制亮度和成片质量\n- 数值越大，感光度高，那么画面亮\n\n### ISO影响画质（噪点）\n\n- ![](Snipaste_2025-01-19_16-38-20.png)\n\n - 感光度的运用 #拍摄技巧 \n\t - **对于ISO，其作用相当于给你一盏灯，在黑暗环境下我们需要打开灯看清画面，灯的功率有不同的瓦数。**\n\t - 通常情况\n\t\t - ![](Snipaste_2025-01-19_16-41-30.png)\n\t - 过暗环境 ISO太高导致噪点\n\t\t - 兼顾画质和画面：**补光** 闪光灯、常亮灯\n\t\t - 画面优先：提高ISO\n\t- 想要复古感，想要噪点：主动提高ISO\n\n---\n\n## 曝光三要素的结合使用\n\n![](Snipaste_2025-01-19_17-03-48.png)\n\n### 在一个阳光灿烂的中午拍摄有虚化效果的小花\n\n- 首先光圈要大一点，才有虚化效果，静止物体，不需要高速或低速快门，室外阳光天气光线充足，ISO调到最小\n- f/1.8 1/500 100\n- 没有大光圈，怎么办 #拍摄技巧 \n\t- 主体离背景足够远，也会有虚化效果\n- 感觉可以使用光圈A优先。。\n\n### 拍摄人在夜晚跑步\n\n- 夜晚环境较暗，使用较大光圈提高进光量，但是太大会跑焦，拍摄运动的物体，快门spee的快一点，但是快门太快画面太暗，于是调高感光度\n- f/2.8 1/250 800\n- 个人感觉可以使用快门S优先。。\n","tags":["摄影基础","学习笔记","曝光三要素"],"categories":["摄影学习"]}]
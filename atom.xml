<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GoDm@&#39;s Blog</title>
  
  <subtitle>记录自己所爱。</subtitle>
  <link href="https://blog.godmao.top/atom.xml" rel="self"/>
  
  <link href="https://blog.godmao.top/"/>
  <updated>2025-09-10T08:47:26.680Z</updated>
  <id>https://blog.godmao.top/</id>
  
  <author>
    <name>GoDm@</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux-Process</title>
    <link href="https://blog.godmao.top/posts/43741/"/>
    <id>https://blog.godmao.top/posts/43741/</id>
    <published>2025-09-10T06:53:13.000Z</published>
    <updated>2025-09-10T08:47:26.680Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><div class="admonition info"><p>AI 辅助创作</p></div><p>在 Linux 编程中，<strong>进程（Process）</strong> 是操作系统分配资源和调度的基本单位。每个进程都有自己独立的内存空间、代码段、数据段和执行上下文。多个进程之间常常需要协作，这就涉及到 <strong>进程间通信（IPC, Inter-Process Communication）</strong>。本篇博客会系统介绍进程的基础操作，并对常见的 IPC 方式进行详细解释与示例，带你从零开始掌握。</p><hr /><h2 id="1-进程与-pid"><a class="markdownIt-Anchor" href="#1-进程与-pid"></a> 1. 进程与 PID</h2><p>每个进程都会有一个唯一的 <strong>进程号（PID）</strong>，可以通过 <code>getpid()</code> 获取当前进程号，通过 <code>getppid()</code> 获取父进程号。这在调试和进程管理时非常重要。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前进程PID=%d, 父进程PID=%d\n&quot;</span>, getpid(), getppid());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>⚠️ 注意：如果父进程先退出，子进程会被 <code>init</code> 进程接管，<code>ppid</code> 会变为 1。</p><hr /><h2 id="2-创建进程-fork"><a class="markdownIt-Anchor" href="#2-创建进程-fork"></a> 2. 创建进程 — <code>fork()</code></h2><p><code>fork()</code> 是创建新进程的主要方式。它会复制当前进程（父进程）的大部分内容，生成一个几乎一模一样的子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> pid = fork();<br></code></pre></td></tr></table></figure><ul><li><p><strong>在父进程中，<code>fork()</code> 返回子进程的 PID。</strong></p></li><li><p><strong>在子进程中，<code>fork()</code> 返回 0。</strong></p></li><li><p>如果失败，返回 -1。</p></li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[子进程] pid=%d, ppid=%d\n&quot;</span>, getpid(), getppid());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[父进程] pid=%d, 子进程pid=%d\n&quot;</span>, getpid(), pid);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        perror(<span class="hljs-string">&quot;fork 失败&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition caution"><p class="admonition-title">caution</p><ul><li><p>子进程不会继承父进程的所有资源，例如文件锁。</p></li><li><p><code>fork()</code> 之后，父子进程执行顺序不确定，需要通过 <code>wait()</code> 或其他机制控制。</p></li></ul></div><hr /><h2 id="3-程序替换-exec-系列"><a class="markdownIt-Anchor" href="#3-程序替换-exec-系列"></a> 3. 程序替换 — <code>exec()</code> 系列</h2><p>子进程常常需要运行一个新的程序，这就需要 <code>exec()</code> 系列函数（如 <code>execlp</code>, <code>execvp</code> 等）。<br /><code>exec</code> 系列函数的作用是：<strong>用新的程序替换当前进程的代码段</strong>，而进程的 PID、文件描述符（除非设置了 <code>FD_CLOEXEC</code>）等保持不变。它不会创建新进程，而是在当前进程内加载并运行新程序。</p><h3 id="常见函数"><a class="markdownIt-Anchor" href="#常见函数"></a> 常见函数</h3><p><code>exec</code> 系列一共有 6 个常用函数，主要区别在于 <strong>参数传递方式</strong> 和 <strong>是否依赖 PATH 环境变量</strong>。</p><table><thead><tr><th>函数</th><th>参数传递方式</th><th>是否搜索 PATH</th><th>说明</th></tr></thead><tbody><tr><td><code>execl(path, arg0, arg1, ..., NULL)</code></td><td>列表（逐个传参）</td><td>否</td><td>最常见，参数以不定长列表形式传递，最后必须以 <code>NULL</code> 结尾。</td></tr><tr><td><code>execv(path, argv[])</code></td><td>数组</td><td>否</td><td>参数通过字符串数组传递，方便动态构造参数。</td></tr><tr><td><code>execlp(file, arg0, arg1, ..., NULL)</code></td><td>列表</td><td>是</td><td>与 <code>execl</code> 类似，但会在 <code>PATH</code> 中搜索可执行文件。</td></tr><tr><td><code>execvp(file, argv[])</code></td><td>数组</td><td>是</td><td>与 <code>execv</code> 类似，但会在 <code>PATH</code> 中搜索可执行文件。</td></tr><tr><td><code>execle(path, arg0, arg1, ..., NULL, envp[])</code></td><td>列表</td><td>否</td><td>可以自定义环境变量，最后参数需提供 <code>envp</code>。</td></tr><tr><td><code>execve(path, argv[], envp[])</code></td><td>数组</td><td>否</td><td>最底层的系统调用，其它 <code>exec</code> 函数最终都调用它。</td></tr></tbody></table><p>说明：</p><ul><li><code>PATH</code>：系统环境变量</li><li><code>path</code>：要执行的程序路径（可以是绝对路径，也可以是相对路径）。</li><li><code>arg</code>：程序要输入的参数</li></ul><h3 id="使用示例"><a class="markdownIt-Anchor" href="#使用示例"></a> 使用示例</h3><ol><li><strong>execl：用绝对路径调用程序</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;     <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before exec\n&quot;</span>);     <br>execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>, <span class="hljs-literal">NULL</span>);     <br><span class="hljs-comment">// 只有 exec 调用失败时才会继续执行    </span><br>perror(<span class="hljs-string">&quot;execl failed&quot;</span>);     <br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>execvp：在 PATH 中搜索命令</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> *argv[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    execvp(<span class="hljs-string">&quot;ls&quot;</span>, argv);<br>    perror(<span class="hljs-string">&quot;execvp failed&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>execle：传入自定义环境变量</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> *envp[] = &#123;<span class="hljs-string">&quot;MYVAR=HelloExec&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    execl(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>, <span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-literal">NULL</span>, envp);<br>    perror(<span class="hljs-string">&quot;execle failed&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ul><li><p><code>exec</code> 系列 <strong>不会返回</strong>，除非调用失败。</p></li><li><p>若调用成功，原进程的代码和数据段会被新程序替换。</p></li><li><p><strong>文件描述符默认继承</strong>，可以用于在父进程中设置好管道/重定向，让子进程在 exec 后继续使用。</p></li><li><p>需要保证参数列表最后有 <code>NULL</code>，否则会引发不可预期错误。</p></li></ul><hr /><h2 id="4-等待子进程-wait-waitpid"><a class="markdownIt-Anchor" href="#4-等待子进程-wait-waitpid"></a> 4. 等待子进程 — <code>wait()</code> / <code>waitpid()</code></h2><p><strong>父进程需要回收子进程退出时的资源，否则子进程会成为 僵尸进程（Zombie）。</strong></p><p>这两个函数用于 <strong>父进程等待子进程结束</strong> 并<strong>回收资源</strong>，避免僵尸进程。</p><h3 id="1-wait"><a class="markdownIt-Anchor" href="#1-wait"></a> 1. wait()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *status)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>参数</strong></p><ul><li><code>status</code>：指向整数的指针，用于存储子进程退出状态。如果不关心状态，可以传 <code>NULL</code>。</li></ul></li><li><p><strong>返回值</strong></p><ul><li><p>成功：返回结束的子进程 PID</p></li><li><p>失败：返回 -1（例如没有子进程存在时）</p></li></ul></li><li><p><strong>使用示例</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child running...\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-type">int</span> status;<br>        <span class="hljs-type">pid_t</span> cpid = wait(&amp;status); <span class="hljs-comment">// 等待子进程</span><br>        <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123;   <span class="hljs-comment">// 判断是否正常退出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child %d exited with code %d\n&quot;</span>, cpid, WEXITSTATUS(status));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition caution"><p class="admonition-title">caution</p><ul><li><p><code>wait()</code> 会阻塞父进程，直到任意一个子进程退出。</p></li><li><p>如果父进程没有子进程，返回 -1 并设置 <code>errno = ECHILD</code>。</p></li></ul></div><h3 id="2-waitpid"><a class="markdownIt-Anchor" href="#2-waitpid"></a> 2. waitpid()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *status, <span class="hljs-type">int</span> options)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>参数</strong></p><ul><li><p><code>pid</code>：</p><ul><li><p><code>&gt;0</code> ：等待指定 PID 的子进程</p></li><li><p>-1 ：等待任意子进程（功能类似 <code>wait()</code>）</p></li><li><p>0 ：等待与调用进程同组的任意子进程</p></li><li><p>&lt;-1：等待进程组 ID = |pid| 的任意子进程</p></li></ul></li><li><p><code>status</code>：指向整数的指针，用于保存退出状态</p></li><li><p><code>options</code>：控制函数行为，常用值：</p><ul><li><p><code>0</code>：阻塞等待（默认行为）</p></li><li><p><code>WNOHANG</code>：非阻塞，如果没有子进程退出立即返回 0</p></li><li><p><code>WUNTRACED</code>：返回被暂停的子进程（收到 SIGSTOP）</p></li><li><p><code>WCONTINUED</code>：返回继续运行的子进程（收到 SIGCONT）</p></li></ul></li></ul></li><li><p><strong>返回值</strong></p><ul><li><p>成功：返回子进程 PID</p></li><li><p>非阻塞且没有子进程退出：返回 0</p></li><li><p>失败：返回 -1，并设置 <code>errno</code></p></li></ul></li><li><p><strong>使用示例</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-type">int</span> status;<br>        <span class="hljs-type">pid_t</span> cpid;<br>        <span class="hljs-keyword">while</span> ((cpid = waitpid(pid, &amp;status, WNOHANG)) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child still running...\n&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child %d exited with code %d\n&quot;</span>, cpid, WEXITSTATUS(status));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><div class="admonition caution"><p class="admonition-title">caution</p><ul><li><p><code>waitpid()</code> 可以实现 <strong>非阻塞等待</strong>，适合父进程同时管理多个子进程。</p></li><li><p><code>WIFEXITED(status)</code> 判断子进程是否正常退出。</p></li><li><p><code>WIFSIGNALED(status)</code> 判断子进程是否被信号终止。</p></li><li><p>使用 <code>waitpid()</code> 可以精准回收指定子进程，避免僵尸进程积累。</p></li></ul></div><div class="admonition note"><p class="admonition-title">tips</p><ul><li><p>父进程只需要等待任意子进程 → 用 <code>wait()</code> 即可。</p></li><li><p>父进程需要精确控制或非阻塞 → 用 <code>waitpid()</code>。</p></li><li><p>调用前一定要理解 <strong>阻塞 vs 非阻塞</strong>，避免父进程被卡住。</p></li></ul></div><hr /><h2 id="5-进程退出-exit-与-_exit"><a class="markdownIt-Anchor" href="#5-进程退出-exit-与-_exit"></a> 5. 进程退出 — <code>exit()</code> 与 <code>_exit()</code></h2><ul><li><p><code>exit()</code>：会刷新缓冲区，执行清理函数。</p></li><li><p><code>_exit()</code>：立即退出，不做清理，通常在子进程 <code>fork()</code> 后的错误处理中使用。</p></li></ul><p>⚠️ 区别：<code>exit()</code> 适合普通退出，<code>_exit()</code> 适合在 <code>fork()</code> 后不希望影响父进程的环境时使用。</p><div class="admonition caution"><p class="admonition-title">caution</p><ul><li>子进程执行退出函数后，子进程结束并变为僵尸🧟，内核保留子进程在进程表中的部分信息（PID、退出码等）占用少量系统资源，但不会再运行。需要父进程调用wait释放子进程资源，净化僵尸，释放灵魂👻</li></ul></div><hr /><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="内核" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="进程" scheme="https://blog.godmao.top/Tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux C标准IO操作</title>
    <link href="https://blog.godmao.top/posts/45385/"/>
    <id>https://blog.godmao.top/posts/45385/</id>
    <published>2025-09-09T12:54:03.000Z</published>
    <updated>2025-09-09T12:58:06.832Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h1 id="c-标准库-io-函数基于-stdioh"><a class="markdownIt-Anchor" href="#c-标准库-io-函数基于-stdioh"></a> 📌 C 标准库 I/O 函数（基于 <code>&lt;stdio.h&gt;</code>）</h1><h2 id="1-打开和关闭文件"><a class="markdownIt-Anchor" href="#1-打开和关闭文件"></a> 1. 打开和关闭文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br>FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span>; <br><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">(FILE *stream)</span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>fopen 参数 mode 常用值：</strong></p><ul><li><p><code>&quot;r&quot;</code>：只读（文件必须存在）</p></li><li><p><code>&quot;w&quot;</code>：只写（不存在则创建，存在则清空）</p></li><li><p><code>&quot;a&quot;</code>：追加写（不存在则创建）</p></li><li><p><code>&quot;r+&quot;</code>：读写（必须存在）</p></li><li><p><code>&quot;w+&quot;</code>：读写（不存在则创建，存在则清空）</p></li><li><p><code>&quot;a+&quot;</code>：读写（追加模式）</p></li></ul></li></ul><hr /><h2 id="2-读写字符"><a class="markdownIt-Anchor" href="#2-读写字符"></a> 2. 读写字符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *stream)</span>;     <span class="hljs-comment">// 读取一个字符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *stream)</span>;  <span class="hljs-comment">// 写入一个字符</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> c = fgetc(fp);<br>fputc(<span class="hljs-string">&#x27;A&#x27;</span>, fp);<br></code></pre></td></tr></table></figure><hr /><h2 id="3-读写字符串"><a class="markdownIt-Anchor" href="#3-读写字符串"></a> 3. 读写字符串</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> size, FILE *stream)</span>; <span class="hljs-comment">// 读取一行（最多 size-1 个字符） </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, FILE *stream)</span>;       <span class="hljs-comment">// 写入字符串</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>]; fgets(buf, <span class="hljs-keyword">sizeof</span>(buf), fp); <br><span class="hljs-built_in">fputs</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>, fp);<br></code></pre></td></tr></table></figure><hr /><h2 id="4-格式化-io"><a class="markdownIt-Anchor" href="#4-格式化-io"></a> 4. 格式化 I/O</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;  <span class="hljs-comment">// 格式化输出到文件 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;   <span class="hljs-comment">// 格式化读取</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;name=%s age=%d\n&quot;</span>, <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">20</span>); <br><span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%s %d&quot;</span>, name, &amp;age);<br></code></pre></td></tr></table></figure><hr /><h2 id="5-块读写适合二进制文件"><a class="markdownIt-Anchor" href="#5-块读写适合二进制文件"></a> 5. 块读写（适合二进制文件）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fread</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>; <br><span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, FILE *stream)</span>;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> data[<span class="hljs-number">10</span>]; fwrite(data, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), <span class="hljs-number">10</span>, fp); <span class="hljs-comment">// 写10个整数 </span><br>fread(data, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>), <span class="hljs-number">10</span>, fp);  <span class="hljs-comment">// 读10个整数</span><br></code></pre></td></tr></table></figure><hr /><h2 id="6-文件定位"><a class="markdownIt-Anchor" href="#6-文件定位"></a> 6. 文件定位</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE *stream, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> whence)</span>;  <span class="hljs-comment">// 移动文件指针</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">ftell</span><span class="hljs-params">(FILE *stream)</span>;                         <span class="hljs-comment">// 获取当前位置 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">rewind</span><span class="hljs-params">(FILE *stream)</span>;                        <span class="hljs-comment">// 回到开头`</span><br></code></pre></td></tr></table></figure><p><code>whence</code> 可取：</p><ul><li><p><code>SEEK_SET</code>：文件开头</p></li><li><p><code>SEEK_CUR</code>：当前位置</p></li><li><p><code>SEEK_END</code>：文件末尾</p></li></ul><hr /><h2 id="7-缓冲刷新"><a class="markdownIt-Anchor" href="#7-缓冲刷新"></a> 7. 缓冲刷新</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fflush</span><span class="hljs-params">(FILE *stream)</span>;  <span class="hljs-comment">// 强制把缓冲区写入文件</span><br></code></pre></td></tr></table></figure><p>常用于写日志，避免异常退出时丢数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="IO" scheme="https://blog.godmao.top/Tags/IO/"/>
    
    <category term="内核" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统IO编程</title>
    <link href="https://blog.godmao.top/posts/7076/"/>
    <id>https://blog.godmao.top/posts/7076/</id>
    <published>2025-09-09T05:15:16.000Z</published>
    <updated>2025-09-09T13:04:05.999Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="文件描述符内核分发的身份证"><a class="markdownIt-Anchor" href="#文件描述符内核分发的身份证"></a> 文件描述符：内核分发的身份证</h2><p>在 Linux 系统中，<strong>文件描述符（File Descriptor，简称 FD）是一个核心概念，它是一个非负整数</strong>，用于唯一标识一个已打开的文件。这个文件可以是普通文件、目录、网络套接字（socket），甚至是设备（如键盘、显示器）。</p><p>文件描述符的设计主要有以下几个优点：</p><ol><li><p><strong>简化了 I/O 接口</strong>：无论是读写本地文件，还是进行网络通信，开发者都可以使用一套统一的系统调用（<code>read</code>, <code>write</code>, <code>close</code> 等），而无需关心底层的具体类型。这种“一切皆文件”的设计哲学是 Linux 简洁和强大的体现。</p></li><li><p><strong>隔离了应用程序与内核</strong>：应用程序只知道一个简单的整数，而不需要知道文件在磁盘上的物理位置，也不用关心内核是如何管理文件的。所有复杂的操作都由内核在幕后完成。</p></li><li><p><strong>管理系统资源</strong>：内核通过文件描述符表来管理每个进程打开的文件。当一个进程结束时，内核可以根据这个表自动关闭所有打开的文件，避免资源泄露。</p></li></ol><p>文件描述符的几个重要特点：</p><ul><li><p><strong>唯一性</strong>：在一个进程中，每个打开的文件都有一个独一无二的文件描述符。</p></li><li><p><strong>非负整数</strong>：文件描述符的值通常从 3 开始分配，因为 0、1、2 这三个描述符被系统预留给标准输入、标准输出和标准错误。</p><ul><li><p><strong>0</strong>：标准输入（<code>stdin</code>），通常是键盘。</p></li><li><p><strong>1</strong>：标准输出（<code>stdout</code>），通常是显示器。</p></li><li><p><strong>2</strong>：标准错误（<code>stderr</code>），也通常是显示器。</p></li></ul></li><li><p><strong>进程私有</strong>：文件描述符是在进程内部使用的，不同进程的文件描述符互不影响。例如，进程 A 的文件描述符 3 和进程 B 的文件描述符 3 可能指向完全不同的文件。</p></li></ul><h2 id="最基础的系统调用函数"><a class="markdownIt-Anchor" href="#最基础的系统调用函数"></a> 最基础的系统调用函数</h2><p><strong>Linux I/O 编程中常见的系统调用函数</strong>，这些函数位于 <strong><code>unistd.h</code></strong>（以及 <code>fcntl.h</code> 等）中，是用户态和内核态交互的基础接口。</p><h3 id="1-open"><a class="markdownIt-Anchor" href="#1-open"></a> 1. <code>open</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span>    <span class="hljs-comment">// open flags</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><h4 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h4><p>打开或创建一个文件，返回一个 <strong>文件描述符</strong>（fd，整数），后续 I/O 都依赖它。</p><h4 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h4><ul><li><p><code>pathname</code>：文件路径。</p></li><li><p><code>flags</code>：打开方式，常用值：</p><ul><li><p><code>O_RDONLY</code>：只读</p></li><li><p><code>O_WRONLY</code>：只写</p></li><li><p><code>O_RDWR</code>：读写</p></li><li><p><code>O_CREAT</code>：若文件不存在则创建，需要配合 <code>mode</code> 参数</p></li><li><p><code>O_TRUNC</code>：打开时清空文件</p></li><li><p><code>O_APPEND</code>：写时追加到文件尾部</p></li><li><p><code>O_NOBLOCK</code>：非阻塞模式</p></li></ul></li><li><p><code>mode</code>：创建文件时的权限（如 <code>0666</code>，受 umask 影响）。</p></li></ul><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h4><ul><li><p>成功：文件描述符（非负整数）</p></li><li><p>失败：<code>-1</code>，并设置 <code>errno</code></p></li></ul><hr /><h3 id="2-write"><a class="markdownIt-Anchor" href="#2-write"></a> 2. <code>write</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><h4 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2"></a> 作用</h4><p>向文件（或设备）写入数据。</p><h4 id="参数-2"><a class="markdownIt-Anchor" href="#参数-2"></a> 参数</h4><ul><li><p><code>fd</code>：文件描述符</p></li><li><p><code>buf</code>：要写入的数据缓冲区指针</p></li><li><p><code>count</code>：要写入的字节数</p></li></ul><h4 id="返回值-2"><a class="markdownIt-Anchor" href="#返回值-2"></a> 返回值</h4><ul><li><p>成功：实际写入的字节数（可能小于 <code>count</code>）</p></li><li><p>失败：<code>-1</code></p></li></ul><h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4><ul><li><p>对于普通文件，通常会写入全部数据。</p></li><li><p>对于管道、socket 等，可能分多次写入，需要循环写。</p></li></ul><hr /><h3 id="3-read"><a class="markdownIt-Anchor" href="#3-read"></a> 3. <code>read</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br>  <br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><h4 id="作用-3"><a class="markdownIt-Anchor" href="#作用-3"></a> 作用</h4><p>从文件（或设备）读取数据。</p><h4 id="参数-3"><a class="markdownIt-Anchor" href="#参数-3"></a> 参数</h4><ul><li><p><code>fd</code>：文件描述符</p></li><li><p><code>buf</code>：存放读出数据的缓冲区</p></li><li><p><code>count</code>：最大读取字节数</p></li></ul><h4 id="返回值-3"><a class="markdownIt-Anchor" href="#返回值-3"></a> 返回值</h4><ul><li><p>成功：实际读取的字节数</p><ul><li><code>0</code> 表示到达文件结尾 (EOF)</li></ul></li><li><p>失败：<code>-1</code></p></li></ul><h4 id="注意-2"><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h4><ul><li><p>实际读取字节数可能小于 <code>count</code>。</p></li><li><p>对于阻塞 I/O，如果没有数据，可能会挂起等待。</p></li></ul><hr /><h3 id="4-lseek"><a class="markdownIt-Anchor" href="#4-lseek"></a> 4. <code>lseek</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span>  </span><br><br><span class="hljs-type">off_t</span> <span class="hljs-title function_">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset, <span class="hljs-type">int</span> whence)</span>;<br></code></pre></td></tr></table></figure><h4 id="作用-4"><a class="markdownIt-Anchor" href="#作用-4"></a> 作用</h4><p>移动文件读写位置（文件指针）。</p><h4 id="参数-4"><a class="markdownIt-Anchor" href="#参数-4"></a> 参数</h4><ul><li><p><code>fd</code>：文件描述符</p></li><li><p><code>offset</code>：偏移量（可正可负）</p></li><li><p><code>whence</code>：偏移起始点</p><ul><li><p><code>SEEK_SET</code>：从文件开头</p></li><li><p><code>SEEK_CUR</code>：从当前位置</p></li><li><p><code>SEEK_END</code>：从文件末尾</p></li></ul></li></ul><h4 id="返回值-4"><a class="markdownIt-Anchor" href="#返回值-4"></a> 返回值</h4><ul><li><p>成功：新的文件偏移位置</p></li><li><p>失败：<code>-1</code></p></li></ul><h4 id="注意-3"><a class="markdownIt-Anchor" href="#注意-3"></a> 注意</h4><ul><li><p>常用来实现随机读写。</p></li><li><p>对某些设备文件可能不支持（如管道）。</p></li></ul><hr /><h3 id="5-close"><a class="markdownIt-Anchor" href="#5-close"></a> 5. <code>close</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br></code></pre></td></tr></table></figure><h4 id="作用-5"><a class="markdownIt-Anchor" href="#作用-5"></a> 作用</h4><p>关闭一个打开的文件描述符，释放内核资源。</p><h4 id="参数-5"><a class="markdownIt-Anchor" href="#参数-5"></a> 参数</h4><ul><li><code>fd</code>：文件描述符</li></ul><h4 id="返回值-5"><a class="markdownIt-Anchor" href="#返回值-5"></a> 返回值</h4><ul><li><p>成功：<code>0</code></p></li><li><p>失败：<code>-1</code></p></li></ul><h2 id="常见函数查找表"><a class="markdownIt-Anchor" href="#常见函数查找表"></a> 常见函数查找表</h2><table><thead><tr><th>函数</th><th>头文件</th><th>功能</th><th>主要参数</th><th>返回值</th><th>常见用途</th></tr></thead><tbody><tr><td><code>open</code></td><td><code>&lt;fcntl.h&gt;</code>, <code>&lt;unistd.h&gt;</code></td><td>打开或创建文件，返回文件描述符</td><td><code>pathname</code>：路径<code>flags</code>：打开方式（如 <code>O_RDONLY</code>）<code>mode</code>：权限（如 <code>0644</code>，仅在 <code>O_CREAT</code> 时有效）</td><td>成功：文件描述符 (≥0)失败：<code>-1</code></td><td>打开文件/设备，获得 <code>fd</code></td></tr><tr><td><code>write</code></td><td><code>&lt;unistd.h&gt;</code></td><td>向文件写入数据</td><td><code>fd</code>：文件描述符<code>buf</code>：数据缓冲区<code>count</code>：要写入字节数</td><td>成功：实际写入字节数失败：<code>-1</code></td><td>向文件、管道、socket 写数据</td></tr><tr><td><code>read</code></td><td><code>&lt;unistd.h&gt;</code></td><td>从文件读取数据</td><td><code>fd</code>：文件描述符<code>buf</code>：存放数据的缓冲区<code>count</code>：最大读取字节数</td><td>成功：实际读取字节数<code>0</code>：文件结尾失败：<code>-1</code></td><td>读取文件、键盘输入、网络数据</td></tr><tr><td><code>lseek</code></td><td><code>&lt;unistd.h&gt;</code></td><td>改变文件读写位置（文件指针）</td><td><code>fd</code>：文件描述符<code>offset</code>：偏移量<code>whence</code>：参考位置（<code>SEEK_SET</code>/<code>SEEK_CUR</code>/<code>SEEK_END</code>）</td><td>成功：新的偏移位置失败：<code>-1</code></td><td>随机读写文件、获取文件大小</td></tr><tr><td><code>close</code></td><td><code>&lt;unistd.h&gt;</code></td><td>关闭文件描述符，释放资源</td><td><code>fd</code>：文件描述符</td><td>成功：<code>0</code>失败：<code>-1</code></td><td>程序结束或文件不再使用时关闭</td></tr><tr><td><code>sync</code></td><td><code>&lt;unistd.h&gt;</code></td><td>将内核缓冲区中所有修改过的数据（脏页）写入磁盘</td><td>无</td><td>无返回值</td><td>全局刷新，影响所有文件，效率较低</td></tr><tr><td><code>fsync</code></td><td><code>&lt;unistd.h&gt;</code></td><td>将指定文件的缓存数据强制写入磁盘</td><td><code>fd</code>：文件描述符</td><td>成功：<code>0</code>，失败：<code>-1</code></td><td>精确到单个文件，常用于数据库、日志写入</td></tr><tr><td><code>pipe</code></td><td><code>&lt;unistd.h&gt;</code></td><td>创建匿名管道，用于进程间通信</td><td><code>int pipefd[2]</code></td><td>成功：0，失败：-1</td><td><code>pipefd[0]</code> 读端，<code>pipefd[1]</code> 写端</td></tr><tr><td><code>unlink</code></td><td><code>&lt;unistd.h&gt;</code></td><td>删除一个文件（目录用 <code>rmdir</code>）</td><td><code>pathname</code>：文件路径</td><td>成功：0，失败：-1</td><td>实际删除在引用计数归零时发生</td></tr><tr><td><code>access</code></td><td><code>&lt;unistd.h&gt;</code></td><td>检查文件是否存在及权限</td><td><code>pathname, mode</code></td><td>成功：0，失败：-1</td><td><code>mode</code> 可取 <code>R_OK, W_OK, X_OK, F_OK</code></td></tr></tbody></table><h2 id="对比c-标准库io操作"><a class="markdownIt-Anchor" href="#对比c-标准库io操作"></a> 对比C 标准库IO操作</h2><p>使用c标准库的IO操作，小量频繁读写的效率更高，因为其内部自带有缓冲区。<br />这可以理解为在系统IO上有封装了一层，进行文件操作时写入C自带缓冲区，满足一定条件再调用系统IO，将缓冲区的内容写入IO缓存区，再到内核的页缓存区，最后到物理的磁盘。</p><table><thead><tr><th>特性</th><th>Linux 系统调用 I/O</th><th>C 标准库文件操作</th></tr></thead><tbody><tr><td><strong>头文件</strong></td><td><code>&lt;unistd.h&gt;</code>, <code>&lt;fcntl.h&gt;</code></td><td><code>&lt;stdio.h&gt;</code></td></tr><tr><td><strong>函数示例</strong></td><td><code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code>, <code>close</code></td><td><code>fopen</code>, <code>fread</code>, <code>fwrite</code>, <code>fseek</code>, <code>fclose</code>, <code>fprintf</code>, <code>fscanf</code></td></tr><tr><td><strong>返回值</strong></td><td>直接返回字节数、文件描述符等，或 <code>-1</code></td><td>返回 <code>FILE*</code> 指针，或 <code>EOF</code> 等错误码</td></tr><tr><td><strong>数据单位</strong></td><td>以 <strong>字节（byte）</strong> 为单位</td><td>以 <strong>缓冲区 / 结构化数据</strong> 为单位（有缓冲机制）</td></tr><tr><td><strong>缓冲</strong></td><td><strong>无用户态缓冲</strong>，直接在用户空间和内核空间间传递数据</td><td><strong>带缓冲区</strong>（stdio 库内部维护缓存，加速小块读写）</td></tr><tr><td><strong>层次</strong></td><td>操作系统内核提供的 <strong>底层接口</strong></td><td>基于系统调用的 <strong>封装库函数</strong></td></tr><tr><td><strong>灵活性</strong></td><td>可操作普通文件、设备文件、socket、管道</td><td>主要操作普通文件和标准输入输出</td></tr><tr><td><strong>可移植性</strong></td><td>偏向 Unix/Linux 系统</td><td>跨平台（符合 ANSI C 标准，Windows/Linux 通用）</td></tr><tr><td><strong>典型用途</strong></td><td>驱动开发、系统编程、精确控制 I/O</td><td>应用层文件读写、文本处理、快速开发</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="IO" scheme="https://blog.godmao.top/Tags/IO/"/>
    
    <category term="内核" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>MakeFile简明指南</title>
    <link href="https://blog.godmao.top/posts/4341/"/>
    <id>https://blog.godmao.top/posts/4341/</id>
    <published>2025-09-07T13:48:09.000Z</published>
    <updated>2025-09-08T14:42:12.627Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><p>在软件开发中，项目通常包含很多源文件，如果每次编译都手动敲命令，不仅繁琐，还容易出错。<br /><strong>Makefile</strong> 可以帮助我们自动化构建流程，大幅提升效率。本文将介绍 Makefile 的基础语法与常用用法。</p><hr /><ul><li><a href="#1-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">1. 基础用法</a></li><li><a href="#2-%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%911">2. 执行逻辑^1</a><ul><li><a href="#21--%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE">2.1. 🔄 执行流程示意图</a></li></ul></li><li><a href="#3-%E4%BC%AA%E7%9B%AE%E6%A0%87-phony">3. 伪目标 .PHONY</a></li><li><a href="#4-%E5%8F%98%E9%87%8F">4. 变量</a><ul><li><a href="#41-%E8%B5%8B%E5%80%BC%E7%AC%A6%E5%8F%B7">4.1. 赋值符号</a></li></ul></li><li><a href="#5-%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6">5. 隐含规则与通配符</a></li><li><a href="#6-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF">6. 条件分支</a><ul><li><a href="#61-%E8%AF%AD%E6%B3%95">6.1. 语法</a></li><li><a href="#62-%E7%A4%BA%E4%BE%8B%E4%B8%80%E6%A0%B9%E6%8D%AE%E5%B9%B3%E5%8F%B0%E9%80%89%E6%8B%A9clean%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F">6.2. 示例一：根据平台选择clean执行方式</a></li><li><a href="#63-%E7%A4%BA%E4%BE%8B%E4%BA%8C%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F">6.3. 示例二：调试模式与发布模式</a></li></ul></li><li><a href="#7-%E5%87%BD%E6%95%B0">7. 函数</a><ul><li><a href="#71-subst--%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2">7.1. <code>subst</code> —— 字符串替换</a></li><li><a href="#72-patsubst--%E6%A8%A1%E5%BC%8F%E6%9B%BF%E6%8D%A2">7.2. <code>patsubst</code> —— 模式替换</a></li><li><a href="#73-wildcard--%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8">7.3. <code>wildcard</code> —— 获取文件列表</a></li><li><a href="#74-notdir--%E5%8E%BB%E6%8E%89%E8%B7%AF%E5%BE%84%E5%8F%AA%E4%BF%9D%E7%95%99%E6%96%87%E4%BB%B6%E5%90%8D">7.4. <code>notdir</code> —— 去掉路径，只保留文件名</a></li><li><a href="#75-dir--%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E9%83%A8%E5%88%86">7.5. <code>dir</code> —— 获取路径部分</a></li><li><a href="#76-basename--addsuffix-%E5%92%8C-addprefix--%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E5%90%8D">7.6. <code>basename</code> 、 <code>addsuffix</code> 和 <code>addprefix</code> —— 批量处理文件名</a></li><li><a href="#77-shell--%E6%89%A7%E8%A1%8C-shell-%E5%91%BD%E4%BB%A4">7.7. <code>shell</code> —— 执行 shell 命令</a></li></ul></li><li><a href="#8-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F">8. 完整示例程序</a></li></ul><h2 id="1-基础用法"><a class="markdownIt-Anchor" href="#1-基础用法"></a> 1. 基础用法</h2><p>一个典型的规则格式如下：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-section">target: dependencies</span><br>&lt;TAB&gt; command<br></code></pre></td></tr></table></figure><ul><li>target：目标文件，比如可执行文件或中间文件。</li><li>dependencies：依赖文件（源文件、头文件等）。</li><li>command：生成目标所需要执行的命令（必须以 TAB 缩进 开头）。</li></ul><p>示例：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-section">main.o: main.c</span><br>gcc -c main.c -o main.o<br></code></pre></td></tr></table></figure><div class="admonition warning"><p class="admonition-title">warning</p><p>由于makfile对空格、tab极其敏感，建议编写时打开编辑器的空格、tab显示，并避免不必要的空格，规范化书写。</p></div><h2 id="2-执行逻辑"><a class="markdownIt-Anchor" href="#2-执行逻辑"></a> 2. 执行逻辑<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2><p>当我们执行 <code>make</code> 时，大致流程如下：</p><ol><li><p><strong>解析 Makefile</strong></p><ul><li><code>make</code> 会从当前目录寻找 <code>Makefile</code> 或 <code>makefile</code> 文件。</li><li>读取其中的规则、变量、伪目标等定义。</li></ul></li><li><p><strong>确定默认目标</strong></p><ul><li>一般是文件中的第一个目标（例如 <code>app</code>）。</li><li>也可以通过命令行指定，例如：</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make clean<br></code></pre></td></tr></table></figure><ol start="3"><li><p><strong>检查依赖关系</strong></p><ul><li>从目标开始，逐层检查依赖文件是否存在、是否比目标文件更新。</li><li>如果依赖文件比目标文件“新”，说明目标需要重新生成。</li></ul></li><li><p><strong>执行命令</strong></p><ul><li>对需要更新的目标，执行其规则中定义的命令。</li><li>命令必须以 <strong>TAB 缩进</strong> 开头。</li></ul></li><li><p><strong>递归构建</strong></p><ul><li>如果依赖文件本身也是其他规则的目标，则会递归检查和执行。</li><li>直到所有依赖满足，才最终生成目标。</li></ul></li><li><p><strong>结束</strong></p><ul><li>如果所有目标都已是最新，则 <code>make</code> 会提示：</li></ul></li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">make</span>: <span class="hljs-string">&#x27;app&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">up</span> <span class="hljs-keyword">to</span> date.<br></code></pre></td></tr></table></figure><h3 id="21-执行流程示意图"><a class="markdownIt-Anchor" href="#21-执行流程示意图"></a> 2.1. 🔄 执行流程示意图</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">          make<br>           │<br>           ▼<br>   读取并解析 Makefile<br>           │<br>           ▼<br>   确定要构建的目标 (默认/指定)<br>           │<br>           ▼<br>   检查目标的依赖文件<br>           │<br>    ┌──────┴────────┐<br>    │               │<br>依赖比目标旧      依赖比目标新/不存在<br>    │               │<br>目标已是最新    执行规则命令 → 生成新目标<br></code></pre></td></tr></table></figure><div class="admonition info"><p class="admonition-title">tips</p><p>可以使用 make -f [makefile_name] 指定使用某个makefile文件。</p></div><h2 id="3-伪目标-phony"><a class="markdownIt-Anchor" href="#3-伪目标-phony"></a> 3. 伪目标 .PHONY</h2><p>有些目标不是实际文件，而只是一个操作，例如 <code>clean</code>。<br />这时建议使用 <strong>.PHONY</strong> 声明：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean  </span><br><span class="hljs-section">clean:  </span><br>rm -r  [filepath]<br></code></pre></td></tr></table></figure><p>指定make目标文件：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make">make clean<br></code></pre></td></tr></table></figure><h2 id="4-变量"><a class="markdownIt-Anchor" href="#4-变量"></a> 4. 变量</h2><p>Makefile 支持变量，常用于保存编译器或编译选项。<br />使用示例如下：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs make">CC = gcc<br>CFLAGS = -Wall -g<br><br><span class="hljs-section">app: main.o utils.o</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> main.o utils.o -o app<br><br><span class="hljs-section">main.o: main.c</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c main.c -o main.o<br><br><span class="hljs-section">utils.o: utils.c</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -c utils.c -o utils.o<br></code></pre></td></tr></table></figure><h3 id="41-赋值符号"><a class="markdownIt-Anchor" href="#41-赋值符号"></a> 4.1. 赋值符号</h3><ul><li><strong>=</strong><br />我称之为最终赋值，同一个变量无论被赋值多次，永远取最后指定的值。<br />示例：</li></ul><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs make">VIR_A = A<br>VIR_B = <span class="hljs-variable">$(VIR_A)</span> B<br>VIR_A = AA<br></code></pre></td></tr></table></figure><p>最后VIR_B的值是AA B。</p><ul><li><strong>:=</strong><br />立即赋值，正常逻辑的赋值号，类似于c语言的赋值号。</li><li><strong>?=</strong><br />如果变量在之前没有被赋值则赋值。<br />可以理解为  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ...</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><strong>+=</strong><br />追加赋值，将值追加到变量中。</li></ul><h2 id="5-隐含规则与通配符"><a class="markdownIt-Anchor" href="#5-隐含规则与通配符"></a> 5. 隐含规则与通配符</h2><p>Make 内置了一些规则，可以用简写方式：</p><ul><li><code>$@</code>：目标文件名</li><li><code>$&lt;</code>：第一个依赖文件</li><li><code>$^</code>：所有依赖文件</li></ul><p><code>%</code> 表示可以匹配任意长度的字符串，用于定义一类文件的生成规则。例如：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-section">%.o: %.c     </span><br>gcc -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><ul><li>含义：<ul><li><code>%.o</code> 表示所有以 <code>.o</code> 结尾的目标文件。</li><li><code>%.c</code> 表示所有以 <code>.c</code> 结尾的源文件。</li><li><code>$&lt;</code> 是第一个依赖文件（这里是 <code>.c</code> 文件）。</li><li><code>$@</code> 是目标文件（这里是 <code>.o</code> 文件）。</li></ul></li><li>作用：这条规则表示，所有 <code>.c</code> 文件可以通过编译生成对应的 <code>.o</code> 文件。</li></ul><hr /><p><code>%</code> 可以匹配文件名的某一部分，用于简化规则。例如：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">build/<span class="hljs-comment">%: src/%     </span><br>cp <span class="hljs-string">$&lt;</span> <span class="hljs-string">$@</span><br></code></pre></td></tr></table></figure><ul><li>含义：<ul><li><code>build/%</code> 表示目标文件在 <code>build/</code> 目录下。</li><li><code>src/%</code> 表示依赖文件在 <code>src/</code> 目录下。</li><li><code>$&lt;</code> 是依赖文件，<code>$@</code> 是目标文件。</li></ul></li><li>作用：这条规则表示，将 <code>src/</code> 目录下的文件复制到 <code>build/</code> 目录下。</li></ul><hr /><p>在模式规则中，<code>%</code> 可以用于定义多个目标。例如：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">%.a: %.b %.c     <br>cat $^ &gt; $@<span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><ul><li>含义：<ul><li><code>%.a</code> 是目标文件。</li><li><code>%.b</code> 和 <code>%.c</code> 是依赖文件。</li><li><code>$^</code> 表示所有依赖文件，<code>$@</code> 是目标文件。</li></ul></li><li>作用：这条规则表示，将 <code>.b</code> 和 <code>.c</code> 文件合并生成 <code>.a</code> 文件。</li></ul><hr /><h2 id="6-条件分支"><a class="markdownIt-Anchor" href="#6-条件分支"></a> 6. 条件分支</h2><p>在 Makefile 中，我们可以使用条件语句来根据不同情况执行不同规则或定义变量。常见的有 <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code>。</p><h3 id="61-语法"><a class="markdownIt-Anchor" href="#61-语法"></a> 6.1. 语法</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-keyword">ifeq</span> (条件1, 条件2)<br>    <span class="hljs-comment"># 当 条件1 == 条件2 时执行这里</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment"># 否则执行这里</span><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-keyword">ifneq</span> (条件1, 条件2)<br>    <span class="hljs-comment"># 当 条件1 != 条件2 时执行这里</span><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-keyword">ifdef</span> 变量名<br>    <span class="hljs-comment"># 当变量已定义时执行这里</span><br><span class="hljs-keyword">endif</span><br><br><span class="hljs-keyword">ifndef</span> 变量名<br>    <span class="hljs-comment"># 当变量未定义时执行这里</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><h3 id="62-示例一根据平台选择clean执行方式"><a class="markdownIt-Anchor" href="#62-示例一根据平台选择clean执行方式"></a> 6.2. 示例一：根据平台选择clean执行方式</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-comment"># 默认变量</span><br>CC = gcc<br><br><span class="hljs-comment"># 判断系统</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(OS)</span>, Windows_NT)<br>    RM = del<br><span class="hljs-keyword">else</span><br>    RM = rm -f<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-section">app: main.o</span><br><span class="hljs-variable">$(CC)</span> main.o -o app<br><br><span class="hljs-section">clean:</span><br><span class="hljs-variable">$(RM)</span> *.o app<br></code></pre></td></tr></table></figure><h3 id="63-示例二调试模式与发布模式"><a class="markdownIt-Anchor" href="#63-示例二调试模式与发布模式"></a> 6.3. 示例二：调试模式与发布模式</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-comment"># 设置编译选项</span><br>CFLAGS = -Wall<br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(MODE)</span>, debug)<br>    CFLAGS += -g<br><span class="hljs-keyword">else</span><br>    CFLAGS += -O2<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-section">app: main.o</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> main.o -o app<br></code></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make MODE=debug   <span class="hljs-comment"># 调试模式，带调试信息</span><br>make MODE=release <span class="hljs-comment"># 默认优化模式</span><br></code></pre></td></tr></table></figure><h2 id="7-函数"><a class="markdownIt-Anchor" href="#7-函数"></a> 7. 函数</h2><p>Makefile 内置了许多函数，用来处理字符串、文件名、路径等。<br />常见函数格式为：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make">$(函数名 参数1 参数2 ...)<br></code></pre></td></tr></table></figure><p>下面介绍一些<strong>常用函数</strong></p><h3 id="71-subst-字符串替换"><a class="markdownIt-Anchor" href="#71-subst-字符串替换"></a> 7.1. <code>subst</code> —— 字符串替换</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> from,to,text)</span><br></code></pre></td></tr></table></figure><ul><li><p>功能：将 <code>text</code> 中的 <code>from</code> 替换为 <code>to</code>。</p></li><li><p>示例：</p></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">SRC = main.c utils.c <br>OBJ = <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> .c,.o,<span class="hljs-variable">$(SRC)</span>)</span> <br><br><span class="hljs-comment"># 结果：OBJ = main.o utils.o</span><br></code></pre></td></tr></table></figure><hr /><h3 id="72-patsubst-模式替换"><a class="markdownIt-Anchor" href="#72-patsubst-模式替换"></a> 7.2. <code>patsubst</code> —— 模式替换</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> pattern,replacement,text)</span><br></code></pre></td></tr></table></figure><ul><li><p>功能：更灵活的字符串替换，支持通配符 <code>%</code>。</p></li><li><p>示例：</p></li></ul><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs make">SRC = main.c utils.c test.c<br>OBJ = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,%.o,<span class="hljs-variable">$(SRC)</span>)</span><br><br><span class="hljs-comment"># 结果：OBJ = main.o utils.o test.o</span><br></code></pre></td></tr></table></figure><hr /><h3 id="73-wildcard-获取文件列表"><a class="markdownIt-Anchor" href="#73-wildcard-获取文件列表"></a> 7.3. <code>wildcard</code> —— 获取文件列表</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> pattern)</span><br></code></pre></td></tr></table></figure><ul><li><p>功能：匹配符合模式的文件。</p></li><li><p>示例：</p></li></ul><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs make">SRC = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c)</span><br><span class="hljs-comment"># 结果：SRC = 当前目录下所有 .c 文件</span><br></code></pre></td></tr></table></figure><hr /><h3 id="74-notdir-去掉路径只保留文件名"><a class="markdownIt-Anchor" href="#74-notdir-去掉路径只保留文件名"></a> 7.4. <code>notdir</code> —— 去掉路径，只保留文件名</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs make">FILES = src/main.c src/utils.c<br>NAMES = <span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(FILES)</span>)</span><br><span class="hljs-comment"># 结果：NAMES = main.c utils.c</span><br></code></pre></td></tr></table></figure><hr /><h3 id="75-dir-获取路径部分"><a class="markdownIt-Anchor" href="#75-dir-获取路径部分"></a> 7.5. <code>dir</code> —— 获取路径部分</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs make">FILES = src/main.c src/utils.c<br>PATHS = <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$(FILES)</span>)</span><br><span class="hljs-comment"># 结果：PATHS = src/ src/</span><br></code></pre></td></tr></table></figure><hr /><h3 id="76-basename-addsuffix-和-addprefix-批量处理文件名"><a class="markdownIt-Anchor" href="#76-basename-addsuffix-和-addprefix-批量处理文件名"></a> 7.6. <code>basename</code> 、 <code>addsuffix</code> 和 <code>addprefix</code> —— 批量处理文件名</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs make">FILES = main.c utils.c<br><br><span class="hljs-comment"># 去掉后缀</span><br>NAMES = <span class="hljs-variable">$(<span class="hljs-built_in">basename</span> <span class="hljs-variable">$(FILES)</span>)</span><br><span class="hljs-comment"># NAMES = main utils</span><br><br><span class="hljs-comment"># 批量添加后缀</span><br>OBJS = <span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> .o,<span class="hljs-variable">$(NAMES)</span>)</span><br><span class="hljs-comment"># OBJS = main.o utils.o</span><br><br><span class="hljs-comment"># 批量添加前缀</span><br>OBJS = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> -I,<span class="hljs-variable">$(NAMES)</span>)</span><br><span class="hljs-comment"># OBJS = -Imain -Iutils</span><br></code></pre></td></tr></table></figure><hr /><h3 id="77-shell-执行-shell-命令"><a class="markdownIt-Anchor" href="#77-shell-执行-shell-命令"></a> 7.7. <code>shell</code> —— 执行 shell 命令</h3><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make">DATE = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> date +%Y-%m-%d)</span><br></code></pre></td></tr></table></figure><p>这样可以在 Makefile 中直接使用系统命令的输出。</p><h2 id="8-完整示例程序"><a class="markdownIt-Anchor" href="#8-完整示例程序"></a> 8. 完整示例程序</h2><p>这是一个完整Makefile示例程序，用于将c语言程序编译为可执行的二进制bin文件。它可以制成镜像供SoC烧录。</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs make"><span class="hljs-comment">#0###########################################################</span><br><br><span class="hljs-comment"># 设置目录变量，方便统一管理和修改</span><br><span class="hljs-comment"># 当前根目录:</span><br>ROOT_DIR := .<br><br><span class="hljs-comment"># 中间目标文件（.o）输出目录:</span><br>BUILD_DIR := build<br><br><span class="hljs-comment"># 最终生成的二进制文件（.bin）目录:</span><br>BIN_DIR := bin<br><br><span class="hljs-comment"># 工程名</span><br>NAME := key<br><br><span class="hljs-comment"># 指定链接脚本</span><br>LDS = imx.lds<br><br><span class="hljs-comment">#############################################################</span><br><br><span class="hljs-comment">#1###########################################################</span><br><br><span class="hljs-comment"># 自动查找 src/ 目录下的所有 .c 文件</span><br>SRCS = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find <span class="hljs-variable">$(ROOT_DIR)</span> -name <span class="hljs-string">&quot;*.c&quot;</span>)</span><br><br><span class="hljs-comment"># 将 SRC中的 xxx.c 转换为 build/xxx.o</span><br><span class="hljs-comment"># 同时添加 build/startup.o（汇编启动文件）</span><br>OBJS = <span class="hljs-variable">$(BUILD_DIR)</span>/startup.o<br>OBJS += <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,<span class="hljs-variable">$(BUILD_DIR)</span>/%.o,<span class="hljs-variable">$(SRCS)</span>)</span><br><br><span class="hljs-comment"># 自动查找所有包含头文件的目录</span><br>INC_DIRS = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find <span class="hljs-variable">$(ROOT_DIR)</span> -type f -name <span class="hljs-string">&quot;*.h&quot;</span> -exec dirname &#123;&#125; \; | <span class="hljs-built_in">sort</span> -u)</span><br>INCLUDES = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> -I, <span class="hljs-variable">$(INC_DIRS)</span>)</span><br><br><span class="hljs-comment">#############################################################</span><br><br><span class="hljs-comment">#2###########################################################</span><br><br><span class="hljs-comment"># 设置编译工具（使用 ARM 的交叉编译工具链）</span><br>CC := arm-none-eabi-<br><br><span class="hljs-comment"># 编译器（用于 .c 和 .S 文件）:</span><br>GCC := <span class="hljs-variable">$(CC)</span>gcc<br><br><span class="hljs-comment"># 链接器:</span><br>LD := <span class="hljs-variable">$(CC)</span>ld<br><br><span class="hljs-comment"># 用于将 elf 转为 bin 格式:</span><br>OBJCOPY := <span class="hljs-variable">$(CC)</span>objcopy<br><br><span class="hljs-comment"># 用于反汇编</span><br>OBJDUMP := <span class="hljs-variable">$(CC)</span>objdump<br><br><span class="hljs-comment"># 编译选项（GCC 编译阶段）</span><br><span class="hljs-comment"># -I：指定头文件搜索目录</span><br><span class="hljs-comment"># -Wall：打开所有警告</span><br><span class="hljs-comment"># -O2：优化等级 2（推荐用于 release）</span><br><span class="hljs-comment"># -nostdlib：不链接标准库（适用于裸机）</span><br><span class="hljs-comment"># -c：只编译，不链接</span><br>GCC_FLAGS = <span class="hljs-variable">$(INCLUDES)</span> -Wall -nostdlib -c<br><br><span class="hljs-comment"># 链接器选项</span><br>LD_FLAGS = -T<span class="hljs-variable">$(LDS)</span><br><br><span class="hljs-comment"># 使用 objdump 工具对生成的 ELF 文件进行反汇编</span><br><span class="hljs-comment"># -D：反汇编所有节（包括代码段、启动代码等）</span><br><span class="hljs-comment"># -m arm：指定目标架构为 ARM</span><br><span class="hljs-comment"># .elf：输入的可执行文件</span><br><span class="hljs-comment"># &gt; .dis：将反汇编结果输出为 .dis 文本文件</span><br>OBJDUMP_FLAGS = -D -m arm <span class="hljs-variable">$(BUILD_DIR)</span>/<span class="hljs-variable">$(NAME)</span>.elf &gt; <span class="hljs-variable">$(BUILD_DIR)</span>/<span class="hljs-variable">$(NAME)</span>.dis<br><br><span class="hljs-comment">#############################################################</span><br><br><span class="hljs-comment">#3###########################################################</span><br><br><span class="hljs-comment"># 目标：生成最终的二进制文件 bin/$(NAME).bin</span><br><span class="hljs-variable">$(BIN_DIR)</span>/<span class="hljs-variable">$(NAME)</span>.bin: <span class="hljs-variable">$(OBJS)</span><br><span class="hljs-comment"># 链接所有 .o 文件生成 elf 格式可执行文件</span><br>    <span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LD_FLAGS)</span> <span class="hljs-variable">$(OBJS)</span> -o <span class="hljs-variable">$(BUILD_DIR)</span>/<span class="hljs-variable">$(NAME)</span>.elf<br><span class="hljs-comment"># 反汇编 调试用</span><br>    <span class="hljs-variable">$(OBJDUMP)</span> <span class="hljs-variable">$(OBJDUMP_FLAGS)</span><br><span class="hljs-comment"># 把 elf 文件转换为裸机二进制文件（无符号、无头信息）</span><br>    <span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(BUILD_DIR)</span>/<span class="hljs-variable">$(NAME)</span>.elf <span class="hljs-variable">$@</span><br> <br><span class="hljs-comment"># 编译汇编启动文件 startup.S，生成 build/startup.o</span><br><span class="hljs-variable">$(BUILD_DIR)</span>/startup.o: startup.S<br><span class="hljs-comment"># 注意 startup.S 是汇编文件，用 gcc 编译也可以，默认会调用汇编器</span><br>    <span class="hljs-variable">$(GCC)</span> <span class="hljs-variable">$(GCC_FLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 编译每个 .c 文件到 build/xxx.o</span><br><span class="hljs-comment"># $@：目标文件（例如 build/main.o）</span><br><span class="hljs-comment"># $&lt;：依赖的源文件（例如 src/main.c）</span><br><span class="hljs-variable">$(BUILD_DIR)</span>/%.o: %.c<br><span class="hljs-comment"># 修复由于没有文件夹报错</span><br>    mkdir -p <span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$@</span>)</span><br>    <span class="hljs-variable">$(GCC)</span> <span class="hljs-variable">$(GCC_FLAGS)</span> -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment">#############################################################</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>    rm -r <span class="hljs-variable">$(BUILD_DIR)</span>/* <span class="hljs-variable">$(BIN_DIR)</span>/*<br></code></pre></td></tr></table></figure><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>仅作了解 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="项目管理" scheme="https://blog.godmao.top/categories/Linux/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="MakeFile" scheme="https://blog.godmao.top/Tags/MakeFile/"/>
    
  </entry>
  
  <entry>
    <title>交叉编译器相关知识梳理</title>
    <link href="https://blog.godmao.top/posts/27939/"/>
    <id>https://blog.godmao.top/posts/27939/</id>
    <published>2025-09-07T09:18:55.000Z</published>
    <updated>2025-09-07T10:45:40.598Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于Linux开发板与上位机的连接方式</title>
    <link href="https://blog.godmao.top/posts/32814/"/>
    <id>https://blog.godmao.top/posts/32814/</id>
    <published>2025-09-07T09:17:17.000Z</published>
    <updated>2025-09-07T11:49:14.697Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><div class="admonition info"><p class="admonition-title">info</p><p>本文旨在记录自己的IMX6ULL开发板上位机连接的过程。~~为什么感觉是后端这一块呢？~~</p></div><h2 id="前提条件"><a class="markdownIt-Anchor" href="#前提条件"></a> 前提条件</h2><div class="admonition note"><p class="admonition-title">设备</p><p>装有Debian/Ubuntu系统的、安装了ssh服务的、带有网络设备及驱动的开发板</p></div><div class="admonition note"><p class="admonition-title">工具</p><p>MobaXterm工具</p></div><div class="admonition todo"><p class="admonition-title">todo</p><p>目前使用的上位机是Win11平台，后续再研究Linux平台。</p></div><h2 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h2><h3 id="查询设备网络连接状态及ip地址"><a class="markdownIt-Anchor" href="#查询设备网络连接状态及ip地址"></a> 查询设备网络连接状态及ip地址</h3><p><code>ifconfig</code> 命令</p><h3 id="连接测试"><a class="markdownIt-Anchor" href="#连接测试"></a> 连接测试</h3><p><code>ping</code> 命令</p><h3 id="动态分配ip主动申请ip地址"><a class="markdownIt-Anchor" href="#动态分配ip主动申请ip地址"></a> 动态分配ip/主动申请ip地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">udhcpc -i eth0<br></code></pre></td></tr></table></figure><p><strong><code>udhcpc</code></strong></p><ul><li>全称是 <em>Micro DHCP Client</em>，是 BusyBox 提供的一个轻量级 DHCP 客户端工具。</li><li>它会向局域网里的 DHCP 服务器（比如路由器、主机上的 Internet Connection Sharing 服务）发送请求，请求一个 IP 地址。</li></ul><p><strong><code>-i eth0</code></strong></p><ul><li>指定要使用的网络接口，这里是 <code>eth0</code>（开发板上的以太网网卡）。</li><li>如果你用的是其他网卡（比如 <code>eth1</code> 或 <code>enp0s3</code>），需要改成对应名字。</li></ul><p>成功的话，它会显示类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">udhcpc: sending discover<br>udhcpc: sending <span class="hljs-keyword">select</span> <span class="hljs-keyword">for</span> 192.168.137.2<br>udhcpc: lease of 192.168.137.2 obtained, lease <span class="hljs-keyword">time</span> 86400<br></code></pre></td></tr></table></figure><p>这表示网卡已经从 DHCP 服务器那里拿到了 IP（这里是 <code>192.168.137.2</code>）。如果没有 DHCP 服务器响应，就会一直 <code>sending discover</code>，说明没有可分配 IP。</p><h3 id="手动设置设备ip地址"><a class="markdownIt-Anchor" href="#手动设置设备ip地址"></a> 手动设置设备ip地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ifconfig eth0 192.168.10.2 netmask 255.255.255.0 up<br></code></pre></td></tr></table></figure><p><code>up</code> 指启用</p><h3 id="查询ssh是否开启"><a class="markdownIt-Anchor" href="#查询ssh是否开启"></a> 查询ssh是否开启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl status ssh<br></code></pre></td></tr></table></figure><h3 id="开启ssh服务"><a class="markdownIt-Anchor" href="#开启ssh服务"></a> 开启ssh服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start ssh<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/init.d/ssh start<br></code></pre></td></tr></table></figure><h3 id="ssh远程连接"><a class="markdownIt-Anchor" href="#ssh远程连接"></a> ssh远程连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh [username]@[ip-addr/hostname]<br></code></pre></td></tr></table></figure><h3 id="通过mobaxterm连接"><a class="markdownIt-Anchor" href="#通过mobaxterm连接"></a> 通过MobaXterm连接</h3><p>填好即可。<br /><img src="Snipaste_2025-09-07_19-20-07.png" alt="" /></p><p><code>hostname</code> 可以输入同名指令查看。</p><h2 id="方式一无线网络连接"><a class="markdownIt-Anchor" href="#方式一无线网络连接"></a> 方式一：无线网络连接</h2><div class="admonition note"><p class="admonition-title">优点</p><p>无线通信。</p></div><div class="admonition error"><p class="admonition-title">缺点</p><p>延迟可能较高。</p></div><h3 id="同一网络下"><a class="markdownIt-Anchor" href="#同一网络下"></a> 同一网络下</h3><p>在同一网段下（连接同一个WIFI），通过ssh建立连接。简简单单。</p><h3 id="不同网络下"><a class="markdownIt-Anchor" href="#不同网络下"></a> 不同网络下</h3><div class="admonition todo"><p class="admonition-title">todo</p><p>待补充。</p></div><h2 id="方式二通过网线与win电脑连接"><a class="markdownIt-Anchor" href="#方式二通过网线与win电脑连接"></a> 方式二：通过网线与Win电脑连接</h2><div class="admonition note"><p class="admonition-title">优点</p><p>延迟低。</p></div><div class="admonition error"><p class="admonition-title">缺点</p><p>有线通信。</p></div><h3 id="点对点通信无需共享电脑网络"><a class="markdownIt-Anchor" href="#点对点通信无需共享电脑网络"></a> 点对点通信（无需共享电脑网络）</h3><div class="admonition note"><p class="admonition-title">优点</p><p>操作简单。</p></div><div class="admonition error"><p class="admonition-title">缺点</p><p>开发板不能共享电脑网络。</p></div><p>将开发板网口和电脑网口用网线连接，进入电脑<code>网络和Internet</code>设置，选择<code>以太网</code></p><p>ip分配改为手动，ip地址可以分配为<code>192.168.10.1</code><br />掩码为<code>255.255.255.0</code><br /><img src="Snipaste_2025-09-07_19-29-57.png" alt="" /></p><p>开发板端同样指定ip地址和掩码，须在同一网段，例如<code>192.168.10.7</code> 。这样两个设备就能互相找到了。<br />再在电脑上进行ping测试。能ping通用ssh/MobaXterm连接即可。</p><h3 id="点对点通信并共享电脑网络电脑成网关"><a class="markdownIt-Anchor" href="#点对点通信并共享电脑网络电脑成网关"></a> 点对点通信并共享电脑网络（电脑成网关）</h3><div class="admonition note"><p class="admonition-title">优点</p><p>开发板不仅可以与电脑建立通信，还能共享电脑网络。</p></div><div class="admonition error"><p class="admonition-title">缺点</p><p>操作较复杂。</p></div><p>电脑通过wifi连接网络，通过以太网接口连接开发板。<br />在电脑控制面板&gt;网络和Internet&gt;网络和共享中心 右侧更改适配器设置，双击无线网卡设备（连接网络的那个设备）选择属性&gt; 共享选项卡 勾选<br /><img src="Snipaste_2025-09-07_19-41-42.png" alt="" /></p><p>提示：<br /><img src="Snipaste_2025-09-07_19-41-53.png" alt="" /></p><p>意思是：当该功能被启用时，你的LAN口 ip地址 自动被设置为 <code>192.168.137.1</code>，要通过这个LAN口连接网络的设备需将自己ip地址设置为动态获取，也就是在开发板执行前面的动态获取ip地址的命令。</p><p>当开发版成功获取到ip地址后，则可以正常建立连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="网络" scheme="https://blog.godmao.top/Tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="通信" scheme="https://blog.godmao.top/Tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>无聊随便打点字</title>
    <link href="https://blog.godmao.top/posts/7593/"/>
    <id>https://blog.godmao.top/posts/7593/</id>
    <published>2025-08-25T07:16:07.000Z</published>
    <updated>2025-08-25T08:25:43.233Z</updated>
    
    <content type="html"><![CDATA[<hr /><h1 id="和时间赛跑-林清玄"><a class="markdownIt-Anchor" href="#和时间赛跑-林清玄"></a> 和时间赛跑 林清玄</h1><p>读小学的时候，我的外祖母去世了。外祖母生前最疼爱我。我无法排除自己的忧伤，每天在学校的操场上一圈一圈地跑着，跑得累倒在地上，扑在草坪上痛哭。</p><p>那哀痛的日子持续了很久，爸爸妈妈也不知道如何安慰我。他们知道与其欺骗我说外祖母睡着了，还不如对我说实话：外祖母永远不会回来了。</p><p>“什么是永远不会回来了呢？”我问。</p><p>“所有时间里的事物，都永远不会回来了，你的昨天过去了，它就永远变成昨天，你再也不能回到昨天了。爸爸以前和你一样小，现在再也不能回到你这么小的童年了。有一天你会长大，你也会像外祖母一样老，有一天你度过了你的所有时间，也会像外祖母一样永远不能回来了。”爸爸说。</p><p>爸爸等于给我说了一个谜，这个谜比“一寸光阴一寸金，寸金难买寸光阴”还让我感到可怕，比“光阴似箭，日月如梭”更让我有一种说不出的滋味。</p><p>以后，我每天放学回家，在庭院时看着太阳一寸一寸地沉进了山头，就知道一天真的过完了。虽然明天还会有新的太阳，但永远不会有今天的太阳了。</p><p>我看到鸟儿飞到天空，它们飞得多块呀。明天它们再飞过同样的路线，也永远不是今天了。或许明天飞过这条路线的，不是老鸟，而是小鸟了。</p><p>时间过得飞快，使我的小心眼不只是着急，还有悲伤。有一天我放学回家，看到太阳快落山了，就下决心说：“我要比太阳更快地回家。”我狂奔回去，站在庭院里喘气的时候，看到太阳还露着半边脸，我高兴地跳起来。那一天我跑赢了太阳。以后我常做这样的游戏，有时和太阳赛跑，有时和西北风比赛，有时一个暑假的作业，我十天就做完了。那时我三年级，常把哥哥五年级的作业拿来做。每一次比赛胜过时间，我就快乐得不知道怎么形容。</p><p>后来二十年里，我因此受益无穷。虽然我知道人永远跑不过时间，但是可以比原来跑快一步，如果加把劲，有时可以快好几步。那几步虽然很小很小，用途却很大很大。</p><p>如果将来我有什么要教给孩子，我会告诉他：假若你一直和时间赛跑，你就可以成功。</p><h1 id="秋天的怀念-史铁生"><a class="markdownIt-Anchor" href="#秋天的怀念-史铁生"></a> 秋天的怀念 史铁生</h1><p>双腿瘫痪后，我的脾气变得暴怒无常。望着望着天上北归的雁阵，我会突然把面前的玻璃砸碎；听着听着李谷一甜美的歌声，我会猛地把手边的东西摔向四周的墙壁。母亲就悄悄地躲出去，在我看不见的地方偷偷地听着我的动静。当一切恢复沉寂，她又悄悄地进来，眼边红红的，看着我。“听说北海的花儿都开了，我推你去走走。”她总是这么说。母亲喜欢花，可自从我双腿瘫痪后，她侍弄的那些花都死了。“不，我不去！”我狠命地捶打这两条可恨的腿，喊着：“我活着有什么劲！”母亲扑过来抓住我的手，忍住哭声说：“咱娘儿俩在一块儿，好好儿活……”可我却一直都不知道，她的病已经到了那步田地。后来妹妹告诉我，她常常肝疼得整宿整宿翻来覆去地睡不了觉。</p><p>那天我又独自坐在屋里，看着窗外的树叶“唰唰啦啦”地飘落。母亲进来了，挡在窗前：“北海地菊花开了，我推着你去看看吧。”她憔悴的脸上现出央求般的神色。“什么时候？”你要是愿意，就明天？“她说。我的回答已经让她喜出望外了。”好吧，就明天。“我说。她高兴得一会坐下，一会站起：”那就赶紧准备准备。“”唉呀，烦不烦？几步路，有什么好准备的！“她也笑了，坐在我身边，絮絮叨叨地说着”看完菊花，咱们就去‘仿膳’，你小时候最爱吃那儿的豌豆黄儿。还记得那回我带你去北海吗？你偏说那杨树花是毛毛虫，跑着，一脚踩扁一个……“她忽然不说了。对于”跑“和”踩“一类的字眼儿。她比我还敏感。她又悄悄出去了。</p><p>她出去了。就再也没回来。</p><p>邻居们把她抬到车上时，她还在大口大口地吐着鲜血。我没想到她已经病成那样。看着三轮车远去，也绝没有想到那竟是永远的诀别。</p><p>邻居的小伙子背着我去看她的时候，她正艰难地呼吸着，像她那一生艰难的生活。别人告诉我，他昏迷前的最后一句话是：”我那个有病的儿子和我那个未成年的女儿……“</p><p>又是秋天，妹妹推着我去北海看了菊花。黄色的花淡雅、白色的花高洁、紫红色的花热烈而深沉，泼泼洒洒，秋风中正开的烂漫。我懂得母亲没有说完的话，妹妹也懂。我俩在一块儿，要好好儿活……</p>]]></content>
    
    
    <summary type="html">喵喵喵。</summary>
    
    
    
    <category term="其他" scheme="https://blog.godmao.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>I-MX6ULL的中断实验（下）</title>
    <link href="https://blog.godmao.top/posts/33465/"/>
    <id>https://blog.godmao.top/posts/33465/</id>
    <published>2025-08-24T14:17:34.000Z</published>
    <updated>2025-08-25T08:21:45.638Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="c语言下中断模块"><a class="markdownIt-Anchor" href="#c语言下中断模块"></a> C语言下中断模块</h2><h3 id="核心思路"><a class="markdownIt-Anchor" href="#核心思路"></a> 核心思路：</h3><p>每个中断对象包含：1个中断处理函数和需要传入的参数——一个函数指针+一个未定义类型指针。所以将中断对象打包成一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义中断处理函数原型 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">sys_irq_handler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id, <span class="hljs-type">void</span> *para)</span>;<br><br><span class="hljs-comment">/* 定义中断函数结构体 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">sys_irq_handle</span>&#123;</span><br>    <span class="hljs-type">sys_irq_handler_t</span> irqHandler;<br>    <span class="hljs-type">void</span>* usrPara;<br>&#125;<span class="hljs-type">sys_irq_handle_t</span>;<br></code></pre></td></tr></table></figure><p>指定一个默认中断处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义默认中断处理函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">default_irqHandler</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id, <span class="hljs-type">void</span> *para)</span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将所有中断对象归入一个表中，按中断id索引：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_OF_IT_VECTORS 160</span><br><span class="hljs-type">static</span> <span class="hljs-type">sys_irq_handle_t</span> irqTable[NUM_OF_IT_VECTORS];<br></code></pre></td></tr></table></figure><p>后续可能涉及到中断嵌套，因此定义一个中断嵌套计数器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> irqNesting; <span class="hljs-comment">//中断嵌套计数器</span><br></code></pre></td></tr></table></figure><p>初始化中断对象表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 初始化中断处理表 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">sys_iqrTable_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i = <span class="hljs-number">0</span>;<br>    irqNesting = <span class="hljs-number">0</span>; <span class="hljs-comment">//中断嵌套计数器</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i&lt; NUM_OF_IT_VECTORS; i++)&#123;<br>        irqTable[i].irqHandler = default_irqHandler;<br>        irqTable[i].usrPara = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上一节中，我们实现了当进入中断时跳入一个名为<code>system_irqhandler</code>的函数处理中断。因此我们需要定义该函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// @brief 中断处理函数</span><br><span class="hljs-comment">/// @param gicciar 寄存器gicciar的值</span><br><span class="hljs-comment">/// @note 进入irq中断后自动调用</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">system_irqhandler</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> gicciar)</span>&#123; <br>    <span class="hljs-type">uint32_t</span> id = gicciar &amp; <span class="hljs-number">0x3ff</span>; <span class="hljs-comment">//从gicciar寄存器中读取中断id号（0~9位 故&amp; 0x3ff）</span><br>    <span class="hljs-comment">/* 安全检查 */</span><br>    <span class="hljs-keyword">if</span>(id == <span class="hljs-number">1023</span> || id &gt;= NUM_OF_IT_VECTORS) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//1023即没有中断，即0~9位全为1</span><br>    irqNesting++;<br>    <span class="hljs-comment">/* 开始处理 */</span><br>    irqTable[id].irqHandler(id, irqTable[id].usrPara);<br>    irqNesting--;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们不可能只用默认中断处理函数，肯定要自己自定义，自定义完处理函数后，将该函数注册给中断对象，因此我们需要一个用于注册的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// @brief 用于注册你自定义的中断处理函数</span><br><span class="hljs-comment">/// @param irq_id 你为哪个中断写好了处理函数，写入id</span><br><span class="hljs-comment">/// @param handler 你写的处理函数的地址</span><br><span class="hljs-comment">/// @param para 要传入的参数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">register_irqHandler</span><span class="hljs-params">(IRQn_Type irq_id, <span class="hljs-type">sys_irq_handler_t</span> handler, <span class="hljs-type">void</span> *para)</span>&#123;<br>    irqTable[irq_id].irqHandler = handler;<br>    irqTable[irq_id].usrPara = para;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置gpio外部中断"><a class="markdownIt-Anchor" href="#配置gpio外部中断"></a> 配置gpio外部中断</h2><p>通过原理图可知，应配置为上升沿触发。</p><h3 id="配置gpio_icr寄存器"><a class="markdownIt-Anchor" href="#配置gpio_icr寄存器"></a> 配置GPIO_ICR寄存器</h3><p>寄存器用于指定触发方式——上升沿触发。<br />我的开发板应指定GOIO5_ICR1_icr1 为 10。</p><h3 id="配置gpio_imr寄存器"><a class="markdownIt-Anchor" href="#配置gpio_imr寄存器"></a> 配置GPIO_IMR寄存器</h3><p>该寄存器用于使能中断。<br />我的开发板应指定GPIO5_IMR_imr1 为 1——UNMASKED</p><h2 id="中断后清除中断标志位"><a class="markdownIt-Anchor" href="#中断后清除中断标志位"></a> 中断后清除中断标志位</h2><p>参考手册中指出，处理完中断后，需清除GPIO_ISR寄存器的相应位。<br />需要注意的是<strong>通过对该位写1清除。</strong></p><h2 id="gic-配置"><a class="markdownIt-Anchor" href="#gic-配置"></a> GIC 配置</h2><p>just like NVIC… you must know cubemx right？</p><h3 id="使能相应的中断id"><a class="markdownIt-Anchor" href="#使能相应的中断id"></a> 使能相应的中断ID</h3><p>GPIO5_1对应的中断id为74<br /><img src="Snipaste_2025-08-24_23-51-22.png" alt="" /><br />但是注意这段话：<br /><img src="Snipaste_2025-08-24_23-53-41.png" alt="" /></p><p>告诉我们前面还有32个中断接到了CPU的接口 所以中断ID为 74+32 = 106。</p><h3 id="配置中断优先级"><a class="markdownIt-Anchor" href="#配置中断优先级"></a> 配置中断优先级</h3><h2 id="注册中断处理函数"><a class="markdownIt-Anchor" href="#注册中断处理函数"></a> 注册中断处理函数</h2>]]></content>
    
    
    <summary type="html">本篇编写c语言中的中断模块并配置GPIO外部中断。</summary>
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>I-MX6ULL的中断实验（上）</title>
    <link href="https://blog.godmao.top/posts/32440/"/>
    <id>https://blog.godmao.top/posts/32440/</id>
    <published>2025-08-11T13:17:21.000Z</published>
    <updated>2025-08-24T16:22:17.968Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><ul><li><a href="#1-cortex-a7%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F">1. Cortex-A7中断系统</a><ul><li><a href="#11-cortex-a%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8">1.1. Cortex-A中断向量表</a></li><li><a href="#12-%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%81%8F%E7%A7%BB">1.2. 中断向量表偏移</a></li><li><a href="#13-gic-v2%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8">1.3. GIC v2中断控制器</a><ul><li><a href="#131-gic-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">1.3.1. GIC 的主要功能</a></li><li><a href="#132-%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84">1.3.2. 核心结构</a></li><li><a href="#133-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E7%89%88">1.3.3. 核心原理（简单版）</a></li></ul></li><li><a href="#14-%E4%B8%AD%E6%96%AD%E5%8F%B7">1.4. 中断号</a></li></ul></li><li><a href="#2-%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8">2. 添加中断向量表</a></li><li><a href="#3-%E5%A4%8D%E4%BD%8D%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%96%E5%86%99">3. 复位中断函数的编写</a><ul><li><a href="#31-%E6%93%8D%E4%BD%9Ccp15%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8">3.1. 操作CP15协处理器</a></li><li><a href="#32-%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%81%8F%E7%A7%BB">3.2. 中断向量表偏移</a></li><li><a href="#33-%E8%AE%BE%E7%BD%AEsp%E6%8C%87%E9%92%88">3.3. 设置sp指针</a></li><li><a href="#34-%E6%B8%85%E9%99%A4bss%E6%AE%B5">3.4. 清除.bss段</a></li></ul></li><li><a href="#4-irq%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%96%E5%86%99">4. IRQ中断函数的编写</a><ul><li><a href="#41-%E4%BF%9D%E5%AD%98%E4%B8%AD%E6%96%AD%E7%8E%B0%E5%9C%BA%E9%98%B2%E6%AD%A2%E7%A0%B4%E5%9D%8F%E5%8E%9F%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81">4.1. 保存中断现场（防止破坏原任务状态）</a></li><li><a href="#42-%E4%BB%8E-gic%E9%80%9A%E7%94%A8%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%BB%E5%8F%96%E4%B8%AD%E6%96%AD%E5%8F%B7">4.2. 从 GIC（通用中断控制器）读取中断号</a></li><li><a href="#43-%E5%88%87%E6%8D%A2%E5%88%B0-svc-%E6%A8%A1%E5%BC%8F%E6%89%A7%E8%A1%8C-c-%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">4.3. 切换到 SVC 模式执行 C 语言中断处理函数</a></li><li><a href="#44-%E7%BB%93%E6%9D%9F%E4%B8%AD%E6%96%AD%E5%B9%B6%E6%81%A2%E5%A4%8D%E7%8E%B0%E5%9C%BA">4.4. 结束中断并恢复现场</a></li></ul></li><li><a href="#5-%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6">5. 整个启动文件</a></li></ul><h2 id="1-cortex-a7中断系统"><a class="markdownIt-Anchor" href="#1-cortex-a7中断系统"></a> 1. Cortex-A7中断系统</h2><h3 id="11-cortex-a中断向量表"><a class="markdownIt-Anchor" href="#11-cortex-a中断向量表"></a> 1.1. Cortex-A中断向量表</h3><p>Cortex-A中断向量<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>表有8个中断，其中重点关注IRQ。Cortex-A的中断向量表需要用户自己去定义。</p><p><img src="Snipaste_2025-08-11_21-20-27.png" alt="" /></p><p>各中断的简单介绍：<br /><img src="Snipaste_2025-08-11_21-27-07.png" alt="" /></p><p>其中IRQ中断为非向量中断，所有中断共享同一入口，再软件判断来源。<br />大概是这样：<br /><img src="Snipaste_2025-08-11_21-27-26.png" alt="" /></p><h3 id="12-中断向量表偏移"><a class="markdownIt-Anchor" href="#12-中断向量表偏移"></a> 1.2. 中断向量表偏移</h3><p>通过设置中断向量表偏移，指定中断向量表的地址。</p><h3 id="13-gic-v2中断控制器"><a class="markdownIt-Anchor" href="#13-gic-v2中断控制器"></a> 1.3. GIC v2中断控制器</h3><p>类似于STM32的NVIC，CortexA7使用 GIC v2 作为中断控制器，比NVIC更强大因为GIC能处理多核的中断。</p><h4 id="131-gic-的主要功能"><a class="markdownIt-Anchor" href="#131-gic-的主要功能"></a> 1.3.1. GIC 的主要功能</h4><ol><li><strong>收集中断</strong><br />接收来自外设和 CPU 内部的各种中断请求（SPI、PPI、SGI）。</li><li><strong>优先级管理</strong><br />按优先级裁定哪个中断先被处理。</li><li><strong>目标选择</strong><br />把中断发给指定的 CPU 核，或广播给多个核。</li><li><strong>中断屏蔽与使能</strong><br />软件可选择屏蔽某个中断或所有中断。</li><li><strong>确认与结束</strong><br />CPU 核心在处理前向 GIC 确认（acknowledge），处理完向 GIC 报告结束（end of interrupt）。</li></ol><h4 id="132-核心结构"><a class="markdownIt-Anchor" href="#132-核心结构"></a> 1.3.2. 核心结构</h4><p>ARM GIC 主要由两部分组成：</p><ul><li><strong>Distributor（分发器）</strong><br />负责接收所有外设中断，决定送到哪一个 CPU。</li><li><strong>CPU Interface（CPU 接口）</strong><br />每个 CPU 核对应一个接口，负责和 Distributor 通信，接收/确认/结束中断。</li></ul><h4 id="133-核心原理简单版"><a class="markdownIt-Anchor" href="#133-核心原理简单版"></a> 1.3.3. 核心原理（简单版）</h4><p>GIC 的核心流程基本就是三步：</p><ol><li><strong>接收中断请求</strong><br />外设（SPI）、特定 CPU 相关的中断（PPI）、核间中断（SGI）都送进 GIC。</li><li><strong>仲裁优先级 + 选择目标 CPU</strong><ul><li>比较中断优先级（Priority）</li><li>检查中断是否被屏蔽（Enable Mask）</li><li>根据目标 CPU 配置（Target CPU Mask）决定发给谁</li></ul></li><li><strong>通知 CPU → CPU 响应 → 完成汇报</strong><ul><li>发信号到目标 CPU 接口</li><li>CPU 读取中断号（acknowledge）并执行 ISR</li><li>ISR 结束后 CPU 通知 GIC（end of interrupt）</li></ul></li></ol><h3 id="14-中断号"><a class="markdownIt-Anchor" href="#14-中断号"></a> 1.4. 中断号</h3><p>中断的 ID Card。<br /><img src="Snipaste_2025-08-11_21-54-28.png" alt="" /></p><h2 id="2-添加中断向量表"><a class="markdownIt-Anchor" href="#2-添加中断向量表"></a> 2. 添加中断向量表</h2><ul><li><p><strong>向量表的“表项”是指令，不是纯地址。</strong></p></li><li><p>每个向量入口的指令都指向某个具体的处理函数（Reset_Handler、IRQ_Handler 等）。</p></li><li><p>当发生异常，CPU 硬件会取指执行入口指令 → <code>ldr pc, =xxx</code> → 跳到真正的处理函数。</p></li></ul><p>这样，<strong>只要依次写好这些跳转指令，后续再告诉cpu这些指令在哪个位置，就等于告诉 CPU“各种异常该去哪”</strong>。</p><p>:::danger<br /><strong>中断向量表必须按固定顺序来定义</strong>，顺序是由 ARM 硬件架构规定的，不是随便排列的。这样CPU才能正确处理不同的异常<br />:::</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asm">/* 设置中断向量表，当中断来时，CPU就会执行对应指令 */<br><br>    /* 顺序不能改变，名字可以改变！ */<br><br>    ldr pc, =Reset_Handler      /* 复位中断                     */  <br><br>    ldr pc, =Undefined_Handler  /* 未定义中断                    */<br><br>    ldr pc, =SVC_Handler        /* SVC(Supervisor)中断        */<br><br>    ldr pc, =PrefAbort_Handler  /* 预取终止中断                   */<br><br>    ldr pc, =DataAbort_Handler  /* 数据终止中断                   */<br><br>    ldr pc, =NotUsed_Handler    /* 未使用中断                    */<br><br>    ldr pc, =IRQ_Handler        /* IRQ中断                    */<br><br>    ldr pc, =FIQ_Handler        /* FIQ(快速中断)未定义中断           */<br></code></pre></td></tr></table></figure><h2 id="3-复位中断函数的编写"><a class="markdownIt-Anchor" href="#3-复位中断函数的编写"></a> 3. 复位中断函数的编写</h2><h3 id="31-操作cp15协处理器"><a class="markdownIt-Anchor" href="#31-操作cp15协处理器"></a> 3.1. 操作CP15协处理器</h3><p><strong>关闭I、D Cache 和MMU</strong></p><details><summary>为什么要这样做？</summary><p>CP15 是 Cortex-A 系列处理器的 <strong>系统控制寄存器集</strong>，其中 <strong>SCTLR（System Control Register, c1）</strong> 控制了处理器的一些核心行为，例如：</p><table><thead><tr><th>位</th><th>功能</th></tr></thead><tbody><tr><td>M</td><td>MMU 使能位（Memory Management Unit）</td></tr><tr><td>C</td><td>数据缓存使能位</td></tr><tr><td>I</td><td>指令缓存使能位</td></tr><tr><td>A</td><td>对齐检查（Alignment）使能</td></tr><tr><td>Z</td><td>缓存清零 / 压缩乘法指令</td></tr><tr><td>V</td><td>高速异常向量表</td></tr><tr><td>…</td><td>其他一些调试、异常行为控制</td></tr></tbody></table><p>在复位后，SCTLR 寄存器的初始值不一定是你想要的运行状态。不同的 SoC 或板级支持包可能默认值不同，有些位可能 <strong>默认启用某些功能但不适合裸机启动阶段</strong>。</p><p>在裸机启动阶段，你通常需要：</p><ol><li><p><strong>禁用 MMU 和缓存</strong>：</p><ul><li>在初始化页表和内存映射前，启用 MMU 会导致访问非法地址或产生未定义行为。</li><li>数据缓存如果没有正确初始化，可能会导致数据写入内存不一致。</li></ul></li><li><p><strong>关闭对齐检查</strong>：</p><ul><li>对齐检查在裸机启动阶段可能会导致异常，因为启动代码可能使用非对齐访问。</li></ul></li><li><p><strong>保证指令执行顺序一致</strong>：</p><ul><li>SCTLR 的某些位会影响指令缓存和流水线行为。</li><li>在系统初始化阶段，确保缓存和 MMU关闭可以让你更容易调试和保证代码执行顺序。</li></ul></li><li><p><strong>统一系统行为</strong>：</p><ul><li>不同芯片可能在复位后 SCTLR 寄存器的默认值不同。</li><li>显式初始化可以保证启动代码在各种芯片上行为一致。</li></ul></li></ol><p>如果不重置这些位可能的风险：</p><ul><li><p><strong>访问未定义</strong>：</p><ul><li>如果 MMU 默认启用但页表未初始化，访问内存可能触发数据异常。</li></ul></li><li><p><strong>数据不一致</strong>：</p><ul><li>缓存启用但未正确设置缓存策略，读写内存可能得到错误数据。</li></ul></li><li><p><strong>异常频发</strong>：</p><ul><li>对齐检查默认启用，而启动代码中可能有非对齐访问，导致异常。</li></ul></li><li><p><strong>调试困难</strong>：</p><ul><li>程序执行行为不确定，难以定位启动问题。</li></ul></li></ul></details><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">* 禁用MMU、cache、对齐检查等，配置适合裸机启动的环境，这样的启动代码移植性更好 */<br><br>    mrc     p15, 0, r0, c1, c0, 0     /*  读取CP15系统控制寄存器   */<br><br>    bic     r0,  r0, #0x1000          /*  清除第12位（I位）禁用 I Cache  */<br><br>    bic     r0,  r0, #0x4             /*  清除第 2位（C位）禁用 D Cache  */<br><br>    bic     r0,  r0, #0x2             /*  清除第 1位（A位）禁止严格对齐   */<br><br>    bic     r0,  r0, #0x800           /*  清除第11位（Z位）分支预测   */<br><br>    bic     r0,  r0, #0x1             /*  清除第 0位（M位）禁用 MMU   */<br><br>    mcr     p15, 0, r0, c1, c0, 0     /*  将修改后的值写回CP15寄存器   */<br></code></pre></td></tr></table></figure><h3 id="32-中断向量表偏移"><a class="markdownIt-Anchor" href="#32-中断向量表偏移"></a> 3.2. 中断向量表偏移</h3><p>访问CP15 VBAR（Vector Base Address Register）寄存器，该寄存器是专门指定中断向量表偏移首地址的。</p><ul><li><code>dsb</code>（Data Synchronization Barrier）保证所有数据访问指令执行完再继续。</li><li><code>isb</code>（Instruction Synchronization Barrier）保证新的 VBAR 设置马上生效，不会被 CPU 指令流水线里的旧指令影响。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asm">/* 访问CP15 VBAR寄存器 设置中断向量表偏移 */<br><br>    ldr r0, =0x80000000<br><br>    dsb<br><br>    isb /* 数据同步指令 */<br><br>    mcr p15, 0, r0, c12, c0, 0<br><br>    dsb<br><br>    isb<br></code></pre></td></tr></table></figure><h3 id="33-设置sp指针"><a class="markdownIt-Anchor" href="#33-设置sp指针"></a> 3.3. 设置sp指针</h3><p>内核工作在不同模式下，User模式和是Sys模式共用sp寄存器，而其他模式是独享一个sp寄存器。</p><ul><li>ARMv7-A 每个异常模式都有自己的栈指针寄存器，如果不设置，进入该模式时可能破坏未知内存。</li><li>给每种模式单独分配内存空间，可以防止中断嵌套、函数调用等操作时栈互相冲突。</li></ul><h3 id="34-清除bss段"><a class="markdownIt-Anchor" href="#34-清除bss段"></a> 3.4. 清除.bss段</h3><details><summary>bss段是什么？</summary><p>在编译链接后，程序的内存布局通常分为几个主要段：</p><ul><li><p><strong>.text</strong>：存放代码（只读）。</p></li><li><p><strong>.data</strong>：存放已初始化的全局/静态变量（初始值不为 0）。</p></li><li><p><strong>.bss</strong>：存放<strong>未初始化的</strong>或者<strong>初始化为 0</strong> 的全局/静态变量。</p></li></ul><p><code>.bss</code> 只在运行时需要分配内存，编译产物中不占用存储空间（只是记录了大小），这样可以减少可执行文件体积。</p></details><details><summary>为什么要这样做？</summary><p>根据 <strong>C 语言标准</strong>：</p><blockquote><p>所有未显式初始化的全局变量、静态变量在程序开始执行前必须被初始化为 0。</p></blockquote><p>这意味着：</p><ul><li><p>如果 <code>bss</code> 段中的内容不是全 0，程序可能会读到<strong>随机的旧内存内容</strong>。</p></li><li><p>硬件上，RAM 启动后可能是<strong>杂乱的值</strong>（上电状态、上次运行残留、调试器写入等）。</p></li></ul><p>因此，<strong>启动代码（crt0 或汇编 startup.s）通常会在 <code>main()</code> 之前清零 bss 段</strong>，保证所有这些变量是干净的 0。</p></details><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">/* 清除bss段 防止未初始化变量等数据访问错误 */<br><br>    ldr r0, =__bss_start<br><br>    ldr r1, =__bss_end<br><br>    mov r2, #0<br><br>bss_clear:          /* ia: increse after */<br><br>    stmia r0!, &#123;r2&#125; /* stmia: 从r0所存地址开始，将r2的值写入该地址，写入后地址自动递增 */<br><br>    cmp r0, r1<br><br>    ble bss_clear /* less &amp; equal */<br></code></pre></td></tr></table></figure><h2 id="4-irq中断函数的编写"><a class="markdownIt-Anchor" href="#4-irq中断函数的编写"></a> 4. IRQ中断函数的编写</h2><details><summary>中断函数实现了什么？（详细版）</summary><h3 id="41-保存中断现场防止破坏原任务状态"><a class="markdownIt-Anchor" href="#41-保存中断现场防止破坏原任务状态"></a> 4.1. 保存中断现场（防止破坏原任务状态）</h3><p>一旦 CPU 进入 IRQ 模式，中断处理代码首先：</p><ul><li><p>把 <code>lr</code>（中断返回地址）、<code>r0</code>~<code>r3</code>、<code>r12</code> 等易被破坏的寄存器压栈保存。</p></li><li><p>保存 <code>SPSR</code>（中断进入时的 CPSR 状态），以便中断结束时恢复原任务的运行状态。</p></li></ul><p><strong>目的</strong>：防止中断服务过程破坏被中断的程序的寄存器内容和运行状态。</p><hr /><h3 id="42-从-gic通用中断控制器读取中断号"><a class="markdownIt-Anchor" href="#42-从-gic通用中断控制器读取中断号"></a> 4.2. 从 GIC（通用中断控制器）读取中断号</h3><ul><li><p>读取 <strong>GICC_IAR</strong>（Interrupt Acknowledge Register）寄存器。</p></li><li><p>这个寄存器会返回当前触发的中断 ID（是哪一个外设触发的 IRQ）。</p></li></ul><p><strong>目的</strong>：确定是哪个具体中断源发生了 IRQ。</p><hr /><h3 id="43-切换到-svc-模式执行-c-语言中断处理函数"><a class="markdownIt-Anchor" href="#43-切换到-svc-模式执行-c-语言中断处理函数"></a> 4.3. 切换到 SVC 模式执行 C 语言中断处理函数</h3><ul><li><p>ARMv7-A 的 IRQ 模式不适合直接运行通用 C 代码（栈、寄存器不统一），所以这里切到 SVC 模式。</p></li><li><p>在 SVC 模式下调用 <code>system_irqhandler</code>（C 写的总中断处理函数）。</p></li><li><p><code>system_irqhandler</code> 会根据中断号去调用具体外设的中断处理例程。</p></li></ul><p><strong>目的</strong>：统一用 SVC 模式的栈和环境执行中断逻辑，方便用 C 语言写 ISR 分发器。</p><hr /><h3 id="44-结束中断并恢复现场"><a class="markdownIt-Anchor" href="#44-结束中断并恢复现场"></a> 4.4. 结束中断并恢复现场</h3><ul><li><p>切回 IRQ 模式。</p></li><li><p>向 GIC 写 <strong>EOIR</strong>（End of Interrupt Register），通知 GIC 这个中断处理完成，可以接收新的中断。</p></li><li><p>从栈中弹出寄存器和 <code>SPSR</code>，恢复进入中断前的状态。</p></li><li><p>用 <code>subs pc, lr, #4</code> 返回到中断发生前的指令位置继续运行。</p></li></ul><p><strong>目的</strong>：</p><ul><li><p>告诉中断控制器“我处理完了”。</p></li><li><p>让 CPU 完整回到被打断的程序，像中断没发生一样继续执行。</p></li></ul></details><p>省流版：<br />当一个程序在 <strong>SVC 模式</strong> 下运行时，如果来了 IRQ：</p><ol><li>CPU 自动切到 IRQ 模式。</li><li>把 <strong>SVC 模式的 CPSR</strong> 存进 <strong>IRQ 模式的 SPSR</strong>。</li><li>把返回地址放进 IRQ 模式的 LR。</li><li>开始执行 IRQ 模式的向量入口代码（也就是 <code>IRQ_Handler</code>）。<br />irq_handler:</li></ol><ul><li>保存现场</li><li>查中断号</li><li>切换到svc模式 调用用c语言编写的中断分发函数 根据中断号分发到中断处理函数 来执行中断处理</li><li>结束中断、恢复现场<br />ps： 最后一行subs指令有点抽象。。。。。。。。</li></ul><h2 id="5-整个启动文件"><a class="markdownIt-Anchor" href="#5-整个启动文件"></a> 5. 整个启动文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs asm">.global _start<br>/* 以下两个变量在链接脚本中定义 */<br>.global __bss_start<br>.global __bss_end<br>_start:<br>    @ /* 1.设置处理器模式为SVC模式(其实CotexA内核上电默认即为SVC模式故不需要写) */<br>    @ mrs r0, cpsr                /* 读取cpsr到r0 */<br>    @ bic r0, r0, #0x1f           /* bic bit-clear位清零 */          <br>    @                             /* 等同于R0 = R0 &amp; (~Operand2) 这个操作数2自己推算*/<br>    @                             /* 现在这个操作相当于将r0的前5位清零了 */<br>    @ orr r0, r0, #0x13           /* orr 按位或 */<br>    @ msr cpsr, r0                /* 写入cpsr */  <br>    /* 设置中断向量表，当中断来时，CPU就会执行对应指令 */<br>    /* 顺序不能改变，名字可以改变！ */<br>    ldr pc, =Reset_Handler      /* 复位中断                     */  <br>    ldr pc, =Undefined_Handler  /* 未定义中断                    */<br>    ldr pc, =SVC_Handler        /* SVC(Supervisor)中断        */<br>    ldr pc, =PrefAbort_Handler  /* 预取终止中断                   */<br>    ldr pc, =DataAbort_Handler  /* 数据终止中断                   */<br>    ldr pc, =NotUsed_Handler    /* 未使用中断                    */<br>    ldr pc, =IRQ_Handler        /* IRQ中断                    */<br>    ldr pc, =FIQ_Handler        /* FIQ(快速中断)未定义中断           */<br>Reset_Handler:  <br>    cpsid i                           /* Change Processor State Interrupt or abort Disable irq */<br><br>    /* 禁用MMU、cache、对齐检查等，配置适合裸机启动的环境，这样的启动代码移植性更好 */<br>    mrc     p15, 0, r0, c1, c0, 0     /*  读取CP15系统控制寄存器   */<br>    bic     r0,  r0, #0x1000          /*  清除第12位（I位）禁用 I Cache  */<br>    bic     r0,  r0, #0x4             /*  清除第 2位（C位）禁用 D Cache  */<br>    bic     r0,  r0, #0x2             /*  清除第 1位（A位）禁止严格对齐   */<br>    bic     r0,  r0, #0x800           /*  清除第11位（Z位）分支预测   */<br>    bic     r0,  r0, #0x1             /*  清除第 0位（M位）禁用 MMU   */<br>    mcr     p15, 0, r0, c1, c0, 0     /*  将修改后的值写回CP15寄存器   */<br>    /* 访问CP15 VBAR寄存器 设置中断向量表偏移 */<br>    ldr r0, =0x80000000<br>    dsb<br>    isb /* 数据同步指令 */<br>    mcr p15, 0, r0, c12, c0, 0<br>    dsb<br>    isb<br>    /* 清除bss段 防止未初始化变量等数据访问错误 */<br>    ldr r0, =__bss_start<br>    ldr r1, =__bss_end<br>    mov r2, #0<br>bss_clear:          /* ia: increse after */<br>    stmia r0!, &#123;r2&#125; /* stmia: 从r0所存地址开始，将r2的值写入该地址，写入后地址自动递增 */<br>    cmp r0, r1<br>    ble bss_clear /* less &amp; equal */  <br>    /* 设置各个模式下的栈指针，<br>     * 注意：IMX6UL的堆栈是向下增长的！<br>     * 堆栈指针地址一定要是4字节地址对齐的！！！<br>     * DDR范围:0X80000000~0X9FFFFFFF<br>     */<br>    /* 进入IRQ模式 */<br>    mrs r0, cpsr<br>    bic r0, r0, #0x1f   /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  */<br>    orr r0, r0, #0x12   /* r0或上0x13,表示使用IRQ模式                   */<br>    msr cpsr, r0        /* 将r0 的数据写入到cpsr_c中                    */<br>    ldr sp, =0x80600000 /* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB */<br>    /* 进入SYS模式 */<br>    mrs r0, cpsr<br>    bic r0, r0, #0x1f   /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  */<br>    orr r0, r0, #0x1f   /* r0或上0x13,表示使用SYS模式                   */<br>    msr cpsr, r0        /* 将r0 的数据写入到cpsr_c中                    */<br>    ldr sp, =0x80500000 /* 设置SYS模式下的栈首地址为0X80400000,大小为2MB */<br>    /* 进入SVC模式 */<br>    mrs r0, cpsr<br>    bic r0, r0, #0x1f   /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  */<br>    orr r0, r0, #0x13   /* r0或上0x13,表示使用SVC模式                   */<br>    msr cpsr, r0        /* 将r0 的数据写入到cpsr_c中                    */<br>    ldr sp, =0X80400000 /* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */<br>    cpsie i             /* 打开全局中断 */<br>    /* 跳转到main函数 */<br>    b main<br>/* 未定义中断 */<br>Undefined_Handler:<br>    ldr r0, =Undefined_Handler<br>    bx r0<br>/* SVC中断 */<br>SVC_Handler:<br>    ldr r0, =SVC_Handler<br>    bx r0<br>/* 预取终止中断 */<br>PrefAbort_Handler:<br>    ldr r0, =PrefAbort_Handler  <br>    bx r0<br>/* 数据终止中断 */<br>DataAbort_Handler:<br>    ldr r0, =DataAbort_Handler<br>    bx r0  <br>/* 未使用的中断 */<br>NotUsed_Handler:<br>    ldr r0, =NotUsed_Handler<br>    bx r0  <br>/* IRQ中断！重点！！！！！ */<br>IRQ_Handler:<br>    /* 保护现场 */<br>    push &#123;lr&#125;                   /* 保存lr地址 */<br>    push &#123;r0-r3, r12&#125;           /* 保存r0-r3，r12寄存器 */<br>    mrs r0, spsr                /* 读取spsr寄存器 */<br>    push &#123;r0&#125;                   /* 保存spsr寄存器 */ <br><br>    /* 读取GIC控制器基地址 */<br>    mrc p15, 4, r1, c15, c0, 0 /* 从CP15的C0寄存器内的值到R1寄存器中<br>                                * 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49<br>                                * Cortex-A7 Technical ReferenceManua.pdf P68 P138<br>                                */                          <br>    add r1, r1, #0X2000         /* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 */<br>    /* 查询中断号 */<br>    ldr r0, [r1, #0XC]          /* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，<br>                                 * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据<br>                                 * 这个中断号来绝对调用哪个中断服务函数<br>                                 */<br>    push &#123;r0, r1&#125;               /* 保存r0,r1 */<br>    cps #0x13                   /* 进入SVC模式，允许其他中断再次进去 */<br>    push &#123;lr&#125;                   /* 保存SVC模式的lr寄存器 */<br>    ldr r2, =system_irqhandler  /* 加载C语言中断处理函数到r2寄存器中*/<br>    blx r2                      /* 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 */<br>    pop &#123;lr&#125;                    /* 执行完C语言中断服务函数，lr出栈 */<br>    cps #0x12                   /* 进入IRQ模式 */<br>    pop &#123;r0, r1&#125;                <br>    str r0, [r1, #0X10]         /* 中断执行完成，写EOIR，相当于确认中断执行完成 */<br>    pop &#123;r0&#125;                        <br>    msr spsr_cxsf, r0           /* 恢复spsr */<br>    pop &#123;r0-r3, r12&#125;            /* r0-r3,r12出栈 */<br>    pop &#123;lr&#125;                    /* lr出栈 */<br>    subs pc, lr, #4             /* 将lr-4赋给pc */<br>/* FIQ中断 */<br>FIQ_Handler:<br>    ldr r0, =FIQ_Handler    <br>    bx r0<br>loop:<br>    b loop<br></code></pre></td></tr></table></figure><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>中断向量，英文名为Interrupt Vector，在早期计算机体系结构里，“vector”常被用作“指针/地址索引”的意思，所以”向量“实际上就是地址指针的意思。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">本篇学习CortexA7中断系统和配置中断的启动文件的编写。</summary>
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>I-MX6ULL主频与时钟配置实验</title>
    <link href="https://blog.godmao.top/posts/33477/"/>
    <id>https://blog.godmao.top/posts/33477/</id>
    <published>2025-08-06T13:50:03.000Z</published>
    <updated>2025-08-14T14:51:38.995Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><h2 id="系统时钟浅析"><a class="markdownIt-Anchor" href="#系统时钟浅析"></a> 系统时钟浅析</h2><h3 id="7路pll"><a class="markdownIt-Anchor" href="#7路pll"></a> 7路PLL</h3><p>为了方便生成时钟，6从24MHz晶振生出来7路PLL。这7路PLL中有的又生出来PFD。</p><ul><li><code>PLL1</code>：ARM PLL供给ARM内核。</li><li><code>PLL2</code>：sysytem PLL，528MHz，528_PLL，此路PLL分出了4路PFD，分别为PLL2_PFD0~PFD3</li><li><code>PLL3</code>: USB1 PLL，480MHz 480_PLL，此路PLL分出了4路PFD，分别为PLL3_PFD0~PFD3。</li><li><code>PLL4</code>: Audio PLL，主供音频使用。</li><li><code>PLL5</code>: Video PLL，主供视频外设，比如RGB LCD接口，和图像处理有关的外设。</li><li><code>PLL6</code>：ENET PLL，主供网络外设。</li><li><code>PLL7</code>: USB2_PLL ,480MHz，无PFD。</li></ul><p>详见 IMX6ULL参考手册 Chapter 18 Clock Controller Module (CCM)</p><p>附 时钟树图：<br />t形为多路选择器</p><p><img src="Snipaste_2025-08-06_22-02-07.png" alt="" /><br /><img src="Snipaste_2025-08-06_22-03-45.png" alt="" /></p><h3 id="要初始化的pll和pfd"><a class="markdownIt-Anchor" href="#要初始化的pll和pfd"></a> 要初始化的PLL和PFD</h3><ul><li>PLL1，</li><li>PLL2，以及PLL2_PFD0~PFD3.</li><li>PLL3以及PLL3_PFD0~PFD3.<br />其他需要时再设置。<br />一般按照时钟树里面的值进行设置。</li></ul><h2 id="具体配置"><a class="markdownIt-Anchor" href="#具体配置"></a> 具体配置</h2><h3 id="系统主频的配置"><a class="markdownIt-Anchor" href="#系统主频的配置"></a> 系统主频的配置</h3><p>根据时钟树来设定系统主频。具体时钟配置的说明可以参见 IMX6ULL参考手册 18.5.1.5<br />CCM internal clock generation<br />下图为时钟切换器 （CCM_CLK_SWITCHER） 控制输出的示意图。</p><p><img src="Snipaste_2025-08-07_10-00-08.png" alt="" /></p><ol><li><p>要设置ARM内核主频为528MHz，设置CACRR寄存器的ARM_PODF位为2分频，然后设置PLL1=1056MHz即可。CACRR的bit3<sub>0为ARM_PODF位，可设置0</sub>7，分别对应1~8分频。应该设置CACRR寄存器的ARM_PODF=1。</p></li><li><p>切换时钟源。PLL1输出为pll1_sw_clk。pll1_sw_clk有两路可以选择，分别为pll1_main_clk，和step_clk，通过CCSR寄存器的pll1_sw_clk_sel位(bit2)来选择。为0的时候选择pll1_main_clk，为1的时候选额step_clk。</p></li><li><p>在修改PLL1的时候，也就是设置系统时钟的时候需要给6ULL一个临时的时钟，也就是step_clk。在修改PLL1的时候需要将pll1_sw_clk切换到step_clk上。</p></li><li><p>设置step_clk。Step_clk也有两路来源，由CCSR的step_sel位(bit8)来设置，为0的时候设置step_clk为osc=24MHz。为1的时候不重要，不用。</p></li><li><p>时钟切换成功以后就可以修改PLL1的值。</p></li><li><p>通过CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位(bit6~0)来设置PLL1的频率，公式为：</p><pre><code> Output = fref*DIV_SEL/2  1056=24*DIV_SEL/2=&gt;DIEV_SEL=88。  设置CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位=88即可。PLL1=1056MHz  还要设置CCM_ANALOG_PLL_ARM寄存器的ENABLE位(bit13)为1，也就是使能输出。</code></pre></li><li><p>在切换回PLL1之前，设置置CACRR寄存器的ARM_PODF=1！！切记。</p></li></ol><h3 id="其他pll设置"><a class="markdownIt-Anchor" href="#其他pll设置"></a> 其他PLL设置</h3><p>PLL2和PLL3。PLL2固定为528MHz，PLL3固定为480MHz。</p><ol><li>初始化PLL2_PFD0~PFD3。寄存器CCM_ANALOG_PFD_528用于设置4路PFD的时钟。比如PFD0= 528 * 18 / PFD0_FRAC。 设置PFD0_FRAC位即可。比如PLL2_PFD0=352M=528 *  18 / PFD0_FRAC，因此FPD0_FRAC=27。</li><li>同理初始化PLL3_PFD0~PFD3</li></ol><h2 id="外设时钟"><a class="markdownIt-Anchor" href="#外设时钟"></a> 外设时钟</h2><p>AHB_CLK_ROOT、PERCLK_CLK_ROOT以及IPG_CLK_ROOT。</p><p>因为PERCLK_CLK_ROOT和IPG_CLK_ROOT要用到AHB_CLK_ROOT，所以我们要初始化AHB_CLK_ROOT。</p><h3 id="ahb_clk_root的初始化"><a class="markdownIt-Anchor" href="#ahb_clk_root的初始化"></a> AHB_CLK_ROOT的初始化</h3><p>AHB_CLK_ROOT=132MHz。</p><p>设置CBCMR寄存器的PRE_PERIPH_CLK_SEL位，设置CBCDR寄存器的PERIPH_CLK_SEL位0。设置CBCDR寄存器的AHB_PODF位为2，也就是3分频，因此396/3=132MHz。</p><h3 id="ipg_clk_root初始化"><a class="markdownIt-Anchor" href="#ipg_clk_root初始化"></a> IPG_CLK_ROOT初始化</h3><p>设置CBCDR寄存器IPG_PODF=1，也就是2分频。</p><h3 id="perclk_clk_root初始化"><a class="markdownIt-Anchor" href="#perclk_clk_root初始化"></a> PERCLK_CLK_ROOT初始化</h3><p>设置CSCMR1寄存器的PERCLK_CLK_SEL位为0，表示PERCLK的时钟源为IPG。</p><h2 id="这篇文章写得很不错摘录一些"><a class="markdownIt-Anchor" href="#这篇文章写得很不错摘录一些"></a> 这篇文章写得很不错,摘录一些</h2><p><a href="https://blog.csdn.net/Beihai_Van/article/details/139868239">【嵌入式Linux】i.MX6ULL 时钟树——理论分析-CSDN博客</a></p><h3 id="总结pfd配置寄存器"><a class="markdownIt-Anchor" href="#总结pfd配置寄存器"></a> 总结PFD配置寄存器:</h3><p>CCM_ANALOG_PFD_528n 寄存器控制着 <a href="http://i.MX">i.MX</a> 6ULL 处理器中四个分数分频器的配置，包括时钟门控、稳定性状态和分数分频值。这些分频器用于生成不同频率的时钟信号，以满足各种外设的需求。</p><ol><li>CLKGATE 位 (Clock Gate): 时钟门控</li></ol><ul><li>作用: CLKGATE 位控制着对应 PFD 的时钟信号是否被开启或关闭。</li><li>值:<ul><li>0: 时钟信号开启，PFD 正常工作，可以输出分频后的时钟信号。</li><li>1: 时钟信号关闭，PFD 处于关闭状态，不输出时钟信号。</li></ul></li><li>目的:<ul><li>省电: 当某个外设不需要时钟信号时，可以通过设置 CLKGATE 位为 1 来关闭该 PFD 的时钟，从而减少功耗。</li><li>控制时钟信号: 在某些情况下，可能需要动态地控制某个外设的时钟信号，例如在系统启动或进入低功耗模式时。</li></ul></li></ul><ol start="2"><li>STABLE 位 (Stable): 稳定性状态</li></ol><ul><li>作用: STABLE 位指示对应 PFD 的输出时钟信号是否已经稳定。</li><li>值:<br />当新的分数分频值生效时，位域的值会反转（从 0 变为 1 或从 1 变为 0）。这个反转就像一个信号，表明分频器已经完成调整。</li><li>目的:<ul><li>诊断: STABLE 位是一个只读位，用于诊断 PFD 的稳定性。</li><li>确保时钟信号质量: 在修改 PFD 的分数分频值后，需要等待 STABLE 位反转，才能确保输出的时钟信号稳定可靠。</li></ul></li></ul><h3 id="imx6u-芯片-pll-时钟详解"><a class="markdownIt-Anchor" href="#imx6u-芯片-pll-时钟详解"></a> i.MX6U 芯片 PLL 时钟详解</h3><p>i.MX6U 芯片拥有多个 PLL（Phase-Locked Loop，锁相环）模块，用于生成各种频率的时钟信号，为芯片内部的不同模块和外设提供时钟源。下面整理了 i.MX6U 芯片的 7 个主要 PLL：</p><ol><li>ARM_PLL (PLL1)<ul><li>用途: 为 ARM 内核提供时钟信号。</li><li>倍频: 可编程，最高可倍频至 1.3GHz。</li><li>特点: ARM 内核的运行速度直接取决于此 PLL 的输出频率。</li></ul></li><li>528_PLL (PLL2)<ul><li>用途: 为系统总线、内部逻辑单元、DDR 接口、NAND/NOR 接口等提供时钟源。</li><li>倍频: 固定 22 倍频，不可编程。</li><li>输出频率: 24MHz * 22 = 528MHz。</li><li>特点: 该 PLL 以及其生成的 4 路 PFD (PLL2_PFD0~PLL2_PFD3) 是 i.MX6U 内部系统总线的核心时钟源。</li></ul></li><li>USB1_PLL (PLL3)<ul><li>用途: 主要用于 USB1PHY，但也可作为其他外设的时钟源。</li><li>倍频: 固定 20 倍频。</li><li>输出频率: 24MHz * 20 = 480MHz。</li><li>特点: 该 PLL 以及其生成的 4 路 PFD (PLL3_PFD0~PLL3_PFD3) 可用于多种外设。</li></ul></li><li>USB2_PLL (PLL7)<ul><li>用途: 为 USB2PHY 提供时钟信号。</li><li>倍频: 固定 20 倍频。</li><li>输出频率: 24MHz * 20 = 480MHz。</li><li>特点: 虽然序号标为 4，但实际是 PLL7。</li></ul></li><li>ENET_PLL (PLL6)<ul><li>用途: 用于生成网络所需的时钟信号。</li><li>倍频: 固定 20+5/6 倍频。</li><li>输出频率: 24MHz * (20+5/6) = 500MHz。</li><li>特点: 可在此 PLL 的基础上生成 25/50/100/125MHz 的网络时钟。</li></ul></li><li>VIDEO_PLL (PLL5)<ul><li>用途: 用于显示相关外设，例如 LCD。</li><li>倍频: 可调整，输出范围在 650MHz~1300MHz。</li><li>分频: 可选 1/2/4/8/16 分频。</li><li>特点: 可根据显示设备的需求调整输出频率和分频比。</li></ul></li><li>AUDIO_PLL (PLL4)<ul><li>用途: 用于音频相关外设。</li><li>倍频: 可调整，输出范围在 650MHz~1300MHz。</li><li>分频: 可选 1/2/4 分频。</li><li>特点: 可根据音频设备的需求调整输出频率和分频比。<br />总结:</li></ul></li></ol><p>i.MX6U 芯片通过多个 PLL 模块，生成各种频率的时钟信号，为芯片内部的不同模块和外设提供时钟源。每个 PLL 的倍频和分频都可以根据需要进行配置，以满足不同外设的需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>I-MX6ULL开发板C语言运行环境搭建并点灯</title>
    <link href="https://blog.godmao.top/posts/2969/"/>
    <id>https://blog.godmao.top/posts/2969/</id>
    <published>2025-07-28T09:03:51.000Z</published>
    <updated>2025-07-29T16:53:01.625Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><h2 id="c语言运行环境搭建"><a class="markdownIt-Anchor" href="#c语言运行环境搭建"></a> C语言运行环境搭建</h2><p>前面我们讲解了如何用汇编语言编写 LED 灯实验，但是实际开发过程中汇编用的很少，大部分都是 C 语言开发，汇编只是用来完成 C 语言环境的初始化。本文我们就来学习如何用汇编来完成 C 语言环境的初始化工作，然后从汇编跳转到 C 语言代码里面去。</p><h3 id="设置处理器模式"><a class="markdownIt-Anchor" href="#设置处理器模式"></a> 设置处理器模式</h3><p>对于Cortex-A处理器，有多种运行模式，例如User模式、中断模式等。除用户（User）模式为非特权模式，其余均为特权模式，特权模式下程序可以访问所有系统资源，还有自己独有的寄存器组，而非特权模式下访问受限。</p><p><img src="Snipaste_2025-07-28_17-13-11.png" alt="" /></p><p>而现在我们需要将处理器模式设置为SVC模式。<br />这就需要了解到内核寄存器组中的CPSR寄存器，其低四位为处理器运行模式控制位。</p><p><img src="Snipaste_2025-07-28_17-16-59.png" alt="" /></p><p><img src="Snipaste_2025-07-28_17-19-33%201.png" alt="" /></p><p><img src="Snipaste_2025-07-28_17-20-27.png" alt="" /></p><p>设置CPSR寄存器的bit4-0，也就是M[4:0]为10011=0X13。读写状态寄存器需要用到 MRS<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 和 MSR<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 指令。MRS将CPSR寄存器数据读出到通用寄存器里面，MSR指令将通用寄存器的值写入到CPSR寄存器里面去。</p><p>为啥不用SDR、LDR？因为这他妈属于处理器内部自己在传输数据，而不是从寄存器与存储器！而且它只能操作通用寄存器。</p><p><img src="Snipaste_2025-07-28_17-26-03.png" alt="" /></p><h3 id="设置sp寄存器"><a class="markdownIt-Anchor" href="#设置sp寄存器"></a> 设置sp寄存器</h3><p>也就是栈的起始地址。<br />Sp可以指向内部RAM，也可以指向DDR，我们将其指向DDR。Sp设置到哪里？512MB的范围0x80000000~0x9FFFFFFF。栈大小，0x200000=2MB，很大大大大了。</p><p>再提一嘴，由于NXP给我们提供的SDK包里面有初始化DDR等一系列操作，所以这里我们可以方便的设置sp寄存器，其他处理器（启动方式设置为DDR的情况下）如果没有初始化DDR，还需要先初始化DDR。</p><p>这里再说一下栈的特性，有点抽象……</p><ul><li>向上增长：即从低地址往高地址增长。以此判断即可。</li><li>向下增长：从高地址往低地址增长。</li><li>栈底：栈的起始位置。根据定义，如果是向下增长的，那么栈底为高地址。以此类推。</li><li>栈顶：程序运行时sp指针所指示的位置，不断变化。<br />处理器栈增长方式，对于A7而言是向下增长的。设置sp指向0x80200000。</li></ul><h3 id="跳转到c语言"><a class="markdownIt-Anchor" href="#跳转到c语言"></a> 跳转到C语言</h3><p>使用b指令，跳转到C语言函数，比如main函数。</p><p>其实我们在stm32的启动文件中也可以看到这些操作，提一嘴……</p><h2 id="实操"><a class="markdownIt-Anchor" href="#实操"></a> 实操</h2><p>我的文件结构长这样：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">project/<br>├── Makefile、lds<br>├── <span class="hljs-attribute">src</span>/<br>│   └── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>├── inc/<br>│   └── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.h</span><br>├── build/<br>└── bin/<br></code></pre></td></tr></table></figure><p>同时为了学习makefile，makefile就写得比较复杂：<br />注意makefile文件对缩进、空格非常敏感！</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># 设置目录变量，方便统一管理和修改</span><br><span class="hljs-comment"># 源代码目录:</span><br>SRC_DIR := src<br><span class="hljs-comment"># 头文件目录:</span><br>INC_DIR := inc<br><span class="hljs-comment"># 中间目标文件（.o）输出目录:</span><br>BUILD_DIR := build<br><span class="hljs-comment"># 最终生成的二进制文件（.bin）目录:</span><br>BIN_DIR := bin<br><br><span class="hljs-comment"># 设置编译工具（使用 ARM 的交叉编译工具链）</span><br><span class="hljs-comment"># 编译器（用于 .c 和 .S 文件）:</span><br>CC = arm-none-eabi-gcc<br><span class="hljs-comment"># 链接器:</span><br>LD = arm-none-eabi-ld<br><span class="hljs-comment"># 用于将 elf 转为 bin 格式:</span><br>OBJCOPY = arm-none-eabi-objcopy<br><br><span class="hljs-comment"># 编译选项（GCC 编译阶段）</span><br><span class="hljs-comment"># -I：指定头文件搜索目录</span><br><span class="hljs-comment"># -Wall：打开所有警告</span><br><span class="hljs-comment"># -nostdlib：不链接标准库（适用于裸机）</span><br><span class="hljs-comment"># -c：只编译，不链接</span><br>GCC_FLAGS = -I<span class="hljs-variable">$(INC_DIR)</span> -Wall -nostdlib -c<br><br><span class="hljs-comment"># 链接器选项</span><br><span class="hljs-comment"># -Ttext=0x80000000：设置代码段的起始地址（你设备上运行程序的入口地址）</span><br><span class="hljs-comment"># -e _start：显式设置程序入口点（防止链接器猜测）</span><br>LD_FLAGS = -Timx.lds<br><br><span class="hljs-comment"># 自动查找 src/ 目录下的所有 .c 文件</span><br>SRCS = <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(SRC_DIR)</span>/*.c)</span><br><br><span class="hljs-comment"># 将 src/xxx.c 转换为 build/xxx.o</span><br><span class="hljs-comment"># 例如：src/main.c → build/main.o</span><br><span class="hljs-comment"># 同时添加 build/startup.o（汇编启动文件）</span><br><span class="hljs-comment"># 这里注意是按顺序链接的，所以startup一定要在第一个否则链接到的地址不对（查看反汇编可知）</span><br>OBJS = <span class="hljs-variable">$(BUILD_DIR)</span>/startup.o<br>OBJS += <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> <span class="hljs-variable">$(SRC_DIR)</span>/%.c,<span class="hljs-variable">$(BUILD_DIR)</span>/%.o,<span class="hljs-variable">$(SRCS)</span>)</span><br><br><span class="hljs-comment"># 目标：生成最终的二进制文件 bin/ledc.bin</span><br><span class="hljs-variable">$(BIN_DIR)</span>/ledc.bin: <span class="hljs-variable">$(OBJS)</span><br><span class="hljs-comment"># 链接所有 .o 文件生成 elf 格式可执行文件</span><br>    <span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LD_FLAGS)</span> <span class="hljs-variable">$(OBJS)</span> -o <span class="hljs-variable">$(BUILD_DIR)</span>/ledc.elf<br><span class="hljs-comment"># 反汇编 调试用</span><br>    arm-none-eabi-objdump -D -m arm <span class="hljs-variable">$(BUILD_DIR)</span>/ledc.elf &gt; <span class="hljs-variable">$(BUILD_DIR)</span>/ledc.dis<br><span class="hljs-comment"># 把 elf 文件转换为裸机二进制文件（无符号、无头信息）</span><br>    <span class="hljs-variable">$(OBJCOPY)</span> -O binary -S <span class="hljs-variable">$(BUILD_DIR)</span>/ledc.elf <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 编译汇编启动文件 startup.S，生成 build/startup.o</span><br><span class="hljs-variable">$(BUILD_DIR)</span>/startup.o: startup.S<br><span class="hljs-comment"># 注意 startup.S 是汇编文件，用 gcc 编译也可以，默认会调用汇编器</span><br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(GCC_FLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 编译每个 .c 文件到 build/xxx.o</span><br><span class="hljs-comment"># $@：目标文件（例如 build/main.o）</span><br><span class="hljs-comment"># $&lt;：依赖的源文件（例如 src/main.c）</span><br><span class="hljs-variable">$(BUILD_DIR)</span>/%.o: <span class="hljs-variable">$(SRC_DIR)</span>/%.c<br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(GCC_FLAGS)</span> <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>    rm <span class="hljs-variable">$(BUILD_DIR)</span>/*.o <span class="hljs-variable">$(BUILD_DIR)</span>/*.elf <span class="hljs-variable">$(BIN_DIR)</span>/*.bin <span class="hljs-variable">$(BUILD_DIR)</span>/*.dis<br></code></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;main.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">clk_enable</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    LED_CLK_REG = <span class="hljs-number">0xffffffff</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    LED_MUX_REG = <span class="hljs-number">0x5</span>;          <span class="hljs-comment">//复用为GPIO1_IO4</span><br>    LED_PAD_REG = <span class="hljs-number">0x10b0</span>;       <span class="hljs-comment">//设置电气属性</span><br>    LED_GPIO_DIR_REG = <span class="hljs-number">0x10</span>;    <span class="hljs-comment">//io4设置为输出</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    clk_enable();<br>    led_init();<br>    LED_GPIO_DATA_REG = <span class="hljs-number">0x0</span>;      <span class="hljs-comment">//输出为低电平</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MAIN_H_  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MAIN_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED_CLK_REG *((volatile unsigned int*)0x020c406c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED_MUX_REG *((volatile unsigned int*)0x020e006c)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED_PAD_REG *((volatile unsigned int*)0x020e02f8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED_GPIO_DIR_REG *((volatile unsigned int*)0x0209c004)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED_GPIO_DATA_REG *((volatile unsigned int*)0x0209c000)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>startup.S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs asm">  <br>.global _start<br><br>_start:<br><br>    @ /* 1.设置处理器模式为SVC模式(其实CotexA内核上电默认即为SVC模式故不需要写) */<br>    @ mrs r0, cpsr                /* 读取cpsr到r0 */<br>    @ bic r0, r0, #0x1f           /* bic bit-clear位清零 */          <br>    @                             /* 等同于R0 = R0 &amp; (~Operand2) 这个操作数2自己推算*/<br>    @                             /* 现在这个操作相当于将r0的前5位清零了 */<br>    @ orr r0, r0, #0x13           /* orr 按位或 */<br><br>    @ msr cpsr, r0                /* 写入cpsr */<br>    @下面这段是重置CP15寄存器的一些位，好像加了更保险一些。目前还没弄明白，但是实测不需要也可以运行。<br>    @ mrc     p15, 0, r0, c1, c0, 0     /*读取CP15系统控制寄存器   */<br>    @ bic     r0,  r0, #0x1000     /*  清除第12位（I位）禁用 I Cache  */<br>    @ bic     r0,  r0, #0x4     /*  清除第 2位（C位）禁用 D Cache  */<br>    @ bic     r0,  r0, #0x2             /*  清除第 1位（A位）禁止严格对齐   */<br>    @ bic     r0,  r0, #0x800     /*  清除第11位（Z位）分支预测   */<br>    @ bic     r0,  r0, #0x1             /*  清除第 0位（M位）禁用 MMU   */<br>    @ mcr     p15, 0, r0, c1, c0, 0     /*  将修改后的值写回CP15寄存器   */<br><br>    /* 2.设置sp寄存器 */<br>    ldr sp, =0x80100000         /* 栈大小1M */<br>    <br>    /* 3.跳转到main函数 */<br>    b main<br>loop:<br>    b loop<br></code></pre></td></tr></table></figure><p>链接脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs lds"><br>ENTRY(_start)<br>SECTIONS &#123;<br>    . = 0x80000000;<br>    <br>    . = ALIGN(4);<br>    .text :<br>    &#123;<br>        build/startup.o<br>        *(.text)<br>    &#125;<br><br>    . = ALIGN(4);<br>    .rodata : <br>    &#123;<br>        *(.rodata*)<br>    &#125;<br>    <br>    . = ALIGN(4);<br>    .data : <br>    &#123;<br>        *(.data)<br>    &#125;<br><br>    . = ALIGN(4);<br>    __bss_start = .;  <br>    .bss :<br>    &#123;<br>        *(.bss)<br>        *(COMMON)<br>    &#125;<br>    __bss_end = .;<br> &#125;<br><br></code></pre></td></tr></table></figure><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><strong>M</strong>ove to <strong>R</strong>egister from <strong>S</strong>pecial register.  加载到通用寄存器 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><strong>M</strong>ove to <strong>S</strong>pecial register from <strong>R</strong>egister.  恢复到特殊寄存器 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浅析IMX镜像文件结构</title>
    <link href="https://blog.godmao.top/posts/undefined/"/>
    <id>https://blog.godmao.top/posts/undefined/</id>
    <published>2025-07-14T11:24:15.000Z</published>
    <updated>2025-07-28T09:01:32.042Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><h2 id="当使用内部bootrom启动时发生了什么"><a class="markdownIt-Anchor" href="#当使用内部bootrom启动时发生了什么"></a> 当使用内部BootROM启动时，发生了什么？</h2><p>当我们通过设置BOOT_MODE[1:0]为内部启动模式时，即芯片通过执行内部的bootROM固有的代码来启动，在此模式下，芯片会执行内部的 boot ROM 代码，这段 boot ROM 代码会进行硬件初始化(一部分外设)，然后从 boot 设备(就是存放代码的设备、比如 SD/EMMC、NAND)中将代码拷贝出来复制到指定的 RAM 中，一般是 DDR。</p><ul><li>设置内核时钟为396MHz。使能MMU和Cache，使能L1cache、L2 cache、MMU，目的就为了加速启动。</li><li>从BOOT_CFG设置的外置存储中，读取image，然后做相应的处理。</li></ul><p><img src="Snipaste_2025-07-14_19-59-23.png" alt="" /><img src="Snipaste_2025-07-14_20-01-17.png" alt="" /><br />其中内存管理单元（Memory Management Unit）用于将物理地址翻译为虚拟内存地址，以及通过虚拟内存访问实际物理内存。而初始化高速缓存则是加速数据访问。</p><h2 id="镜像文件结构"><a class="markdownIt-Anchor" href="#镜像文件结构"></a> 镜像文件结构</h2><p>在上一节<a href="https://blog.godmao.top/posts/43400/">【点灯大师】点亮I.MX6ULL开发板的LED灯</a>提到过，通过汇编生成的bin文件并不能直接使用，还需要添加额外的头文件信息。我们使用VSCODE（需要扩展hex-editor）打开生成的img文件，这个文件是上一节我们使用<code>mkimage.sh</code>生成的。我们可以先查看一下这个sh文件方便理解：<br />我们只截取通过sd卡启动的配置参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">elif [ &quot;$1&quot; == &quot;sd&quot; ]; then<br>    ../bin/$IMG_BUILDER --combine base_addr=0x80000000 ivt_offset=0x400 app_offset=0x2000 dcd_file=dcd.bin app_file=sdk20-app.bin ofile=sdk20-app.img image_entry_point=0x80002000<br></code></pre></td></tr></table></figure><p>可以看到，该脚本为我们默认设置的基址为0x80000000，也就是绝对的起始地址，在此基础上，偏移app_offset即为应用程序的起始地址。因此程序的起始地址（bin的起始地址）为0x80002000，ivt表则是偏移了1024字节，0x400。<br /><img src="Snipaste_2025-07-14_21-25-46.png" alt="" /><br />接下来我们看img文件的内容：<br /><img src="Snipaste_2025-07-14_21-34-13.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="boot" scheme="https://blog.godmao.top/Tags/boot/"/>
    
  </entry>
  
  <entry>
    <title>【点灯大师】点亮I.MX6ULL开发板的LED灯</title>
    <link href="https://blog.godmao.top/posts/43400/"/>
    <id>https://blog.godmao.top/posts/43400/</id>
    <published>2025-06-29T17:03:23.000Z</published>
    <updated>2025-07-28T10:35:42.849Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><ul><li><a href="#1-%E6%B1%87%E7%BC%96led%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">1. 汇编LED原理分析</a></li><li><a href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B">2. 初始化流程</a><ul><li><a href="#21-stm32%E7%9A%84%E5%A4%A7%E8%87%B4io%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B">2.1. STM32的大致IO初始化流程</a></li><li><a href="#22-imx6ull-io%E5%88%9D%E5%A7%8B%E5%8C%96">2.2. I.MX6ULL IO初始化</a></li></ul></li><li><a href="#3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">3. 汇编语言实现</a></li><li><a href="#4-%E9%93%BE%E6%8E%A5%E4%B8%8E%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2">4. 链接与格式转换</a><ul><li><a href="#41-%E9%93%BE%E6%8E%A5">4.1. 链接</a></li><li><a href="#42-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2">4.2. 格式转换</a></li></ul></li><li><a href="#5-%E4%BD%BF%E7%94%A8%E5%AE%98%E6%96%B9sdk%E5%8C%85%E7%94%9F%E6%88%90%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6">5. 使用官方SDK包生成镜像文件</a></li><li><a href="#6-%E5%AE%89%E8%A3%85sdk%E5%8C%85">6. 安装SDK包</a><ul><li><a href="#61-build-sdk">6.1. build SDK</a></li><li><a href="#62-%E7%94%9F%E6%88%90%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6">6.2. 生成镜像文件</a></li></ul></li><li><a href="#7-%E7%83%A7%E5%BD%95%E5%88%B0sd%E5%8D%A1">7. 烧录到SD卡</a></li><li><a href="#8-%E8%BE%BE%E6%88%90%E6%88%90%E5%B0%B1%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88">8. 达成成就【点灯大师】</a></li><li><a href="#9-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">9. 参考资料</a></li></ul><h2 id="1-汇编led原理分析"><a class="markdownIt-Anchor" href="#1-汇编led原理分析"></a> 1. 汇编LED原理分析</h2><p>为什么不像STM32那样直接使用c语言？</p><p>答：因为ST已经为你用汇编写好了初始化过程，比如初始化时钟等等外设，初始化Ram，设置sp指针，配置好c语言运行环境等等。而一般这些一块CortexA架构的板子是不提供的。</p><p>所以我们要使用汇编：</p><ol><li>初始化一些SOC外设。</li><li>初始化DDR<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</li></ol><blockquote><p>这个I.MX6U倒是不需要。I.MX内部的ROM存放了自己编写的启动代码，这些启动代码可以读取DDR配置信息，并完成其的初始化。</p></blockquote><ol start="3"><li>设置sp指针，一般指向DDR，设置好C语言运行环境。</li></ol><h2 id="2-初始化流程"><a class="markdownIt-Anchor" href="#2-初始化流程"></a> 2. 初始化流程</h2><blockquote><p>具体原理、寄存器详细位讲解可以看正点原子的Linux驱动开发指南。</p></blockquote><p>这里我们对比STM32的IO初始化流程来学习I.MX的初始化流程</p><h3 id="21-stm32的大致io初始化流程"><a class="markdownIt-Anchor" href="#21-stm32的大致io初始化流程"></a> 2.1. STM32的大致IO初始化流程</h3><ol><li>使能时钟</li><li>设置IO复用，复用为GPIO</li><li>配置GPIO的电气属性</li><li>使用GPIO——利用控制寄存器设置GPIO的输入输出功能</li></ol><h3 id="22-imx6ull-io初始化"><a class="markdownIt-Anchor" href="#22-imx6ull-io初始化"></a> 2.2. I.MX6ULL IO初始化</h3><p>同样的，IO的使用分为两个部分，CONFIG和CONTROL</p><p>CONFIG部分，I.MX的每个IO都有两个寄存器来配置，分别是多路复用寄存器（IOMUXC_SW_MUX_CTL_PAD_XX_XX）和配置电气特性的寄存器（IOMUXC_SW_PAD_CTL_PAD_XX_XX）它们在命名的第三个字段加以区分。我们可以查阅正点原子的Linux驱动开发指南以及官方的参考手册查看每一位的意义。</p><p>CONTROL部分，也有各种寄存器，来控制IO的各个功能，比如<em>GPIOx_DR</em>寄存器就是控制输入输出的高低电平，共有32位，每一位控制第x组IO各个引脚的高低电平。</p><p>使能时钟，CCGR0~CCGR6这7个寄存器控制着6ULL所有外设时钟的使能。（参考《I.MX6UL 参考手册》的第 18 章“Chapter 18: ClockController Module(CCM)”）</p><p>总结一下，I.MX6ULL的初始化一个IO流程如下：</p><ol><li>使能时钟，CCGR0<sub>CCGR6这7个寄存器控制着6ULL所有外设时钟的使能。为了简单，设置CCGR0</sub>CCGR6这7个寄存器全部为0XFFFFFFFF，相当于使能所有外设时钟。</li><li>IO复用，将寄存器IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03的bit3~0设置为0101=5，这样GPIO1_IO03就复用为GPIO。</li><li>寄存器IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03是设置GPIO1_IO03的电气属性。包括压摆率、速度、驱动能力、开漏、上下拉等。</li><li>配置GPIO功能，设置输入输出。设置GPIO1_GDIR寄存器bit3为1，也就是设置为输出模式。设置GPIO1_DR寄存器的bit3，为1表示输出高电平，为0表示输出低电平。</li></ol><h2 id="3-汇编语言实现"><a class="markdownIt-Anchor" href="#3-汇编语言实现"></a> 3. 汇编语言实现</h2><p>在了解上述内容后我们可以正式开始写代码了，在Linux环境下新建<code>led.s</code>汇编文件。<br />内容可以参考如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs asm">/* 点亮led汇编代码 */<br><br>.global _start @全局标号<br><br>_start:<br><br>@1.使能时钟<br>    @查找原理图和参考手册可知，LED1连接GPIO1-io4，GPIO1的时钟属于CCM_CCGR1 CG13（26-27位）<br><br>ldr r0, =0x020c406c @将寄存器地址加载到r0<br>ldr r1, =0xFFFFFFF  @为了方便打开全部时钟，相应的功耗也有所增加<br>str r1, [r0] @将r1中的值存入以r0中的值为地址的寄存器中<br>  <br>2.设置io引脚复用为gpio<br>  <br>ldr r0, =0x020e006c @将寄存器地址加载到r0<br>mov r1, #5 @将寄存器要设置的值加载到r1<br>str r1, [r0]<br><br><br>@3.设置io电气属性<br><br>    /*<br><br>     * bit0     SRE压摆率       0       disable<br><br>     * bit5:3   DSE io驱动能力  110     R0/6<br><br>     * bit7:6   speed          10      100MHz<br><br>     * bit11    ODE 开路输出     0      disable<br><br>     * bit12    PKE 使能pull/keeper 1   enable<br><br>     * bit13    PUE pull or keeper 0   keeper<br><br>     * bit15:14 上下拉电阻       00      100K下拉<br><br>     * bit16    HYS             0       disable<br><br>     */<br><br>ldr r0, =0x020e02f8<br>ldr r1, =0x10b0 @将寄存器要设置的值加载到r1<br>str r1, [r0]<br> <br>@4.设置GPIO功能<br>    @设置为输出 GDIR寄存器<br><br>ldr r0, =0x0209c004<br>mov r1, #16<br>str r1, [r0] @将GPIO1组的第4个io口设置为输出模式<br><br>    @设置为输出低电平 DR寄存器<br><br>ldr r0, =0x0209c000<br>mov r1, #0<br>str r1, [r0] @将GPIO1组的第4个io口设置为输出低电平  <br><br>@5.防止CPU进入未知状态<br><br>    @写入死循环<br>loop:<br>    b loop<br>    <br>/* Finally! END! */<br></code></pre></td></tr></table></figure><h2 id="4-链接与格式转换"><a class="markdownIt-Anchor" href="#4-链接与格式转换"></a> 4. 链接与格式转换</h2><blockquote><p>默认已安装了<code>arm-linux-gnueabihf</code>编译套件</p></blockquote><h3 id="41-链接"><a class="markdownIt-Anchor" href="#41-链接"></a> 4.1. 链接</h3><p>使用命令</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">arm-linux-gnueabihf-ld -Ttext 0X80000000 led.o -o led.elf<br></code></pre></td></tr></table></figure><p>上述命令中-Ttext 就是指定链接起始地址，“-o”，我理解为output，指定链接生成的 elf 文件名，这里我们命名为 led.elf。上述命令执行完以后就会在工程目录下多一个 led.elf 文件。<br />这个elf相当于win中的exe，是一个可执行文件。</p><h3 id="42-格式转换"><a class="markdownIt-Anchor" href="#42-格式转换"></a> 4.2. 格式转换</h3><p>使用命令</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin<br></code></pre></td></tr></table></figure><p>上述命令中，“-O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出，<br />选项“-S”表示不要复制源文件中的重定位信息和符号信息，“-g”表示不复制源文件中的调试<br />信息。<br />至此我们终于等到了想要的东西—led.bin 文件。<br />但是 I.MX6U 不能直接烧写编译生成的.bin 文件，我们需要在.bin 文件前面添加一些头信息构成满足 I.MX6U 需求的最终可烧写文件，I.MX6U 的最终可烧写文件组成如下：</p><ol><li>Image vector table，简称 IVT，IVT 里面包含了一系列的地址信息，这些地址信息在<br />ROM 中按照固定的地址存放着。</li><li>Boot data，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。</li><li>Device configuration data，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置。</li><li>用户代码可执行文件，比如 led.bin。</li></ol><h2 id="5-使用官方sdk包生成镜像文件"><a class="markdownIt-Anchor" href="#5-使用官方sdk包生成镜像文件"></a> 5. 使用官方SDK包生成镜像文件</h2><p><span class="spoiler">你不会以为我要用正点原子或者野火提供的镜像制作软件吧孩子</span></p><p>此步所需软件：<br />:::success</p><ul><li>NXP SDK_2.2_MCIM6ULL<br />:::</li></ul><p>第二个可从NXP官网获取。</p><h2 id="6-安装sdk包"><a class="markdownIt-Anchor" href="#6-安装sdk包"></a> 6. 安装SDK包</h2><p>使用共享文件夹将“SDK_2.2_MCIM6ULL_RFP_Linux.run” 拷贝到Linux下，存放位置自定。用chmod添加权限。然后运行.run文件生成SDK，linux下的源文件命令如下：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">./SDK_2.2_MCIM6ULL_RFP_Linux.run<br></code></pre></td></tr></table></figure><h3 id="61-build-sdk"><a class="markdownIt-Anchor" href="#61-build-sdk"></a> 6.1. build SDK</h3><p>此步所需软件：<br />:::success</p><ul><li>gcc-arm-none-eabi交叉编译套件</li><li>cmake<br />:::<br />在Linux环境下，<br />添加临时环境变量，执行以下命令：</li></ul><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh"><span class="hljs-built_in">export</span> ARMGCC_DIR=/usr<br></code></pre></td></tr></table></figure><p>进入工程文件<strong>SDK_2.2_MCIM6ULL/boards/evkmcimx6ull/demo_apps/hello_world/armgcc</strong> 运行build_ddr_release.sh脚本</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">./build_ddr_release.sh<br></code></pre></td></tr></table></figure><h3 id="62-生成镜像文件"><a class="markdownIt-Anchor" href="#62-生成镜像文件"></a> 6.2. 生成镜像文件</h3><p>进入工程文件<strong>SDK_2.2_MCIM6ULL/tools/imgutil/evkmcimx6ull</strong><br />查看readme.txt 查看使用教程<br />readme.txt内容如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">IMGUTIL User Guide<br>  <br>======================================<br><br>1. Build SDK2.0 application<br>2. Copy built binary (.bin file) to imgutil/&lt;board&gt; folder and rename to sdk20-app.bin<br>3. In imgutil/&lt;board&gt; folder, run mkimage.sh in mingw32 shell to get bootable image file sdk20-app.img<br>    a. If the image is built with ram link file, use &quot;mkimage.sh ram&quot; to make the bootable image.<br>    b. If the image is built with flash link file, use &quot;mkimage.sh flash&quot; to make the bootable XIP image.<br>    c. If the image is built with ram link file and want to boot from MicroSD card, use &quot;mkimage.sh sd&quot; to make the bootable image.<br><br>======================================<br></code></pre></td></tr></table></figure><p>大致意思：</p><ol><li>build SDK（前面已经做了）</li><li>复制你要制作为镜像的bin文件到对应的设备文件夹并将复制的bin文件改名为<code>sdk20-app.bin</code></li></ol><blockquote><p>我们的板子是imx6ull，故复制到当前文件夹</p></blockquote><ol start="3"><li>使用 mkimage.sh+参数 来制作镜像 参数指定启动方式，有：<ul><li>ram</li><li>flash</li><li>sd<br />参数我们使用sd。</li></ul></li></ol><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">./mkimage sd<br></code></pre></td></tr></table></figure><p>运行后，生成了<code>sdk20-app.img</code>文件</p><h2 id="7-烧录到sd卡"><a class="markdownIt-Anchor" href="#7-烧录到sd卡"></a> 7. 烧录到SD卡</h2><p>由于我使用的是WSL环境，WSL访问USB比较不方便所以改在win下烧录。</p><p>此步所需软件：<br />:::success</p><ul><li>Win32DiskImager<br />:::</li></ul><p>此步非常简单，将生成的img文件传到win文件夹下，使用Win32DiskImager软件烧录到连接到win的SD卡。</p><h2 id="8-达成成就点灯大师"><a class="markdownIt-Anchor" href="#8-达成成就点灯大师"></a> 8. 达成成就【点灯大师】</h2><p>将SD卡插入imx6ull，设置启动方式为SD卡，具体设置需参考你板子的硬件原理图，比如我的：<br /><img src="Snipaste_2025-06-30_00-49-08.png" alt="" /><br />成功点亮！<br /><img src="WIN_20250630_00_50_53_Pro.jpg" alt="" /></p><h2 id="9-参考资料"><a class="markdownIt-Anchor" href="#9-参考资料"></a> 9. 参考资料</h2><ul><li>《【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.81》</li><li><a href="https://doc.embedfire.com/linux/imx6/driver/zh/latest/index.html">[野火]嵌入式Linux驱动开发实战指南——基于i.MX6ULL系列 — [野火]嵌入式Linux驱动开发实战指南——基于i.MX6ULL系列 文档</a></li><li>《IMX6ULL参考手册》</li></ul><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Double Data Rate SDRAM 双倍数据速率同步动态随机存储器 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本流程控制简明指南</title>
    <link href="https://blog.godmao.top/posts/21870/"/>
    <id>https://blog.godmao.top/posts/21870/</id>
    <published>2025-06-18T10:38:30.000Z</published>
    <updated>2025-06-18T10:54:34.197Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><ul><li><a href="#1-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5-ifelse">1. 条件判断语句 if/else</a><ul><li><a href="#11-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">1.1. 基本语法：</a></li><li><a href="#12-%E7%A4%BA%E4%BE%8B">1.2. 示例：</a></li></ul></li><li><a href="#2-%E5%88%A4%E6%96%AD%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E">2. 判断符号说明</a></li><li><a href="#3-case-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">3. case 分支结构</a><ul><li><a href="#31-%E8%AF%AD%E6%B3%95">3.1. 语法：</a></li><li><a href="#32-%E7%A4%BA%E4%BE%8B">3.2. 示例：</a></li></ul></li><li><a href="#4-for-%E5%BE%AA%E7%8E%AF">4. for 循环</a><ul><li><a href="#41-%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8">4.1. 遍历列表：</a></li><li><a href="#42-%E4%BD%BF%E7%94%A8-c-%E9%A3%8E%E6%A0%BC%E8%AF%AD%E6%B3%95">4.2. 使用 C 风格语法：</a></li></ul></li><li><a href="#5-while-%E5%BE%AA%E7%8E%AF">5. while 循环</a><ul><li><a href="#51-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">5.1. 基本语法：</a></li><li><a href="#52-%E7%A4%BA%E4%BE%8B">5.2. 示例：</a></li></ul></li><li><a href="#6-until-%E5%BE%AA%E7%8E%AF">6. until 循环</a></li><li><a href="#7-%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AFbreak-%E5%92%8C-continue">7. 跳出循环：break 和 continue</a></li></ul><p>Shell 脚本不仅可以批量处理命令任务，还拥有完整的流程控制语法结构，包括条件判断、循环与分支等逻辑控制结构。本文将简明介绍 Shell 的基本流程控制语法，适用于 bash 环境。</p><h2 id="1-条件判断语句-ifelse"><a class="markdownIt-Anchor" href="#1-条件判断语句-ifelse"></a> 1. 条件判断语句 if/else</h2><h3 id="11-基本语法"><a class="markdownIt-Anchor" href="#11-基本语法"></a> 1.1. 基本语法：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ 条件 ]; then<br>    命令1<br>elif [ 条件 ]; then<br>    命令2<br>else<br>    命令3<br>fi<br></code></pre></td></tr></table></figure><p>写成一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ ]; then ; fi<br></code></pre></td></tr></table></figure><h3 id="12-示例"><a class="markdownIt-Anchor" href="#12-示例"></a> 1.2. 示例：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">read -p &quot;请输入一个数字: &quot; num<br>if [ &quot;$num&quot; -gt 0 ]; then<br>    echo &quot;正数&quot;<br>elif [ &quot;$num&quot; -lt 0 ]; then<br>    echo &quot;负数&quot;<br>else<br>    echo &quot;零&quot;<br>fi<br></code></pre></td></tr></table></figure><hr /><h2 id="2-判断符号说明"><a class="markdownIt-Anchor" href="#2-判断符号说明"></a> 2. 判断符号说明</h2><table><thead><tr><th>条件表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>等于（整数）</td></tr><tr><td><code>-ne</code></td><td>不等于</td></tr><tr><td><code>-gt</code></td><td>大于</td></tr><tr><td><code>-lt</code></td><td>小于</td></tr><tr><td><code>-ge</code></td><td>大于等于</td></tr><tr><td><code>-le</code></td><td>小于等于</td></tr><tr><td><code>-z str</code></td><td>字符串是否为空</td></tr><tr><td><code>-n str</code></td><td>字符串是否非空</td></tr><tr><td><code>str1 = str2</code></td><td>字符串相等</td></tr><tr><td><code>-f file</code></td><td>是否为普通文件</td></tr><tr><td><code>-d dir</code></td><td>是否为目录</td></tr></tbody></table><blockquote><p>注意：<code>[</code> 和 <code>]</code> 要有空格；变量最好加引号防止空值。</p></blockquote><h2 id="3-case-分支结构"><a class="markdownIt-Anchor" href="#3-case-分支结构"></a> 3. case 分支结构</h2><p>用于多个条件的匹配处理。</p><h3 id="31-语法"><a class="markdownIt-Anchor" href="#31-语法"></a> 3.1. 语法：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量 in<br>    模式1)<br>        命令 ;;<br>    模式2)<br>        命令 ;;<br>    *)<br>        默认命令 ;;<br>esac<br></code></pre></td></tr></table></figure><h3 id="32-示例"><a class="markdownIt-Anchor" href="#32-示例"></a> 3.2. 示例：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">read -p &quot;请输入选项[a/b/c]: &quot; choice<br>case $choice in<br>    a) echo &quot;你选择了A&quot; ;;<br>    b) echo &quot;你选择了B&quot; ;;<br>    c) echo &quot;你选择了C&quot; ;;<br>    *) echo &quot;无效选项&quot; ;;<br>esac<br></code></pre></td></tr></table></figure><h2 id="4-for-循环"><a class="markdownIt-Anchor" href="#4-for-循环"></a> 4. for 循环</h2><h3 id="41-遍历列表"><a class="markdownIt-Anchor" href="#41-遍历列表"></a> 4.1. 遍历列表：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">for var in 值1 值2 值3; do<br>    命令<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">for name in Alice Bob Charlie; do<br>    echo &quot;Hello, $name&quot;<br>done<br></code></pre></td></tr></table></figure><h3 id="42-使用-c-风格语法"><a class="markdownIt-Anchor" href="#42-使用-c-风格语法"></a> 4.2. 使用 C 风格语法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> ((i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">5</span>; i++)); <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;第 <span class="hljs-variable">$i</span> 次&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h2 id="5-while-循环"><a class="markdownIt-Anchor" href="#5-while-循环"></a> 5. while 循环</h2><h3 id="51-基本语法"><a class="markdownIt-Anchor" href="#51-基本语法"></a> 5.1. 基本语法：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">while [ 条件 ]; do<br>    命令<br>done<br></code></pre></td></tr></table></figure><h3 id="52-示例"><a class="markdownIt-Anchor" href="#52-示例"></a> 5.2. 示例：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">i=1<br>while [ $i -le 5 ]; do<br>    echo &quot;循环第 $i 次&quot;<br>    ((i++))<br>done<br></code></pre></td></tr></table></figure><h2 id="6-until-循环"><a class="markdownIt-Anchor" href="#6-until-循环"></a> 6. until 循环</h2><p>与 <code>while</code> 相反：<strong>条件为假时执行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">i=1<br>until [ $i -gt 5 ]; do<br>    echo &quot;第 $i 次&quot;<br>    ((i++))<br>done<br></code></pre></td></tr></table></figure><h2 id="7-跳出循环break-和-continue"><a class="markdownIt-Anchor" href="#7-跳出循环break-和-continue"></a> 7. 跳出循环：break 和 continue</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">for ((i=1;i&lt;=10;i++)); do<br>    if [ $i -eq 5 ]; then<br>        break   # 提前结束循环<br>    fi<br>    echo $i<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">for ((i=1;i&lt;=5;i++)); do<br>    if [ $i -eq 3 ]; then<br>        continue   # 跳过当前循环<br>    fi<br>    echo $i<br>done<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="Shell" scheme="https://blog.godmao.top/categories/Linux/Shell/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="shell" scheme="https://blog.godmao.top/Tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本入门</title>
    <link href="https://blog.godmao.top/posts/27290/"/>
    <id>https://blog.godmao.top/posts/27290/</id>
    <published>2025-06-18T08:22:15.000Z</published>
    <updated>2025-06-18T10:34:11.431Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>作为linux嵌入式开发，掌握一些shell脚本的基础是必要的。</p><ul><li><a href="#1-shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%86%99%E6%B3%95">1. shell脚本的写法</a></li><li><a href="#2-shell%E8%84%9A%E6%9C%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">2. shell脚本的一些基本用法</a><ul><li><a href="#21-%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0">2.1. 输入参数</a></li><li><a href="#22-%E6%95%B4%E5%BD%A2%E8%BF%90%E7%AE%97">2.2. 整形运算</a></li><li><a href="#23-test%E5%91%BD%E4%BB%A4">2.3. test命令</a><ul><li><a href="#231-%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95">2.3.1. 文件测试</a></li><li><a href="#232-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83">2.3.2. 字符串比较</a></li><li><a href="#233-%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83">2.3.3. 数值比较</a></li><li><a href="#234-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6">2.3.4. 逻辑操作符</a></li></ul></li><li><a href="#24-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">2.4. 条件判断</a></li></ul></li><li><a href="#3-%E6%8B%93%E5%B1%95shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">3. 拓展：shell脚本中<code>$</code>的作用</a><ul><li><a href="#31-%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8">3.1. 变量引用</a></li><li><a href="#32-%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2">3.2. 命令替换</a></li><li><a href="#33-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%92%8C%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F">3.3. 位置参数和特殊变量</a></li><li><a href="#34-%E7%AE%97%E6%9C%AF%E6%89%A9%E5%B1%95">3.4. 算术扩展</a></li><li><a href="#35-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC%E5%A4%84%E7%90%86">3.5. 字符串操作和默认值处理</a></li></ul></li></ul><h2 id="1-shell脚本的写法"><a class="markdownIt-Anchor" href="#1-shell脚本的写法"></a> 1. shell脚本的写法</h2><p>shell是个纯文本文件，命令从上而下，一行一行开始执行，<a href="http://xn--shell-iq1h016atuqd2mjsls84bdt0a.sh">shell脚本的扩展名为.sh</a><br />第一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">！/bin/bash</span><br></code></pre></td></tr></table></figure><p>表示使用bash</p><h2 id="2-shell脚本的一些基本用法"><a class="markdownIt-Anchor" href="#2-shell脚本的一些基本用法"></a> 2. shell脚本的一些基本用法</h2><h3 id="21-输入参数"><a class="markdownIt-Anchor" href="#21-输入参数"></a> 2.1. 输入参数</h3><p><code>read</code>常用选项：</p><ul><li>-a array 将输入的值作为数组赋值</li><li>-d delim 指定输入结束的标识符</li><li>-p prompt 在输入前打印提示信息</li><li>-t timeout 设置超时时间</li><li>-e 在输入的时候可以使用命令补全</li><li>-s silent 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。</li></ul><hr /><h3 id="22-整形运算"><a class="markdownIt-Anchor" href="#22-整形运算"></a> 2.2. 整形运算</h3><p>使用<code>$[]</code>进行算数扩展</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">read -p &quot;two num: &quot; num1 num2<br>echo &quot;$num1 + $num2 = $[num1 + num2]&quot;<br></code></pre></td></tr></table></figure><hr /><h3 id="23-test命令"><a class="markdownIt-Anchor" href="#23-test命令"></a> 2.3. test命令</h3><p>用于查看文件是否存在、权限等信息。可以对数值、字符、文件三方面测试，<strong>返回布尔值</strong><br />格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">test EXPRESSION<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>[ EXPRESSION ]  # 注意方括号内必须有空格<br></code></pre></td></tr></table></figure><h4 id="231-文件测试"><a class="markdownIt-Anchor" href="#231-文件测试"></a> 2.3.1. 文件测试</h4><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>-e</td><td>文件是否存在</td><td><code>[ -e file.txt ]</code></td></tr><tr><td>-f</td><td>是普通文件</td><td><code>[ -f /path/to/file ]</code></td></tr><tr><td>-d</td><td>是目录</td><td><code>[ -d /path/to/dir ]</code></td></tr><tr><td>-r</td><td>可读</td><td><code>[ -r file.txt ]</code></td></tr><tr><td>-w</td><td>可写</td><td><code>[ -w file.txt ]</code></td></tr><tr><td>-x</td><td>可执行</td><td><code>[ -x script.sh ]</code></td></tr><tr><td>-s</td><td>文件大小 &gt;0</td><td><code>[ -s logfile ]</code></td></tr><tr><td>-L</td><td>是符号链接</td><td><code>[ -L symlink ]</code></td></tr></tbody></table><h4 id="232-字符串比较"><a class="markdownIt-Anchor" href="#232-字符串比较"></a> 2.3.2. 字符串比较</h4><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>-z STRING</td><td>字符串为空</td><td><code>[ -z &quot;$var&quot; ]</code></td></tr><tr><td>-n STRING</td><td>字符串非空</td><td><code>[ -n &quot;$var&quot; ]</code></td></tr><tr><td>STRING1 = STRING2</td><td>字符串相等</td><td><code>[ &quot;$var1&quot; = &quot;$var2&quot; ]</code></td></tr><tr><td>STRING1 != STRING2</td><td>字符串不等</td><td><code>[ &quot;$var1&quot; != &quot;$var2&quot; ]</code></td></tr></tbody></table><h4 id="233-数值比较"><a class="markdownIt-Anchor" href="#233-数值比较"></a> 2.3.3. 数值比较</h4><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>-eq</td><td>等于</td><td><code>[ &quot;$a&quot; -eq &quot;$b&quot; ]</code></td></tr><tr><td>-ne</td><td>不等于</td><td><code>[ &quot;$a&quot; -ne &quot;$b&quot; ]</code></td></tr><tr><td>-gt</td><td>大于</td><td><code>[ &quot;$a&quot; -gt &quot;$b&quot; ]</code></td></tr><tr><td>-ge</td><td>大于或等于</td><td><code>[ &quot;$a&quot; -ge &quot;$b&quot; ]</code></td></tr><tr><td>-lt</td><td>小于</td><td><code>[ &quot;$a&quot; -lt &quot;$b&quot; ]</code></td></tr><tr><td>-le</td><td>小于或等于</td><td><code>[ &quot;$a&quot; -le &quot;$b&quot; ]</code></td></tr></tbody></table><h4 id="234-逻辑操作符"><a class="markdownIt-Anchor" href="#234-逻辑操作符"></a> 2.3.4. 逻辑操作符</h4><p><code>test</code> 支持逻辑组合：</p><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>!</td><td>逻辑非</td><td><code>[ ! -f &quot;$file&quot; ]</code></td></tr><tr><td>-a</td><td>逻辑与</td><td><code>[ &quot;$a&quot; -eq 1 -a &quot;$b&quot; -eq 2 ]</code></td></tr><tr><td>-o</td><td>逻辑或</td><td><code>[ &quot;$a&quot; -eq 1 -o &quot;$b&quot; -eq 2 ]</code></td></tr></tbody></table><p><strong>现代推荐写法</strong>：使用 <code>&amp;&amp;</code> 和 <code>||</code> 替代 <code>-a</code> 和 <code>-o</code>，更符合 POSIX 标准</p><hr /><h3 id="24-条件判断"><a class="markdownIt-Anchor" href="#24-条件判断"></a> 2.4. 条件判断</h3><p>:::warning<br />和 Java、PHP 等语言不一样，sh 的流程控制不可为空<br />:::</p><p><strong>这个我单独开一篇算了…</strong></p><h2 id="3-拓展shell脚本中的作用"><a class="markdownIt-Anchor" href="#3-拓展shell脚本中的作用"></a> 3. 拓展：shell脚本中<code>$</code>的作用</h2><p>在 Shell 中，<code>$</code> 是一个非常核心的符号，主要用于<strong>变量引用</strong>、<strong>命令替换</strong>、<strong>参数访问</strong>、<strong>字符串操作</strong>等。下面按不同用途分类说明：</p><h3 id="31-变量引用"><a class="markdownIt-Anchor" href="#31-变量引用"></a> 3.1. 变量引用</h3><p><code>$变量名</code> 用于获取变量的值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">name=&quot;lemon&quot;<br>echo $name     # 输出: lemon<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $&#123;name&#125;world   # 输出: lemonworld<br></code></pre></td></tr></table></figure><h3 id="32-命令替换"><a class="markdownIt-Anchor" href="#32-命令替换"></a> 3.2. 命令替换</h3><p><code>$(command)</code> 会执行 <code>command</code> 命令，并将其标准输出结果替换为字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;Today is $(date)&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出: Today is Wed Jun 18 17:00:00 CST 2025</span><br></code></pre></td></tr></table></figure><p>等价于旧式：<code>`command`</code></p><h3 id="33-位置参数和特殊变量"><a class="markdownIt-Anchor" href="#33-位置参数和特殊变量"></a> 3.3. 位置参数和特殊变量</h3><p>Shell 脚本中 <code>$</code> 也用于获取传入脚本的参数或特殊含义变量：</p><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code></td><td>脚本名</td></tr><tr><td><code>$1</code> ~ <code>$9</code></td><td>脚本参数（第1~9个）</td></tr><tr><td><code>$@</code></td><td>所有参数（独立）</td></tr><tr><td><code>$*</code></td><td>所有参数（整体）</td></tr><tr><td><code>$#</code></td><td>参数个数</td></tr><tr><td><code>$$</code></td><td>当前脚本/进程的 PID</td></tr><tr><td><code>$?</code></td><td>上一个命令的返回值</td></tr><tr><td><code>$!</code></td><td>最近一个后台进程的 PID</td></tr></tbody></table><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo &quot;【\$0】：脚本名称：$0&quot;<br>echo &quot;【\$1】：第一个参数：$1&quot;<br>echo &quot;【\$2】：第二个参数：$2&quot;<br>echo &quot;【\$#】：参数总数：$#&quot;<br><br>echo &quot;【\$@】：所有参数（逐个显示）&quot;<br>for arg in &quot;$@&quot;; do<br>    echo &quot;  - $arg&quot;<br>done<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> 或<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;【\$@】：所有参数:&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span></span><br>echo &quot;【\$*】：所有参数（整体显示）&quot;<br>for arg in &quot;$*&quot;; do<br>    echo &quot;  - $arg&quot;<br>done<br><br>echo &quot;【\$$】：当前脚本的 PID 是：$$&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">模拟一个命令并查看返回值</span><br>echo &quot;执行 ls 命令：&quot;<br>ls &gt; /dev/null<br>echo &quot;【\$?】：上一个命令的退出状态码：$?&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">模拟后台命令并查看其 PID</span><br>sleep 5 &amp;<br>echo &quot;【\$!】：最近一个后台任务的 PID 是：$!&quot;<br><br></code></pre></td></tr></table></figure><p>常见问题：<code>$&#123;@&#125;</code>与 <code>$&#123;*&#125;</code>的区别</p><table><thead><tr><th>表达式</th><th>解释</th></tr></thead><tbody><tr><td><code>&quot;$&#123;@&#125;&quot;</code></td><td>把每个参数<strong>作为独立字符串</strong>处理，适合 for 循环</td></tr><tr><td><code>&quot;$&#123;*&#125;&quot;</code></td><td>把所有参数当作<strong>一个整体字符串</strong>处理，若带引号会合并成一个参数</td></tr></tbody></table><h3 id="34-算术扩展"><a class="markdownIt-Anchor" href="#34-算术扩展"></a> 3.4. 算术扩展</h3><p>用 <code>$(())</code> 或 <code>$[]</code> 进行算术运算：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">a=5<br>b=3<br><span class="hljs-built_in">echo</span> $[a + b]  <span class="hljs-comment"># 输出: 8</span><br></code></pre></td></tr></table></figure><h3 id="35-字符串操作和默认值处理"><a class="markdownIt-Anchor" href="#35-字符串操作和默认值处理"></a> 3.5. 字符串操作和默认值处理</h3><p>支持 <code>:-</code>, <code>:=</code>, <code>:+</code>, <code>:?</code> 等操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $&#123;var:-default&#125;   # var未定义则使用&quot;default&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="Shell" scheme="https://blog.godmao.top/categories/Linux/Shell/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="shell" scheme="https://blog.godmao.top/Tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下连接文件</title>
    <link href="https://blog.godmao.top/posts/36626/"/>
    <id>https://blog.godmao.top/posts/36626/</id>
    <published>2025-06-14T13:09:49.000Z</published>
    <updated>2025-06-14T14:04:11.213Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>在 Linux 系统中，我们常常需要在不同位置引用同一个文件，或者希望通过某种方式为某个文件设置别名。这时候，文件“连接（Link）”机制就派上用场了。本文将详细介绍 Linux 下的硬链接（Hard Link）与符号链接（Symbolic Link，又称软链接）的概念、区别以及实际用法。</p><hr /><h2 id="一-什么是文件连接"><a class="markdownIt-Anchor" href="#一-什么是文件连接"></a> 📌 一、什么是文件连接？</h2><p>Linux 中的“连接”指的是为某个文件创建一个别名或指针，使你可以通过多个路径访问同一个文件内容。</p><p>连接分为两种类型：</p><ul><li><strong>硬链接（Hard Link）</strong></li><li><strong>符号链接（Symbolic Link 或 Soft Link）</strong></li></ul><hr /><h2 id="二-硬链接hard-link"><a class="markdownIt-Anchor" href="#二-硬链接hard-link"></a> 🔗 二、硬链接（Hard Link）</h2><h3 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1. 概念</h3><p>硬链接是文件系统中的一种机制，它为<strong>同一个 inode（索引节点）</strong> 创建多个目录项。多个硬链接本质上是“平等的”，互为镜像。</p><h3 id="2-特点"><a class="markdownIt-Anchor" href="#2-特点"></a> 2. 特点</h3><ul><li>同一个 inode 号，表示指向同一个文件内容。</li><li>删除其中一个链接不会影响其他链接。</li><li>不支持对目录创建硬链接（为避免环形结构）。</li><li>只能对同一文件系统内的文件创建。</li></ul><h3 id="3-创建命令"><a class="markdownIt-Anchor" href="#3-创建命令"></a> 3. 创建命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> 源文件 目标文件<br></code></pre></td></tr></table></figure><h3 id="4实验"><a class="markdownIt-Anchor" href="#4实验"></a> 4.实验</h3><p>查看链接数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l<br></code></pre></td></tr></table></figure><p>第二列显示的数字表示链接数（包括自己）。</p><p><img src="Snipaste_2025-06-14_21-30-04.png" alt="" /><br />可见其所占用的存储空间是相同的，说明它们本质是相同的，指向同一incode，删除链接源文件，其他文件依然可以运行。<br />例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> hello<br>./ hello2<br></code></pre></td></tr></table></figure><p>依然正常输出</p><hr /><h2 id="三-符号链接symbolic-link-soft-link"><a class="markdownIt-Anchor" href="#三-符号链接symbolic-link-soft-link"></a> 三、符号链接（Symbolic Link / Soft Link）</h2><h3 id="1-概念-2"><a class="markdownIt-Anchor" href="#1-概念-2"></a> 1. 概念</h3><p>符号链接类似 Windows 的快捷方式，它是一个<strong>特殊类型的文件</strong>，包含了另一个文件的路径。</p><h3 id="2-特点-2"><a class="markdownIt-Anchor" href="#2-特点-2"></a> 2. 特点</h3><ul><li>是一个独立的文件，有自己的 inode。</li><li>链接路径，而非直接指向数据块。</li><li>删除源文件会导致符号链接失效（变成“悬挂链接”或“死链接”）。</li><li>可跨文件系统，也可指向目录。</li></ul><p>:::bug<br /><strong>请使用绝对路径，否则拷贝文件到另一目录时会失去软连接</strong><br />:::</p><h3 id="3-创建命令-2"><a class="markdownIt-Anchor" href="#3-创建命令-2"></a> 3. 创建命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s 源文件 目标链接名<br></code></pre></td></tr></table></figure><h3 id="4-实验"><a class="markdownIt-Anchor" href="#4-实验"></a> 4. 实验</h3><p>拷贝文件保留软链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> -d [源] [目的]<br></code></pre></td></tr></table></figure><p>当使用相对路径时：<br /><img src="Snipaste_2025-06-14_21-42-53.png" alt="" /><br /><img src="Snipaste_2025-06-14_21-48-24.png" alt="" /><br />使用绝对路径：<br /><img src="Snipaste_2025-06-14_21-54-29.png" alt="" /></p><hr /><h2 id="四-硬链接-vs-符号链接"><a class="markdownIt-Anchor" href="#四-硬链接-vs-符号链接"></a> 🆚 四、硬链接 vs 符号链接</h2><table><thead><tr><th>特性</th><th>硬链接（Hard Link）</th><th>符号链接（Symbolic Link）</th></tr></thead><tbody><tr><td>是否有独立 inode</td><td>否</td><td>是</td></tr><tr><td>是否可跨文件系统</td><td>否</td><td>是</td></tr><tr><td>是否可链接目录</td><td>否</td><td>是（需管理员权限）</td></tr><tr><td>删除原文件后</td><td>内容仍保留</td><td>链接失效（悬挂链接）</td></tr><tr><td>作用</td><td>多个文件名共享内容</td><td>文件快捷方式</td></tr></tbody></table><hr /><h2 id="五-补充"><a class="markdownIt-Anchor" href="#五-补充"></a> 🧪 五、补充</h2><h3 id="查找所有指向同一-inode-的文件"><a class="markdownIt-Anchor" href="#查找所有指向同一-inode-的文件"></a> 查找所有指向同一 inode 的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -inum &lt;inode号&gt;<br></code></pre></td></tr></table></figure><h3 id="查找所有死链接"><a class="markdownIt-Anchor" href="#查找所有死链接"></a> 查找所有死链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -xtype l<br></code></pre></td></tr></table></figure><hr /><h2 id="六-总结"><a class="markdownIt-Anchor" href="#六-总结"></a> ✅ 六、总结</h2><table><thead><tr><th>关键点</th><th>硬链接</th><th>符号链接</th></tr></thead><tbody><tr><td>安全性</td><td>内容冗余，较安全</td><td>容易产生死链接</td></tr><tr><td>灵活性</td><td>不支持跨系统和目录</td><td>灵活，可指向任意路径</td></tr><tr><td>适用场景</td><td>本地备份，核心文件</td><td>快捷方式，快捷访问</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/categories/Linux/Ubuntu/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="链接文件" scheme="https://blog.godmao.top/Tags/%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>踩坑记录：WSL下对u盘格式化修改后在win下连接u盘发现盘内内容未改变</title>
    <link href="https://blog.godmao.top/posts/20676/"/>
    <id>https://blog.godmao.top/posts/20676/</id>
    <published>2025-06-14T10:15:30.000Z</published>
    <updated>2025-06-14T10:37:16.303Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>我将USB读卡器插入microSD卡（该SD卡此前刷入过micropython固件包），并将其连接至电脑，接着我在win系统下，在SD卡目录下创建了一个文件wtf.txt，然后打开WSL，使用usbip将该u盘共享，在WSL下，u盘能正确读取、挂载，我在WSL重新对这个u盘使用fdisk重新分区，mkfs重新格式化为FAT32文件系统，并且在WSL下touch了一个新文件hi.txt，使用sync同步，然后使用usbipd的命令断开连接，接入win系统后，wtf.txt居然还在，再次将u盘接入WSL，发现hi.txt也在，也就是说，同样的SD卡，两个系统读到的东西却不一样，这是怎么回事？<br />按照网上的主流方法，尝试过编译内核添加usb驱动支持，手动安装usbip工具都不管用。</p><h2 id="问题解决"><a class="markdownIt-Anchor" href="#问题解决"></a> 问题解决</h2><p>在使用fdisk分区时，我发现如下警告：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">The device contains hybrid MBR -- writing GPT only.<br></code></pre></td></tr></table></figure><p>在询问chatgpt后，弄清了这条警告的含义：</p><ol><li><strong>磁盘中检测到 Hybrid MBR</strong>：即使之前格式化或重分区过，它仍可能保留有旧的混合结构。</li><li><strong>当前正尝试用 GPT 格式重写该磁盘</strong>：工具会忽略 MBR 部分，只写入纯 GPT。</li></ol><p><strong>Hybrid MBR（混合主引导记录）</strong> 是一种兼容机制，它允许一个磁盘同时拥有：</p><ul><li>一部分 <strong>MBR（传统 BIOS 启动支持）</strong></li><li>一部分 <strong>GPT（用于现代系统的分区方案）</strong></li></ul><p>这种结构通常用于让 <strong>使用 GPT 分区的磁盘</strong>仍然可以在一些只识别 MBR 的系统中启动，比如旧版 BIOS 系统。</p><p>我突然想起来这个SD卡不就是之前用于引导启动micropython固件的吗，所以存在混合结构，而正是这样的混合结构，是使得在win下，系统读到的是MBR分区表，Linux下读到的是GPT分区表，这就像 SD 卡前面贴着两张标签纸（MBR 和 GPT）：</p><ul><li>Windows 看标签 A，就看到旧文件</li><li>Linux 看标签 B，就看到新文件</li><li>它们根本没在“同一张纸”上操作</li></ul><p>于是我按照GPT提供的方法，使用命令彻底清除磁盘前部（包括 MBR &amp; GPT）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/dev/sdd bs=1M count=10<br><span class="hljs-built_in">sync</span><br></code></pre></td></tr></table></figure><p>完全抹除了旧的结构信息，再次重复分区、格式化、挂载、创建文件等操作，这下两个系统读取到的文件就同步了😍！</p><h2 id="特别感谢"><a class="markdownIt-Anchor" href="#特别感谢"></a> 特别感谢</h2><ul><li><a href="https://chatgpt.com/">ChatGPT</a>!，AI改变世界啊~</li><li>我自己！</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="踩坑记录" scheme="https://blog.godmao.top/Tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下文件权限管理</title>
    <link href="https://blog.godmao.top/posts/10180/"/>
    <id>https://blog.godmao.top/posts/10180/</id>
    <published>2025-06-14T09:31:19.000Z</published>
    <updated>2025-06-14T10:37:16.300Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>在命令行界面下，输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /dev<br><span class="hljs-built_in">ls</span> -l<br></code></pre></td></tr></table></figure><p>得到输出如下：</p><p><img src="Snipaste_2025-06-14_17-39-42.png" alt="" /></p><p>每列释义如下：</p><table><thead><tr><th>列</th><th>示例值</th><th>含义说明</th></tr></thead><tbody><tr><td>1</td><td><code>crw-rw----</code></td><td>文件类型与权限（c 表示字符设备；接下来是用户/组/其他的读写执行权限）</td></tr><tr><td>2</td><td><code>1</code></td><td>硬链接数量（对于设备文件通常是1）</td></tr><tr><td>3</td><td><code>root</code></td><td>文件（或设备）的所有者</td></tr><tr><td>4</td><td><code>root</code></td><td>所属用户组</td></tr><tr><td>5</td><td><code>188, 0</code></td><td>主设备号和次设备号（<strong>仅对设备文件存在</strong>，表示对应驱动和设备）</td></tr><tr><td>6</td><td><code>Jun 14 16:45</code></td><td>最后修改时间</td></tr><tr><td>7</td><td><code>ttyUSB0</code></td><td>文件名（这里是设备名）</td></tr></tbody></table><h2 id="主次设备号"><a class="markdownIt-Anchor" href="#主次设备号"></a> 主次设备号</h2><p>主设备号（Major Number）</p><ul><li>决定了这个文件对应哪个<strong>驱动程序</strong>。</li><li>比如所有的 <code>ttyUSBx</code> 设备可能都由主设备号 188 对应的驱动处理。</li></ul><p>次设备号（Minor Number）</p><ul><li>由主设备号指定的驱动程序使用，用于区分同一驱动管理下的不同设备。</li><li>比如 <code>ttyUSB0</code> 是第一个设备，<code>ttyUSB1</code> 是第二个，以此类推。</li></ul><h2 id="文件权限位详解"><a class="markdownIt-Anchor" href="#文件权限位详解"></a> 文件权限位详解</h2><p>第一列是文件权限位，每位释义如下：</p><table><thead><tr><th>位次</th><th>含义</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>文件类型</td><td><code>-</code></td><td><code>-</code> 普通文件、<code>d</code> 目录、<code>l</code> 软链接、<code>c</code> 字符设备等</td></tr><tr><td>2-4</td><td>所有者权限（user）</td><td><code>rwx</code></td><td>读（r）、写（w）、执行（x）</td></tr><tr><td>5-7</td><td>用户组权限（group）</td><td><code>r-x</code></td><td></td></tr><tr><td>8-10</td><td>其他人权限（other）</td><td><code>r--</code></td><td></td></tr><tr><td>权限字符：</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>r</code></td><td>可读（read）：可以读取文件内容或列出目录内容</td></tr><tr><td><code>w</code></td><td>可写（write）：可以修改文件内容或添加/删除目录项</td></tr><tr><td><code>x</code></td><td>可执行（execute）：可执行程序或进入目录</td></tr><tr><td><code>-</code></td><td>没有该权限</td></tr></tbody></table><h2 id="文件权限修改"><a class="markdownIt-Anchor" href="#文件权限修改"></a> 文件权限修改</h2><h3 id="一-chmod-命令概述"><a class="markdownIt-Anchor" href="#一-chmod-命令概述"></a> 一、<code>chmod</code> 命令概述</h3><p>用于更改文件或目录的权限，支持 <strong>符号法</strong> 和 <strong>数字法</strong>。</p><hr /><h3 id="二-权限基础"><a class="markdownIt-Anchor" href="#二-权限基础"></a> 二、权限基础</h3><table><thead><tr><th>权限字符</th><th>权限含义</th><th>对文件作用</th><th>对目录作用</th></tr></thead><tbody><tr><td><code>r</code></td><td>读权限</td><td>可读取内容</td><td>可列出目录文件</td></tr><tr><td><code>w</code></td><td>写权限</td><td>可修改内容</td><td>可创建/删除文件</td></tr><tr><td><code>x</code></td><td>执行权限</td><td>可执行</td><td>可进入目录</td></tr></tbody></table><hr /><h3 id="三-符号法symbolic-mode"><a class="markdownIt-Anchor" href="#三-符号法symbolic-mode"></a> 三、符号法（Symbolic Mode）</h3><h4 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> [对象][操作][权限] 文件名<br></code></pre></td></tr></table></figure><h4 id="对象权限归属"><a class="markdownIt-Anchor" href="#对象权限归属"></a> 对象（权限归属）</h4><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>u</code></td><td>所有者</td></tr><tr><td><code>g</code></td><td>所属组</td></tr><tr><td><code>o</code></td><td>其他用户</td></tr><tr><td><code>a</code></td><td>所有人（ugo）</td></tr></tbody></table><h4 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> 操作符</h4><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>+</code></td><td>添加权限</td></tr><tr><td><code>-</code></td><td>删除权限</td></tr><tr><td><code>=</code></td><td>赋予权限（替换）</td></tr></tbody></table><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> u+x file.sh     <span class="hljs-comment"># 给所有者添加执行权限</span><br><span class="hljs-built_in">chmod</span> g-w file.txt    <span class="hljs-comment"># 移除组的写权限</span><br><span class="hljs-built_in">chmod</span> o=r file.txt    <span class="hljs-comment"># 其他人只读</span><br><span class="hljs-built_in">chmod</span> a+x run.sh      <span class="hljs-comment"># 所有人添加执行权限</span><br></code></pre></td></tr></table></figure><hr /><h3 id="四-数字法octal-mode"><a class="markdownIt-Anchor" href="#四-数字法octal-mode"></a> 四、数字法（Octal Mode）</h3><h4 id="权限与数字映射"><a class="markdownIt-Anchor" href="#权限与数字映射"></a> 权限与数字映射</h4><table><thead><tr><th>权限</th><th>数值</th><th>含义</th></tr></thead><tbody><tr><td><code>---</code></td><td>0</td><td>无权限</td></tr><tr><td><code>--x</code></td><td>1</td><td>执行</td></tr><tr><td><code>-w-</code></td><td>2</td><td>写</td></tr><tr><td><code>-wx</code></td><td>3</td><td>写 + 执行</td></tr><tr><td><code>r--</code></td><td>4</td><td>读</td></tr><tr><td><code>r-x</code></td><td>5</td><td>读 + 执行</td></tr><tr><td><code>rw-</code></td><td>6</td><td>读 + 写</td></tr><tr><td><code>rwx</code></td><td>7</td><td>全部权限</td></tr><tr><td>相当于以二进制对应的十进制来表示，这点应该不陌生。</td><td></td><td></td></tr></tbody></table><h4 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 755 script.sh    <span class="hljs-comment"># 所有者全部权限，其他用户读+执行</span><br><span class="hljs-built_in">chmod</span> 644 note.txt     <span class="hljs-comment"># 所有者读写，其他人只读</span><br><span class="hljs-built_in">chmod</span> 700 secret.txt   <span class="hljs-comment"># 只有所有者有权限</span><br></code></pre></td></tr></table></figure><hr /><h3 id="五-递归权限修改"><a class="markdownIt-Anchor" href="#五-递归权限修改"></a> 五、递归权限修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> -R 755 myfolder     <span class="hljs-comment"># 递归修改目录及其下所有文件/子目录权限</span><br></code></pre></td></tr></table></figure><hr /><h3 id="六-使用-find-批量设置权限"><a class="markdownIt-Anchor" href="#六-使用-find-批量设置权限"></a> 六、使用 find 批量设置权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">chmod</span> 644 &#123;&#125; \;   <span class="hljs-comment"># 设置所有文件权限</span><br>find . -<span class="hljs-built_in">type</span> d -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">chmod</span> 755 &#123;&#125; \;   <span class="hljs-comment"># 设置所有目录权限</span><br></code></pre></td></tr></table></figure><hr /><h3 id="七-常见目录权限推荐"><a class="markdownIt-Anchor" href="#七-常见目录权限推荐"></a> 七、常见目录权限推荐</h3><table><thead><tr><th>目录</th><th>推荐权限</th><th>含义说明</th></tr></thead><tbody><tr><td><code>/home/用户名</code></td><td><code>700</code></td><td>仅用户本人访问</td></tr><tr><td><code>/tmp</code></td><td><code>1777</code></td><td>所有人可写，Sticky 位保护</td></tr><tr><td>网站目录</td><td><code>755</code></td><td>其他人可访问但不可修改</td></tr></tbody></table><hr /><h3 id="八-特殊权限简述可选"><a class="markdownIt-Anchor" href="#八-特殊权限简述可选"></a> 八、特殊权限简述（可选）</h3><table><thead><tr><th>权限</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>SUID</td><td>执行程序时使用文件所有者权限</td><td><code>chmod u+s</code></td></tr><tr><td>SGID</td><td>同上，应用于组</td><td><code>chmod g+s</code></td></tr><tr><td>Sticky</td><td>只能删除自己文件（多用于/tmp）</td><td><code>chmod +t</code></td></tr></tbody></table><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/categories/Linux/Ubuntu/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/Tags/Ubuntu/"/>
    
    <category term="文件系统" scheme="https://blog.godmao.top/Tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下磁盘管理</title>
    <link href="https://blog.godmao.top/posts/30265/"/>
    <id>https://blog.godmao.top/posts/30265/</id>
    <published>2025-06-12T08:00:30.000Z</published>
    <updated>2025-06-14T10:37:16.302Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>前面我们成功让WSL读取到Win系统的USB设备，下面来学习WSL下磁盘的管理。</p><h2 id="磁盘和目录的容量查询命令"><a class="markdownIt-Anchor" href="#磁盘和目录的容量查询命令"></a> 磁盘和目录的容量查询命令</h2><p><code>df</code> ：查看文件系统使用量，主要查看文件系统的使用量。<br /><code>du</code> ：评估文件系统的磁盘使用量，主要查看单个文件大小。<br /><code>lsblk</code> ：<em>List Block Devices</em> 列出系统中SSD、U盘等存储设备的信息</p><h2 id="磁盘的挂载卸载"><a class="markdownIt-Anchor" href="#磁盘的挂载卸载"></a> 磁盘的挂载卸载</h2><p>还记得前面提到的<a href="https://blog.godmao.top/posts/7417/">Ubuntu文件系统结构</a>吗？想要读取u盘里的文件，需要把u盘挂载在某个目录下才能访问。</p><h3 id="什么是挂载"><a class="markdownIt-Anchor" href="#什么是挂载"></a> 什么是挂载？</h3><p>挂载就是“<strong>把设备上的文件系统接入Linux的目录结构中</strong>”。</p><ul><li>Linux 的目录结构是一个<strong>统一的树形结构</strong>（根目录 <code>/</code> 是起点）。</li><li>所有的文件、文件夹、设备访问，都要通过这个统一的目录树。</li><li>当你插入一个U盘时，它本身是一个独立的文件系统（如FAT32），Linux不会自动将其连接进目录树，除非你明确地<strong>挂载</strong>它。</li></ul><h3 id="为什么linux要挂载windows为什么不需要"><a class="markdownIt-Anchor" href="#为什么linux要挂载windows为什么不需要"></a> 为什么Linux要挂载？Windows为什么不需要？</h3><p><strong>Linux设计哲学：</strong></p><ul><li>Linux源于Unix，追求“一切皆文件”，统一的目录结构。</li><li>所有设备都必须通过<code>/dev/xxx</code>表示为一个文件，然后挂载到某个目录（如<code>/mnt/usb</code>）才可以访问。<br /><strong>Windows的方式：</strong></li><li>Windows是“盘符式”的，每个设备有独立的盘符（如<code>E:\</code>, <code>F:\</code>），操作系统会<strong>自动识别并挂载</strong>。</li><li>挂载过程对用户是透明的，但其实系统内部也在完成挂载，只是隐藏了细节。<br />所以：<strong>Windows系统也挂载，只是自动化并且用盘符表示；Linux则更显式且灵活</strong>。</li></ul><h3 id="linux下如何手动挂载u盘"><a class="markdownIt-Anchor" href="#linux下如何手动挂载u盘"></a> Linux下如何手动挂载u盘？</h3><p>如果是U盘可以挂载在<code>/dev/media/</code>目录或<code>/dev/mnt/</code>目录</p><h4 id="1查看u盘设备名"><a class="markdownIt-Anchor" href="#1查看u盘设备名"></a> 1.查看u盘设备名</h4><p>在使用usbipd使WSL读取到u盘后，运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsblk<br></code></pre></td></tr></table></figure><p>会看到类似这样的输出：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">sdb      8:16  <span class="hljs-number"> 1 </span> 29.8G <span class="hljs-number"> 0 </span>disk<br>├─sdb1   8:17  <span class="hljs-number"> 1 </span> 10.0G <span class="hljs-number"> 0 </span>part<br>├─sdb2   8:18  <span class="hljs-number"> 1 </span>  9.8G <span class="hljs-number"> 0 </span>part<br>└─sdb3   8:19  <span class="hljs-number"> 1 </span> 10.0G <span class="hljs-number"> 0 </span>part<br></code></pre></td></tr></table></figure><p>这里 <code>sdb1</code> 是U盘的分区名。磁盘可能有很多分区嘛。</p><h4 id="2为每个分区创建挂载点目录"><a class="markdownIt-Anchor" href="#2为每个分区创建挂载点目录"></a> 2.为每个分区创建挂载点目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /mnt/usb1 /mnt/usb2 /mnt/usb3<br></code></pre></td></tr></table></figure><h4 id="3逐个挂载"><a class="markdownIt-Anchor" href="#3逐个挂载"></a> 3.逐个挂载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mount /dev/sdb1 /mnt/usb1<br><span class="hljs-built_in">sudo</span> mount /dev/sdb2 /mnt/usb2<br><span class="hljs-built_in">sudo</span> mount /dev/sdb3 /mnt/usb3<br></code></pre></td></tr></table></figure><p>如果某个分区的文件系统不是自动识别的（报错），你可以指定类型挂载，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mount -t vfat /dev/sdb1 /mnt/usb1<br><span class="hljs-built_in">sudo</span> mount -t ext4 /dev/sdb2 /mnt/usb2<br><span class="hljs-built_in">sudo</span> mount -t ntfs /dev/sdb3 /mnt/usb3<br></code></pre></td></tr></table></figure><p>如果不清楚类型运行如下命令可以查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> blkid /dev/sdb1 /dev/sdb2 /dev/sdb3<br></code></pre></td></tr></table></figure><h3 id="卸载"><a class="markdownIt-Anchor" href="#卸载"></a> 卸载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> umount /mnt/usb1<br><span class="hljs-built_in">sudo</span> umount /mnt/usb2<br><span class="hljs-built_in">sudo</span> umount /mnt/usb3<br></code></pre></td></tr></table></figure><h2 id="磁盘分区"><a class="markdownIt-Anchor" href="#磁盘分区"></a> 磁盘分区</h2><h3 id="fdisk命令常用选项"><a class="markdownIt-Anchor" href="#fdisk命令常用选项"></a> fdisk命令常用选项</h3><table><thead><tr><th>命令</th><th>含义</th><th>功能说明</th></tr></thead><tbody><tr><td><code>m</code></td><td>help</td><td>显示所有可用命令</td></tr><tr><td><code>p</code></td><td>print</td><td>显示当前分区表</td></tr><tr><td><code>n</code></td><td>new</td><td>创建一个新分区（主分区或逻辑分区）</td></tr><tr><td><code>d</code></td><td>delete</td><td>删除一个已有分区</td></tr><tr><td><code>t</code></td><td>type</td><td>修改分区的类型 ID</td></tr><tr><td><code>l</code></td><td>list</td><td>列出所有分区类型 ID</td></tr><tr><td><code>a</code></td><td>toggle bootable</td><td>切换分区的启动标志（设置/取消可引导分区）</td></tr><tr><td><code>w</code></td><td>write</td><td>写入分区表并退出</td></tr><tr><td><code>q</code></td><td>quit</td><td>不保存更改，直接退出</td></tr><tr><td><code>g</code></td><td>gpt</td><td>创建新的 GPT 分区表</td></tr><tr><td><code>o</code></td><td>dos</td><td>创建新的空白 DOS (MBR) 分区表</td></tr><tr><td><code>v</code></td><td>verify</td><td>验证分区表的完整性</td></tr><tr><td><code>x</code></td><td>expert</td><td>进入专家模式（用于高级操作）</td></tr></tbody></table><h3 id="用fdisk打开要分区的磁盘"><a class="markdownIt-Anchor" href="#用fdisk打开要分区的磁盘"></a> 用fdisk打开要分区的磁盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> fdisk /dev/sde<br></code></pre></td></tr></table></figure><p>:::warning<br />千万不要误选，否则可能破坏你的数据。<br />:::</p><h3 id="删除分区"><a class="markdownIt-Anchor" href="#删除分区"></a> 删除分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): p        ← 查看当前分区情况（确认要删哪个）<br>Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): d        ← 删除分区<br>Partition number (1,2,...): 2  ← 选择你要删除的分区编号（比如 2 表示 /dev/sdb2）<br>Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): w        ← 保存更改并退出<br></code></pre></td></tr></table></figure><h3 id="创建分区"><a class="markdownIt-Anchor" href="#创建分区"></a> 创建分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): n<br></code></pre></td></tr></table></figure><p><img src="Snipaste_2025-06-12_17-21-39.png" alt="" /></p><p>1：分区编号，直接回车接受默认编号。<br />2：起始扇区，默认值通常合适，直接回车即可。<br />3：结束扇区 or 分区大小，可以输入：扇区编号（直接回车使用剩余空间）或者手动输入大小（例如：<code>+1G</code>、<code>+512M</code>）</p><h3 id="写出"><a class="markdownIt-Anchor" href="#写出"></a> 写出</h3><p>保存并退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): w<br></code></pre></td></tr></table></figure><h2 id="格式化分区"><a class="markdownIt-Anchor" href="#格式化分区"></a> 格式化分区</h2><p>当用 <code>fdisk</code> 创建完一个分区后，这个分区只是“逻辑划分好了”，但<strong>还不能使用</strong>，必须要**格式化（创建文件系统）**才能真正读写数据。</p><h3 id="为什么要格式化"><a class="markdownIt-Anchor" href="#为什么要格式化"></a> 为什么要格式化？</h3><p>格式化的本质是：</p><blockquote><p><strong>在分区上写入特定的文件系统结构</strong>（如 ext4、FAT32、NTFS 等）。</p></blockquote><p>只有这样，操作系统才知道如何在这块区域内组织、存储和查找文件。</p><h3 id="1选择格式化类型"><a class="markdownIt-Anchor" href="#1选择格式化类型"></a> 1.选择格式化类型</h3><table><thead><tr><th>文件系统</th><th>说明</th></tr></thead><tbody><tr><td>ext4</td><td>Linux常用，性能稳定，支持大文件</td></tr><tr><td>vfat</td><td>FAT32，兼容Windows/Mac/Linux，不支持大文件</td></tr><tr><td>ntfs</td><td>Windows常用，Linux可读写（需驱动）</td></tr><tr><td>exfat</td><td>新型通用格式，支持大文件，跨平台兼容性好</td></tr></tbody></table><h3 id="2执行格式化命令"><a class="markdownIt-Anchor" href="#2执行格式化命令"></a> 2.执行格式化命令</h3><p><em>make file system</em> -type</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mkfs.vfat -f 32 /dev/sde2<br></code></pre></td></tr></table></figure><p>没有mkfs的先安装，不然报错：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">failed to<span class="hljs-built_in"> execute </span>mkfs.vfat: No such file<span class="hljs-built_in"> or </span>directory<br></code></pre></td></tr></table></figure><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install dosfstools<br></code></pre></td></tr></table></figure><h3 id="检查"><a class="markdownIt-Anchor" href="#检查"></a> 检查</h3><p>可以输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> blkid /dev/sde1 /dev/sde2<br></code></pre></td></tr></table></figure><p>检查type<br />输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sde1: <span class="hljs-attribute">UUID</span>=<span class="hljs-string">&quot;FBD5-E06C&quot;</span> <span class="hljs-attribute">BLOCK_SIZE</span>=<span class="hljs-string">&quot;512&quot;</span> <span class="hljs-attribute">TYPE</span>=<span class="hljs-string">&quot;vfat&quot;</span> <span class="hljs-attribute">PARTUUID</span>=<span class="hljs-string">&quot;3b15f93b-f163-491d-9f0f-94be96692beb&quot;</span><br>sde2: <span class="hljs-attribute">UUID</span>=<span class="hljs-string">&quot;FC22-7890&quot;</span> <span class="hljs-attribute">BLOCK_SIZE</span>=<span class="hljs-string">&quot;512&quot;</span> <span class="hljs-attribute">TYPE</span>=<span class="hljs-string">&quot;vfat&quot;</span> <span class="hljs-attribute">PARTUUID</span>=<span class="hljs-string">&quot;248a2fdb-2255-4a7a-802e-e5a11bb87c53&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/categories/Linux/Ubuntu/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/Tags/Ubuntu/"/>
    
    <category term="磁盘管理" scheme="https://blog.godmao.top/Tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>WSL下连接USB设备</title>
    <link href="https://blog.godmao.top/posts/13715/"/>
    <id>https://blog.godmao.top/posts/13715/</id>
    <published>2025-06-11T15:49:53.000Z</published>
    <updated>2025-06-14T09:32:43.934Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>⭐⭐⭐本文参考自微软官方WSL文档——<a href="https://learn.microsoft.com/zh-cn/windows/wsl/connect-usb">连接 USB 设备 | Microsoft Learn</a></p><p>由于WSL不提供本机连接USB设备的支持，因此需要安装开源项目usbipd-win来支持USB的共享连接。</p><h2 id="什么是usbpid"><a class="markdownIt-Anchor" href="#什么是usbpid"></a> 什么是usbpid？</h2><p>usbipd 是一个<strong>用于管理 USB/IP（USB over IP）服务的命令行工具</strong>，可以在 Windows 下使用。 USB/IP 是一种协议，允许<strong>通过网络共享USB 设备</strong>。 usbipd工具允许用户在 Windows 上共享 USB 设备，使其他计算机能够通过网络访问这些设备。</p><h2 id="安装-usbipd-win-项目"><a class="markdownIt-Anchor" href="#安装-usbipd-win-项目"></a> 安装 USBIPD-WIN 项目</h2><ol><li>转到 <a href="https://github.com/dorssel/usbipd-win/releases">usbipd-win 项目的最新发布页面</a>。</li><li>选择 .msi 文件，该文件将下载安装程序。 （你可能会收到一条警告，要求你确认你信任此下载）。</li><li>运行下载 usbipd-win_x.msi 安装程序文件。</li></ol><p>这将安装：</p><ul><li>名为 <code>usbipd</code> 的服务，（显示名称：USBIP 设备主机）。 可以使用 Windows 中的服务应用检查此服务的状态。</li><li>命令行工具 <code>usbipd</code>。 此工具的位置将添加到 PATH 环境变量。</li><li>名为 <code>usbipd</code> 的防火墙规则，用于允许所有本地子网连接到服务。 可修改此防火墙规则以微调访问控制。</li></ul><ol start="4"><li>若要附加 USB 设备，请运行以下命令。 （不再需要使用提升的管理员提示。确保 WSL 命令提示符处于打开状态，以使 WSL 2 轻型 VM 保持活动状态。 <strong>请注意，只要 USB 设备连接到 WSL，Windows 将无法使用它。</strong> 一旦连接到 WSL，任何在 WSL 2 上运行的发行版都可以使用该 USB 设备。 请确认设备是否已连接 <code>usbipd list</code>。 在 WSL 提示符下，运行 <code>lsusb</code> 以验证 USB 设备是否已列出，并且可以使用 Linux 工具与之交互。</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd attach <span class="hljs-literal">--wsl</span> <span class="hljs-literal">--busid</span> &lt;busid&gt;<br></code></pre></td></tr></table></figure><ol start="5"><li>打开 Ubuntu（或首选 WSL 命令行），并使用以下命令列出附加的 USB 设备：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsusb<br>或者<br>lsblk -f<br></code></pre></td></tr></table></figure><p>若没有找到命令，则先下载<code>usbutils</code><br /><img src="Snipaste_2025-06-12_00-11-23.png" alt="" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install usbutils<br></code></pre></td></tr></table></figure><p>可以看到已经成功读取到u盘，并且能够使用普通 Linux 工具与之交互。 根据应用程序，可能需要配置 udev 规则，以允许非根用户访问设备。<br /><img src="Snipaste_2025-06-12_00-18-59.png" alt="" /><br />6. 在 WSL 中使用设备后，可以物理断开 USB 设备的连接，或者从 PowerShell 运行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">usbipd detach <span class="hljs-literal">--busid</span> &lt;busid&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="WSL2" scheme="https://blog.godmao.top/categories/Linux/WSL2/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="USB" scheme="https://blog.godmao.top/Tags/USB/"/>
    
    <category term="WSL2" scheme="https://blog.godmao.top/Tags/WSL2/"/>
    
  </entry>
  
</feed>

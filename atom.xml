<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GoDm@&#39;s Blog</title>
  
  <subtitle>记录自己所爱。</subtitle>
  <link href="https://blog.godmao.top/atom.xml" rel="self"/>
  
  <link href="https://blog.godmao.top/"/>
  <updated>2025-09-28T04:30:28.179Z</updated>
  <id>https://blog.godmao.top/</id>
  
  <author>
    <name>GoDm@</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux内核模块初体验</title>
    <link href="https://blog.godmao.top/posts/49513/"/>
    <id>https://blog.godmao.top/posts/49513/</id>
    <published>2025-09-27T07:48:35.000Z</published>
    <updated>2025-09-28T04:30:28.179Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><div class="admonition note"><p class="admonition-title">note</p><p>本篇摘自野火嵌入式Linux系列教程驱动开发篇</p></div><h2 id="内核模块基本概念"><a class="markdownIt-Anchor" href="#内核模块基本概念"></a> 内核模块基本概念</h2><h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3><p>解决linux内核可扩展性和可维护性相对较差的缺陷</p><h3 id="现代内核派系"><a class="markdownIt-Anchor" href="#现代内核派系"></a> 现代内核派系</h3><p>宏内核：关键功能和服务功能均在内核空间提供</p><ul><li>运行效率高</li><li>扩展性较差</li></ul><p>微内核：内核空间只提供关键功能，服务功能在用户空间提供</p><ul><li>运行效率较低</li><li>安全性、扩展性较高</li></ul><h3 id="内核模块加载卸载"><a class="markdownIt-Anchor" href="#内核模块加载卸载"></a> 内核模块加载/卸载</h3><ul><li><p>使用insmod命令加载</p></li><li><p>使用rmmod命令卸载</p></li></ul><h3 id="内核模块入口出口"><a class="markdownIt-Anchor" href="#内核模块入口出口"></a> 内核模块入口/出口</h3><ul><li>module_init()：加载模块式该函数自动执行，进行初始化操作</li><li>module_exit()：卸载模块时函数自动执行，进行清理操作</li></ul><h3 id="内核模块信息声明"><a class="markdownIt-Anchor" href="#内核模块信息声明"></a> 内核模块信息声明</h3><ul><li>MODULE_LICENSE()：表示模块代码接受的软件许可协议，Linux内核遵循GPL V2开源协议，内核模块与linux内核保持一致即可。</li><li>MODULE_AUTHOR()：描述模块的作者信息</li><li>MODULE_DESCRIPTION()：对模块的简单介绍</li><li>MODULE_ALIAS()：给模块设置一个别名</li></ul><h2 id="内核模块实验1"><a class="markdownIt-Anchor" href="#内核模块实验1"></a> 内核模块实验1</h2><h3 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h3><ul><li>开发板烧录好Debian镜像</li><li>启动开发板，搭建好nfs客户端，挂载共享文件夹</li><li>获取Debian镜像的内核源码并编译</li></ul><h3 id="编译41971版本内核"><a class="markdownIt-Anchor" href="#编译41971版本内核"></a> 编译4.19.71版本内核</h3><p>内核模块的功能需要依赖内核提供的各种底层接口</p><p>1.下载linux内核源码</p><p>​github:</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;Embedfire&#x2F;ebf-buster-linux.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​gitee:</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;gitee.com&#x2F;Embedfire&#x2F;ebf-buster-linux.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.安装必要环境工具库</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install make gcc-arm-linux-gnueabihf gcc bison flex libssl-dev dpkg-dev lzop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.一键编译内核</p><pre class="line-numbers language-none"><code class="language-none">sudo .&#x2F;make_deb.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.获取编译出来的内核相关文件</p><pre class="line-numbers language-none"><code class="language-none">...&#x2F;ebf_linux_kernel_6ull_depth1&#x2F;build_image&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="内核模块头文件"><a class="markdownIt-Anchor" href="#内核模块头文件"></a> 内核模块头文件</h3><ul><li><code>#include &lt;linux/module.h&gt;</code>：包含内核模块信息声明的相关函数</li><li><code>#include &lt;linux/init.h&gt;</code>：包含了 module_init()和 module_exit()函数的声明</li><li><code>#include &lt;linux/kernel.h&gt;</code>：包含内核提供的各种函数，如printk</li></ul><h3 id="内核模块打印函数"><a class="markdownIt-Anchor" href="#内核模块打印函数"></a> 内核模块打印函数</h3><ul><li><p><code>printf</code>：glibc实现的打印函数，工作于用户空间，不可在内核使用</p></li><li><p><code>printk</code>：内核模块无法使用glibc库函数，内核自身实现的一个类printf函数，但是需要指定打印等级。</p><ul><li><code>#define KERN_EMERG</code> “&lt;0&gt;” 通常是系统崩溃前的信息</li><li><code>#define KERN_ALERT</code>          “&lt;1&gt;” 需要立即处理的消息</li><li><code>#define KERN_CRIT</code>             “&lt;2&gt;” 严重情况</li><li><code>#define KERN_ERR</code>              “&lt;3&gt;” 错误情况</li><li><code>#define KERN_WARNING</code>      “&lt;4&gt;” 有问题的情况</li><li><code>#define KERN_NOTICE</code>       “&lt;5&gt;” 注意信息</li><li><code>#define KERN_INFO</code>            “&lt;6&gt;” 普通消息</li><li><code>#define KERN_DEBUG</code>        “&lt;7&gt;” 调试信息</li></ul></li></ul><p>查看当前系统printk打印等级：<code>cat /proc/sys/kernel/printk</code><br />输出</p><pre class="line-numbers language-none"><code class="language-none">7       4       1       7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示：</p><ul><li>当前控制台日志级别</li><li>默认消息日志级别</li><li>最小的控制台级别</li><li>默认控制台日志级别</li></ul><p>打印内核所有打印信息：dmesg</p><ul><li>内核log缓冲区大小有限制，缓冲区数据可能被冲掉</li></ul><h3 id="makefile分析"><a class="markdownIt-Anchor" href="#makefile分析"></a> Makefile分析</h3><ul><li><p><code>KERNEL_DIR</code>：指向linux内核具体路径</p></li><li><p><code>export</code>：导出变量给子Makefile使用</p></li><li><p><code>obj-m</code> := &lt;模块名&gt;.o：定义要生成的模块</p></li><li><p><code>$(MAKE)</code>：Makefile的默认变量，值为make</p></li><li><p><code>选项”-C”</code>：让make工具跳转到linux内核目录下读取顶层Makefile</p></li><li><p><code>M=</code>：表示内核模块源码目录</p></li><li><p><code>$(CURDIR)</code>：Makefile默认变量，值为当前目录所在路径</p></li><li><p><code>make modules</code>：执行Linux顶层Makefile的伪目标，它实现内核模块的源码读取并编译为.ko文件</p></li></ul><h3 id="编译内核模块"><a class="markdownIt-Anchor" href="#编译内核模块"></a> 编译内核模块</h3><pre class="line-numbers language-none"><code class="language-none">make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="把生成的内核模块拷贝到nfs共享目录"><a class="markdownIt-Anchor" href="#把生成的内核模块拷贝到nfs共享目录"></a> 把生成的内核模块拷贝到nfs共享目录</h3><pre class="line-numbers language-none"><code class="language-none">make copy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="开发板加载内核模块"><a class="markdownIt-Anchor" href="#开发板加载内核模块"></a> 开发板加载内核模块</h3><pre class="line-numbers language-none"><code class="language-none">insmod xxx.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>WSL-Archlinux安装后应该做什么？</title>
    <link href="https://blog.godmao.top/posts/17327/"/>
    <id>https://blog.godmao.top/posts/17327/</id>
    <published>2025-09-18T12:21:15.000Z</published>
    <updated>2025-09-28T04:46:25.585Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><ul><li><a href="#1-%E5%9C%A8wsl%E4%B8%8A%E5%AE%89%E8%A3%85archlinux">1. 在WSL上安装Archlinux</a></li><li><a href="#2-%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F">2. 更新系统</a></li><li><a href="#3-%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE">3. 基础配置</a><ul><li><a href="#31-%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81">3.1. 设置root密码</a></li><li><a href="#32-%E5%88%9B%E5%BB%BA%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%B9%B6%E5%8A%A0%E5%85%A5-wheel-%E7%BB%84%E6%96%B9%E4%BE%BF%E5%90%8E%E7%BB%AD-sudo-%E6%9D%83%E9%99%90">3.2. 创建普通用户并加入 <code>wheel</code> 组（方便后续 sudo 权限）：</a></li><li><a href="#33-%E7%BC%96%E8%BE%91-sudo-%E6%9D%83%E9%99%90">3.3. 编辑 sudo 权限</a></li><li><a href="#34-%E8%AE%BE%E5%AE%9A%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7">3.4. 设定默认用户</a></li><li><a href="#35-%E8%AE%BE%E7%BD%AE%E8%AF%AD%E8%A8%80%E5%92%8C%E5%9C%B0%E5%8C%BA">3.5. 设置语言和地区</a></li><li><a href="#36-aur-%E6%94%AF%E6%8C%81">3.6. AUR 支持</a></li><li><a href="#37-%E5%85%B3%E4%BA%8E%E6%8D%A2%E6%BA%90">3.7. 关于换源</a></li></ul></li><li><a href="#4-%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE">4. 个性化设置</a><ul><li><a href="#41-%E4%BD%BF%E7%94%A8zsh%E6%9B%BF%E4%BB%A3bash">4.1. 使用zsh替代bash</a></li><li><a href="#42-%E4%BD%BF%E7%94%A8oh-my-zsh%E4%B8%BAzsh%E6%8F%90%E4%BE%9B%E6%8F%92%E4%BB%B6%E6%9C%8D%E5%8A%A1">4.2. 使用oh-my-zsh为zsh提供插件服务</a></li><li><a href="#43-%E4%BD%BF%E7%94%A8oh-my-posh%E4%B8%BAzsh%E6%8F%90%E4%BE%9B%E4%B8%BB%E9%A2%98">4.3. 使用oh-my-posh为zsh提供主题</a></li></ul></li></ul><h2 id="1-在wsl上安装archlinux"><a class="markdownIt-Anchor" href="#1-在wsl上安装archlinux"></a> 1. 在WSL上安装Archlinux</h2><p>请参见—— <a href="https://wiki.archlinuxcn.org/wiki/%E5%9C%A8_WSL_%E4%B8%8A%E5%AE%89%E8%A3%85_Arch_Linux">在 WSL 上安装 Arch Linux - Arch Linux 中文维基</a></p><h2 id="2-更新系统"><a class="markdownIt-Anchor" href="#2-更新系统"></a> 2. 更新系统</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pacman <span class="token parameter variable">-Syu</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-基础配置"><a class="markdownIt-Anchor" href="#3-基础配置"></a> 3. 基础配置</h2><h3 id="31-设置root密码"><a class="markdownIt-Anchor" href="#31-设置root密码"></a> 3.1. 设置root密码</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">passwd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="32-创建普通用户并加入-wheel-组方便后续-sudo-权限"><a class="markdownIt-Anchor" href="#32-创建普通用户并加入-wheel-组方便后续-sudo-权限"></a> 3.2. 创建普通用户并加入 <code>wheel</code> 组（方便后续 sudo 权限）：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">useradd</span> <span class="token parameter variable">-m</span> <span class="token parameter variable">-G</span> wheel <span class="token parameter variable">-s</span> /bin/bash yourname<span class="token function">passwd</span> yourname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>-m</code>：自动创建用户目录<br /><code>-G</code>：指定用户组<br /><code>-s</code>：指定shell</p><h3 id="33-编辑-sudo-权限"><a class="markdownIt-Anchor" href="#33-编辑-sudo-权限"></a> 3.3. 编辑 sudo 权限</h3><p>安装 <code>sudo</code>，再启用 <code>wheel</code> 组：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman <span class="token parameter variable">-S</span> <span class="token function">sudo</span> <span class="token function">nano</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nano</span> /etc/sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>去掉 <code># %wheel ALL=(ALL:ALL) ALL</code> 前的注释</p><div class="admonition todo"><p class="admonition-title">tip</p><p>前面带%(如%wheel)则表示这是一个用户组，不带则表示这是一个用户。</p></div><h3 id="34-设定默认用户"><a class="markdownIt-Anchor" href="#34-设定默认用户"></a> 3.4. 设定默认用户</h3><p>不能总是用root用户登录。<br />首先确保该用户已被创建，然后将以下行添加到 <code>/etc/wsl.conf</code>：</p><pre class="line-numbers language-none"><code class="language-none">[user]default&#x3D;username<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="35-设置语言和地区"><a class="markdownIt-Anchor" href="#35-设置语言和地区"></a> 3.5. 设置语言和地区</h3><p>目的是正确显示中文字符</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">locale-gen<span class="token builtin class-name">echo</span> <span class="token string">"LANG=en_US.UTF-8"</span> <span class="token operator">></span> /etc/locale.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>请参见——<a href="https://wiki.archlinuxcn.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E6%9C%AC%E5%9C%B0%E5%8C%96">简体中文本地化 - Arch Linux 中文维基</a></p><h3 id="36-aur-支持"><a class="markdownIt-Anchor" href="#36-aur-支持"></a> 3.6. AUR 支持</h3><p>可以下载来自社区的软件包，这里选用AUR助手 yay<br />选择一个指定目录然后执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman <span class="token parameter variable">-S</span> <span class="token function">git</span> base-devel <span class="token parameter variable">--needed</span>  <span class="token comment">#&lt;-这是基本的开发工具包，如gcc、make</span><span class="token function">git</span> clone https://aur.archlinux.org/yay-bin.git<span class="token builtin class-name">cd</span> yay-binmakepkg <span class="token parameter variable">-si</span> <span class="token comment"># 构建包</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>-s</code>：自动安装依赖<br /><code>-i</code>：编译完成后自动安装生成的包</p><p>请参见——<a href="https://wiki.archlinuxcn.org/wiki/Yay">yay - Arch Linux 中文维基</a></p><h3 id="37-关于换源"><a class="markdownIt-Anchor" href="#37-关于换源"></a> 3.7. 关于换源</h3><p>打开<code>WSL-setting</code>（直接在win11里搜索）的网络设置，将网络模式由<code>NAT</code> 改为 <code>mirror</code>， 则可直接继承宿主机的网络环境。在宿主机使用网络安全工具即可，因此暂时没有换源。</p><h2 id="4-个性化设置"><a class="markdownIt-Anchor" href="#4-个性化设置"></a> 4. 个性化设置</h2><h3 id="41-使用zsh替代bash"><a class="markdownIt-Anchor" href="#41-使用zsh替代bash"></a> 4.1. 使用zsh替代bash</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pacman <span class="token parameter variable">-S</span> <span class="token function">zsh</span>chsh <span class="token parameter variable">-s</span> /bin/zsh <span class="token comment"># 改变默认shell</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="42-使用oh-my-zsh为zsh提供插件服务"><a class="markdownIt-Anchor" href="#42-使用oh-my-zsh为zsh提供插件服务"></a> 4.2. 使用oh-my-zsh为zsh提供插件服务</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yay <span class="token parameter variable">-S</span> oh-my-zsh.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后 可以在 <code>/usr/share/oh-my-zsh</code> 中查看主题文件和插件以及其提供的<code>zshrc</code>配置模板，直接使用配置模板。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /usr/share/oh-my-zsh/zshrc ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入<code>/usr/share/oh-my-zsh\plugins</code>目录 安装自动补全与语法高亮插件（不自带）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/zsh-users/zsh-autosuggestions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/zsh-users/zsh-syntax-highlighting.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>.zshrc</code> 里添加：</p><pre class="line-numbers language-none"><code class="language-none">plugins&#x3D;(git zsh-autosuggestions zsh-syntax-highlighting)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="43-使用oh-my-posh为zsh提供主题"><a class="markdownIt-Anchor" href="#43-使用oh-my-posh为zsh提供主题"></a> 4.3. 使用oh-my-posh为zsh提供主题</h3><p>你也可以使用<code>oh-my-zsh</code>的主题，只不过我更喜欢<code>oh-my-posh</code>的主题</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yay <span class="token parameter variable">-S</span> oh-my-posh-bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样，安装完成后 可以在 <code>/usr/share/oh-my-posh</code> 中查看主题文件，<br />编辑<code>~/.zshrc</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#注释掉ZSH_THEME="robbyrussell"</span><span class="token builtin class-name">eval</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span>oh-my-posh init <span class="token function">zsh</span> <span class="token parameter variable">--config</span> <span class="token string">'amro'</span><span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="admonition error"><p class="admonition-title">bug</p><p>建议不要使用类似于 <code>--config ~/.poshthemes/mytheme.omp.json</code>的选项，这可能会出现问题。</p></div><p>重新加载：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="WSL2" scheme="https://blog.godmao.top/Tags/WSL2/"/>
    
    <category term="ArchLinux" scheme="https://blog.godmao.top/Tags/ArchLinux/"/>
    
  </entry>
  
  <entry>
    <title>POSIX IPC：System V 的继任者</title>
    <link href="https://blog.godmao.top/posts/26506/"/>
    <id>https://blog.godmao.top/posts/26506/</id>
    <published>2025-09-15T14:24:58.000Z</published>
    <updated>2025-09-15T14:45:59.965Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><ul><li><a href="#1-posix-ipcsystem-v-%E7%9A%84%E7%BB%A7%E4%BB%BB%E8%80%85">1. POSIX IPC：System V 的继任者</a><ul><li><a href="#11-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">1.1. POSIX 消息队列</a><ul><li><a href="#111-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B1%9E%E6%80%A7">1.1.1. 消息队列属性</a></li></ul></li><li><a href="#12-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F">1.2. POSIX 信号量</a></li><li><a href="#13-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">1.3. POSIX 共享内存</a></li></ul></li></ul><h2 id="1-posix-ipcsystem-v-的继任者"><a class="markdownIt-Anchor" href="#1-posix-ipcsystem-v-的继任者"></a> 1. POSIX IPC：System V 的继任者</h2><p><strong>POSIX IPC</strong>（Portable Operating System Interface）是一套新的 IPC 标准，旨在解决 <strong>System V IPC</strong> 的一些局限性。它提供了一套更统一、更现代的 API，使用<strong>文件名</strong>作为标识符，而不是 System V 的<strong>键值</strong>，这使得 IPC 资源的管理更加直观。</p><h3 id="11-posix-消息队列"><a class="markdownIt-Anchor" href="#11-posix-消息队列"></a> 1.1. POSIX 消息队列</h3><p>与 System V 消息队列类似，但 API 更简洁。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>基于文件</strong>：通过 <code>/dev/mqueue</code> 目录下的文件名来标识。</p></li><li><p><strong>优先级</strong>：支持消息优先级，高优先级的消息会被优先处理。</p></li><li><p><strong>非阻塞模式</strong>：可以设置消息队列为非阻塞模式，防止 <code>mq_send</code> 或 <code>mq_receive</code> 阻塞进程。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>mq_open()</code></strong>：创建或打开一个消息队列。</p></li><li><p><strong><code>mq_send()</code></strong>：发送消息。</p></li><li><p><strong><code>mq_receive()</code></strong>：接收消息。</p></li><li><p><strong><code>mq_close()</code></strong>：关闭消息队列。</p></li><li><p><strong><code>mq_unlink()</code></strong>：删除消息队列。</p></li></ul></li></ul><h4 id="111-消息队列属性"><a class="markdownIt-Anchor" href="#111-消息队列属性"></a> 1.1.1. 消息队列属性</h4><p>在POSIX消息队列中，<strong>消息队列属性</strong>（<code>mq_attr</code>）是用来设置和获取消息队列的特性和参数的结构体。它的主要作用是控制消息队列的行为，例如最大消息数、消息大小等。<code>mq_attr</code>结构体包含了以下几个字段：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mq_attr</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span>    mq_flags<span class="token punctuation">;</span>      <span class="token comment">// 消息队列的标志</span>    <span class="token keyword">long</span>    mq_maxmsg<span class="token punctuation">;</span>     <span class="token comment">// 消息队列中最多可以容纳的消息数量</span>    <span class="token keyword">long</span>    mq_msgsize<span class="token punctuation">;</span>    <span class="token comment">// 队列中每条消息的最大大小</span>    <span class="token keyword">long</span>    mq_curmsgs<span class="token punctuation">;</span>    <span class="token comment">// 当前队列中的消息数</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p><code>mq_flags</code></p><p>这个字段用于设置消息队列的标志。常见的标志有：</p><ul><li><p><strong><code>O_NONBLOCK</code></strong>：以非阻塞模式打开消息队列。这意味着如果消息队列为空，接收操作（<code>mq_receive()</code>）会立即返回，而不是阻塞等待。</p></li><li><p><strong><code>O_RDWR</code></strong>：允许对消息队列进行读写操作。</p></li></ul><p>如果没有设置这些标志，消息队列将会默认阻塞模式操作。</p></li><li><p><code>mq_maxmsg</code></p><p>这个字段定义了消息队列可以容纳的最大消息数量。如果消息队列已经存满，且没有空间容纳新的消息，后续的消息发送（<code>mq_send()</code>）将会被阻塞，直到队列中有足够的空间。这个属性通常设置为你希望消息队列中能存储的消息个数。</p></li><li><p><code>mq_msgsize</code></p><p>此字段定义每条消息的最大字节数。在创建消息队列时，必须确保消息发送和接收操作的消息大小不会超过这个值。如果消息超过了这个大小，发送操作将返回错误。</p></li><li><p><code>mq_curmsgs</code></p><p>这个字段是一个只读属性，用于获取当前队列中的消息数量。它是一个动态更新的值，每次读取时会返回当前消息队列中实际存储的消息数。这个字段对应用程序来说很有用，尤其是在需要了解队列当前状态的场景。</p></li></ol><p>这个例子展示了两个不相关的进程如何通过 POSIX 消息队列进行通信。<br />发送方(sender.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span>          <span class="token comment">/* 动态内存管理及其他辅助功能如exit、abort */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span>           <span class="token comment">/* 提供 O_CREAT, O_RDWR 用于文件控制 */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span>        <span class="token comment">/* 文件属性操作 如chmod、umask */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mqueue.h></span>          <span class="token comment">/* 提供POSIX消息队列支持 */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>          <span class="token comment">/* 提供POSIX接口 */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MQ_NAME</span> <span class="token string">"/my_mq"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">mqd_t</span> mqd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">mq_attr</span> attr<span class="token punctuation">;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"Hello from sender!"</span><span class="token punctuation">;</span>    <span class="token comment">// 设置消息队列属性</span>    attr<span class="token punctuation">.</span>mq_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    attr<span class="token punctuation">.</span>mq_maxmsg <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    attr<span class="token punctuation">.</span>mq_msgsize <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">;</span>    attr<span class="token punctuation">.</span>mq_curmsgs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 创建或打开消息队列</span>    mqd <span class="token operator">=</span> <span class="token function">mq_open</span><span class="token punctuation">(</span>MQ_NAME<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_WRONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mqd <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token class-name">mqd_t</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mq_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sender: Sending message...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息，优先级为1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mq_send</span><span class="token punctuation">(</span>mqd<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mq_send"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 关闭消息队列描述符</span>    <span class="token function">mq_close</span><span class="token punctuation">(</span>mqd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sender: Message sent and mq closed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接收方(receiver.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mqueue.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MQ_NAME</span> <span class="token string">"/my_mq"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">mqd_t</span> mqd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">mq_attr</span> attr<span class="token punctuation">;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">256</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prio<span class="token punctuation">;</span>    <span class="token comment">// 打开消息队列</span>    mqd <span class="token operator">=</span> <span class="token function">mq_open</span><span class="token punctuation">(</span>MQ_NAME<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mqd <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token class-name">mqd_t</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mq_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取消息队列属性</span>    <span class="token function">mq_getattr</span><span class="token punctuation">(</span>mqd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receiver: Waiting for message...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 接收消息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mq_receive</span><span class="token punctuation">(</span>mqd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> attr<span class="token punctuation">.</span>mq_msgsize<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prio<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mq_receive"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receiver: Received message: %s (Priority: %u)\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭和删除消息队列</span>    <span class="token function">mq_close</span><span class="token punctuation">(</span>mqd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mq_unlink</span><span class="token punctuation">(</span>MQ_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>编译和运行</strong>： <code>gcc sender.c -o sender -lrt</code> <code>gcc receiver.c -o receiver -lrt</code> （需要链接实时库 <code>-lrt</code>） 先运行 <code>./sender</code>，再运行 <code>./receiver</code>。</p><h3 id="12-posix-信号量"><a class="markdownIt-Anchor" href="#12-posix-信号量"></a> 1.2. POSIX 信号量</h3><p>用于进程间的同步，功能与 System V 信号量类似，但提供了更简单的接口。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>有名信号量</strong>：通过一个文件名标识，可以用于非亲缘进程。</p></li><li><p><strong>无名信号量</strong>：常用于线程间的同步，存放在共享内存中，只能用于有亲缘关系的进程。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>sem_open()</code></strong>：创建或打开有名信号量。</p></li><li><p><strong><code>sem_wait()</code></strong>：原子性地减少信号量计数器，如果为0则阻塞。</p></li><li><p><strong><code>sem_post()</code></strong>：原子性地增加信号量计数器。</p></li><li><p><strong><code>sem_close()</code></strong>：关闭信号量。</p></li><li><p><strong><code>sem_unlink()</code></strong>：删除信号量。</p></li></ul></li></ul><p>这个例子展示了如何使用 POSIX 信号量来同步两个进程对一个共享资源的访问。</p><p>共享资源访问程序 (sem_client.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span>           <span class="token comment">/* For O_CREAT, O_RDWR */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span>        <span class="token comment">/* For mode constants */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_NAME</span> <span class="token string">"/my_semaphore"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">;</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token comment">// 打开信号量</span>    sem <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// O_CREAT is not needed here</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem <span class="token operator">==</span> SEM_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Client: Waiting to get semaphore...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// P 操作：等待信号量，如果值为0则阻塞</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sem_wait</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_wait"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Client: Got the semaphore. Accessing shared resource...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟访问共享资源</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Client: Finished. Releasing semaphore...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// V 操作：释放信号量，计数器加1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sem_post</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_post"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 关闭信号量</span>    <span class="token function">sem_close</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>信号量控制程序 (sem_main.c)：`</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_NAME</span> <span class="token string">"/my_semaphore"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token comment">// 创建并初始化信号量，初始值为1</span>    sem <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">,</span> O_CREAT<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem <span class="token operator">==</span> SEM_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: Semaphore created and initialized to 1.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建一个子进程</span>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 子进程运行另一个程序来访问信号量</span>        <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"./sem_client"</span><span class="token punctuation">,</span> <span class="token string">"sem_client"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execlp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果执行失败</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 父进程也尝试访问信号量</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保子进程先运行</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: Waiting to get semaphore...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: Got the semaphore. Accessing shared resource...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: Finished. Releasing semaphore...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待子进程结束</span>        <span class="token comment">// 删除信号量</span>        <span class="token function">sem_unlink</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: Child process finished. Semaphore unlinked.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 关闭信号量</span>    <span class="token function">sem_close</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>编译和运行</strong>： <code>gcc sem_client.c -o sem_client -lrt</code> <code>gcc sem_main.c -o sem_main -lrt</code> （同样需要链接实时库 <code>-lrt</code>） 运行 <code>./sem_main</code>。</p><h3 id="13-posix-共享内存"><a class="markdownIt-Anchor" href="#13-posix-共享内存"></a> 1.3. POSIX 共享内存</h3><p>和 System V 共享内存一样，都是最快的 IPC 方式，但 POSIX 版本使用了文件描述符。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>基于文件</strong>：通过 <code>shm_open</code> 创建或打开一个共享内存对象，返回一个文件描述符。</p></li><li><p><strong>内存映射</strong>：通过 <code>mmap()</code> 将文件描述符对应的内存映射到进程的地址空间。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>shm_open()</code></strong>：创建或打开共享内存对象。</p></li><li><p><strong><code>ftruncate()</code></strong>：调整共享内存对象的大小。</p></li><li><p><strong><code>mmap()</code></strong>：将共享内存映射到进程地址空间。</p></li><li><p><strong><code>munmap()</code></strong>：解除映射。</p></li><li><p><strong><code>shm_unlink()</code></strong>：删除共享内存对象。</p></li></ul></li></ul><p>这个例子展示了两个进程如何通过 POSIX 共享内存来共享一块内存区域，并用一个信号量来同步。</p><p>写入方 (shm_writer.c)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHM_NAME</span> <span class="token string">"/my_shm"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_NAME</span> <span class="token string">"/my_shm_sem"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHM_SIZE</span> <span class="token expression"><span class="token number">4096</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> shm_fd<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"Hello from shm writer!"</span><span class="token punctuation">;</span>    <span class="token comment">// 创建/打开共享内存对象</span>    shm_fd <span class="token operator">=</span> <span class="token function">shm_open</span><span class="token punctuation">(</span>SHM_NAME<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shm_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"shm_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 设置共享内存大小</span>    <span class="token function">ftruncate</span><span class="token punctuation">(</span>shm_fd<span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将共享内存映射到进程地址空间</span>    ptr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">,</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> shm_fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> MAP_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mmap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 创建/打开信号量，用于同步</span>    sem <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">,</span> O_CREAT<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始值为0，表示不可访问</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem <span class="token operator">==</span> SEM_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Writer: Writing to shared memory...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 写入数据</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// V 操作：释放信号量，通知读者可以读取了</span>    <span class="token function">sem_post</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Writer: Data written and semaphore posted.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭</span>    <span class="token function">sem_close</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">munmap</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>shm_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取方 (shm_reader.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHM_NAME</span> <span class="token string">"/my_shm"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_NAME</span> <span class="token string">"/my_shm_sem"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHM_SIZE</span> <span class="token expression"><span class="token number">4096</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> shm_fd<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">;</span>    <span class="token comment">// 打开共享内存对象</span>    shm_fd <span class="token operator">=</span> <span class="token function">shm_open</span><span class="token punctuation">(</span>SHM_NAME<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shm_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"shm_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将共享内存映射到进程地址空间</span>    ptr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">,</span> PROT_READ<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> shm_fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> MAP_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mmap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 打开信号量</span>    sem <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem <span class="token operator">==</span> SEM_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Reader: Waiting for writer...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// P 操作：等待信号量，直到有数据可用</span>    <span class="token function">sem_wait</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Reader: Data received: %s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭和清理</span>    <span class="token function">sem_close</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sem_unlink</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除信号量</span>    <span class="token function">munmap</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>shm_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">shm_unlink</span><span class="token punctuation">(</span>SHM_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除共享内存对象</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>编译和运行</strong>： <code>gcc shm_writer.c -o shm_writer -lrt</code> <code>gcc shm_reader.c -o shm_reader -lrt</code> （同样需要链接实时库 <code>-lrt</code>） 先运行 <code>./shm_writer</code>，再运行 <code>./shm_reader</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="IPC" scheme="https://blog.godmao.top/Tags/IPC/"/>
    
    <category term="POSIX" scheme="https://blog.godmao.top/Tags/POSIX/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Linux IPC：进程间通信的艺术</title>
    <link href="https://blog.godmao.top/posts/46571/"/>
    <id>https://blog.godmao.top/posts/46571/</id>
    <published>2025-09-12T09:28:41.000Z</published>
    <updated>2025-09-15T14:35:23.508Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><ul><li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-ipc">1. 为什么需要 IPC？</a></li><li><a href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84-linux-ipc-%E6%9C%BA%E5%88%B6">2. 常见的 Linux IPC 机制</a><ul><li><a href="#21-%E7%AE%A1%E9%81%93pipes">2.1. 管道（Pipes）</a></li><li><a href="#22-fifo%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93">2.2. FIFO（命名管道）</a></li><li><a href="#23-%E4%BF%A1%E5%8F%B7">2.3. 信号</a><ul><li><a href="#231-%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%88%86%E7%B1%BB">2.3.1. 信号的分类</a></li><li><a href="#232-%E4%BF%A1%E5%8F%B7%E4%B8%8E-ipc-%E7%9A%84%E5%85%B3%E7%B3%BB">2.3.2. 信号与 IPC 的关系</a></li><li><a href="#233-%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">2.3.3. 信号的三种处理方式</a></li><li><a href="#234-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7">2.3.4. 如何使用信号？</a><ul><li><a href="#2341-%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7kill-%E5%87%BD%E6%95%B0">2.3.4.1. 发送信号：<code>kill()</code> 函数</a></li><li><a href="#2342-%E6%B3%A8%E5%86%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0signal-%E5%92%8C-sigaction">2.3.4.2. 注册信号处理函数：<code>signal()</code> 和 <code>sigaction()</code></a></li></ul></li></ul></li><li><a href="#24-%E4%BF%A1%E5%8F%B7%E9%9B%86signal-set%E5%92%8C%E9%98%BB%E5%A1%9E">2.4. 信号集（Signal Set）和阻塞</a><ul><li><a href="#241-%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">2.4.1. 信号集操作函数</a></li><li><a href="#242-%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7sigprocmask">2.4.2. 阻塞信号：<code>sigprocmask()</code></a></li></ul></li><li><a href="#25-system-v-ipc-system-v-ipc">2.5. System V IPC (System V IPC)[^1]</a><ul><li><a href="#251-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97message-queues">2.5.1. 消息队列（Message Queues）</a></li><li><a href="#252-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphores">2.5.2. 信号量（Semaphores）</a></li><li><a href="#253-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98shared-memory">2.5.3. 共享内存（Shared Memory）</a></li></ul></li><li><a href="#26-ipc-%E6%80%BB%E7%BB%93%E4%B8%8E%E9%80%89%E6%8B%A9">2.6. IPC 总结与选择</a></li></ul></li></ul><p>在 Linux 世界中，进程是独立的执行单元，拥有自己的地址空间。但很多时候，为了完成一个复杂的任务，不同的进程需要协同工作，交换数据。这时，我们就需要<strong>进程间通信（IPC, Inter-Process Communication）</strong>。IPC 就像是进程之间的一座桥梁，让它们能够相互“交谈”，共享信息。</p><p>本文将带你深入了解 Linux 中常见的 IPC 机制，并以<strong>使用为导向</strong>，结合代码示例，让你能够快速掌握这些“通信”技术。</p><h2 id="1-为什么需要-ipc"><a class="markdownIt-Anchor" href="#1-为什么需要-ipc"></a> 1. 为什么需要 IPC？</h2><p>想象一个场景：你正在开发一个 Web 服务器。一个主进程负责监听网络请求，但处理这些请求非常耗时。如果主进程自己处理，服务器就会变得很慢，无法响应新的请求。一个更好的设计是，主进程每接收到一个请求，就创建一个新的子进程或将请求发送给一个工作进程池来处理。这样，主进程可以立即回去监听新的连接，而工作进程则专注于处理任务。</p><p>在这个例子中，主进程需要将请求数据传递给工作进程。这就是 IPC 发挥作用的地方。</p><h2 id="2-常见的-linux-ipc-机制"><a class="markdownIt-Anchor" href="#2-常见的-linux-ipc-机制"></a> 2. 常见的 Linux IPC 机制</h2><p>Linux 提供了多种 IPC 机制，每种都有其独特的优缺点和适用场景。我们可以将它们分为两大类：<strong>基于文件</strong>和<strong>基于内存</strong>。</p><h3 id="21-管道pipes"><a class="markdownIt-Anchor" href="#21-管道pipes"></a> 2.1. 管道（Pipes）</h3><p>管道可能是最简单、最古老的 IPC 形式。它就像一个单向的“水管”，一端用于写入，另一端用于读取。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>单向通信</strong>：数据只能从一端流向另一端。</p></li><li><p><strong>父子进程通信</strong>：管道通常用于有亲缘关系的进程之间，比如父进程和子进程。</p></li><li><p><strong>半双工</strong>：虽然是单向，但如果创建两个管道，就可以实现双向通信。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><strong><code>pipe()</code> 函数</strong>：这是创建管道的核心函数。</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>pipefd</code> 是一个包含两个文件描述符的数组，<code>pipefd[0]</code> 用于读取，<code>pipefd[1]</code> 用于写入。</p></li><li><p><strong>代码示例</strong>：一个简单的父子进程通信。</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"Hello from parent!"</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"pipe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭读取端</span>        <span class="token function">write</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭写入端，如果不关，子进程读端收不到EOF信号，则会一直读导致程序阻塞</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭写入端，如果不关</span>        <span class="token function">read</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child received: %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭读取端</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="22-fifo命名管道"><a class="markdownIt-Anchor" href="#22-fifo命名管道"></a> 2.2. FIFO（命名管道）</h3><p>管道只能用于有亲缘关系的进程，那如果两个毫不相关的进程想通信怎么办？答案就是 <strong>FIFO (First-In, First-Out)</strong>，也叫<strong>命名管道</strong>。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>文件系统路径</strong>：它在文件系统中有一个路径名，不同于匿名管道。</p></li><li><p><strong>非亲缘进程通信</strong>：任意两个进程都可以通过这个路径名打开并通信。</p></li><li><p><strong>单向</strong>：和管道一样，FIFO 也是单向的，需要两个 FIFO 来实现双向通信。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><strong><code>mkfifo()</code> 函数</strong>或 <strong><code>mkfifo</code> 命令</strong>：用来创建 FIFO。</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong><code>open()</code>, <code>read()</code>, <code>write()</code> 函数</strong>：像操作普通文件一样来操作 FIFO。</li></ul></li><li><p><strong>代码示例</strong>：</p><ul><li><strong><code>writer.c</code></strong>：</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FIFO_NAME</span> <span class="token string">"my_fifo"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"Hello from writer!"</span><span class="token punctuation">;</span>    <span class="token function">mkfifo</span><span class="token punctuation">(</span>FIFO_NAME<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>FIFO_NAME<span class="token punctuation">,</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>FIFO_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除命名管道文件</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong><code>reader.c</code></strong>：</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FIFO_NAME</span> <span class="token string">"my_fifo"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">mkfifo</span><span class="token punctuation">(</span>FIFO_NAME<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证文件存在</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>FIFO_NAME<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Reader received: %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以先运行 <code>writer.c</code>，再运行 <code>reader.c</code>。</p></li></ul><h3 id="23-信号"><a class="markdownIt-Anchor" href="#23-信号"></a> 2.3. 信号</h3><p><strong>信号（Signal）</strong> 是一种更轻量级、更异步的进程间通信和事件通知机制。它就像一个“软中断”，用来通知进程发生了某个事件。</p><p>想象一下，你正在专注地工作，突然有人拍了你一下肩膀。你停下手中的活，转头看看发生了什么事，然后根据情况做出反应（比如，对方是同事，你可能和他聊两句；对方是领导，你可能马上站起来）。</p><p>在 Linux 中，<strong>信号</strong>就是那个“拍肩膀”的动作。当一个进程收到一个信号时，它会暂停当前执行的任务，转而去处理这个信号，处理完后再恢复执行。</p><ul><li><p><strong>发送者</strong>：可以是内核（比如你按下 <code>Ctrl+C</code>，内核会发送 <code>SIGINT</code> 信号给前台进程）、也可以是其他进程（使用 <code>kill()</code> 函数）。</p></li><li><p><strong>接收者</strong>：任何一个进程都可以接收信号。</p></li></ul><h4 id="231-信号的分类"><a class="markdownIt-Anchor" href="#231-信号的分类"></a> 2.3.1. 信号的分类</h4><p>信号有很多种，每种都有其特定的用途。常见的信号及其作用如下：</p><table><thead><tr><th>信号名称</th><th>默认行为</th><th>解释</th></tr></thead><tbody><tr><td><strong><code>SIGHUP</code> (1)</strong></td><td>终止进程</td><td>当终端关闭时发送给关联的进程。</td></tr><tr><td><strong><code>SIGINT</code> (2)</strong></td><td>终止进程</td><td>来自键盘中断，通常是 <code>Ctrl+C</code>。</td></tr><tr><td><strong><code>SIGQUIT</code> (3)</strong></td><td>终止并生成核心转储文件</td><td>来自键盘退出，通常是 <code>Ctrl+\\</code>。</td></tr><tr><td><strong><code>SIGKILL</code> (9)</strong></td><td>强制终止进程</td><td>无法被捕获、阻塞或忽略，强制杀死进程。</td></tr><tr><td><strong><code>SIGTERM</code> (15)</strong></td><td>终止进程</td><td>友好的终止请求，可以被捕获。<code>kill</code> 命令默认发送此信号。</td></tr><tr><td><strong><code>SIGCHLD</code></strong></td><td>忽略</td><td>子进程终止或停止时发送给父进程。</td></tr><tr><td><strong><code>SIGSTOP</code></strong></td><td>停止进程</td><td>无法被捕获、忽略，暂停进程。</td></tr><tr><td><strong><code>SIGCONT</code></strong></td><td>继续进程</td><td>使停止的进程继续运行。</td></tr></tbody></table><h4 id="232-信号与-ipc-的关系"><a class="markdownIt-Anchor" href="#232-信号与-ipc-的关系"></a> 2.3.2. 信号与 IPC 的关系</h4><ul><li><p><strong>异步通知</strong>：信号是典型的异步 IPC 机制，它不像管道或共享内存那样传递数据，而是<strong>传递事件信息</strong>。</p></li><li><p><strong>轻量级</strong>：相比于其他 IPC，信号的开销非常小。</p></li><li><p><strong>同步</strong>：信号也可以用于同步目的，例如 <code>SIGCHLD</code> 信号常用于父进程等待子进程结束。</p></li></ul><p>理解信号，特别是信号集和阻塞的概念，对于编写健壮的多进程或多线程程序至关重要。它能让你更好地控制程序对外部事件的响应。</p><h4 id="233-信号的三种处理方式"><a class="markdownIt-Anchor" href="#233-信号的三种处理方式"></a> 2.3.3. 信号的三种处理方式</h4><p>当进程收到一个信号时，它可以有三种处理方式：</p><ol><li><p><strong>执行默认动作（Default）</strong>：大多数信号都有一个预定义的默认行为。例如，<code>SIGINT</code> 的默认行为就是终止进程。</p></li><li><p><strong>忽略信号（Ignore）</strong>：有些信号可以被忽略，即进程收到信号后不做任何处理。<code>SIGCHLD</code> 信号的默认行为就是忽略。</p></li><li><p><strong>捕获信号（Catch）</strong>：这是最灵活的方式。进程可以为某个信号注册一个<strong>信号处理函数（Signal Handler）</strong>。当信号到来时，进程会执行这个函数来处理信号，而不是执行默认动作。</p></li></ol><div class="admonition caution"><p class="admonition-title">caution</p><p><strong>注意</strong>：<code>SIGKILL</code> 和 <code>SIGSTOP</code> 这两个信号是<strong>不能被捕获、忽略或阻塞</strong>的。它们是系统管理员强制终止或停止进程的“最后手段”。</p></div><h4 id="234-如何使用信号"><a class="markdownIt-Anchor" href="#234-如何使用信号"></a> 2.3.4. 如何使用信号？</h4><h5 id="2341-发送信号kill-函数"><a class="markdownIt-Anchor" href="#2341-发送信号kill-函数"></a> 2.3.4.1. 发送信号：<code>kill()</code> 函数</h5><p>你可以使用 <code>kill()</code> 函数向另一个进程发送信号。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">int</span> <span class="token function">kill</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><code>pid</code>：目标进程的 ID。</p></li><li><p><code>sig</code>：要发送的信号编号。</p></li></ul><h5 id="2342-注册信号处理函数signal-和-sigaction"><a class="markdownIt-Anchor" href="#2342-注册信号处理函数signal-和-sigaction"></a> 2.3.4.2. 注册信号处理函数：<code>signal()</code> 和 <code>sigaction()</code></h5><ul><li><p><strong><code>signal()</code> 函数</strong>：这是最简单的注册方式，但它在不同系统上的行为可能不一致，不推荐在新代码中使用。</p></li><li><p><strong><code>sigaction()</code> 函数</strong>：这是 POSIX 标准推荐的方式，更强大，更可靠。</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>oldact<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p><code>signum</code>：要捕获的信号编号。</p></li><li><p><code>act</code>：指向 <code>struct sigaction</code> 结构体，该结构体定义了新的信号处理行为。</p></li><li><p><code>oldact</code>：可选，用于保存旧的信号处理行为。</p></li></ul><p><strong><code>struct sigaction</code> 结构体</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sa_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 信号处理函数</span>    <span class="token class-name">sigset_t</span> sa_mask<span class="token punctuation">;</span>         <span class="token comment">// 信号集，在信号处理函数执行期间需要阻塞的信号</span>    <span class="token keyword">int</span> sa_flags<span class="token punctuation">;</span>             <span class="token comment">// 标志位</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="24-信号集signal-set和阻塞"><a class="markdownIt-Anchor" href="#24-信号集signal-set和阻塞"></a> 2.4. 信号集（Signal Set）和阻塞</h3><p>当你在处理一个信号时，你可能不希望被其他信号打断。<strong>信号集（<code>sigset_t</code>）</strong> 就是用来管理一组信号的。通过操作信号集，你可以<strong>阻塞（Block）</strong> 某些信号，让它们在进程处理完当前任务后才被传递。</p><h4 id="241-信号集操作函数"><a class="markdownIt-Anchor" href="#241-信号集操作函数"></a> 2.4.1. 信号集操作函数</h4><ul><li><p><strong><code>sigemptyset()</code></strong>：初始化一个空的信号集。</p></li><li><p><strong><code>sigaddset()</code></strong>：向信号集中添加一个信号。</p></li><li><p><strong><code>sigdelset()</code></strong>：从信号集中删除一个信号。</p></li><li><p><strong><code>sigismember()</code></strong>：检查一个信号是否在信号集中。</p></li></ul><h4 id="242-阻塞信号sigprocmask"><a class="markdownIt-Anchor" href="#242-阻塞信号sigprocmask"></a> 2.4.2. 阻塞信号：<code>sigprocmask()</code></h4><p><code>sigprocmask()</code> 函数用来设置进程的<strong>信号阻塞掩码（Signal Mask）</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>oldset<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p><code>how</code>：指定如何修改信号阻塞掩码，有以下几种：</p><ul><li><p><code>SIG_BLOCK</code>：将 <code>set</code> 中的信号添加到阻塞掩码中。</p></li><li><p><code>SIG_UNBLOCK</code>：将 <code>set</code> 中的信号从阻塞掩码中移除。</p></li><li><p><code>SIG_SETMASK</code>：将阻塞掩码设置为 <code>set</code>。</p></li></ul></li><li><p><code>set</code>：包含要阻塞或解除阻塞的信号集。</p></li><li><p><code>oldset</code>：可选，用于保存旧的阻塞掩码。</p></li></ul><p><strong>示例</strong>：在处理关键代码段时临时阻塞 <code>SIGINT</code>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span> <span class="token function">my_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Caught signal %d\n"</span><span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">sigset_t</span> block_mask<span class="token punctuation">,</span> old_mask<span class="token punctuation">;</span>    <span class="token comment">// 1. 设置要阻塞的信号集</span>    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>block_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>block_mask<span class="token punctuation">,</span> SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 阻塞 SIGINT 信号</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>block_mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>old_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SIGINT is blocked. Press Ctrl+C...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在这10秒内，Ctrl+C不会终止进程</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unblocking SIGINT...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 解除阻塞，恢复旧的信号掩码</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>old_mask<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SIGINT is unblocked. Press Ctrl+C again.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4. 注册一个信号处理函数</span>    <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> sa<span class="token punctuation">;</span>    sa<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> my_handler<span class="token punctuation">;</span>    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sa<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    sa<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">sigaction</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sa<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Running...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行这段代码，你会看到在阻塞期间，<code>Ctrl+C</code> 无法终止进程。当解除阻塞后，<code>Ctrl+C</code> 才能触发信号处理函数。</p><h3 id="25-system-v-ipc-system-v-ipc"><a class="markdownIt-Anchor" href="#25-system-v-ipc-system-v-ipc"></a> 2.5. System V IPC (System V IPC)<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h3><p>System V IPC 是 Linux 系统中一组更高级、更强大的 IPC 机制，包括消息队列、信号量和共享内存。它们都是<strong>基于内核</strong>的，需要一个唯一的键值（key）来标识。</p><h4 id="251-消息队列message-queues"><a class="markdownIt-Anchor" href="#251-消息队列message-queues"></a> 2.5.1. 消息队列（Message Queues）</h4><p>消息队列就像一个链表，允许进程向其中添加消息或从中读取消息。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>异步通信</strong>：发送进程可以发送消息后立即返回，不需要等待接收进程。</p></li><li><p><strong>带类型</strong>：消息可以带有类型，接收进程可以只接收特定类型的消息。</p></li><li><p><strong>存储在内核中</strong>：即使发送进程结束，消息依然保留在队列中，直到被读取。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>ftok()</code></strong>：将文件路径和整数转换为一个唯一的 IPC 键值。</p></li><li><p><strong><code>msgget()</code></strong>：创建或获取一个消息队列。</p></li><li><p><strong><code>msgsnd()</code></strong>：发送消息。</p></li><li><p><strong><code>msgrcv()</code></strong>：接收消息。</p></li><li><p><strong><code>msgctl()</code></strong>：控制消息队列，如删除。</p></li></ul></li></ul><h4 id="252-信号量semaphores"><a class="markdownIt-Anchor" href="#252-信号量semaphores"></a> 2.5.2. 信号量（Semaphores）</h4><p>信号量主要用于<strong>同步</strong>，控制对共享资源的访问。它本身不传递数据，而是作为一种“计数器”。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>互斥和同步</strong>：常用于实现互斥锁，确保同一时间只有一个进程访问共享资源。</p></li><li><p><strong>原子操作</strong>：信号量的操作（P/V操作）是原子的，不会被中断。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>semget()</code></strong>：创建或获取一组信号量。</p></li><li><p><strong><code>semop()</code></strong>：对信号量进行操作，如加/减计数。</p></li><li><p><strong><code>semctl()</code></strong>：控制信号量。</p></li></ul></li></ul><h4 id="253-共享内存shared-memory"><a class="markdownIt-Anchor" href="#253-共享内存shared-memory"></a> 2.5.3. 共享内存（Shared Memory）</h4><p>共享内存是最高效的 IPC 方式。它允许两个或多个进程共享同一块物理内存。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>最高效</strong>：一旦映射到进程的地址空间，读写操作就像访问普通内存一样，不需要内核的参与。</p></li><li><p><strong>需要同步</strong>：由于多个进程同时访问，需要用<strong>信号量</strong>等机制来同步访问，防止数据竞争。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>shmget()</code></strong>：创建或获取一个共享内存段。</p></li><li><p><strong><code>shmat()</code></strong>：将共享内存段附加到进程的地址空间。</p></li><li><p><strong><code>shmdt()</code></strong>：将共享内存段从进程的地址空间分离。</p></li><li><p><strong><code>shmctl()</code></strong>：控制共享内存，如删除。</p></li></ul></li></ul><h3 id="26-ipc-总结与选择"><a class="markdownIt-Anchor" href="#26-ipc-总结与选择"></a> 2.6. IPC 总结与选择</h3><table><thead><tr><th>机制</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>管道</strong></td><td>有亲缘关系的进程</td><td>简单，易于使用</td><td>单向，仅限于亲缘进程</td></tr><tr><td><strong>FIFO</strong></td><td>无亲缘关系的进程</td><td>可以在文件系统中命名，灵活</td><td>单向，需要同步，读写时有阻塞</td></tr><tr><td><strong>消息队列</strong></td><td>异步通信，少量数据</td><td>消息带类型，无需同步</td><td>效率较低，有大小限制</td></tr><tr><td><strong>信号量</strong></td><td>进程间同步，互斥</td><td>用于控制访问，防止竞争</td><td>不传递数据</td></tr><tr><td><strong>共享内存</strong></td><td>大量数据传输</td><td>最高效，读写速度快</td><td>必须配合其他同步机制使用</td></tr></tbody></table><p><strong>如何选择？</strong></p><ul><li><p>如果是父子进程之间少量数据的通信，<strong>管道</strong>是最佳选择。</p></li><li><p>如果是两个不相关的进程，且数据量不大，<strong>消息队列</strong>是一个不错的方案。</p></li><li><p>如果需要传输大量数据，且对性能要求极高，<strong>共享内存</strong>是首选，但<strong>必须</strong>结合<strong>信号量</strong>或其他同步机制。</p></li><li><p>如果你只想解决资源访问的同步问题，<strong>信号量</strong>是专门为此设计的。</p></li></ul><p>了解这些 IPC 机制，就如同掌握了进程之间“沟通”的多种语言。在开发时，选择合适的“语言”能让你的程序更加健壮、高效。现在，你可以尝试用这些机制来解决你遇到的实际问题了！</p><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>作了解，重点使用POSIX IPC。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="IPC" scheme="https://blog.godmao.top/Tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>Linux-Process</title>
    <link href="https://blog.godmao.top/posts/43741/"/>
    <id>https://blog.godmao.top/posts/43741/</id>
    <published>2025-09-10T06:53:13.000Z</published>
    <updated>2025-09-12T11:32:56.501Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><div class="admonition info"><p>AI 辅助创作</p></div><p>在 Linux 编程中，<strong>进程（Process）</strong> 是操作系统分配资源和调度的基本单位。每个进程都有自己独立的内存空间、代码段、数据段和执行上下文。多个进程之间常常需要协作，这就涉及到 <strong>进程间通信（IPC, Inter-Process Communication）</strong>。本篇博客会系统介绍进程的基础操作，并对常见的 IPC 方式进行详细解释与示例，带你从零开始掌握。</p><hr /><h2 id="1-进程与-pid"><a class="markdownIt-Anchor" href="#1-进程与-pid"></a> 1. 进程与 PID</h2><p>每个进程都会有一个唯一的 <strong>进程号（PID）</strong>，可以通过 <code>getpid()</code> 获取当前进程号，通过 <code>getppid()</code> 获取父进程号。这在调试和进程管理时非常重要。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"当前进程PID=%d, 父进程PID=%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⚠️ 注意：如果父进程先退出，子进程会被 <code>init</code> 进程接管，<code>ppid</code> 会变为 1。</p><h2 id="2-创建进程-fork"><a class="markdownIt-Anchor" href="#2-创建进程-fork"></a> 2. 创建进程 — <code>fork()</code></h2><p><code>fork()</code> 是创建新进程的主要方式。它会复制当前进程（父进程）的大部分内容，生成一个几乎一模一样的子进程。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>在父进程中，<code>fork()</code> 返回子进程的 PID。</strong></p></li><li><p><strong>在子进程中，<code>fork()</code> 返回 0。</strong></p></li><li><p>如果失败，返回 -1。</p></li></ul><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[子进程] pid=%d, ppid=%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[父进程] pid=%d, 子进程pid=%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork 失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="admonition caution"><p class="admonition-title">caution</p><ul><li><p>子进程不会继承父进程的所有资源，例如文件锁。</p></li><li><p><code>fork()</code> 之后，父子进程执行顺序不确定，需要通过 <code>wait()</code> 或其他机制控制。</p></li></ul></div><h2 id="3-程序替换-exec-系列"><a class="markdownIt-Anchor" href="#3-程序替换-exec-系列"></a> 3. 程序替换 — <code>exec()</code> 系列</h2><p>子进程常常需要运行一个新的程序，这就需要 <code>exec()</code> 系列函数（如 <code>execlp</code>, <code>execvp</code> 等）。<br /><code>exec</code> 系列函数的作用是：<strong>用新的程序替换当前进程的代码段</strong>，而进程的 PID、文件描述符（除非设置了 <code>FD_CLOEXEC</code>）等保持不变。它不会创建新进程，而是在当前进程内加载并运行新程序。</p><h3 id="常见函数"><a class="markdownIt-Anchor" href="#常见函数"></a> 常见函数</h3><p><code>exec</code> 系列一共有 6 个常用函数，主要区别在于 <strong>参数传递方式</strong> 和 <strong>是否依赖 PATH 环境变量</strong>。</p><table><thead><tr><th>函数</th><th>参数传递方式</th><th>是否搜索 PATH</th><th>说明</th></tr></thead><tbody><tr><td><code>execl(path, arg0, arg1, ..., NULL)</code></td><td>列表（逐个传参）</td><td>否</td><td>最常见，参数以不定长列表形式传递，最后必须以 <code>NULL</code> 结尾。</td></tr><tr><td><code>execv(path, argv[])</code></td><td>数组</td><td>否</td><td>参数通过字符串数组传递，方便动态构造参数。</td></tr><tr><td><code>execlp(file, arg0, arg1, ..., NULL)</code></td><td>列表</td><td>是</td><td>与 <code>execl</code> 类似，但会在 <code>PATH</code> 中搜索可执行文件。</td></tr><tr><td><code>execvp(file, argv[])</code></td><td>数组</td><td>是</td><td>与 <code>execv</code> 类似，但会在 <code>PATH</code> 中搜索可执行文件。</td></tr><tr><td><code>execle(path, arg0, arg1, ..., NULL, envp[])</code></td><td>列表</td><td>否</td><td>可以自定义环境变量，最后参数需提供 <code>envp</code>。</td></tr><tr><td><code>execve(path, argv[], envp[])</code></td><td>数组</td><td>否</td><td>最底层的系统调用，其它 <code>exec</code> 函数最终都调用它。</td></tr></tbody></table><p>说明：</p><ul><li><code>PATH</code>：系统环境变量</li><li><code>path</code>：要执行的程序路径（可以是绝对路径，也可以是相对路径）。</li><li><code>arg</code>：程序要输入的参数</li></ul><h3 id="使用示例"><a class="markdownIt-Anchor" href="#使用示例"></a> 使用示例</h3><ol><li><strong>execl：用绝对路径调用程序</strong></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Before exec\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> <span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 只有 exec 调用失败时才会继续执行    </span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>execvp：在 PATH 中搜索命令</strong></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-a"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execvp failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>execle：传入自定义环境变量</strong></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>envp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"MYVAR=HelloExec"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/usr/bin/env"</span><span class="token punctuation">,</span> <span class="token string">"env"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> envp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execle failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ul><li><p><code>exec</code> 系列 <strong>不会返回</strong>，除非调用失败。</p></li><li><p>若调用成功，原进程的代码和数据段会被新程序替换。</p></li><li><p><strong>文件描述符默认继承</strong>，可以用于在父进程中设置好管道/重定向，让子进程在 exec 后继续使用。</p></li><li><p>需要保证参数列表最后有 <code>NULL</code>，否则会引发不可预期错误。</p></li></ul><h2 id="4-等待子进程-wait-waitpid"><a class="markdownIt-Anchor" href="#4-等待子进程-wait-waitpid"></a> 4. 等待子进程 — <code>wait()</code> / <code>waitpid()</code></h2><p><strong>父进程需要回收子进程退出时的资源，否则子进程会成为 僵尸进程（Zombie）。</strong></p><p>这两个函数用于 <strong>父进程等待子进程结束</strong> 并<strong>回收资源</strong>，避免僵尸进程。</p><h3 id="1-wait"><a class="markdownIt-Anchor" href="#1-wait"></a> 1. wait()</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>参数</strong></p><ul><li><code>status</code>：指向整数的指针，用于存储子进程退出状态。如果不关心状态，可以传 <code>NULL</code>。</li></ul></li><li><p><strong>返回值</strong></p><ul><li><p>成功：返回结束的子进程 PID</p></li><li><p>失败：返回 -1（例如没有子进程存在时）</p></li></ul></li><li><p><strong>使用示例</strong></p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child running...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        <span class="token class-name">pid_t</span> cpid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待子进程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 判断是否正常退出</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d exited with code %d\n"</span><span class="token punctuation">,</span> cpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="admonition caution"><p class="admonition-title">caution</p><ul><li><p><code>wait()</code> 会阻塞父进程，直到任意一个子进程退出。</p></li><li><p>如果父进程没有子进程，返回 -1 并设置 <code>errno = ECHILD</code>。</p></li></ul></div><h3 id="2-waitpid"><a class="markdownIt-Anchor" href="#2-waitpid"></a> 2. waitpid()</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>参数</strong></p><ul><li><p><code>pid</code>：</p><ul><li><p><code>&gt;0</code> ：等待指定 PID 的子进程</p></li><li><p>-1 ：等待任意子进程（功能类似 <code>wait()</code>）</p></li><li><p>0 ：等待与调用进程同组的任意子进程</p></li><li><p>&lt;-1：等待进程组 ID = |pid| 的任意子进程</p></li></ul></li><li><p><code>status</code>：指向整数的指针，用于保存退出状态</p></li><li><p><code>options</code>：控制函数行为，常用值：</p><ul><li><p><code>0</code>：阻塞等待（默认行为）</p></li><li><p><code>WNOHANG</code>：非阻塞，如果没有子进程退出立即返回 0</p></li><li><p><code>WUNTRACED</code>：返回被暂停的子进程（收到 SIGSTOP）</p></li><li><p><code>WCONTINUED</code>：返回继续运行的子进程（收到 SIGCONT）</p></li></ul></li></ul></li><li><p><strong>返回值</strong></p><ul><li><p>成功：返回子进程 PID</p></li><li><p>非阻塞且没有子进程退出：返回 0</p></li><li><p>失败：返回 -1，并设置 <code>errno</code></p></li></ul></li><li><p><strong>使用示例</strong></p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        <span class="token class-name">pid_t</span> cpid<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cpid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child still running...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d exited with code %d\n"</span><span class="token punctuation">,</span> cpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="admonition caution"><p class="admonition-title">caution</p><ul><li><p><code>waitpid()</code> 可以实现 <strong>非阻塞等待</strong>，适合父进程同时管理多个子进程。</p></li><li><p><code>WIFEXITED(status)</code> 判断子进程是否正常退出。</p></li><li><p><code>WIFSIGNALED(status)</code> 判断子进程是否被信号终止。</p></li><li><p>使用 <code>waitpid()</code> 可以精准回收指定子进程，避免僵尸进程积累。</p></li></ul></div><div class="admonition note"><p class="admonition-title">tips</p><ul><li><p>父进程只需要等待任意子进程 → 用 <code>wait()</code> 即可。</p></li><li><p>父进程需要精确控制或非阻塞 → 用 <code>waitpid()</code>。</p></li><li><p>调用前一定要理解 <strong>阻塞 vs 非阻塞</strong>，避免父进程被卡住。</p></li></ul></div><h2 id="5-进程退出-exit-与-_exit"><a class="markdownIt-Anchor" href="#5-进程退出-exit-与-_exit"></a> 5. 进程退出 — <code>exit()</code> 与 <code>_exit()</code></h2><ul><li><p><code>exit()</code>：会刷新缓冲区，执行清理函数。</p></li><li><p><code>_exit()</code>：立即退出，不做清理，通常在子进程 <code>fork()</code> 后的错误处理中使用。</p></li></ul><p>⚠️ 区别：<code>exit()</code> 适合普通退出，<code>_exit()</code> 适合在 <code>fork()</code> 后不希望影响父进程的环境时使用。</p><div class="admonition caution"><p class="admonition-title">caution</p><ul><li>子进程执行退出函数后，子进程结束并变为僵尸🧟，内核保留子进程在进程表中的部分信息（PID、退出码等）占用少量系统资源，但不会再运行。需要父进程调用wait释放子进程资源，净化僵尸，释放灵魂👻</li></ul></div><h2 id="6-ps-命令简述"><a class="markdownIt-Anchor" href="#6-ps-命令简述"></a> 6. ps 命令简述</h2><h3 id="ps-命令的常见用法"><a class="markdownIt-Anchor" href="#ps-命令的常见用法"></a> <code>ps</code> 命令的常见用法</h3><h4 id="1-查看当前终端中的进程"><a class="markdownIt-Anchor" href="#1-查看当前终端中的进程"></a> 1. 查看当前终端中的进程</h4><p>这是最简单的用法，不加任何选项，<code>ps</code> 命令只会显示当前终端会话中运行的进程。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行后你可能会看到类似下面的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PID TTY          TIME CMD<span class="token number">1234</span> pts/0    00:00:00 <span class="token function">bash</span><span class="token number">5678</span> pts/0    00:00:00 <span class="token function">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>PID</strong>：进程的唯一标识符（Process ID）。</p></li><li><p><strong>TTY</strong>：进程运行所在的终端。</p></li><li><p><strong>TIME</strong>：进程使用的 CPU 时间。</p></li><li><p><strong>CMD</strong>：启动进程的命令。</p></li></ul><h4 id="2-查看所有进程"><a class="markdownIt-Anchor" href="#2-查看所有进程"></a> 2. 查看所有进程</h4><p>如果你想查看系统中所有用户的所有进程，可以使用 <code>-e</code> 选项（代表所有进程）或 <code>-a</code> 选项（代表所有进程，除了会话引导进程）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-e</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 <code>-ef</code> 组合，这是最常用的组合之一，它提供了更详细的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-ef</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>UID</strong>：启动进程的用户 ID。</p></li><li><p><strong>PID</strong>：进程 ID。</p></li><li><p><strong>PPID</strong>：父进程 ID。</p></li><li><p><strong>C</strong>：CPU 利用率。</p></li><li><p><strong>STIME</strong>：进程启动时间。</p></li><li><p><strong>TTY</strong>：进程所在的终端。</p></li><li><p><strong>TIME</strong>：进程使用的 CPU 时间。</p></li><li><p><strong>CMD</strong>：启动进程的命令。</p></li></ul><h4 id="3-查看用户进程"><a class="markdownIt-Anchor" href="#3-查看用户进程"></a> 3. 查看用户进程</h4><p>如果你只想查看某个特定用户（例如 <code>root</code>）的进程，可以使用 <code>-u</code> 选项。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-u</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-通过管道和-grep-查找特定进程"><a class="markdownIt-Anchor" href="#4-通过管道和-grep-查找特定进程"></a> 4. 通过管道和 <code>grep</code> 查找特定进程</h4><p>在实际工作中，你通常会需要查找某个特定的进程，比如 Nginx 或 MySQL。这时，<code>ps</code> 命令通常会配合 <code>grep</code> 命令一起使用。<code>grep</code> 可以从 <code>ps</code> 的输出中过滤出你想要的信息。</p><p>例如，查找所有与 Nginx 相关的进程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的 <code>|</code> 是管道符，它的作用是将 <code>ps -ef</code> 命令的输出作为 <code>grep</code> 命令的输入。</p><h3 id="ps-命令的常用选项总结"><a class="markdownIt-Anchor" href="#ps-命令的常用选项总结"></a> <code>ps</code> 命令的常用选项总结</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-e</td><td>显示所有进程</td></tr><tr><td>-f</td><td>显示完整格式的列表</td></tr><tr><td>-a</td><td>显示所有进程（不包括会话引导进程）</td></tr><tr><td>-u</td><td>按用户过滤进程</td></tr><tr><td>-aux</td><td>最经典的组合，显示所有用户的详细进程信息</td></tr></tbody></table><h3 id="实际应用示例"><a class="markdownIt-Anchor" href="#实际应用示例"></a> 实际应用示例</h3><p>假设你想查看当前系统中 CPU 或内存占用最高的几个进程，<code>ps</code> 命令可以与 <code>head</code>、<code>sort</code> 等命令结合使用。</p><p><strong>查看 CPU 占用最高的 5 个进程：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-aux</span> <span class="token parameter variable">--sort</span><span class="token operator">=</span>-%cpu <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的 <code>--sort=-%cpu</code> 表示按 CPU 占用率降序排列，<code>head -n 6</code> 则取前 6 行（包括标题行）。</p><h3 id="解析-ps-aux-命令的输出"><a class="markdownIt-Anchor" href="#解析-ps-aux-命令的输出"></a> 解析 <code>ps -aux</code> 命令的输出</h3><p>当你运行 <code>ps -aux</code> 命令时，你会看到一个包含多个列的表格。每一列都提供了关于进程的重要信息。下面是对这些列的详细解释：</p><ul><li><p><strong>USER</strong>：启动该进程的用户。</p></li><li><p><strong>PID</strong>：进程的唯一标识符（<strong>P</strong>rocess <strong>ID</strong>）。当你需要杀死一个进程时，通常会用到这个 ID。</p></li><li><p><strong>%CPU</strong>：进程在最近一段时间内使用的 <strong>CPU</strong> 占用率。</p></li><li><p><strong>%MEM</strong>：进程使用的 <strong>物理内存</strong> 占用率。</p></li><li><p><strong>VSZ</strong>：进程使用的虚拟内存大小（<strong>V</strong>irtual <strong>S</strong>ize），单位为千字节（KB）。</p></li><li><p><strong>RSS</strong>：进程使用的 <strong>物理内存</strong> 大小（<strong>R</strong>esident <strong>S</strong>et <strong>S</strong>ize），单位为千字节（KB）。</p></li><li><p><strong>TTY</strong>：进程运行所在的终端。如果显示 <code>?</code>，表示该进程没有关联的终端，通常是系统进程。</p></li><li><p><strong>STAT</strong>：进程的当前状态（<strong>STAT</strong>us）。这是一个非常重要的列，常用的状态码有：</p><ul><li><p><strong>R</strong>：正在运行（<strong>R</strong>unning）或可运行（<strong>R</strong>unnable）。</p></li><li><p><strong>S</strong>：可中断的睡眠状态（<strong>S</strong>leeping）。</p></li><li><p><strong>D</strong>：不可中断的睡眠状态（<strong>D</strong>isk sleep），通常表示进程正在等待 I/O 操作。</p></li><li><p><strong>Z</strong>：僵尸进程（<strong>Z</strong>ombie），进程已终止，但其父进程还未对其进行善后处理。</p></li><li><p><strong>T</strong>：停止（<strong>S</strong>topped），进程被信号停止。</p></li><li><p><strong>&lt;</strong>：高优先级进程。</p></li><li><p><strong>N</strong>：低优先级进程。</p></li></ul></li><li><p><strong>START</strong>：进程启动的时间。</p></li><li><p><strong>TIME</strong>：进程已经消耗的 <strong>CPU 时间</strong> 总量。这与 %CPU 不同，%CPU 是瞬时值，而 TIME 是累积值。</p></li><li><p><strong>COMMAND</strong>：启动该进程的完整命令，包括所有参数。</p></li></ul><h3 id="示例解析"><a class="markdownIt-Anchor" href="#示例解析"></a> 示例解析</h3><p>假设你运行 <code>ps -aux</code> 看到以下一行输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root      <span class="token number">1234</span>  <span class="token number">0.0</span>  <span class="token number">0.1</span> <span class="token number">23456</span> <span class="token number">1234</span> ?        S    Sep01  <span class="token number">0</span>:05 /usr/sbin/sshd <span class="token parameter variable">-D</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>USER</strong>：<code>root</code> 用户。</p></li><li><p><strong>PID</strong>：进程 ID 是 <code>1234</code>。</p></li><li><p><strong>%CPU</strong>：CPU 占用率是 <code>0.0%</code>。</p></li><li><p><strong>%MEM</strong>：内存占用率是 <code>0.1%</code>。</p></li><li><p><strong>VSZ</strong>：虚拟内存大小是 <code>23456 KB</code>。</p></li><li><p><strong>RSS</strong>：物理内存大小是 <code>1234 KB</code>。</p></li><li><p><strong>TTY</strong>：<code>?</code>，表示没有关联的终端。</p></li><li><p><strong>STAT</strong>：<code>S</code>，表示进程处于可中断的睡眠状态。</p></li><li><p><strong>START</strong>：启动时间是 <code>Sep01</code>。</p></li><li><p><strong>TIME</strong>：总 CPU 时间是 <code>0:05</code>（5秒）。</p></li><li><p><strong>COMMAND</strong>：完整的命令是 <code>/usr/sbin/sshd -D</code>，这是一个 SSH 服务守护进程。</p></li></ul><p>通过这些信息，你可以快速了解一个进程是由谁运行的、它消耗了多少资源、处于什么状态，以及它是什么程序。这对于系统监控和故障排除非常有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="内核" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="进程" scheme="https://blog.godmao.top/Tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux C标准IO操作</title>
    <link href="https://blog.godmao.top/posts/45385/"/>
    <id>https://blog.godmao.top/posts/45385/</id>
    <published>2025-09-09T12:54:03.000Z</published>
    <updated>2025-09-09T12:58:06.832Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h1 id="c-标准库-io-函数基于-stdioh"><a class="markdownIt-Anchor" href="#c-标准库-io-函数基于-stdioh"></a> 📌 C 标准库 I/O 函数（基于 <code>&lt;stdio.h&gt;</code>）</h1><h2 id="1-打开和关闭文件"><a class="markdownIt-Anchor" href="#1-打开和关闭文件"></a> 1. 打开和关闭文件</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>  </span>FILE <span class="token operator">*</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">fclose</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>fopen 参数 mode 常用值：</strong></p><ul><li><p><code>&quot;r&quot;</code>：只读（文件必须存在）</p></li><li><p><code>&quot;w&quot;</code>：只写（不存在则创建，存在则清空）</p></li><li><p><code>&quot;a&quot;</code>：追加写（不存在则创建）</p></li><li><p><code>&quot;r+&quot;</code>：读写（必须存在）</p></li><li><p><code>&quot;w+&quot;</code>：读写（不存在则创建，存在则清空）</p></li><li><p><code>&quot;a+&quot;</code>：读写（追加模式）</p></li></ul></li></ul><hr /><h2 id="2-读写字符"><a class="markdownIt-Anchor" href="#2-读写字符"></a> 2. 读写字符</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 读取一个字符</span><span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 写入一个字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fputc</span><span class="token punctuation">(</span><span class="token char">'A'</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr /><h2 id="3-读写字符串"><a class="markdownIt-Anchor" href="#3-读写字符串"></a> 3. 读写字符串</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">fgets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取一行（最多 size-1 个字符） </span><span class="token keyword">int</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 写入字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">fgets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"Hello\n"</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr /><h2 id="4-格式化-io"><a class="markdownIt-Anchor" href="#4-格式化-io"></a> 4. 格式化 I/O</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fprintf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 格式化输出到文件 </span><span class="token keyword">int</span> <span class="token function">fscanf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 格式化读取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"name=%s age=%d\n"</span><span class="token punctuation">,</span> <span class="token string">"Tom"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s %d"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr /><h2 id="5-块读写适合二进制文件"><a class="markdownIt-Anchor" href="#5-块读写适合二进制文件"></a> 5. 块读写（适合二进制文件）</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">size_t</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">size_t</span> <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">fwrite</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写10个整数 </span><span class="token function">fread</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 读10个整数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr /><h2 id="6-文件定位"><a class="markdownIt-Anchor" href="#6-文件定位"></a> 6. 文件定位</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fseek</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 移动文件指针</span><span class="token keyword">long</span> <span class="token function">ftell</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 获取当前位置 </span><span class="token keyword">void</span> <span class="token function">rewind</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 回到开头`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>whence</code> 可取：</p><ul><li><p><code>SEEK_SET</code>：文件开头</p></li><li><p><code>SEEK_CUR</code>：当前位置</p></li><li><p><code>SEEK_END</code>：文件末尾</p></li></ul><hr /><h2 id="7-缓冲刷新"><a class="markdownIt-Anchor" href="#7-缓冲刷新"></a> 7. 缓冲刷新</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fflush</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 强制把缓冲区写入文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用于写日志，避免异常退出时丢数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="内核" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="IO" scheme="https://blog.godmao.top/Tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统IO编程</title>
    <link href="https://blog.godmao.top/posts/7076/"/>
    <id>https://blog.godmao.top/posts/7076/</id>
    <published>2025-09-09T05:15:16.000Z</published>
    <updated>2025-09-09T13:04:05.999Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="文件描述符内核分发的身份证"><a class="markdownIt-Anchor" href="#文件描述符内核分发的身份证"></a> 文件描述符：内核分发的身份证</h2><p>在 Linux 系统中，<strong>文件描述符（File Descriptor，简称 FD）是一个核心概念，它是一个非负整数</strong>，用于唯一标识一个已打开的文件。这个文件可以是普通文件、目录、网络套接字（socket），甚至是设备（如键盘、显示器）。</p><p>文件描述符的设计主要有以下几个优点：</p><ol><li><p><strong>简化了 I/O 接口</strong>：无论是读写本地文件，还是进行网络通信，开发者都可以使用一套统一的系统调用（<code>read</code>, <code>write</code>, <code>close</code> 等），而无需关心底层的具体类型。这种“一切皆文件”的设计哲学是 Linux 简洁和强大的体现。</p></li><li><p><strong>隔离了应用程序与内核</strong>：应用程序只知道一个简单的整数，而不需要知道文件在磁盘上的物理位置，也不用关心内核是如何管理文件的。所有复杂的操作都由内核在幕后完成。</p></li><li><p><strong>管理系统资源</strong>：内核通过文件描述符表来管理每个进程打开的文件。当一个进程结束时，内核可以根据这个表自动关闭所有打开的文件，避免资源泄露。</p></li></ol><p>文件描述符的几个重要特点：</p><ul><li><p><strong>唯一性</strong>：在一个进程中，每个打开的文件都有一个独一无二的文件描述符。</p></li><li><p><strong>非负整数</strong>：文件描述符的值通常从 3 开始分配，因为 0、1、2 这三个描述符被系统预留给标准输入、标准输出和标准错误。</p><ul><li><p><strong>0</strong>：标准输入（<code>stdin</code>），通常是键盘。</p></li><li><p><strong>1</strong>：标准输出（<code>stdout</code>），通常是显示器。</p></li><li><p><strong>2</strong>：标准错误（<code>stderr</code>），也通常是显示器。</p></li></ul></li><li><p><strong>进程私有</strong>：文件描述符是在进程内部使用的，不同进程的文件描述符互不影响。例如，进程 A 的文件描述符 3 和进程 B 的文件描述符 3 可能指向完全不同的文件。</p></li></ul><h2 id="最基础的系统调用函数"><a class="markdownIt-Anchor" href="#最基础的系统调用函数"></a> 最基础的系统调用函数</h2><p><strong>Linux I/O 编程中常见的系统调用函数</strong>，这些函数位于 <strong><code>unistd.h</code></strong>（以及 <code>fcntl.h</code> 等）中，是用户态和内核态交互的基础接口。</p><h3 id="1-open"><a class="markdownIt-Anchor" href="#1-open"></a> 1. <code>open</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span>    <span class="token comment">// open flags</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h4><p>打开或创建一个文件，返回一个 <strong>文件描述符</strong>（fd，整数），后续 I/O 都依赖它。</p><h4 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h4><ul><li><p><code>pathname</code>：文件路径。</p></li><li><p><code>flags</code>：打开方式，常用值：</p><ul><li><p><code>O_RDONLY</code>：只读</p></li><li><p><code>O_WRONLY</code>：只写</p></li><li><p><code>O_RDWR</code>：读写</p></li><li><p><code>O_CREAT</code>：若文件不存在则创建，需要配合 <code>mode</code> 参数</p></li><li><p><code>O_TRUNC</code>：打开时清空文件</p></li><li><p><code>O_APPEND</code>：写时追加到文件尾部</p></li><li><p><code>O_NOBLOCK</code>：非阻塞模式</p></li></ul></li><li><p><code>mode</code>：创建文件时的权限（如 <code>0666</code>，受 umask 影响）。</p></li></ul><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h4><ul><li><p>成功：文件描述符（非负整数）</p></li><li><p>失败：<code>-1</code>，并设置 <code>errno</code></p></li></ul><hr /><h3 id="2-write"><a class="markdownIt-Anchor" href="#2-write"></a> 2. <code>write</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2"></a> 作用</h4><p>向文件（或设备）写入数据。</p><h4 id="参数-2"><a class="markdownIt-Anchor" href="#参数-2"></a> 参数</h4><ul><li><p><code>fd</code>：文件描述符</p></li><li><p><code>buf</code>：要写入的数据缓冲区指针</p></li><li><p><code>count</code>：要写入的字节数</p></li></ul><h4 id="返回值-2"><a class="markdownIt-Anchor" href="#返回值-2"></a> 返回值</h4><ul><li><p>成功：实际写入的字节数（可能小于 <code>count</code>）</p></li><li><p>失败：<code>-1</code></p></li></ul><h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4><ul><li><p>对于普通文件，通常会写入全部数据。</p></li><li><p>对于管道、socket 等，可能分多次写入，需要循环写。</p></li></ul><hr /><h3 id="3-read"><a class="markdownIt-Anchor" href="#3-read"></a> 3. <code>read</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>  <span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="作用-3"><a class="markdownIt-Anchor" href="#作用-3"></a> 作用</h4><p>从文件（或设备）读取数据。</p><h4 id="参数-3"><a class="markdownIt-Anchor" href="#参数-3"></a> 参数</h4><ul><li><p><code>fd</code>：文件描述符</p></li><li><p><code>buf</code>：存放读出数据的缓冲区</p></li><li><p><code>count</code>：最大读取字节数</p></li></ul><h4 id="返回值-3"><a class="markdownIt-Anchor" href="#返回值-3"></a> 返回值</h4><ul><li><p>成功：实际读取的字节数</p><ul><li><code>0</code> 表示到达文件结尾 (EOF)</li></ul></li><li><p>失败：<code>-1</code></p></li></ul><h4 id="注意-2"><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h4><ul><li><p>实际读取字节数可能小于 <code>count</code>。</p></li><li><p>对于阻塞 I/O，如果没有数据，可能会挂起等待。</p></li></ul><hr /><h3 id="4-lseek"><a class="markdownIt-Anchor" href="#4-lseek"></a> 4. <code>lseek</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>  </span><span class="token class-name">off_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="作用-4"><a class="markdownIt-Anchor" href="#作用-4"></a> 作用</h4><p>移动文件读写位置（文件指针）。</p><h4 id="参数-4"><a class="markdownIt-Anchor" href="#参数-4"></a> 参数</h4><ul><li><p><code>fd</code>：文件描述符</p></li><li><p><code>offset</code>：偏移量（可正可负）</p></li><li><p><code>whence</code>：偏移起始点</p><ul><li><p><code>SEEK_SET</code>：从文件开头</p></li><li><p><code>SEEK_CUR</code>：从当前位置</p></li><li><p><code>SEEK_END</code>：从文件末尾</p></li></ul></li></ul><h4 id="返回值-4"><a class="markdownIt-Anchor" href="#返回值-4"></a> 返回值</h4><ul><li><p>成功：新的文件偏移位置</p></li><li><p>失败：<code>-1</code></p></li></ul><h4 id="注意-3"><a class="markdownIt-Anchor" href="#注意-3"></a> 注意</h4><ul><li><p>常用来实现随机读写。</p></li><li><p>对某些设备文件可能不支持（如管道）。</p></li></ul><hr /><h3 id="5-close"><a class="markdownIt-Anchor" href="#5-close"></a> 5. <code>close</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="作用-5"><a class="markdownIt-Anchor" href="#作用-5"></a> 作用</h4><p>关闭一个打开的文件描述符，释放内核资源。</p><h4 id="参数-5"><a class="markdownIt-Anchor" href="#参数-5"></a> 参数</h4><ul><li><code>fd</code>：文件描述符</li></ul><h4 id="返回值-5"><a class="markdownIt-Anchor" href="#返回值-5"></a> 返回值</h4><ul><li><p>成功：<code>0</code></p></li><li><p>失败：<code>-1</code></p></li></ul><h2 id="常见函数查找表"><a class="markdownIt-Anchor" href="#常见函数查找表"></a> 常见函数查找表</h2><table><thead><tr><th>函数</th><th>头文件</th><th>功能</th><th>主要参数</th><th>返回值</th><th>常见用途</th></tr></thead><tbody><tr><td><code>open</code></td><td><code>&lt;fcntl.h&gt;</code>, <code>&lt;unistd.h&gt;</code></td><td>打开或创建文件，返回文件描述符</td><td><code>pathname</code>：路径<code>flags</code>：打开方式（如 <code>O_RDONLY</code>）<code>mode</code>：权限（如 <code>0644</code>，仅在 <code>O_CREAT</code> 时有效）</td><td>成功：文件描述符 (≥0)失败：<code>-1</code></td><td>打开文件/设备，获得 <code>fd</code></td></tr><tr><td><code>write</code></td><td><code>&lt;unistd.h&gt;</code></td><td>向文件写入数据</td><td><code>fd</code>：文件描述符<code>buf</code>：数据缓冲区<code>count</code>：要写入字节数</td><td>成功：实际写入字节数失败：<code>-1</code></td><td>向文件、管道、socket 写数据</td></tr><tr><td><code>read</code></td><td><code>&lt;unistd.h&gt;</code></td><td>从文件读取数据</td><td><code>fd</code>：文件描述符<code>buf</code>：存放数据的缓冲区<code>count</code>：最大读取字节数</td><td>成功：实际读取字节数<code>0</code>：文件结尾失败：<code>-1</code></td><td>读取文件、键盘输入、网络数据</td></tr><tr><td><code>lseek</code></td><td><code>&lt;unistd.h&gt;</code></td><td>改变文件读写位置（文件指针）</td><td><code>fd</code>：文件描述符<code>offset</code>：偏移量<code>whence</code>：参考位置（<code>SEEK_SET</code>/<code>SEEK_CUR</code>/<code>SEEK_END</code>）</td><td>成功：新的偏移位置失败：<code>-1</code></td><td>随机读写文件、获取文件大小</td></tr><tr><td><code>close</code></td><td><code>&lt;unistd.h&gt;</code></td><td>关闭文件描述符，释放资源</td><td><code>fd</code>：文件描述符</td><td>成功：<code>0</code>失败：<code>-1</code></td><td>程序结束或文件不再使用时关闭</td></tr><tr><td><code>sync</code></td><td><code>&lt;unistd.h&gt;</code></td><td>将内核缓冲区中所有修改过的数据（脏页）写入磁盘</td><td>无</td><td>无返回值</td><td>全局刷新，影响所有文件，效率较低</td></tr><tr><td><code>fsync</code></td><td><code>&lt;unistd.h&gt;</code></td><td>将指定文件的缓存数据强制写入磁盘</td><td><code>fd</code>：文件描述符</td><td>成功：<code>0</code>，失败：<code>-1</code></td><td>精确到单个文件，常用于数据库、日志写入</td></tr><tr><td><code>pipe</code></td><td><code>&lt;unistd.h&gt;</code></td><td>创建匿名管道，用于进程间通信</td><td><code>int pipefd[2]</code></td><td>成功：0，失败：-1</td><td><code>pipefd[0]</code> 读端，<code>pipefd[1]</code> 写端</td></tr><tr><td><code>unlink</code></td><td><code>&lt;unistd.h&gt;</code></td><td>删除一个文件（目录用 <code>rmdir</code>）</td><td><code>pathname</code>：文件路径</td><td>成功：0，失败：-1</td><td>实际删除在引用计数归零时发生</td></tr><tr><td><code>access</code></td><td><code>&lt;unistd.h&gt;</code></td><td>检查文件是否存在及权限</td><td><code>pathname, mode</code></td><td>成功：0，失败：-1</td><td><code>mode</code> 可取 <code>R_OK, W_OK, X_OK, F_OK</code></td></tr></tbody></table><h2 id="对比c-标准库io操作"><a class="markdownIt-Anchor" href="#对比c-标准库io操作"></a> 对比C 标准库IO操作</h2><p>使用c标准库的IO操作，小量频繁读写的效率更高，因为其内部自带有缓冲区。<br />这可以理解为在系统IO上有封装了一层，进行文件操作时写入C自带缓冲区，满足一定条件再调用系统IO，将缓冲区的内容写入IO缓存区，再到内核的页缓存区，最后到物理的磁盘。</p><table><thead><tr><th>特性</th><th>Linux 系统调用 I/O</th><th>C 标准库文件操作</th></tr></thead><tbody><tr><td><strong>头文件</strong></td><td><code>&lt;unistd.h&gt;</code>, <code>&lt;fcntl.h&gt;</code></td><td><code>&lt;stdio.h&gt;</code></td></tr><tr><td><strong>函数示例</strong></td><td><code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code>, <code>close</code></td><td><code>fopen</code>, <code>fread</code>, <code>fwrite</code>, <code>fseek</code>, <code>fclose</code>, <code>fprintf</code>, <code>fscanf</code></td></tr><tr><td><strong>返回值</strong></td><td>直接返回字节数、文件描述符等，或 <code>-1</code></td><td>返回 <code>FILE*</code> 指针，或 <code>EOF</code> 等错误码</td></tr><tr><td><strong>数据单位</strong></td><td>以 <strong>字节（byte）</strong> 为单位</td><td>以 <strong>缓冲区 / 结构化数据</strong> 为单位（有缓冲机制）</td></tr><tr><td><strong>缓冲</strong></td><td><strong>无用户态缓冲</strong>，直接在用户空间和内核空间间传递数据</td><td><strong>带缓冲区</strong>（stdio 库内部维护缓存，加速小块读写）</td></tr><tr><td><strong>层次</strong></td><td>操作系统内核提供的 <strong>底层接口</strong></td><td>基于系统调用的 <strong>封装库函数</strong></td></tr><tr><td><strong>灵活性</strong></td><td>可操作普通文件、设备文件、socket、管道</td><td>主要操作普通文件和标准输入输出</td></tr><tr><td><strong>可移植性</strong></td><td>偏向 Unix/Linux 系统</td><td>跨平台（符合 ANSI C 标准，Windows/Linux 通用）</td></tr><tr><td><strong>典型用途</strong></td><td>驱动开发、系统编程、精确控制 I/O</td><td>应用层文件读写、文本处理、快速开发</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="内核" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="IO" scheme="https://blog.godmao.top/Tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>MakeFile简明指南</title>
    <link href="https://blog.godmao.top/posts/4341/"/>
    <id>https://blog.godmao.top/posts/4341/</id>
    <published>2025-09-07T13:48:09.000Z</published>
    <updated>2025-09-17T13:36:34.997Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><p>在软件开发中，项目通常包含很多源文件，如果每次编译都手动敲命令，不仅繁琐，还容易出错。<br /><strong>Makefile</strong> 可以帮助我们自动化构建流程，大幅提升效率。本文将介绍 Makefile 的基础语法与常用用法。</p><hr /><ul><li><a href="#1-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">1. 基础用法</a></li><li><a href="#2-%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%911">2. 执行逻辑^1</a><ul><li><a href="#21--%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE">2.1. 🔄 执行流程示意图</a></li></ul></li><li><a href="#3-%E4%BC%AA%E7%9B%AE%E6%A0%87-phony">3. 伪目标 .PHONY</a></li><li><a href="#4-%E5%8F%98%E9%87%8F">4. 变量</a><ul><li><a href="#41-%E8%B5%8B%E5%80%BC%E7%AC%A6%E5%8F%B7">4.1. 赋值符号</a></li></ul></li><li><a href="#5-%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6">5. 隐含规则与通配符</a></li><li><a href="#6-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF">6. 条件分支</a><ul><li><a href="#61-%E8%AF%AD%E6%B3%95">6.1. 语法</a></li><li><a href="#62-%E7%A4%BA%E4%BE%8B%E4%B8%80%E6%A0%B9%E6%8D%AE%E5%B9%B3%E5%8F%B0%E9%80%89%E6%8B%A9clean%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F">6.2. 示例一：根据平台选择clean执行方式</a></li><li><a href="#63-%E7%A4%BA%E4%BE%8B%E4%BA%8C%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F">6.3. 示例二：调试模式与发布模式</a></li></ul></li><li><a href="#7-%E5%87%BD%E6%95%B0">7. 函数</a><ul><li><a href="#71-subst--%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2">7.1. <code>subst</code> —— 字符串替换</a></li><li><a href="#72-patsubst--%E6%A8%A1%E5%BC%8F%E6%9B%BF%E6%8D%A2">7.2. <code>patsubst</code> —— 模式替换</a></li><li><a href="#73-wildcard--%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8">7.3. <code>wildcard</code> —— 获取文件列表</a></li><li><a href="#74-notdir--%E5%8E%BB%E6%8E%89%E8%B7%AF%E5%BE%84%E5%8F%AA%E4%BF%9D%E7%95%99%E6%96%87%E4%BB%B6%E5%90%8D">7.4. <code>notdir</code> —— 去掉路径，只保留文件名</a></li><li><a href="#75-dir--%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E9%83%A8%E5%88%86">7.5. <code>dir</code> —— 获取路径部分</a></li><li><a href="#76-basename--addsuffix-%E5%92%8C-addprefix--%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E5%90%8D">7.6. <code>basename</code> 、 <code>addsuffix</code> 和 <code>addprefix</code> —— 批量处理文件名</a></li><li><a href="#77-shell--%E6%89%A7%E8%A1%8C-shell-%E5%91%BD%E4%BB%A4">7.7. <code>shell</code> —— 执行 shell 命令</a></li></ul></li><li><a href="#8-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F">8. 完整示例程序</a></li></ul><h2 id="1-基础用法"><a class="markdownIt-Anchor" href="#1-基础用法"></a> 1. 基础用法</h2><p>一个典型的规则格式如下：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">target: dependencies&lt;TAB&gt; command<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>target：目标文件，比如可执行文件或中间文件。</li><li>dependencies：依赖文件（源文件、头文件等）。</li><li>command：生成目标所需要执行的命令（必须以 TAB 缩进 开头）。</li></ul><p>示例：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">main.o: main.cgcc -c main.c -o main.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="admonition warning"><p class="admonition-title">warning</p><p>由于makfile对空格、tab极其敏感，建议编写时打开编辑器的空格、tab显示，并避免不必要的空格，规范化书写。</p></div><h2 id="2-执行逻辑"><a class="markdownIt-Anchor" href="#2-执行逻辑"></a> 2. 执行逻辑<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2><p>当我们执行 <code>make</code> 时，大致流程如下：</p><ol><li><p><strong>解析 Makefile</strong></p><ul><li><code>make</code> 会从当前目录寻找 <code>Makefile</code> 或 <code>makefile</code> 文件。</li><li>读取其中的规则、变量、伪目标等定义。</li></ul></li><li><p><strong>确定默认目标</strong></p><ul><li>一般是文件中的第一个目标（例如 <code>app</code>）。</li><li>也可以通过命令行指定，例如：</li></ul></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li><p><strong>检查依赖关系</strong></p><ul><li>从目标开始，逐层检查依赖文件是否存在、是否比目标文件更新。</li><li>如果依赖文件比目标文件“新”，说明目标需要重新生成。</li></ul></li><li><p><strong>执行命令</strong></p><ul><li>对需要更新的目标，执行其规则中定义的命令。</li><li>命令必须以 <strong>TAB 缩进</strong> 开头。</li></ul></li><li><p><strong>递归构建</strong></p><ul><li>如果依赖文件本身也是其他规则的目标，则会递归检查和执行。</li><li>直到所有依赖满足，才最终生成目标。</li></ul></li><li><p><strong>结束</strong></p><ul><li>如果所有目标都已是最新，则 <code>make</code> 会提示：</li></ul></li></ol><pre class="line-numbers language-none"><code class="language-none">make: &#39;app&#39; is up to date.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="21-执行流程示意图"><a class="markdownIt-Anchor" href="#21-执行流程示意图"></a> 2.1. 🔄 执行流程示意图</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">          make           │           ▼   读取并解析 Makefile           │           ▼   确定要构建的目标 (默认/指定)           │           ▼   检查目标的依赖文件           │    ┌──────┴────────┐    │               │依赖比目标旧      依赖比目标新/不存在    │               │目标已是最新    执行规则命令 → 生成新目标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="admonition info"><p class="admonition-title">tips</p><p>可以使用 make -f [makefile_name] 指定使用某个makefile文件。</p></div><h2 id="3-伪目标-phony"><a class="markdownIt-Anchor" href="#3-伪目标-phony"></a> 3. 伪目标 .PHONY</h2><p>有些目标不是实际文件，而只是一个操作，例如 <code>clean</code>。<br />这时建议使用 <strong>.PHONY</strong> 声明：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">.PHONY: clean  clean:  rm -r  [filepath]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>指定make目标文件：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">make clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-变量"><a class="markdownIt-Anchor" href="#4-变量"></a> 4. 变量</h2><p>Makefile 支持变量，常用于保存编译器或编译选项。<br />使用示例如下：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">CC &#x3D; gccCFLAGS &#x3D; -Wall -gapp: main.o utils.o$(CC) $(CFLAGS) main.o utils.o -o appmain.o: main.c$(CC) $(CFLAGS) -c main.c -o main.outils.o: utils.c$(CC) $(CFLAGS) -c utils.c -o utils.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="41-赋值符号"><a class="markdownIt-Anchor" href="#41-赋值符号"></a> 4.1. 赋值符号</h3><ul><li><strong>=</strong><br />我称之为最终赋值，同一个变量无论被赋值多次，永远取最后指定的值。<br />示例：</li></ul><pre class="line-numbers language-make" data-language="make"><code class="language-make">VIR_A &#x3D; AVIR_B &#x3D; $(VIR_A) BVIR_A &#x3D; AA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后VIR_B的值是AA B。</p><ul><li><strong>:=</strong><br />立即赋值，正常逻辑的赋值号，类似于c语言的赋值号。</li><li><strong>?=</strong><br />如果变量在之前没有被赋值则赋值。<br />可以理解为  <pre class="line-numbers language-none"><code class="language-none">#ifndef#define ...#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><strong>+=</strong><br />追加赋值，将值追加到变量中。</li></ul><h2 id="5-隐含规则与通配符"><a class="markdownIt-Anchor" href="#5-隐含规则与通配符"></a> 5. 隐含规则与通配符</h2><p>Make 内置了一些规则，可以用简写方式：</p><ul><li><code>$@</code>：目标文件名</li><li><code>$&lt;</code>：第一个依赖文件</li><li><code>$^</code>：所有依赖文件</li></ul><p><code>%</code> 表示可以匹配任意长度的字符串，用于定义一类文件的生成规则。例如：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">%.o: %.c     gcc -c $&lt; -o $@<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>含义：<ul><li><code>%.o</code> 表示所有以 <code>.o</code> 结尾的目标文件。</li><li><code>%.c</code> 表示所有以 <code>.c</code> 结尾的源文件。</li><li><code>$&lt;</code> 是第一个依赖文件（这里是 <code>.c</code> 文件）。</li><li><code>$@</code> 是目标文件（这里是 <code>.o</code> 文件）。</li></ul></li><li>作用：这条规则表示，所有 <code>.c</code> 文件可以通过编译生成对应的 <code>.o</code> 文件。</li></ul><hr /><p><code>%</code> 可以匹配文件名的某一部分，用于简化规则。例如：</p><pre class="line-numbers language-none"><code class="language-none">build&#x2F;%: src&#x2F;%     cp $&lt; $@<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>含义：<ul><li><code>build/%</code> 表示目标文件在 <code>build/</code> 目录下。</li><li><code>src/%</code> 表示依赖文件在 <code>src/</code> 目录下。</li><li><code>$&lt;</code> 是依赖文件，<code>$@</code> 是目标文件。</li></ul></li><li>作用：这条规则表示，将 <code>src/</code> 目录下的文件复制到 <code>build/</code> 目录下。</li></ul><hr /><p>在模式规则中，<code>%</code> 可以用于定义多个目标。例如：</p><pre class="line-numbers language-none"><code class="language-none">%.a: %.b %.c     cat $^ &gt; $@&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>含义：<ul><li><code>%.a</code> 是目标文件。</li><li><code>%.b</code> 和 <code>%.c</code> 是依赖文件。</li><li><code>$^</code> 表示所有依赖文件，<code>$@</code> 是目标文件。</li></ul></li><li>作用：这条规则表示，将 <code>.b</code> 和 <code>.c</code> 文件合并生成 <code>.a</code> 文件。</li></ul><hr /><h2 id="6-条件分支"><a class="markdownIt-Anchor" href="#6-条件分支"></a> 6. 条件分支</h2><p>在 Makefile 中，我们可以使用条件语句来根据不同情况执行不同规则或定义变量。常见的有 <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code>。</p><h3 id="61-语法"><a class="markdownIt-Anchor" href="#61-语法"></a> 6.1. 语法</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">ifeq (条件1, 条件2)    # 当 条件1 &#x3D;&#x3D; 条件2 时执行这里else    # 否则执行这里endififneq (条件1, 条件2)    # 当 条件1 !&#x3D; 条件2 时执行这里endififdef 变量名    # 当变量已定义时执行这里endififndef 变量名    # 当变量未定义时执行这里endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="62-示例一根据平台选择clean执行方式"><a class="markdownIt-Anchor" href="#62-示例一根据平台选择clean执行方式"></a> 6.2. 示例一：根据平台选择clean执行方式</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make"># 默认变量CC &#x3D; gcc# 判断系统ifeq ($(OS), Windows_NT)    RM &#x3D; delelse    RM &#x3D; rm -fendifapp: main.o$(CC) main.o -o appclean:$(RM) *.o app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="63-示例二调试模式与发布模式"><a class="markdownIt-Anchor" href="#63-示例二调试模式与发布模式"></a> 6.3. 示例二：调试模式与发布模式</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make"># 设置编译选项CFLAGS &#x3D; -Wallifeq ($(MODE), debug)    CFLAGS +&#x3D; -gelse    CFLAGS +&#x3D; -O2endifapp: main.o$(CC) $(CFLAGS) main.o -o app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用方式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">MODE</span><span class="token operator">=</span>debug   <span class="token comment"># 调试模式，带调试信息</span><span class="token function">make</span> <span class="token assign-left variable">MODE</span><span class="token operator">=</span>release <span class="token comment"># 默认优化模式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="7-函数"><a class="markdownIt-Anchor" href="#7-函数"></a> 7. 函数</h2><p>Makefile 内置了许多函数，用来处理字符串、文件名、路径等。<br />常见函数格式为：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">$(函数名 参数1 参数2 ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面介绍一些<strong>常用函数</strong></p><h3 id="71-subst-字符串替换"><a class="markdownIt-Anchor" href="#71-subst-字符串替换"></a> 7.1. <code>subst</code> —— 字符串替换</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">$(subst from,to,text)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>功能：将 <code>text</code> 中的 <code>from</code> 替换为 <code>to</code>。</p></li><li><p>示例：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">SRC &#x3D; main.c utils.c OBJ &#x3D; $(subst .c,.o,$(SRC)) # 结果：OBJ &#x3D; main.o utils.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr /><h3 id="72-patsubst-模式替换"><a class="markdownIt-Anchor" href="#72-patsubst-模式替换"></a> 7.2. <code>patsubst</code> —— 模式替换</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">$(patsubst pattern,replacement,text)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>功能：更灵活的字符串替换，支持通配符 <code>%</code>。</p></li><li><p>示例：</p></li></ul><pre class="line-numbers language-make" data-language="make"><code class="language-make">SRC &#x3D; main.c utils.c test.cOBJ &#x3D; $(patsubst %.c,%.o,$(SRC))# 结果：OBJ &#x3D; main.o utils.o test.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr /><h3 id="73-wildcard-获取文件列表"><a class="markdownIt-Anchor" href="#73-wildcard-获取文件列表"></a> 7.3. <code>wildcard</code> —— 获取文件列表</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">$(wildcard pattern)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>功能：匹配符合模式的文件。</p></li><li><p>示例：</p></li></ul><pre class="line-numbers language-make" data-language="make"><code class="language-make">SRC &#x3D; $(wildcard *.c)# 结果：SRC &#x3D; 当前目录下所有 .c 文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr /><h3 id="74-notdir-去掉路径只保留文件名"><a class="markdownIt-Anchor" href="#74-notdir-去掉路径只保留文件名"></a> 7.4. <code>notdir</code> —— 去掉路径，只保留文件名</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">FILES &#x3D; src&#x2F;main.c src&#x2F;utils.cNAMES &#x3D; $(notdir $(FILES))# 结果：NAMES &#x3D; main.c utils.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr /><h3 id="75-dir-获取路径部分"><a class="markdownIt-Anchor" href="#75-dir-获取路径部分"></a> 7.5. <code>dir</code> —— 获取路径部分</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">FILES &#x3D; src&#x2F;main.c src&#x2F;utils.cPATHS &#x3D; $(dir $(FILES))# 结果：PATHS &#x3D; src&#x2F; src&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr /><h3 id="76-basename-addsuffix-和-addprefix-批量处理文件名"><a class="markdownIt-Anchor" href="#76-basename-addsuffix-和-addprefix-批量处理文件名"></a> 7.6. <code>basename</code> 、 <code>addsuffix</code> 和 <code>addprefix</code> —— 批量处理文件名</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">FILES &#x3D; main.c utils.c# 去掉后缀NAMES &#x3D; $(basename $(FILES))# NAMES &#x3D; main utils# 批量添加后缀OBJS &#x3D; $(addsuffix .o,$(NAMES))# OBJS &#x3D; main.o utils.o# 批量添加前缀OBJS &#x3D; $(addprefix -I,$(NAMES))# OBJS &#x3D; -Imain -Iutils<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr /><h3 id="77-shell-执行-shell-命令"><a class="markdownIt-Anchor" href="#77-shell-执行-shell-命令"></a> 7.7. <code>shell</code> —— 执行 shell 命令</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">DATE &#x3D; $(shell date +%Y-%m-%d)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样可以在 Makefile 中直接使用系统命令的输出。</p><h2 id="8-完整示例程序"><a class="markdownIt-Anchor" href="#8-完整示例程序"></a> 8. 完整示例程序</h2><p>这是一个完整Makefile示例程序，用于将c语言程序编译为可执行的二进制bin文件。它可以制成镜像供SoC烧录。</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">#0############################################################ 设置目录变量，方便统一管理和修改# 当前根目录:ROOT_DIR :&#x3D; .# 中间目标文件（.o）输出目录:BUILD_DIR :&#x3D; build# 最终生成的二进制文件（.bin）目录:BIN_DIR :&#x3D; bin# 工程名NAME :&#x3D; key# 指定链接脚本LDS &#x3D; imx.lds##############################################################1############################################################ 自动查找 src&#x2F; 目录下的所有 .c 文件SRCS &#x3D; $(shell find $(ROOT_DIR) -name &quot;*.c&quot;)# 将 SRC中的 xxx.c 转换为 build&#x2F;xxx.o# 同时添加 build&#x2F;startup.o（汇编启动文件）OBJS &#x3D; $(BUILD_DIR)&#x2F;startup.oOBJS +&#x3D; $(patsubst %.c,$(BUILD_DIR)&#x2F;%.o,$(SRCS))# 自动查找所有包含头文件的目录INC_DIRS &#x3D; $(shell find $(ROOT_DIR) -type f -name &quot;*.h&quot; -exec dirname &#123;&#125; \; | sort -u)INCLUDES &#x3D; $(addprefix -I, $(INC_DIRS))##############################################################2############################################################ 设置编译工具（使用 ARM 的交叉编译工具链）CC :&#x3D; arm-none-eabi-# 编译器（用于 .c 和 .S 文件）:GCC :&#x3D; $(CC)gcc# 链接器:LD :&#x3D; $(CC)ld# 用于将 elf 转为 bin 格式:OBJCOPY :&#x3D; $(CC)objcopy# 用于反汇编OBJDUMP :&#x3D; $(CC)objdump# 编译选项（GCC 编译阶段）# -I：指定头文件搜索目录# -Wall：打开所有警告# -O2：优化等级 2（推荐用于 release）# -nostdlib：不链接标准库（适用于裸机）# -c：只编译，不链接GCC_FLAGS &#x3D; $(INCLUDES) -Wall -nostdlib -c# 链接器选项LD_FLAGS &#x3D; -T$(LDS)# 使用 objdump 工具对生成的 ELF 文件进行反汇编# -D：反汇编所有节（包括代码段、启动代码等）# -m arm：指定目标架构为 ARM# .elf：输入的可执行文件# &gt; .dis：将反汇编结果输出为 .dis 文本文件OBJDUMP_FLAGS &#x3D; -D -m arm $(BUILD_DIR)&#x2F;$(NAME).elf &gt; $(BUILD_DIR)&#x2F;$(NAME).dis##############################################################3############################################################ 目标：生成最终的二进制文件 bin&#x2F;$(NAME).bin$(BIN_DIR)&#x2F;$(NAME).bin: $(OBJS)# 链接所有 .o 文件生成 elf 格式可执行文件    $(LD) $(LD_FLAGS) $(OBJS) -o $(BUILD_DIR)&#x2F;$(NAME).elf# 反汇编 调试用    $(OBJDUMP) $(OBJDUMP_FLAGS)# 把 elf 文件转换为裸机二进制文件（无符号、无头信息）    $(OBJCOPY) -O binary -S $(BUILD_DIR)&#x2F;$(NAME).elf $@ # 编译汇编启动文件 startup.S，生成 build&#x2F;startup.o$(BUILD_DIR)&#x2F;startup.o: startup.S# 注意 startup.S 是汇编文件，用 gcc 编译也可以，默认会调用汇编器    $(GCC) $(GCC_FLAGS) $&lt; -o $@# 编译每个 .c 文件到 build&#x2F;xxx.o# $@：目标文件（例如 build&#x2F;main.o）# $&lt;：依赖的源文件（例如 src&#x2F;main.c）$(BUILD_DIR)&#x2F;%.o: %.c# 修复由于没有文件夹报错    mkdir -p $(dir $@)    $(GCC) $(GCC_FLAGS) -c $&lt; -o $@#############################################################.PHONY: cleanclean:    rm -r $(BUILD_DIR)&#x2F;* $(BIN_DIR)&#x2F;*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个更通用的模板</p><pre class="line-numbers language-make" data-language="make"><code class="language-make"># 通用 Makefile 模板# 1. 编译器及选项CC      :&#x3D; gcc             # C 编译器 (可改成 g++)CFLAGS  :&#x3D; -Wall -O2       # 编译参数LDFLAGS :&#x3D;                 # 链接参数 (库路径)LDLIBS  :&#x3D; -lm             # 依赖的库 (-lpthread, -lrt 等)# 2. 目录结构SRC_DIR :&#x3D; src             # 源码目录OBJ_DIR :&#x3D; build           # 目标文件目录BIN_DIR :&#x3D; bin             # 可执行文件目录# 3. 自动收集源文件SRCS :&#x3D; $(wildcard $(SRC_DIR)&#x2F;*.c)OBJS :&#x3D; $(patsubst $(SRC_DIR)&#x2F;%.c,$(OBJ_DIR)&#x2F;%.o,$(SRCS))TARGET :&#x3D; $(BIN_DIR)&#x2F;app   # 生成的可执行文件名# 4. 默认目标all: $(TARGET)# 5. 链接规则$(TARGET): $(OBJS) | $(BIN_DIR)$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)# 6. 编译规则$(OBJ_DIR)&#x2F;%.o: $(SRC_DIR)&#x2F;%.c | $(OBJ_DIR)$(CC) $(CFLAGS) -c $&lt; -o $@# 7. 目录生成$(OBJ_DIR) $(BIN_DIR):mkdir -p $@# 8. 清理.PHONY: clean runclean:rm -rf $(OBJ_DIR) $(BIN_DIR)# 9. 运行 (可选)run: all.&#x2F;$(TARGET)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>仅作了解 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="项目管理" scheme="https://blog.godmao.top/categories/Linux/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="MakeFile" scheme="https://blog.godmao.top/Tags/MakeFile/"/>
    
  </entry>
  
  <entry>
    <title>交叉编译器相关知识梳理</title>
    <link href="https://blog.godmao.top/posts/27939/"/>
    <id>https://blog.godmao.top/posts/27939/</id>
    <published>2025-09-07T09:18:55.000Z</published>
    <updated>2025-09-07T10:45:40.598Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于Linux开发板与上位机的连接方式</title>
    <link href="https://blog.godmao.top/posts/32814/"/>
    <id>https://blog.godmao.top/posts/32814/</id>
    <published>2025-09-07T09:17:17.000Z</published>
    <updated>2025-09-27T06:57:34.278Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><div class="admonition info"><p class="admonition-title">info</p><p>本文旨在记录自己的IMX6ULL开发板上位机连接的过程。~~为什么感觉是后端这一块呢？~~</p></div><h2 id="1-前提条件"><a class="markdownIt-Anchor" href="#1-前提条件"></a> 1. 前提条件</h2><div class="admonition note"><p class="admonition-title">设备</p><p>装有Debian/Ubuntu系统的、安装了ssh服务的、带有网络设备及驱动的开发板</p></div><div class="admonition note"><p class="admonition-title">工具</p><p>MobaXterm工具</p></div><div class="admonition todo"><p class="admonition-title">todo</p><p>目前使用的上位机是Win11平台，后续再研究Linux平台。</p></div><h2 id="2-基本操作"><a class="markdownIt-Anchor" href="#2-基本操作"></a> 2. 基本操作</h2><h3 id="21-查询设备网络连接状态及ip地址"><a class="markdownIt-Anchor" href="#21-查询设备网络连接状态及ip地址"></a> 2.1. 查询设备网络连接状态及ip地址</h3><p><code>ifconfig</code> 命令</p><h3 id="22-连接测试"><a class="markdownIt-Anchor" href="#22-连接测试"></a> 2.2. 连接测试</h3><p><code>ping</code> 命令</p><h3 id="23-动态分配ip主动申请ip地址"><a class="markdownIt-Anchor" href="#23-动态分配ip主动申请ip地址"></a> 2.3. 动态分配ip/主动申请ip地址</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">udhcpc <span class="token parameter variable">-i</span> eth0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><code>udhcpc</code></strong></p><ul><li>全称是 <em>Micro DHCP Client</em>，是 BusyBox 提供的一个轻量级 DHCP 客户端工具。</li><li>它会向局域网里的 DHCP 服务器（比如路由器、主机上的 Internet Connection Sharing 服务）发送请求，请求一个 IP 地址。</li></ul><p><strong><code>-i eth0</code></strong></p><ul><li>指定要使用的网络接口，这里是 <code>eth0</code>（开发板上的以太网网卡）。</li><li>如果你用的是其他网卡（比如 <code>eth1</code> 或 <code>enp0s3</code>），需要改成对应名字。</li></ul><p>成功的话，它会显示类似：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">udhcpc: sending discoverudhcpc: sending <span class="token keyword">select</span> <span class="token keyword">for</span> <span class="token number">192.168</span>.137.2udhcpc: lease of <span class="token number">192.168</span>.137.2 obtained, lease <span class="token function">time</span> <span class="token number">86400</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这表示网卡已经从 DHCP 服务器那里拿到了 IP（这里是 <code>192.168.137.2</code>）。如果没有 DHCP 服务器响应，就会一直 <code>sending discover</code>，说明没有可分配 IP。</p><h3 id="24-手动设置设备ip地址"><a class="markdownIt-Anchor" href="#24-手动设置设备ip地址"></a> 2.4. 手动设置设备ip地址</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ifconfig</span> eth0 <span class="token number">192.168</span>.10.2 netmask <span class="token number">255.255</span>.255.0 up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>up</code> 指启用</p><h3 id="25-查询ssh是否开启"><a class="markdownIt-Anchor" href="#25-查询ssh是否开启"></a> 2.5. 查询ssh是否开启</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl status <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="26-开启ssh服务"><a class="markdownIt-Anchor" href="#26-开启ssh服务"></a> 2.6. 开启ssh服务</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/etc/init.d/ssh start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="27-ssh远程连接"><a class="markdownIt-Anchor" href="#27-ssh远程连接"></a> 2.7. ssh远程连接</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token punctuation">[</span>username<span class="token punctuation">]</span>@<span class="token punctuation">[</span>ip-addr/hostname<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="28-通过mobaxterm连接"><a class="markdownIt-Anchor" href="#28-通过mobaxterm连接"></a> 2.8. 通过MobaXterm连接</h3><p>填好即可。<br /><img src="Snipaste_2025-09-07_19-20-07.png" alt="" /></p><p><code>hostname</code> 可以输入同名指令查看。</p><h2 id="3-方式一无线网络连接"><a class="markdownIt-Anchor" href="#3-方式一无线网络连接"></a> 3. 方式一：无线网络连接</h2><div class="admonition note"><p class="admonition-title">优点</p><p>无线通信。</p></div><div class="admonition error"><p class="admonition-title">缺点</p><p>延迟可能较高。</p></div><h3 id="31-同一网络下"><a class="markdownIt-Anchor" href="#31-同一网络下"></a> 3.1. 同一网络下</h3><p>在同一网段下（连接同一个WIFI），通过ssh建立连接。简简单单。</p><h3 id="32-不同网络下"><a class="markdownIt-Anchor" href="#32-不同网络下"></a> 3.2. 不同网络下</h3><div class="admonition todo"><p class="admonition-title">todo</p><p>待补充。</p></div><h2 id="4-方式二通过网线与win电脑连接"><a class="markdownIt-Anchor" href="#4-方式二通过网线与win电脑连接"></a> 4. 方式二：通过网线与Win电脑连接</h2><div class="admonition note"><p class="admonition-title">优点</p><p>延迟低。</p></div><div class="admonition error"><p class="admonition-title">缺点</p><p>有线通信。</p></div><h3 id="41-点对点通信无需共享电脑网络"><a class="markdownIt-Anchor" href="#41-点对点通信无需共享电脑网络"></a> 4.1. 点对点通信（无需共享电脑网络）</h3><div class="admonition note"><p class="admonition-title">优点</p><p>操作简单。</p></div><div class="admonition error"><p class="admonition-title">缺点</p><p>开发板不能共享电脑网络。</p></div><p>将开发板网口和电脑网口用网线连接，进入电脑<code>网络和Internet</code>设置，选择<code>以太网</code></p><p>ip分配改为手动，ip地址可以分配为<code>192.168.10.1</code><br />掩码为<code>255.255.255.0</code><br /><img src="Snipaste_2025-09-07_19-29-57.png" alt="" /></p><p>开发板端同样指定ip地址和掩码，须在同一网段，例如<code>192.168.10.7</code> 。这样两个设备就能互相找到了。<br />再在电脑上进行ping测试。能ping通用ssh/MobaXterm连接即可。</p><h3 id="42-点对点通信并共享电脑网络电脑成网关"><a class="markdownIt-Anchor" href="#42-点对点通信并共享电脑网络电脑成网关"></a> 4.2. 点对点通信并共享电脑网络（电脑成网关）</h3><div class="admonition note"><p class="admonition-title">优点</p><p>开发板不仅可以与电脑建立通信，还能共享电脑网络。</p></div><div class="admonition error"><p class="admonition-title">缺点</p><p>操作较复杂。</p></div><p>电脑通过wifi连接网络，通过以太网接口连接开发板。<br />在电脑控制面板&gt;网络和Internet&gt;网络和共享中心 右侧更改适配器设置，双击无线网卡设备（连接网络的那个设备）选择属性&gt; 共享选项卡 勾选<br /><img src="Snipaste_2025-09-07_19-41-42.png" alt="" /></p><p>提示：<br /><img src="Snipaste_2025-09-07_19-41-53.png" alt="" /></p><p>意思是：当该功能被启用时，你的LAN口 ip地址 自动被设置为 <code>192.168.137.1</code>，要通过这个LAN口连接网络的设备需将自己ip地址设置为动态获取，也就是在开发板执行前面的动态获取ip地址的命令。</p><p>当开发版成功获取到ip地址（见基本操作节 分配ip地址）后，则可以正常建立连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="网络" scheme="https://blog.godmao.top/Tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="通信" scheme="https://blog.godmao.top/Tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>无聊随便打点字</title>
    <link href="https://blog.godmao.top/posts/7593/"/>
    <id>https://blog.godmao.top/posts/7593/</id>
    <published>2025-08-25T07:16:07.000Z</published>
    <updated>2025-09-12T11:32:30.195Z</updated>
    
    <content type="html"><![CDATA[<hr /><h1 id="和时间赛跑-林清玄"><a class="markdownIt-Anchor" href="#和时间赛跑-林清玄"></a> 和时间赛跑 林清玄</h1><p>读小学的时候，我的外祖母去世了。外祖母生前最疼爱我。我无法排除自己的忧伤，每天在学校的操场上一圈一圈地跑着，跑得累倒在地上，扑在草坪上痛哭。</p><p>那哀痛的日子持续了很久，爸爸妈妈也不知道如何安慰我。他们知道与其欺骗我说外祖母睡着了，还不如对我说实话：外祖母永远不会回来了。</p><p>“什么是永远不会回来了呢？”我问。</p><p>“所有时间里的事物，都永远不会回来了，你的昨天过去了，它就永远变成昨天，你再也不能回到昨天了。爸爸以前和你一样小，现在再也不能回到你这么小的童年了。有一天你会长大，你也会像外祖母一样老，有一天你度过了你的所有时间，也会像外祖母一样永远不能回来了。”爸爸说。</p><p>爸爸等于给我说了一个谜，这个谜比“一寸光阴一寸金，寸金难买寸光阴”还让我感到可怕，比“光阴似箭，日月如梭”更让我有一种说不出的滋味。</p><p>以后，我每天放学回家，在庭院时看着太阳一寸一寸地沉进了山头，就知道一天真的过完了。虽然明天还会有新的太阳，但永远不会有今天的太阳了。</p><p>我看到鸟儿飞到天空，它们飞得多块呀。明天它们再飞过同样的路线，也永远不是今天了。或许明天飞过这条路线的，不是老鸟，而是小鸟了。</p><p>时间过得飞快，使我的小心眼不只是着急，还有悲伤。有一天我放学回家，看到太阳快落山了，就下决心说：“我要比太阳更快地回家。”我狂奔回去，站在庭院里喘气的时候，看到太阳还露着半边脸，我高兴地跳起来。那一天我跑赢了太阳。以后我常做这样的游戏，有时和太阳赛跑，有时和西北风比赛，有时一个暑假的作业，我十天就做完了。那时我三年级，常把哥哥五年级的作业拿来做。每一次比赛胜过时间，我就快乐得不知道怎么形容。</p><p>后来二十年里，我因此受益无穷。虽然我知道人永远跑不过时间，但是可以比原来跑快一步，如果加把劲，有时可以快好几步。那几步虽然很小很小，用途却很大很大。</p><p>如果将来我有什么要教给孩子，我会告诉他：假若你一直和时间赛跑，你就可以成功。</p><h1 id="秋天的怀念-史铁生"><a class="markdownIt-Anchor" href="#秋天的怀念-史铁生"></a> 秋天的怀念 史铁生</h1><p>双腿瘫痪后，我的脾气变得暴怒无常。望着望着天上北归的雁阵，我会突然把面前的玻璃砸碎；听着听着李谷一甜美的歌声，我会猛地把手边的东西摔向四周的墙壁。母亲就悄悄地躲出去，在我看不见的地方偷偷地听着我的动静。当一切恢复沉寂，她又悄悄地进来，眼边红红的，看着我。“听说北海的花儿都开了，我推你去走走。”她总是这么说。母亲喜欢花，可自从我双腿瘫痪后，她侍弄的那些花都死了。“不，我不去！”我狠命地捶打这两条可恨的腿，喊着：“我活着有什么劲！”母亲扑过来抓住我的手，忍住哭声说：“咱娘儿俩在一块儿，好好儿活……”可我却一直都不知道，她的病已经到了那步田地。后来妹妹告诉我，她常常肝疼得整宿整宿翻来覆去地睡不了觉。</p><p>那天我又独自坐在屋里，看着窗外的树叶“唰唰啦啦”地飘落。母亲进来了，挡在窗前：“北海地菊花开了，我推着你去看看吧。”她憔悴的脸上现出央求般的神色。“什么时候？”你要是愿意，就明天？“她说。我的回答已经让她喜出望外了。”好吧，就明天。“我说。她高兴得一会坐下，一会站起：”那就赶紧准备准备。“”唉呀，烦不烦？几步路，有什么好准备的！“她也笑了，坐在我身边，絮絮叨叨地说着”看完菊花，咱们就去‘仿膳’，你小时候最爱吃那儿的豌豆黄儿。还记得那回我带你去北海吗？你偏说那杨树花是毛毛虫，跑着，一脚踩扁一个……“她忽然不说了。对于”跑“和”踩“一类的字眼儿。她比我还敏感。她又悄悄出去了。</p><p>她出去了。就再也没回来。</p><p>邻居们把她抬到车上时，她还在大口大口地吐着鲜血。我没想到她已经病成那样。看着三轮车远去，也绝没有想到那竟是永远的诀别。</p><p>邻居的小伙子背着我去看她的时候，她正艰难地呼吸着，像她那一生艰难的生活。别人告诉我，他昏迷前的最后一句话是：”我那个有病的儿子和我那个未成年的女儿……“</p><p>又是秋天，妹妹推着我去北海看了菊花。黄色的花淡雅、白色的花高洁、紫红色的花热烈而深沉，泼泼洒洒，秋风中正开的烂漫。我懂得母亲没有说完的话，妹妹也懂。我俩在一块儿，要好好儿活……</p>]]></content>
    
    
    <summary type="html">喵喵喵。</summary>
    
    
    
    <category term="其他" scheme="https://blog.godmao.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>I-MX6ULL的中断实验（下）</title>
    <link href="https://blog.godmao.top/posts/33465/"/>
    <id>https://blog.godmao.top/posts/33465/</id>
    <published>2025-08-24T14:17:34.000Z</published>
    <updated>2025-08-25T08:21:45.638Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="c语言下中断模块"><a class="markdownIt-Anchor" href="#c语言下中断模块"></a> C语言下中断模块</h2><h3 id="核心思路"><a class="markdownIt-Anchor" href="#核心思路"></a> 核心思路：</h3><p>每个中断对象包含：1个中断处理函数和需要传入的参数——一个函数指针+一个未定义类型指针。所以将中断对象打包成一个结构体：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 定义中断处理函数原型 */</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sys_irq_handler_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>para<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 定义中断函数结构体 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_sys_irq_handle</span><span class="token punctuation">&#123;</span>    <span class="token class-name">sys_irq_handler_t</span> irqHandler<span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> usrPara<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">sys_irq_handle_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指定一个默认中断处理函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 定义默认中断处理函数 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">default_irqHandler</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>para<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将所有中断对象归入一个表中，按中断id索引：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_OF_IT_VECTORS</span> <span class="token expression"><span class="token number">160</span></span></span><span class="token keyword">static</span> <span class="token class-name">sys_irq_handle_t</span> irqTable<span class="token punctuation">[</span>NUM_OF_IT_VECTORS<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>后续可能涉及到中断嵌套，因此定义一个中断嵌套计数器：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> irqNesting<span class="token punctuation">;</span> <span class="token comment">//中断嵌套计数器</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化中断对象表：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 初始化中断处理表 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sys_iqrTable_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    irqNesting <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//中断嵌套计数器</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> NUM_OF_IT_VECTORS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        irqTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>irqHandler <span class="token operator">=</span> default_irqHandler<span class="token punctuation">;</span>        irqTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>usrPara <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上一节中，我们实现了当进入中断时跳入一个名为<code>system_irqhandler</code>的函数处理中断。因此我们需要定义该函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/// @brief 中断处理函数</span><span class="token comment">/// @param gicciar 寄存器gicciar的值</span><span class="token comment">/// @note 进入irq中断后自动调用</span><span class="token keyword">void</span> <span class="token function">system_irqhandler</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> gicciar<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token class-name">uint32_t</span> id <span class="token operator">=</span> gicciar <span class="token operator">&amp;</span> <span class="token number">0x3ff</span><span class="token punctuation">;</span> <span class="token comment">//从gicciar寄存器中读取中断id号（0~9位 故&amp; 0x3ff）</span>    <span class="token comment">/* 安全检查 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">1023</span> <span class="token operator">||</span> id <span class="token operator">>=</span> NUM_OF_IT_VECTORS<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//1023即没有中断，即0~9位全为1</span>    irqNesting<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">/* 开始处理 */</span>    irqTable<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">irqHandler</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> irqTable<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>usrPara<span class="token punctuation">)</span><span class="token punctuation">;</span>    irqNesting<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们不可能只用默认中断处理函数，肯定要自己自定义，自定义完处理函数后，将该函数注册给中断对象，因此我们需要一个用于注册的函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/// @brief 用于注册你自定义的中断处理函数</span><span class="token comment">/// @param irq_id 你为哪个中断写好了处理函数，写入id</span><span class="token comment">/// @param handler 你写的处理函数的地址</span><span class="token comment">/// @param para 要传入的参数</span><span class="token keyword">void</span> <span class="token function">register_irqHandler</span><span class="token punctuation">(</span>IRQn_Type irq_id<span class="token punctuation">,</span> <span class="token class-name">sys_irq_handler_t</span> handler<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>para<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    irqTable<span class="token punctuation">[</span>irq_id<span class="token punctuation">]</span><span class="token punctuation">.</span>irqHandler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    irqTable<span class="token punctuation">[</span>irq_id<span class="token punctuation">]</span><span class="token punctuation">.</span>usrPara <span class="token operator">=</span> para<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置gpio外部中断"><a class="markdownIt-Anchor" href="#配置gpio外部中断"></a> 配置gpio外部中断</h2><p>通过原理图可知，应配置为上升沿触发。</p><h3 id="配置gpio_icr寄存器"><a class="markdownIt-Anchor" href="#配置gpio_icr寄存器"></a> 配置GPIO_ICR寄存器</h3><p>寄存器用于指定触发方式——上升沿触发。<br />我的开发板应指定GOIO5_ICR1_icr1 为 10。</p><h3 id="配置gpio_imr寄存器"><a class="markdownIt-Anchor" href="#配置gpio_imr寄存器"></a> 配置GPIO_IMR寄存器</h3><p>该寄存器用于使能中断。<br />我的开发板应指定GPIO5_IMR_imr1 为 1——UNMASKED</p><h2 id="中断后清除中断标志位"><a class="markdownIt-Anchor" href="#中断后清除中断标志位"></a> 中断后清除中断标志位</h2><p>参考手册中指出，处理完中断后，需清除GPIO_ISR寄存器的相应位。<br />需要注意的是<strong>通过对该位写1清除。</strong></p><h2 id="gic-配置"><a class="markdownIt-Anchor" href="#gic-配置"></a> GIC 配置</h2><p>just like NVIC… you must know cubemx right？</p><h3 id="使能相应的中断id"><a class="markdownIt-Anchor" href="#使能相应的中断id"></a> 使能相应的中断ID</h3><p>GPIO5_1对应的中断id为74<br /><img src="Snipaste_2025-08-24_23-51-22.png" alt="" /><br />但是注意这段话：<br /><img src="Snipaste_2025-08-24_23-53-41.png" alt="" /></p><p>告诉我们前面还有32个中断接到了CPU的接口 所以中断ID为 74+32 = 106。</p><h3 id="配置中断优先级"><a class="markdownIt-Anchor" href="#配置中断优先级"></a> 配置中断优先级</h3><h2 id="注册中断处理函数"><a class="markdownIt-Anchor" href="#注册中断处理函数"></a> 注册中断处理函数</h2>]]></content>
    
    
    <summary type="html">本篇编写c语言中的中断模块并配置GPIO外部中断。</summary>
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>I-MX6ULL的中断实验（上）</title>
    <link href="https://blog.godmao.top/posts/32440/"/>
    <id>https://blog.godmao.top/posts/32440/</id>
    <published>2025-08-11T13:17:21.000Z</published>
    <updated>2025-08-24T16:22:17.968Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><ul><li><a href="#1-cortex-a7%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F">1. Cortex-A7中断系统</a><ul><li><a href="#11-cortex-a%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8">1.1. Cortex-A中断向量表</a></li><li><a href="#12-%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%81%8F%E7%A7%BB">1.2. 中断向量表偏移</a></li><li><a href="#13-gic-v2%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8">1.3. GIC v2中断控制器</a><ul><li><a href="#131-gic-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">1.3.1. GIC 的主要功能</a></li><li><a href="#132-%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84">1.3.2. 核心结构</a></li><li><a href="#133-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E7%89%88">1.3.3. 核心原理（简单版）</a></li></ul></li><li><a href="#14-%E4%B8%AD%E6%96%AD%E5%8F%B7">1.4. 中断号</a></li></ul></li><li><a href="#2-%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8">2. 添加中断向量表</a></li><li><a href="#3-%E5%A4%8D%E4%BD%8D%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%96%E5%86%99">3. 复位中断函数的编写</a><ul><li><a href="#31-%E6%93%8D%E4%BD%9Ccp15%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8">3.1. 操作CP15协处理器</a></li><li><a href="#32-%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%81%8F%E7%A7%BB">3.2. 中断向量表偏移</a></li><li><a href="#33-%E8%AE%BE%E7%BD%AEsp%E6%8C%87%E9%92%88">3.3. 设置sp指针</a></li><li><a href="#34-%E6%B8%85%E9%99%A4bss%E6%AE%B5">3.4. 清除.bss段</a></li></ul></li><li><a href="#4-irq%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%96%E5%86%99">4. IRQ中断函数的编写</a><ul><li><a href="#41-%E4%BF%9D%E5%AD%98%E4%B8%AD%E6%96%AD%E7%8E%B0%E5%9C%BA%E9%98%B2%E6%AD%A2%E7%A0%B4%E5%9D%8F%E5%8E%9F%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81">4.1. 保存中断现场（防止破坏原任务状态）</a></li><li><a href="#42-%E4%BB%8E-gic%E9%80%9A%E7%94%A8%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%BB%E5%8F%96%E4%B8%AD%E6%96%AD%E5%8F%B7">4.2. 从 GIC（通用中断控制器）读取中断号</a></li><li><a href="#43-%E5%88%87%E6%8D%A2%E5%88%B0-svc-%E6%A8%A1%E5%BC%8F%E6%89%A7%E8%A1%8C-c-%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">4.3. 切换到 SVC 模式执行 C 语言中断处理函数</a></li><li><a href="#44-%E7%BB%93%E6%9D%9F%E4%B8%AD%E6%96%AD%E5%B9%B6%E6%81%A2%E5%A4%8D%E7%8E%B0%E5%9C%BA">4.4. 结束中断并恢复现场</a></li></ul></li><li><a href="#5-%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6">5. 整个启动文件</a></li></ul><h2 id="1-cortex-a7中断系统"><a class="markdownIt-Anchor" href="#1-cortex-a7中断系统"></a> 1. Cortex-A7中断系统</h2><h3 id="11-cortex-a中断向量表"><a class="markdownIt-Anchor" href="#11-cortex-a中断向量表"></a> 1.1. Cortex-A中断向量表</h3><p>Cortex-A中断向量<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>表有8个中断，其中重点关注IRQ。Cortex-A的中断向量表需要用户自己去定义。</p><p><img src="Snipaste_2025-08-11_21-20-27.png" alt="" /></p><p>各中断的简单介绍：<br /><img src="Snipaste_2025-08-11_21-27-07.png" alt="" /></p><p>其中IRQ中断为非向量中断，所有中断共享同一入口，再软件判断来源。<br />大概是这样：<br /><img src="Snipaste_2025-08-11_21-27-26.png" alt="" /></p><h3 id="12-中断向量表偏移"><a class="markdownIt-Anchor" href="#12-中断向量表偏移"></a> 1.2. 中断向量表偏移</h3><p>通过设置中断向量表偏移，指定中断向量表的地址。</p><h3 id="13-gic-v2中断控制器"><a class="markdownIt-Anchor" href="#13-gic-v2中断控制器"></a> 1.3. GIC v2中断控制器</h3><p>类似于STM32的NVIC，CortexA7使用 GIC v2 作为中断控制器，比NVIC更强大因为GIC能处理多核的中断。</p><h4 id="131-gic-的主要功能"><a class="markdownIt-Anchor" href="#131-gic-的主要功能"></a> 1.3.1. GIC 的主要功能</h4><ol><li><strong>收集中断</strong><br />接收来自外设和 CPU 内部的各种中断请求（SPI、PPI、SGI）。</li><li><strong>优先级管理</strong><br />按优先级裁定哪个中断先被处理。</li><li><strong>目标选择</strong><br />把中断发给指定的 CPU 核，或广播给多个核。</li><li><strong>中断屏蔽与使能</strong><br />软件可选择屏蔽某个中断或所有中断。</li><li><strong>确认与结束</strong><br />CPU 核心在处理前向 GIC 确认（acknowledge），处理完向 GIC 报告结束（end of interrupt）。</li></ol><h4 id="132-核心结构"><a class="markdownIt-Anchor" href="#132-核心结构"></a> 1.3.2. 核心结构</h4><p>ARM GIC 主要由两部分组成：</p><ul><li><strong>Distributor（分发器）</strong><br />负责接收所有外设中断，决定送到哪一个 CPU。</li><li><strong>CPU Interface（CPU 接口）</strong><br />每个 CPU 核对应一个接口，负责和 Distributor 通信，接收/确认/结束中断。</li></ul><h4 id="133-核心原理简单版"><a class="markdownIt-Anchor" href="#133-核心原理简单版"></a> 1.3.3. 核心原理（简单版）</h4><p>GIC 的核心流程基本就是三步：</p><ol><li><strong>接收中断请求</strong><br />外设（SPI）、特定 CPU 相关的中断（PPI）、核间中断（SGI）都送进 GIC。</li><li><strong>仲裁优先级 + 选择目标 CPU</strong><ul><li>比较中断优先级（Priority）</li><li>检查中断是否被屏蔽（Enable Mask）</li><li>根据目标 CPU 配置（Target CPU Mask）决定发给谁</li></ul></li><li><strong>通知 CPU → CPU 响应 → 完成汇报</strong><ul><li>发信号到目标 CPU 接口</li><li>CPU 读取中断号（acknowledge）并执行 ISR</li><li>ISR 结束后 CPU 通知 GIC（end of interrupt）</li></ul></li></ol><h3 id="14-中断号"><a class="markdownIt-Anchor" href="#14-中断号"></a> 1.4. 中断号</h3><p>中断的 ID Card。<br /><img src="Snipaste_2025-08-11_21-54-28.png" alt="" /></p><h2 id="2-添加中断向量表"><a class="markdownIt-Anchor" href="#2-添加中断向量表"></a> 2. 添加中断向量表</h2><ul><li><p><strong>向量表的“表项”是指令，不是纯地址。</strong></p></li><li><p>每个向量入口的指令都指向某个具体的处理函数（Reset_Handler、IRQ_Handler 等）。</p></li><li><p>当发生异常，CPU 硬件会取指执行入口指令 → <code>ldr pc, =xxx</code> → 跳到真正的处理函数。</p></li></ul><p>这样，<strong>只要依次写好这些跳转指令，后续再告诉cpu这些指令在哪个位置，就等于告诉 CPU“各种异常该去哪”</strong>。</p><p>:::danger<br /><strong>中断向量表必须按固定顺序来定义</strong>，顺序是由 ARM 硬件架构规定的，不是随便排列的。这样CPU才能正确处理不同的异常<br />:::</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&#x2F;* 设置中断向量表，当中断来时，CPU就会执行对应指令 *&#x2F;    &#x2F;* 顺序不能改变，名字可以改变！ *&#x2F;    ldr pc, &#x3D;Reset_Handler      &#x2F;* 复位中断                     *&#x2F;      ldr pc, &#x3D;Undefined_Handler  &#x2F;* 未定义中断                    *&#x2F;    ldr pc, &#x3D;SVC_Handler        &#x2F;* SVC(Supervisor)中断        *&#x2F;    ldr pc, &#x3D;PrefAbort_Handler  &#x2F;* 预取终止中断                   *&#x2F;    ldr pc, &#x3D;DataAbort_Handler  &#x2F;* 数据终止中断                   *&#x2F;    ldr pc, &#x3D;NotUsed_Handler    &#x2F;* 未使用中断                    *&#x2F;    ldr pc, &#x3D;IRQ_Handler        &#x2F;* IRQ中断                    *&#x2F;    ldr pc, &#x3D;FIQ_Handler        &#x2F;* FIQ(快速中断)未定义中断           *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-复位中断函数的编写"><a class="markdownIt-Anchor" href="#3-复位中断函数的编写"></a> 3. 复位中断函数的编写</h2><h3 id="31-操作cp15协处理器"><a class="markdownIt-Anchor" href="#31-操作cp15协处理器"></a> 3.1. 操作CP15协处理器</h3><p><strong>关闭I、D Cache 和MMU</strong></p><details><summary>为什么要这样做？</summary><p>CP15 是 Cortex-A 系列处理器的 <strong>系统控制寄存器集</strong>，其中 <strong>SCTLR（System Control Register, c1）</strong> 控制了处理器的一些核心行为，例如：</p><table><thead><tr><th>位</th><th>功能</th></tr></thead><tbody><tr><td>M</td><td>MMU 使能位（Memory Management Unit）</td></tr><tr><td>C</td><td>数据缓存使能位</td></tr><tr><td>I</td><td>指令缓存使能位</td></tr><tr><td>A</td><td>对齐检查（Alignment）使能</td></tr><tr><td>Z</td><td>缓存清零 / 压缩乘法指令</td></tr><tr><td>V</td><td>高速异常向量表</td></tr><tr><td>…</td><td>其他一些调试、异常行为控制</td></tr></tbody></table><p>在复位后，SCTLR 寄存器的初始值不一定是你想要的运行状态。不同的 SoC 或板级支持包可能默认值不同，有些位可能 <strong>默认启用某些功能但不适合裸机启动阶段</strong>。</p><p>在裸机启动阶段，你通常需要：</p><ol><li><p><strong>禁用 MMU 和缓存</strong>：</p><ul><li>在初始化页表和内存映射前，启用 MMU 会导致访问非法地址或产生未定义行为。</li><li>数据缓存如果没有正确初始化，可能会导致数据写入内存不一致。</li></ul></li><li><p><strong>关闭对齐检查</strong>：</p><ul><li>对齐检查在裸机启动阶段可能会导致异常，因为启动代码可能使用非对齐访问。</li></ul></li><li><p><strong>保证指令执行顺序一致</strong>：</p><ul><li>SCTLR 的某些位会影响指令缓存和流水线行为。</li><li>在系统初始化阶段，确保缓存和 MMU关闭可以让你更容易调试和保证代码执行顺序。</li></ul></li><li><p><strong>统一系统行为</strong>：</p><ul><li>不同芯片可能在复位后 SCTLR 寄存器的默认值不同。</li><li>显式初始化可以保证启动代码在各种芯片上行为一致。</li></ul></li></ol><p>如果不重置这些位可能的风险：</p><ul><li><p><strong>访问未定义</strong>：</p><ul><li>如果 MMU 默认启用但页表未初始化，访问内存可能触发数据异常。</li></ul></li><li><p><strong>数据不一致</strong>：</p><ul><li>缓存启用但未正确设置缓存策略，读写内存可能得到错误数据。</li></ul></li><li><p><strong>异常频发</strong>：</p><ul><li>对齐检查默认启用，而启动代码中可能有非对齐访问，导致异常。</li></ul></li><li><p><strong>调试困难</strong>：</p><ul><li>程序执行行为不确定，难以定位启动问题。</li></ul></li></ul></details><p>代码如下：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">* 禁用MMU、cache、对齐检查等，配置适合裸机启动的环境，这样的启动代码移植性更好 *&#x2F;    mrc     p15, 0, r0, c1, c0, 0     &#x2F;*  读取CP15系统控制寄存器   *&#x2F;    bic     r0,  r0, #0x1000          &#x2F;*  清除第12位（I位）禁用 I Cache  *&#x2F;    bic     r0,  r0, #0x4             &#x2F;*  清除第 2位（C位）禁用 D Cache  *&#x2F;    bic     r0,  r0, #0x2             &#x2F;*  清除第 1位（A位）禁止严格对齐   *&#x2F;    bic     r0,  r0, #0x800           &#x2F;*  清除第11位（Z位）分支预测   *&#x2F;    bic     r0,  r0, #0x1             &#x2F;*  清除第 0位（M位）禁用 MMU   *&#x2F;    mcr     p15, 0, r0, c1, c0, 0     &#x2F;*  将修改后的值写回CP15寄存器   *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="32-中断向量表偏移"><a class="markdownIt-Anchor" href="#32-中断向量表偏移"></a> 3.2. 中断向量表偏移</h3><p>访问CP15 VBAR（Vector Base Address Register）寄存器，该寄存器是专门指定中断向量表偏移首地址的。</p><ul><li><code>dsb</code>（Data Synchronization Barrier）保证所有数据访问指令执行完再继续。</li><li><code>isb</code>（Instruction Synchronization Barrier）保证新的 VBAR 设置马上生效，不会被 CPU 指令流水线里的旧指令影响。</li></ul><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&#x2F;* 访问CP15 VBAR寄存器 设置中断向量表偏移 *&#x2F;    ldr r0, &#x3D;0x80000000    dsb    isb &#x2F;* 数据同步指令 *&#x2F;    mcr p15, 0, r0, c12, c0, 0    dsb    isb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="33-设置sp指针"><a class="markdownIt-Anchor" href="#33-设置sp指针"></a> 3.3. 设置sp指针</h3><p>内核工作在不同模式下，User模式和是Sys模式共用sp寄存器，而其他模式是独享一个sp寄存器。</p><ul><li>ARMv7-A 每个异常模式都有自己的栈指针寄存器，如果不设置，进入该模式时可能破坏未知内存。</li><li>给每种模式单独分配内存空间，可以防止中断嵌套、函数调用等操作时栈互相冲突。</li></ul><h3 id="34-清除bss段"><a class="markdownIt-Anchor" href="#34-清除bss段"></a> 3.4. 清除.bss段</h3><details><summary>bss段是什么？</summary><p>在编译链接后，程序的内存布局通常分为几个主要段：</p><ul><li><p><strong>.text</strong>：存放代码（只读）。</p></li><li><p><strong>.data</strong>：存放已初始化的全局/静态变量（初始值不为 0）。</p></li><li><p><strong>.bss</strong>：存放<strong>未初始化的</strong>或者<strong>初始化为 0</strong> 的全局/静态变量。</p></li></ul><p><code>.bss</code> 只在运行时需要分配内存，编译产物中不占用存储空间（只是记录了大小），这样可以减少可执行文件体积。</p></details><details><summary>为什么要这样做？</summary><p>根据 <strong>C 语言标准</strong>：</p><blockquote><p>所有未显式初始化的全局变量、静态变量在程序开始执行前必须被初始化为 0。</p></blockquote><p>这意味着：</p><ul><li><p>如果 <code>bss</code> 段中的内容不是全 0，程序可能会读到<strong>随机的旧内存内容</strong>。</p></li><li><p>硬件上，RAM 启动后可能是<strong>杂乱的值</strong>（上电状态、上次运行残留、调试器写入等）。</p></li></ul><p>因此，<strong>启动代码（crt0 或汇编 startup.s）通常会在 <code>main()</code> 之前清零 bss 段</strong>，保证所有这些变量是干净的 0。</p></details><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&#x2F;* 清除bss段 防止未初始化变量等数据访问错误 *&#x2F;    ldr r0, &#x3D;__bss_start    ldr r1, &#x3D;__bss_end    mov r2, #0bss_clear:          &#x2F;* ia: increse after *&#x2F;    stmia r0!, &#123;r2&#125; &#x2F;* stmia: 从r0所存地址开始，将r2的值写入该地址，写入后地址自动递增 *&#x2F;    cmp r0, r1    ble bss_clear &#x2F;* less &amp; equal *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-irq中断函数的编写"><a class="markdownIt-Anchor" href="#4-irq中断函数的编写"></a> 4. IRQ中断函数的编写</h2><details><summary>中断函数实现了什么？（详细版）</summary><h3 id="41-保存中断现场防止破坏原任务状态"><a class="markdownIt-Anchor" href="#41-保存中断现场防止破坏原任务状态"></a> 4.1. 保存中断现场（防止破坏原任务状态）</h3><p>一旦 CPU 进入 IRQ 模式，中断处理代码首先：</p><ul><li><p>把 <code>lr</code>（中断返回地址）、<code>r0</code>~<code>r3</code>、<code>r12</code> 等易被破坏的寄存器压栈保存。</p></li><li><p>保存 <code>SPSR</code>（中断进入时的 CPSR 状态），以便中断结束时恢复原任务的运行状态。</p></li></ul><p><strong>目的</strong>：防止中断服务过程破坏被中断的程序的寄存器内容和运行状态。</p><hr /><h3 id="42-从-gic通用中断控制器读取中断号"><a class="markdownIt-Anchor" href="#42-从-gic通用中断控制器读取中断号"></a> 4.2. 从 GIC（通用中断控制器）读取中断号</h3><ul><li><p>读取 <strong>GICC_IAR</strong>（Interrupt Acknowledge Register）寄存器。</p></li><li><p>这个寄存器会返回当前触发的中断 ID（是哪一个外设触发的 IRQ）。</p></li></ul><p><strong>目的</strong>：确定是哪个具体中断源发生了 IRQ。</p><hr /><h3 id="43-切换到-svc-模式执行-c-语言中断处理函数"><a class="markdownIt-Anchor" href="#43-切换到-svc-模式执行-c-语言中断处理函数"></a> 4.3. 切换到 SVC 模式执行 C 语言中断处理函数</h3><ul><li><p>ARMv7-A 的 IRQ 模式不适合直接运行通用 C 代码（栈、寄存器不统一），所以这里切到 SVC 模式。</p></li><li><p>在 SVC 模式下调用 <code>system_irqhandler</code>（C 写的总中断处理函数）。</p></li><li><p><code>system_irqhandler</code> 会根据中断号去调用具体外设的中断处理例程。</p></li></ul><p><strong>目的</strong>：统一用 SVC 模式的栈和环境执行中断逻辑，方便用 C 语言写 ISR 分发器。</p><hr /><h3 id="44-结束中断并恢复现场"><a class="markdownIt-Anchor" href="#44-结束中断并恢复现场"></a> 4.4. 结束中断并恢复现场</h3><ul><li><p>切回 IRQ 模式。</p></li><li><p>向 GIC 写 <strong>EOIR</strong>（End of Interrupt Register），通知 GIC 这个中断处理完成，可以接收新的中断。</p></li><li><p>从栈中弹出寄存器和 <code>SPSR</code>，恢复进入中断前的状态。</p></li><li><p>用 <code>subs pc, lr, #4</code> 返回到中断发生前的指令位置继续运行。</p></li></ul><p><strong>目的</strong>：</p><ul><li><p>告诉中断控制器“我处理完了”。</p></li><li><p>让 CPU 完整回到被打断的程序，像中断没发生一样继续执行。</p></li></ul></details><p>省流版：<br />当一个程序在 <strong>SVC 模式</strong> 下运行时，如果来了 IRQ：</p><ol><li>CPU 自动切到 IRQ 模式。</li><li>把 <strong>SVC 模式的 CPSR</strong> 存进 <strong>IRQ 模式的 SPSR</strong>。</li><li>把返回地址放进 IRQ 模式的 LR。</li><li>开始执行 IRQ 模式的向量入口代码（也就是 <code>IRQ_Handler</code>）。<br />irq_handler:</li></ol><ul><li>保存现场</li><li>查中断号</li><li>切换到svc模式 调用用c语言编写的中断分发函数 根据中断号分发到中断处理函数 来执行中断处理</li><li>结束中断、恢复现场<br />ps： 最后一行subs指令有点抽象。。。。。。。。</li></ul><h2 id="5-整个启动文件"><a class="markdownIt-Anchor" href="#5-整个启动文件"></a> 5. 整个启动文件</h2><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">.global _start&#x2F;* 以下两个变量在链接脚本中定义 *&#x2F;.global __bss_start.global __bss_end_start:    @ &#x2F;* 1.设置处理器模式为SVC模式(其实CotexA内核上电默认即为SVC模式故不需要写) *&#x2F;    @ mrs r0, cpsr                &#x2F;* 读取cpsr到r0 *&#x2F;    @ bic r0, r0, #0x1f           &#x2F;* bic bit-clear位清零 *&#x2F;              @                             &#x2F;* 等同于R0 &#x3D; R0 &amp; (~Operand2) 这个操作数2自己推算*&#x2F;    @                             &#x2F;* 现在这个操作相当于将r0的前5位清零了 *&#x2F;    @ orr r0, r0, #0x13           &#x2F;* orr 按位或 *&#x2F;    @ msr cpsr, r0                &#x2F;* 写入cpsr *&#x2F;      &#x2F;* 设置中断向量表，当中断来时，CPU就会执行对应指令 *&#x2F;    &#x2F;* 顺序不能改变，名字可以改变！ *&#x2F;    ldr pc, &#x3D;Reset_Handler      &#x2F;* 复位中断                     *&#x2F;      ldr pc, &#x3D;Undefined_Handler  &#x2F;* 未定义中断                    *&#x2F;    ldr pc, &#x3D;SVC_Handler        &#x2F;* SVC(Supervisor)中断        *&#x2F;    ldr pc, &#x3D;PrefAbort_Handler  &#x2F;* 预取终止中断                   *&#x2F;    ldr pc, &#x3D;DataAbort_Handler  &#x2F;* 数据终止中断                   *&#x2F;    ldr pc, &#x3D;NotUsed_Handler    &#x2F;* 未使用中断                    *&#x2F;    ldr pc, &#x3D;IRQ_Handler        &#x2F;* IRQ中断                    *&#x2F;    ldr pc, &#x3D;FIQ_Handler        &#x2F;* FIQ(快速中断)未定义中断           *&#x2F;Reset_Handler:      cpsid i                           &#x2F;* Change Processor State Interrupt or abort Disable irq *&#x2F;    &#x2F;* 禁用MMU、cache、对齐检查等，配置适合裸机启动的环境，这样的启动代码移植性更好 *&#x2F;    mrc     p15, 0, r0, c1, c0, 0     &#x2F;*  读取CP15系统控制寄存器   *&#x2F;    bic     r0,  r0, #0x1000          &#x2F;*  清除第12位（I位）禁用 I Cache  *&#x2F;    bic     r0,  r0, #0x4             &#x2F;*  清除第 2位（C位）禁用 D Cache  *&#x2F;    bic     r0,  r0, #0x2             &#x2F;*  清除第 1位（A位）禁止严格对齐   *&#x2F;    bic     r0,  r0, #0x800           &#x2F;*  清除第11位（Z位）分支预测   *&#x2F;    bic     r0,  r0, #0x1             &#x2F;*  清除第 0位（M位）禁用 MMU   *&#x2F;    mcr     p15, 0, r0, c1, c0, 0     &#x2F;*  将修改后的值写回CP15寄存器   *&#x2F;    &#x2F;* 访问CP15 VBAR寄存器 设置中断向量表偏移 *&#x2F;    ldr r0, &#x3D;0x80000000    dsb    isb &#x2F;* 数据同步指令 *&#x2F;    mcr p15, 0, r0, c12, c0, 0    dsb    isb    &#x2F;* 清除bss段 防止未初始化变量等数据访问错误 *&#x2F;    ldr r0, &#x3D;__bss_start    ldr r1, &#x3D;__bss_end    mov r2, #0bss_clear:          &#x2F;* ia: increse after *&#x2F;    stmia r0!, &#123;r2&#125; &#x2F;* stmia: 从r0所存地址开始，将r2的值写入该地址，写入后地址自动递增 *&#x2F;    cmp r0, r1    ble bss_clear &#x2F;* less &amp; equal *&#x2F;      &#x2F;* 设置各个模式下的栈指针，     * 注意：IMX6UL的堆栈是向下增长的！     * 堆栈指针地址一定要是4字节地址对齐的！！！     * DDR范围:0X80000000~0X9FFFFFFF     *&#x2F;    &#x2F;* 进入IRQ模式 *&#x2F;    mrs r0, cpsr    bic r0, r0, #0x1f   &#x2F;* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  *&#x2F;    orr r0, r0, #0x12   &#x2F;* r0或上0x13,表示使用IRQ模式                   *&#x2F;    msr cpsr, r0        &#x2F;* 将r0 的数据写入到cpsr_c中                    *&#x2F;    ldr sp, &#x3D;0x80600000 &#x2F;* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB *&#x2F;    &#x2F;* 进入SYS模式 *&#x2F;    mrs r0, cpsr    bic r0, r0, #0x1f   &#x2F;* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  *&#x2F;    orr r0, r0, #0x1f   &#x2F;* r0或上0x13,表示使用SYS模式                   *&#x2F;    msr cpsr, r0        &#x2F;* 将r0 的数据写入到cpsr_c中                    *&#x2F;    ldr sp, &#x3D;0x80500000 &#x2F;* 设置SYS模式下的栈首地址为0X80400000,大小为2MB *&#x2F;    &#x2F;* 进入SVC模式 *&#x2F;    mrs r0, cpsr    bic r0, r0, #0x1f   &#x2F;* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  *&#x2F;    orr r0, r0, #0x13   &#x2F;* r0或上0x13,表示使用SVC模式                   *&#x2F;    msr cpsr, r0        &#x2F;* 将r0 的数据写入到cpsr_c中                    *&#x2F;    ldr sp, &#x3D;0X80400000 &#x2F;* 设置SVC模式下的栈首地址为0X80200000,大小为2MB *&#x2F;    cpsie i             &#x2F;* 打开全局中断 *&#x2F;    &#x2F;* 跳转到main函数 *&#x2F;    b main&#x2F;* 未定义中断 *&#x2F;Undefined_Handler:    ldr r0, &#x3D;Undefined_Handler    bx r0&#x2F;* SVC中断 *&#x2F;SVC_Handler:    ldr r0, &#x3D;SVC_Handler    bx r0&#x2F;* 预取终止中断 *&#x2F;PrefAbort_Handler:    ldr r0, &#x3D;PrefAbort_Handler      bx r0&#x2F;* 数据终止中断 *&#x2F;DataAbort_Handler:    ldr r0, &#x3D;DataAbort_Handler    bx r0  &#x2F;* 未使用的中断 *&#x2F;NotUsed_Handler:    ldr r0, &#x3D;NotUsed_Handler    bx r0  &#x2F;* IRQ中断！重点！！！！！ *&#x2F;IRQ_Handler:    &#x2F;* 保护现场 *&#x2F;    push &#123;lr&#125;                   &#x2F;* 保存lr地址 *&#x2F;    push &#123;r0-r3, r12&#125;           &#x2F;* 保存r0-r3，r12寄存器 *&#x2F;    mrs r0, spsr                &#x2F;* 读取spsr寄存器 *&#x2F;    push &#123;r0&#125;                   &#x2F;* 保存spsr寄存器 *&#x2F;     &#x2F;* 读取GIC控制器基地址 *&#x2F;    mrc p15, 4, r1, c15, c0, 0 &#x2F;* 从CP15的C0寄存器内的值到R1寄存器中                                * 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49                                * Cortex-A7 Technical ReferenceManua.pdf P68 P138                                *&#x2F;                              add r1, r1, #0X2000         &#x2F;* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 *&#x2F;    &#x2F;* 查询中断号 *&#x2F;    ldr r0, [r1, #0XC]          &#x2F;* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，                                 * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据                                 * 这个中断号来绝对调用哪个中断服务函数                                 *&#x2F;    push &#123;r0, r1&#125;               &#x2F;* 保存r0,r1 *&#x2F;    cps #0x13                   &#x2F;* 进入SVC模式，允许其他中断再次进去 *&#x2F;    push &#123;lr&#125;                   &#x2F;* 保存SVC模式的lr寄存器 *&#x2F;    ldr r2, &#x3D;system_irqhandler  &#x2F;* 加载C语言中断处理函数到r2寄存器中*&#x2F;    blx r2                      &#x2F;* 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 *&#x2F;    pop &#123;lr&#125;                    &#x2F;* 执行完C语言中断服务函数，lr出栈 *&#x2F;    cps #0x12                   &#x2F;* 进入IRQ模式 *&#x2F;    pop &#123;r0, r1&#125;                    str r0, [r1, #0X10]         &#x2F;* 中断执行完成，写EOIR，相当于确认中断执行完成 *&#x2F;    pop &#123;r0&#125;                            msr spsr_cxsf, r0           &#x2F;* 恢复spsr *&#x2F;    pop &#123;r0-r3, r12&#125;            &#x2F;* r0-r3,r12出栈 *&#x2F;    pop &#123;lr&#125;                    &#x2F;* lr出栈 *&#x2F;    subs pc, lr, #4             &#x2F;* 将lr-4赋给pc *&#x2F;&#x2F;* FIQ中断 *&#x2F;FIQ_Handler:    ldr r0, &#x3D;FIQ_Handler        bx r0loop:    b loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>中断向量，英文名为Interrupt Vector，在早期计算机体系结构里，“vector”常被用作“指针/地址索引”的意思，所以”向量“实际上就是地址指针的意思。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">本篇学习CortexA7中断系统和配置中断的启动文件的编写。</summary>
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>I-MX6ULL主频与时钟配置实验</title>
    <link href="https://blog.godmao.top/posts/33477/"/>
    <id>https://blog.godmao.top/posts/33477/</id>
    <published>2025-08-06T13:50:03.000Z</published>
    <updated>2025-08-14T14:51:38.995Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><h2 id="系统时钟浅析"><a class="markdownIt-Anchor" href="#系统时钟浅析"></a> 系统时钟浅析</h2><h3 id="7路pll"><a class="markdownIt-Anchor" href="#7路pll"></a> 7路PLL</h3><p>为了方便生成时钟，6从24MHz晶振生出来7路PLL。这7路PLL中有的又生出来PFD。</p><ul><li><code>PLL1</code>：ARM PLL供给ARM内核。</li><li><code>PLL2</code>：sysytem PLL，528MHz，528_PLL，此路PLL分出了4路PFD，分别为PLL2_PFD0~PFD3</li><li><code>PLL3</code>: USB1 PLL，480MHz 480_PLL，此路PLL分出了4路PFD，分别为PLL3_PFD0~PFD3。</li><li><code>PLL4</code>: Audio PLL，主供音频使用。</li><li><code>PLL5</code>: Video PLL，主供视频外设，比如RGB LCD接口，和图像处理有关的外设。</li><li><code>PLL6</code>：ENET PLL，主供网络外设。</li><li><code>PLL7</code>: USB2_PLL ,480MHz，无PFD。</li></ul><p>详见 IMX6ULL参考手册 Chapter 18 Clock Controller Module (CCM)</p><p>附 时钟树图：<br />t形为多路选择器</p><p><img src="Snipaste_2025-08-06_22-02-07.png" alt="" /><br /><img src="Snipaste_2025-08-06_22-03-45.png" alt="" /></p><h3 id="要初始化的pll和pfd"><a class="markdownIt-Anchor" href="#要初始化的pll和pfd"></a> 要初始化的PLL和PFD</h3><ul><li>PLL1，</li><li>PLL2，以及PLL2_PFD0~PFD3.</li><li>PLL3以及PLL3_PFD0~PFD3.<br />其他需要时再设置。<br />一般按照时钟树里面的值进行设置。</li></ul><h2 id="具体配置"><a class="markdownIt-Anchor" href="#具体配置"></a> 具体配置</h2><h3 id="系统主频的配置"><a class="markdownIt-Anchor" href="#系统主频的配置"></a> 系统主频的配置</h3><p>根据时钟树来设定系统主频。具体时钟配置的说明可以参见 IMX6ULL参考手册 18.5.1.5<br />CCM internal clock generation<br />下图为时钟切换器 （CCM_CLK_SWITCHER） 控制输出的示意图。</p><p><img src="Snipaste_2025-08-07_10-00-08.png" alt="" /></p><ol><li><p>要设置ARM内核主频为528MHz，设置CACRR寄存器的ARM_PODF位为2分频，然后设置PLL1=1056MHz即可。CACRR的bit3<sub>0为ARM_PODF位，可设置0</sub>7，分别对应1~8分频。应该设置CACRR寄存器的ARM_PODF=1。</p></li><li><p>切换时钟源。PLL1输出为pll1_sw_clk。pll1_sw_clk有两路可以选择，分别为pll1_main_clk，和step_clk，通过CCSR寄存器的pll1_sw_clk_sel位(bit2)来选择。为0的时候选择pll1_main_clk，为1的时候选额step_clk。</p></li><li><p>在修改PLL1的时候，也就是设置系统时钟的时候需要给6ULL一个临时的时钟，也就是step_clk。在修改PLL1的时候需要将pll1_sw_clk切换到step_clk上。</p></li><li><p>设置step_clk。Step_clk也有两路来源，由CCSR的step_sel位(bit8)来设置，为0的时候设置step_clk为osc=24MHz。为1的时候不重要，不用。</p></li><li><p>时钟切换成功以后就可以修改PLL1的值。</p></li><li><p>通过CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位(bit6~0)来设置PLL1的频率，公式为：</p><pre><code> Output = fref*DIV_SEL/2  1056=24*DIV_SEL/2=&gt;DIEV_SEL=88。  设置CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位=88即可。PLL1=1056MHz  还要设置CCM_ANALOG_PLL_ARM寄存器的ENABLE位(bit13)为1，也就是使能输出。</code></pre></li><li><p>在切换回PLL1之前，设置置CACRR寄存器的ARM_PODF=1！！切记。</p></li></ol><h3 id="其他pll设置"><a class="markdownIt-Anchor" href="#其他pll设置"></a> 其他PLL设置</h3><p>PLL2和PLL3。PLL2固定为528MHz，PLL3固定为480MHz。</p><ol><li>初始化PLL2_PFD0~PFD3。寄存器CCM_ANALOG_PFD_528用于设置4路PFD的时钟。比如PFD0= 528 * 18 / PFD0_FRAC。 设置PFD0_FRAC位即可。比如PLL2_PFD0=352M=528 *  18 / PFD0_FRAC，因此FPD0_FRAC=27。</li><li>同理初始化PLL3_PFD0~PFD3</li></ol><h2 id="外设时钟"><a class="markdownIt-Anchor" href="#外设时钟"></a> 外设时钟</h2><p>AHB_CLK_ROOT、PERCLK_CLK_ROOT以及IPG_CLK_ROOT。</p><p>因为PERCLK_CLK_ROOT和IPG_CLK_ROOT要用到AHB_CLK_ROOT，所以我们要初始化AHB_CLK_ROOT。</p><h3 id="ahb_clk_root的初始化"><a class="markdownIt-Anchor" href="#ahb_clk_root的初始化"></a> AHB_CLK_ROOT的初始化</h3><p>AHB_CLK_ROOT=132MHz。</p><p>设置CBCMR寄存器的PRE_PERIPH_CLK_SEL位，设置CBCDR寄存器的PERIPH_CLK_SEL位0。设置CBCDR寄存器的AHB_PODF位为2，也就是3分频，因此396/3=132MHz。</p><h3 id="ipg_clk_root初始化"><a class="markdownIt-Anchor" href="#ipg_clk_root初始化"></a> IPG_CLK_ROOT初始化</h3><p>设置CBCDR寄存器IPG_PODF=1，也就是2分频。</p><h3 id="perclk_clk_root初始化"><a class="markdownIt-Anchor" href="#perclk_clk_root初始化"></a> PERCLK_CLK_ROOT初始化</h3><p>设置CSCMR1寄存器的PERCLK_CLK_SEL位为0，表示PERCLK的时钟源为IPG。</p><h2 id="这篇文章写得很不错摘录一些"><a class="markdownIt-Anchor" href="#这篇文章写得很不错摘录一些"></a> 这篇文章写得很不错,摘录一些</h2><p><a href="https://blog.csdn.net/Beihai_Van/article/details/139868239">【嵌入式Linux】i.MX6ULL 时钟树——理论分析-CSDN博客</a></p><h3 id="总结pfd配置寄存器"><a class="markdownIt-Anchor" href="#总结pfd配置寄存器"></a> 总结PFD配置寄存器:</h3><p>CCM_ANALOG_PFD_528n 寄存器控制着 <a href="http://i.MX">i.MX</a> 6ULL 处理器中四个分数分频器的配置，包括时钟门控、稳定性状态和分数分频值。这些分频器用于生成不同频率的时钟信号，以满足各种外设的需求。</p><ol><li>CLKGATE 位 (Clock Gate): 时钟门控</li></ol><ul><li>作用: CLKGATE 位控制着对应 PFD 的时钟信号是否被开启或关闭。</li><li>值:<ul><li>0: 时钟信号开启，PFD 正常工作，可以输出分频后的时钟信号。</li><li>1: 时钟信号关闭，PFD 处于关闭状态，不输出时钟信号。</li></ul></li><li>目的:<ul><li>省电: 当某个外设不需要时钟信号时，可以通过设置 CLKGATE 位为 1 来关闭该 PFD 的时钟，从而减少功耗。</li><li>控制时钟信号: 在某些情况下，可能需要动态地控制某个外设的时钟信号，例如在系统启动或进入低功耗模式时。</li></ul></li></ul><ol start="2"><li>STABLE 位 (Stable): 稳定性状态</li></ol><ul><li>作用: STABLE 位指示对应 PFD 的输出时钟信号是否已经稳定。</li><li>值:<br />当新的分数分频值生效时，位域的值会反转（从 0 变为 1 或从 1 变为 0）。这个反转就像一个信号，表明分频器已经完成调整。</li><li>目的:<ul><li>诊断: STABLE 位是一个只读位，用于诊断 PFD 的稳定性。</li><li>确保时钟信号质量: 在修改 PFD 的分数分频值后，需要等待 STABLE 位反转，才能确保输出的时钟信号稳定可靠。</li></ul></li></ul><h3 id="imx6u-芯片-pll-时钟详解"><a class="markdownIt-Anchor" href="#imx6u-芯片-pll-时钟详解"></a> i.MX6U 芯片 PLL 时钟详解</h3><p>i.MX6U 芯片拥有多个 PLL（Phase-Locked Loop，锁相环）模块，用于生成各种频率的时钟信号，为芯片内部的不同模块和外设提供时钟源。下面整理了 i.MX6U 芯片的 7 个主要 PLL：</p><ol><li>ARM_PLL (PLL1)<ul><li>用途: 为 ARM 内核提供时钟信号。</li><li>倍频: 可编程，最高可倍频至 1.3GHz。</li><li>特点: ARM 内核的运行速度直接取决于此 PLL 的输出频率。</li></ul></li><li>528_PLL (PLL2)<ul><li>用途: 为系统总线、内部逻辑单元、DDR 接口、NAND/NOR 接口等提供时钟源。</li><li>倍频: 固定 22 倍频，不可编程。</li><li>输出频率: 24MHz * 22 = 528MHz。</li><li>特点: 该 PLL 以及其生成的 4 路 PFD (PLL2_PFD0~PLL2_PFD3) 是 i.MX6U 内部系统总线的核心时钟源。</li></ul></li><li>USB1_PLL (PLL3)<ul><li>用途: 主要用于 USB1PHY，但也可作为其他外设的时钟源。</li><li>倍频: 固定 20 倍频。</li><li>输出频率: 24MHz * 20 = 480MHz。</li><li>特点: 该 PLL 以及其生成的 4 路 PFD (PLL3_PFD0~PLL3_PFD3) 可用于多种外设。</li></ul></li><li>USB2_PLL (PLL7)<ul><li>用途: 为 USB2PHY 提供时钟信号。</li><li>倍频: 固定 20 倍频。</li><li>输出频率: 24MHz * 20 = 480MHz。</li><li>特点: 虽然序号标为 4，但实际是 PLL7。</li></ul></li><li>ENET_PLL (PLL6)<ul><li>用途: 用于生成网络所需的时钟信号。</li><li>倍频: 固定 20+5/6 倍频。</li><li>输出频率: 24MHz * (20+5/6) = 500MHz。</li><li>特点: 可在此 PLL 的基础上生成 25/50/100/125MHz 的网络时钟。</li></ul></li><li>VIDEO_PLL (PLL5)<ul><li>用途: 用于显示相关外设，例如 LCD。</li><li>倍频: 可调整，输出范围在 650MHz~1300MHz。</li><li>分频: 可选 1/2/4/8/16 分频。</li><li>特点: 可根据显示设备的需求调整输出频率和分频比。</li></ul></li><li>AUDIO_PLL (PLL4)<ul><li>用途: 用于音频相关外设。</li><li>倍频: 可调整，输出范围在 650MHz~1300MHz。</li><li>分频: 可选 1/2/4 分频。</li><li>特点: 可根据音频设备的需求调整输出频率和分频比。<br />总结:</li></ul></li></ol><p>i.MX6U 芯片通过多个 PLL 模块，生成各种频率的时钟信号，为芯片内部的不同模块和外设提供时钟源。每个 PLL 的倍频和分频都可以根据需要进行配置，以满足不同外设的需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>I-MX6ULL开发板C语言运行环境搭建并点灯</title>
    <link href="https://blog.godmao.top/posts/2969/"/>
    <id>https://blog.godmao.top/posts/2969/</id>
    <published>2025-07-28T09:03:51.000Z</published>
    <updated>2025-07-29T16:53:01.625Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><h2 id="c语言运行环境搭建"><a class="markdownIt-Anchor" href="#c语言运行环境搭建"></a> C语言运行环境搭建</h2><p>前面我们讲解了如何用汇编语言编写 LED 灯实验，但是实际开发过程中汇编用的很少，大部分都是 C 语言开发，汇编只是用来完成 C 语言环境的初始化。本文我们就来学习如何用汇编来完成 C 语言环境的初始化工作，然后从汇编跳转到 C 语言代码里面去。</p><h3 id="设置处理器模式"><a class="markdownIt-Anchor" href="#设置处理器模式"></a> 设置处理器模式</h3><p>对于Cortex-A处理器，有多种运行模式，例如User模式、中断模式等。除用户（User）模式为非特权模式，其余均为特权模式，特权模式下程序可以访问所有系统资源，还有自己独有的寄存器组，而非特权模式下访问受限。</p><p><img src="Snipaste_2025-07-28_17-13-11.png" alt="" /></p><p>而现在我们需要将处理器模式设置为SVC模式。<br />这就需要了解到内核寄存器组中的CPSR寄存器，其低四位为处理器运行模式控制位。</p><p><img src="Snipaste_2025-07-28_17-16-59.png" alt="" /></p><p><img src="Snipaste_2025-07-28_17-19-33%201.png" alt="" /></p><p><img src="Snipaste_2025-07-28_17-20-27.png" alt="" /></p><p>设置CPSR寄存器的bit4-0，也就是M[4:0]为10011=0X13。读写状态寄存器需要用到 MRS<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 和 MSR<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 指令。MRS将CPSR寄存器数据读出到通用寄存器里面，MSR指令将通用寄存器的值写入到CPSR寄存器里面去。</p><p>为啥不用SDR、LDR？因为这他妈属于处理器内部自己在传输数据，而不是从寄存器与存储器！而且它只能操作通用寄存器。</p><p><img src="Snipaste_2025-07-28_17-26-03.png" alt="" /></p><h3 id="设置sp寄存器"><a class="markdownIt-Anchor" href="#设置sp寄存器"></a> 设置sp寄存器</h3><p>也就是栈的起始地址。<br />Sp可以指向内部RAM，也可以指向DDR，我们将其指向DDR。Sp设置到哪里？512MB的范围0x80000000~0x9FFFFFFF。栈大小，0x200000=2MB，很大大大大了。</p><p>再提一嘴，由于NXP给我们提供的SDK包里面有初始化DDR等一系列操作，所以这里我们可以方便的设置sp寄存器，其他处理器（启动方式设置为DDR的情况下）如果没有初始化DDR，还需要先初始化DDR。</p><p>这里再说一下栈的特性，有点抽象……</p><ul><li>向上增长：即从低地址往高地址增长。以此判断即可。</li><li>向下增长：从高地址往低地址增长。</li><li>栈底：栈的起始位置。根据定义，如果是向下增长的，那么栈底为高地址。以此类推。</li><li>栈顶：程序运行时sp指针所指示的位置，不断变化。<br />处理器栈增长方式，对于A7而言是向下增长的。设置sp指向0x80200000。</li></ul><h3 id="跳转到c语言"><a class="markdownIt-Anchor" href="#跳转到c语言"></a> 跳转到C语言</h3><p>使用b指令，跳转到C语言函数，比如main函数。</p><p>其实我们在stm32的启动文件中也可以看到这些操作，提一嘴……</p><h2 id="实操"><a class="markdownIt-Anchor" href="#实操"></a> 实操</h2><p>我的文件结构长这样：</p><pre class="line-numbers language-none"><code class="language-none">project&#x2F;├── Makefile、lds├── src&#x2F;│   └── main.c├── inc&#x2F;│   └── main.h├── build&#x2F;└── bin&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时为了学习makefile，makefile就写得比较复杂：<br />注意makefile文件对缩进、空格非常敏感！</p><pre class="line-numbers language-Makefile" data-language="Makefile"><code class="language-Makefile"># 设置目录变量，方便统一管理和修改# 源代码目录:SRC_DIR :&#x3D; src# 头文件目录:INC_DIR :&#x3D; inc# 中间目标文件（.o）输出目录:BUILD_DIR :&#x3D; build# 最终生成的二进制文件（.bin）目录:BIN_DIR :&#x3D; bin# 设置编译工具（使用 ARM 的交叉编译工具链）# 编译器（用于 .c 和 .S 文件）:CC &#x3D; arm-none-eabi-gcc# 链接器:LD &#x3D; arm-none-eabi-ld# 用于将 elf 转为 bin 格式:OBJCOPY &#x3D; arm-none-eabi-objcopy# 编译选项（GCC 编译阶段）# -I：指定头文件搜索目录# -Wall：打开所有警告# -nostdlib：不链接标准库（适用于裸机）# -c：只编译，不链接GCC_FLAGS &#x3D; -I$(INC_DIR) -Wall -nostdlib -c# 链接器选项# -Ttext&#x3D;0x80000000：设置代码段的起始地址（你设备上运行程序的入口地址）# -e _start：显式设置程序入口点（防止链接器猜测）LD_FLAGS &#x3D; -Timx.lds# 自动查找 src&#x2F; 目录下的所有 .c 文件SRCS &#x3D; $(wildcard $(SRC_DIR)&#x2F;*.c)# 将 src&#x2F;xxx.c 转换为 build&#x2F;xxx.o# 例如：src&#x2F;main.c → build&#x2F;main.o# 同时添加 build&#x2F;startup.o（汇编启动文件）# 这里注意是按顺序链接的，所以startup一定要在第一个否则链接到的地址不对（查看反汇编可知）OBJS &#x3D; $(BUILD_DIR)&#x2F;startup.oOBJS +&#x3D; $(patsubst $(SRC_DIR)&#x2F;%.c,$(BUILD_DIR)&#x2F;%.o,$(SRCS))# 目标：生成最终的二进制文件 bin&#x2F;ledc.bin$(BIN_DIR)&#x2F;ledc.bin: $(OBJS)# 链接所有 .o 文件生成 elf 格式可执行文件    $(LD) $(LD_FLAGS) $(OBJS) -o $(BUILD_DIR)&#x2F;ledc.elf# 反汇编 调试用    arm-none-eabi-objdump -D -m arm $(BUILD_DIR)&#x2F;ledc.elf &gt; $(BUILD_DIR)&#x2F;ledc.dis# 把 elf 文件转换为裸机二进制文件（无符号、无头信息）    $(OBJCOPY) -O binary -S $(BUILD_DIR)&#x2F;ledc.elf $@# 编译汇编启动文件 startup.S，生成 build&#x2F;startup.o$(BUILD_DIR)&#x2F;startup.o: startup.S# 注意 startup.S 是汇编文件，用 gcc 编译也可以，默认会调用汇编器    $(CC) $(GCC_FLAGS) $&lt; -o $@# 编译每个 .c 文件到 build&#x2F;xxx.o# $@：目标文件（例如 build&#x2F;main.o）# $&lt;：依赖的源文件（例如 src&#x2F;main.c）$(BUILD_DIR)&#x2F;%.o: $(SRC_DIR)&#x2F;%.c    $(CC) $(GCC_FLAGS) $&lt; -o $@.PHONY: cleanclean:    rm $(BUILD_DIR)&#x2F;*.o $(BUILD_DIR)&#x2F;*.elf $(BIN_DIR)&#x2F;*.bin $(BUILD_DIR)&#x2F;*.dis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"main.h"</span></span><span class="token keyword">void</span> <span class="token function">clk_enable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LED_CLK_REG <span class="token operator">=</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">led_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LED_MUX_REG <span class="token operator">=</span> <span class="token number">0x5</span><span class="token punctuation">;</span>          <span class="token comment">//复用为GPIO1_IO4</span>    LED_PAD_REG <span class="token operator">=</span> <span class="token number">0x10b0</span><span class="token punctuation">;</span>       <span class="token comment">//设置电气属性</span>    LED_GPIO_DIR_REG <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">;</span>    <span class="token comment">//io4设置为输出</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">clk_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">led_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LED_GPIO_DATA_REG <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>      <span class="token comment">//输出为低电平</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.h</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__MAIN_H_  </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__MAIN_H_</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_CLK_REG</span> <span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x020c406c</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_MUX_REG</span> <span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x020e006c</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_PAD_REG</span> <span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x020e02f8</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_GPIO_DIR_REG</span> <span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x0209c004</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_GPIO_DATA_REG</span> <span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x0209c000</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>startup.S</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">  .global _start_start:    @ &#x2F;* 1.设置处理器模式为SVC模式(其实CotexA内核上电默认即为SVC模式故不需要写) *&#x2F;    @ mrs r0, cpsr                &#x2F;* 读取cpsr到r0 *&#x2F;    @ bic r0, r0, #0x1f           &#x2F;* bic bit-clear位清零 *&#x2F;              @                             &#x2F;* 等同于R0 &#x3D; R0 &amp; (~Operand2) 这个操作数2自己推算*&#x2F;    @                             &#x2F;* 现在这个操作相当于将r0的前5位清零了 *&#x2F;    @ orr r0, r0, #0x13           &#x2F;* orr 按位或 *&#x2F;    @ msr cpsr, r0                &#x2F;* 写入cpsr *&#x2F;    @下面这段是重置CP15寄存器的一些位，好像加了更保险一些。目前还没弄明白，但是实测不需要也可以运行。    @ mrc     p15, 0, r0, c1, c0, 0     &#x2F;*读取CP15系统控制寄存器   *&#x2F;    @ bic     r0,  r0, #0x1000     &#x2F;*  清除第12位（I位）禁用 I Cache  *&#x2F;    @ bic     r0,  r0, #0x4     &#x2F;*  清除第 2位（C位）禁用 D Cache  *&#x2F;    @ bic     r0,  r0, #0x2             &#x2F;*  清除第 1位（A位）禁止严格对齐   *&#x2F;    @ bic     r0,  r0, #0x800     &#x2F;*  清除第11位（Z位）分支预测   *&#x2F;    @ bic     r0,  r0, #0x1             &#x2F;*  清除第 0位（M位）禁用 MMU   *&#x2F;    @ mcr     p15, 0, r0, c1, c0, 0     &#x2F;*  将修改后的值写回CP15寄存器   *&#x2F;    &#x2F;* 2.设置sp寄存器 *&#x2F;    ldr sp, &#x3D;0x80100000         &#x2F;* 栈大小1M *&#x2F;        &#x2F;* 3.跳转到main函数 *&#x2F;    b mainloop:    b loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>链接脚本：</p><pre class="line-numbers language-lds" data-language="lds"><code class="language-lds">ENTRY(_start)SECTIONS &#123;    . &#x3D; 0x80000000;        . &#x3D; ALIGN(4);    .text :    &#123;        build&#x2F;startup.o        *(.text)    &#125;    . &#x3D; ALIGN(4);    .rodata :     &#123;        *(.rodata*)    &#125;        . &#x3D; ALIGN(4);    .data :     &#123;        *(.data)    &#125;    . &#x3D; ALIGN(4);    __bss_start &#x3D; .;      .bss :    &#123;        *(.bss)        *(COMMON)    &#125;    __bss_end &#x3D; .; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><strong>M</strong>ove to <strong>R</strong>egister from <strong>S</strong>pecial register.  加载到通用寄存器 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><strong>M</strong>ove to <strong>S</strong>pecial register from <strong>R</strong>egister.  恢复到特殊寄存器 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>浅析IMX镜像文件结构</title>
    <link href="https://blog.godmao.top/posts/undefined/"/>
    <id>https://blog.godmao.top/posts/undefined/</id>
    <published>2025-07-14T11:24:15.000Z</published>
    <updated>2025-07-28T09:01:32.042Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><h2 id="当使用内部bootrom启动时发生了什么"><a class="markdownIt-Anchor" href="#当使用内部bootrom启动时发生了什么"></a> 当使用内部BootROM启动时，发生了什么？</h2><p>当我们通过设置BOOT_MODE[1:0]为内部启动模式时，即芯片通过执行内部的bootROM固有的代码来启动，在此模式下，芯片会执行内部的 boot ROM 代码，这段 boot ROM 代码会进行硬件初始化(一部分外设)，然后从 boot 设备(就是存放代码的设备、比如 SD/EMMC、NAND)中将代码拷贝出来复制到指定的 RAM 中，一般是 DDR。</p><ul><li>设置内核时钟为396MHz。使能MMU和Cache，使能L1cache、L2 cache、MMU，目的就为了加速启动。</li><li>从BOOT_CFG设置的外置存储中，读取image，然后做相应的处理。</li></ul><p><img src="Snipaste_2025-07-14_19-59-23.png" alt="" /><img src="Snipaste_2025-07-14_20-01-17.png" alt="" /><br />其中内存管理单元（Memory Management Unit）用于将物理地址翻译为虚拟内存地址，以及通过虚拟内存访问实际物理内存。而初始化高速缓存则是加速数据访问。</p><h2 id="镜像文件结构"><a class="markdownIt-Anchor" href="#镜像文件结构"></a> 镜像文件结构</h2><p>在上一节<a href="https://blog.godmao.top/posts/43400/">【点灯大师】点亮I.MX6ULL开发板的LED灯</a>提到过，通过汇编生成的bin文件并不能直接使用，还需要添加额外的头文件信息。我们使用VSCODE（需要扩展hex-editor）打开生成的img文件，这个文件是上一节我们使用<code>mkimage.sh</code>生成的。我们可以先查看一下这个sh文件方便理解：<br />我们只截取通过sd卡启动的配置参数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">==</span> <span class="token string">"sd"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token punctuation">..</span>/bin/<span class="token variable">$IMG_BUILDER</span> <span class="token parameter variable">--combine</span> <span class="token assign-left variable">base_addr</span><span class="token operator">=</span>0x80000000 <span class="token assign-left variable">ivt_offset</span><span class="token operator">=</span>0x400 <span class="token assign-left variable">app_offset</span><span class="token operator">=</span>0x2000 <span class="token assign-left variable">dcd_file</span><span class="token operator">=</span>dcd.bin <span class="token assign-left variable">app_file</span><span class="token operator">=</span>sdk20-app.bin <span class="token assign-left variable">ofile</span><span class="token operator">=</span>sdk20-app.img <span class="token assign-left variable">image_entry_point</span><span class="token operator">=</span>0x80002000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到，该脚本为我们默认设置的基址为0x80000000，也就是绝对的起始地址，在此基础上，偏移app_offset即为应用程序的起始地址。因此程序的起始地址（bin的起始地址）为0x80002000，ivt表则是偏移了1024字节，0x400。<br /><img src="Snipaste_2025-07-14_21-25-46.png" alt="" /><br />接下来我们看img文件的内容：<br /><img src="Snipaste_2025-07-14_21-34-13.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="boot" scheme="https://blog.godmao.top/Tags/boot/"/>
    
  </entry>
  
  <entry>
    <title>【点灯大师】点亮I.MX6ULL开发板的LED灯</title>
    <link href="https://blog.godmao.top/posts/43400/"/>
    <id>https://blog.godmao.top/posts/43400/</id>
    <published>2025-06-29T17:03:23.000Z</published>
    <updated>2025-07-28T10:35:42.849Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><ul><li><a href="#1-%E6%B1%87%E7%BC%96led%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">1. 汇编LED原理分析</a></li><li><a href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B">2. 初始化流程</a><ul><li><a href="#21-stm32%E7%9A%84%E5%A4%A7%E8%87%B4io%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B">2.1. STM32的大致IO初始化流程</a></li><li><a href="#22-imx6ull-io%E5%88%9D%E5%A7%8B%E5%8C%96">2.2. I.MX6ULL IO初始化</a></li></ul></li><li><a href="#3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0">3. 汇编语言实现</a></li><li><a href="#4-%E9%93%BE%E6%8E%A5%E4%B8%8E%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2">4. 链接与格式转换</a><ul><li><a href="#41-%E9%93%BE%E6%8E%A5">4.1. 链接</a></li><li><a href="#42-%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2">4.2. 格式转换</a></li></ul></li><li><a href="#5-%E4%BD%BF%E7%94%A8%E5%AE%98%E6%96%B9sdk%E5%8C%85%E7%94%9F%E6%88%90%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6">5. 使用官方SDK包生成镜像文件</a></li><li><a href="#6-%E5%AE%89%E8%A3%85sdk%E5%8C%85">6. 安装SDK包</a><ul><li><a href="#61-build-sdk">6.1. build SDK</a></li><li><a href="#62-%E7%94%9F%E6%88%90%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6">6.2. 生成镜像文件</a></li></ul></li><li><a href="#7-%E7%83%A7%E5%BD%95%E5%88%B0sd%E5%8D%A1">7. 烧录到SD卡</a></li><li><a href="#8-%E8%BE%BE%E6%88%90%E6%88%90%E5%B0%B1%E7%82%B9%E7%81%AF%E5%A4%A7%E5%B8%88">8. 达成成就【点灯大师】</a></li><li><a href="#9-%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">9. 参考资料</a></li></ul><h2 id="1-汇编led原理分析"><a class="markdownIt-Anchor" href="#1-汇编led原理分析"></a> 1. 汇编LED原理分析</h2><p>为什么不像STM32那样直接使用c语言？</p><p>答：因为ST已经为你用汇编写好了初始化过程，比如初始化时钟等等外设，初始化Ram，设置sp指针，配置好c语言运行环境等等。而一般这些一块CortexA架构的板子是不提供的。</p><p>所以我们要使用汇编：</p><ol><li>初始化一些SOC外设。</li><li>初始化DDR<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</li></ol><blockquote><p>这个I.MX6U倒是不需要。I.MX内部的ROM存放了自己编写的启动代码，这些启动代码可以读取DDR配置信息，并完成其的初始化。</p></blockquote><ol start="3"><li>设置sp指针，一般指向DDR，设置好C语言运行环境。</li></ol><h2 id="2-初始化流程"><a class="markdownIt-Anchor" href="#2-初始化流程"></a> 2. 初始化流程</h2><blockquote><p>具体原理、寄存器详细位讲解可以看正点原子的Linux驱动开发指南。</p></blockquote><p>这里我们对比STM32的IO初始化流程来学习I.MX的初始化流程</p><h3 id="21-stm32的大致io初始化流程"><a class="markdownIt-Anchor" href="#21-stm32的大致io初始化流程"></a> 2.1. STM32的大致IO初始化流程</h3><ol><li>使能时钟</li><li>设置IO复用，复用为GPIO</li><li>配置GPIO的电气属性</li><li>使用GPIO——利用控制寄存器设置GPIO的输入输出功能</li></ol><h3 id="22-imx6ull-io初始化"><a class="markdownIt-Anchor" href="#22-imx6ull-io初始化"></a> 2.2. I.MX6ULL IO初始化</h3><p>同样的，IO的使用分为两个部分，CONFIG和CONTROL</p><p>CONFIG部分，I.MX的每个IO都有两个寄存器来配置，分别是多路复用寄存器（IOMUXC_SW_MUX_CTL_PAD_XX_XX）和配置电气特性的寄存器（IOMUXC_SW_PAD_CTL_PAD_XX_XX）它们在命名的第三个字段加以区分。我们可以查阅正点原子的Linux驱动开发指南以及官方的参考手册查看每一位的意义。</p><p>CONTROL部分，也有各种寄存器，来控制IO的各个功能，比如<em>GPIOx_DR</em>寄存器就是控制输入输出的高低电平，共有32位，每一位控制第x组IO各个引脚的高低电平。</p><p>使能时钟，CCGR0~CCGR6这7个寄存器控制着6ULL所有外设时钟的使能。（参考《I.MX6UL 参考手册》的第 18 章“Chapter 18: ClockController Module(CCM)”）</p><p>总结一下，I.MX6ULL的初始化一个IO流程如下：</p><ol><li>使能时钟，CCGR0<sub>CCGR6这7个寄存器控制着6ULL所有外设时钟的使能。为了简单，设置CCGR0</sub>CCGR6这7个寄存器全部为0XFFFFFFFF，相当于使能所有外设时钟。</li><li>IO复用，将寄存器IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03的bit3~0设置为0101=5，这样GPIO1_IO03就复用为GPIO。</li><li>寄存器IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03是设置GPIO1_IO03的电气属性。包括压摆率、速度、驱动能力、开漏、上下拉等。</li><li>配置GPIO功能，设置输入输出。设置GPIO1_GDIR寄存器bit3为1，也就是设置为输出模式。设置GPIO1_DR寄存器的bit3，为1表示输出高电平，为0表示输出低电平。</li></ol><h2 id="3-汇编语言实现"><a class="markdownIt-Anchor" href="#3-汇编语言实现"></a> 3. 汇编语言实现</h2><p>在了解上述内容后我们可以正式开始写代码了，在Linux环境下新建<code>led.s</code>汇编文件。<br />内容可以参考如下</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&#x2F;* 点亮led汇编代码 *&#x2F;.global _start @全局标号_start:@1.使能时钟    @查找原理图和参考手册可知，LED1连接GPIO1-io4，GPIO1的时钟属于CCM_CCGR1 CG13（26-27位）ldr r0, &#x3D;0x020c406c @将寄存器地址加载到r0ldr r1, &#x3D;0xFFFFFFF  @为了方便打开全部时钟，相应的功耗也有所增加str r1, [r0] @将r1中的值存入以r0中的值为地址的寄存器中  2.设置io引脚复用为gpio  ldr r0, &#x3D;0x020e006c @将寄存器地址加载到r0mov r1, #5 @将寄存器要设置的值加载到r1str r1, [r0]@3.设置io电气属性    &#x2F;*     * bit0     SRE压摆率       0       disable     * bit5:3   DSE io驱动能力  110     R0&#x2F;6     * bit7:6   speed          10      100MHz     * bit11    ODE 开路输出     0      disable     * bit12    PKE 使能pull&#x2F;keeper 1   enable     * bit13    PUE pull or keeper 0   keeper     * bit15:14 上下拉电阻       00      100K下拉     * bit16    HYS             0       disable     *&#x2F;ldr r0, &#x3D;0x020e02f8ldr r1, &#x3D;0x10b0 @将寄存器要设置的值加载到r1str r1, [r0] @4.设置GPIO功能    @设置为输出 GDIR寄存器ldr r0, &#x3D;0x0209c004mov r1, #16str r1, [r0] @将GPIO1组的第4个io口设置为输出模式    @设置为输出低电平 DR寄存器ldr r0, &#x3D;0x0209c000mov r1, #0str r1, [r0] @将GPIO1组的第4个io口设置为输出低电平  @5.防止CPU进入未知状态    @写入死循环loop:    b loop    &#x2F;* Finally! END! *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-链接与格式转换"><a class="markdownIt-Anchor" href="#4-链接与格式转换"></a> 4. 链接与格式转换</h2><blockquote><p>默认已安装了<code>arm-linux-gnueabihf</code>编译套件</p></blockquote><h3 id="41-链接"><a class="markdownIt-Anchor" href="#41-链接"></a> 4.1. 链接</h3><p>使用命令</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">arm-linux-gnueabihf-ld -Ttext 0X80000000 led.o -o led.elf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述命令中-Ttext 就是指定链接起始地址，“-o”，我理解为output，指定链接生成的 elf 文件名，这里我们命名为 led.elf。上述命令执行完以后就会在工程目录下多一个 led.elf 文件。<br />这个elf相当于win中的exe，是一个可执行文件。</p><h3 id="42-格式转换"><a class="markdownIt-Anchor" href="#42-格式转换"></a> 4.2. 格式转换</h3><p>使用命令</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述命令中，“-O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出，<br />选项“-S”表示不要复制源文件中的重定位信息和符号信息，“-g”表示不复制源文件中的调试<br />信息。<br />至此我们终于等到了想要的东西—led.bin 文件。<br />但是 I.MX6U 不能直接烧写编译生成的.bin 文件，我们需要在.bin 文件前面添加一些头信息构成满足 I.MX6U 需求的最终可烧写文件，I.MX6U 的最终可烧写文件组成如下：</p><ol><li>Image vector table，简称 IVT，IVT 里面包含了一系列的地址信息，这些地址信息在<br />ROM 中按照固定的地址存放着。</li><li>Boot data，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。</li><li>Device configuration data，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置。</li><li>用户代码可执行文件，比如 led.bin。</li></ol><h2 id="5-使用官方sdk包生成镜像文件"><a class="markdownIt-Anchor" href="#5-使用官方sdk包生成镜像文件"></a> 5. 使用官方SDK包生成镜像文件</h2><p><span class="spoiler">你不会以为我要用正点原子或者野火提供的镜像制作软件吧孩子</span></p><p>此步所需软件：<br />:::success</p><ul><li>NXP SDK_2.2_MCIM6ULL<br />:::</li></ul><p>第二个可从NXP官网获取。</p><h2 id="6-安装sdk包"><a class="markdownIt-Anchor" href="#6-安装sdk包"></a> 6. 安装SDK包</h2><p>使用共享文件夹将“SDK_2.2_MCIM6ULL_RFP_Linux.run” 拷贝到Linux下，存放位置自定。用chmod添加权限。然后运行.run文件生成SDK，linux下的源文件命令如下：</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">.&#x2F;SDK_2.2_MCIM6ULL_RFP_Linux.run<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="61-build-sdk"><a class="markdownIt-Anchor" href="#61-build-sdk"></a> 6.1. build SDK</h3><p>此步所需软件：<br />:::success</p><ul><li>gcc-arm-none-eabi交叉编译套件</li><li>cmake<br />:::<br />在Linux环境下，<br />添加临时环境变量，执行以下命令：</li></ul><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">export ARMGCC_DIR&#x3D;&#x2F;usr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入工程文件<strong>SDK_2.2_MCIM6ULL/boards/evkmcimx6ull/demo_apps/hello_world/armgcc</strong> 运行build_ddr_release.sh脚本</p><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">.&#x2F;build_ddr_release.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="62-生成镜像文件"><a class="markdownIt-Anchor" href="#62-生成镜像文件"></a> 6.2. 生成镜像文件</h3><p>进入工程文件<strong>SDK_2.2_MCIM6ULL/tools/imgutil/evkmcimx6ull</strong><br />查看readme.txt 查看使用教程<br />readme.txt内容如下：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">IMGUTIL User Guide  ======================================1. Build SDK2.0 application2. Copy built binary (.bin file) to imgutil/&lt;board> folder and rename to sdk20-app.bin3. In imgutil/&lt;board> folder, run mkimage.sh in mingw32 shell to get bootable image file sdk20-app.img    a. If the image is built with ram link file, use "mkimage.sh ram" to make the bootable image.    b. If the image is built with flash link file, use "mkimage.sh flash" to make the bootable XIP image.    c. If the image is built with ram link file and want to boot from MicroSD card, use "mkimage.sh sd" to make the bootable image.======================================<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大致意思：</p><ol><li>build SDK（前面已经做了）</li><li>复制你要制作为镜像的bin文件到对应的设备文件夹并将复制的bin文件改名为<code>sdk20-app.bin</code></li></ol><blockquote><p>我们的板子是imx6ull，故复制到当前文件夹</p></blockquote><ol start="3"><li>使用 mkimage.sh+参数 来制作镜像 参数指定启动方式，有：<ul><li>ram</li><li>flash</li><li>sd<br />参数我们使用sd。</li></ul></li></ol><pre class="line-numbers language-zsh" data-language="zsh"><code class="language-zsh">.&#x2F;mkimage sd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行后，生成了<code>sdk20-app.img</code>文件</p><h2 id="7-烧录到sd卡"><a class="markdownIt-Anchor" href="#7-烧录到sd卡"></a> 7. 烧录到SD卡</h2><p>由于我使用的是WSL环境，WSL访问USB比较不方便所以改在win下烧录。</p><p>此步所需软件：<br />:::success</p><ul><li>Win32DiskImager<br />:::</li></ul><p>此步非常简单，将生成的img文件传到win文件夹下，使用Win32DiskImager软件烧录到连接到win的SD卡。</p><h2 id="8-达成成就点灯大师"><a class="markdownIt-Anchor" href="#8-达成成就点灯大师"></a> 8. 达成成就【点灯大师】</h2><p>将SD卡插入imx6ull，设置启动方式为SD卡，具体设置需参考你板子的硬件原理图，比如我的：<br /><img src="Snipaste_2025-06-30_00-49-08.png" alt="" /><br />成功点亮！<br /><img src="WIN_20250630_00_50_53_Pro.jpg" alt="" /></p><h2 id="9-参考资料"><a class="markdownIt-Anchor" href="#9-参考资料"></a> 9. 参考资料</h2><ul><li>《【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.81》</li><li><a href="https://doc.embedfire.com/linux/imx6/driver/zh/latest/index.html">[野火]嵌入式Linux驱动开发实战指南——基于i.MX6ULL系列 — [野火]嵌入式Linux驱动开发实战指南——基于i.MX6ULL系列 文档</a></li><li>《IMX6ULL参考手册》</li></ul><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Double Data Rate SDRAM 双倍数据速率同步动态随机存储器 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本流程控制简明指南</title>
    <link href="https://blog.godmao.top/posts/21870/"/>
    <id>https://blog.godmao.top/posts/21870/</id>
    <published>2025-06-18T10:38:30.000Z</published>
    <updated>2025-09-28T04:48:30.345Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><ul><li><a href="#1-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5-ifelse">1. 条件判断语句 if/else</a><ul><li><a href="#11-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">1.1. 基本语法：</a></li><li><a href="#12-%E7%A4%BA%E4%BE%8B">1.2. 示例：</a></li></ul></li><li><a href="#2-%E5%88%A4%E6%96%AD%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E">2. 判断符号说明</a></li><li><a href="#3-case-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">3. case 分支结构</a><ul><li><a href="#31-%E8%AF%AD%E6%B3%95">3.1. 语法：</a></li><li><a href="#32-%E7%A4%BA%E4%BE%8B">3.2. 示例：</a></li></ul></li><li><a href="#4-for-%E5%BE%AA%E7%8E%AF">4. for 循环</a><ul><li><a href="#41-%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8">4.1. 遍历列表：</a></li><li><a href="#42-%E4%BD%BF%E7%94%A8-c-%E9%A3%8E%E6%A0%BC%E8%AF%AD%E6%B3%95">4.2. 使用 C 风格语法：</a></li></ul></li><li><a href="#5-while-%E5%BE%AA%E7%8E%AF">5. while 循环</a><ul><li><a href="#51-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">5.1. 基本语法：</a></li><li><a href="#52-%E7%A4%BA%E4%BE%8B">5.2. 示例：</a></li></ul></li><li><a href="#6-until-%E5%BE%AA%E7%8E%AF">6. until 循环</a></li><li><a href="#7-%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AFbreak-%E5%92%8C-continue">7. 跳出循环：break 和 continue</a></li></ul><p>Shell 脚本不仅可以批量处理命令任务，还拥有完整的流程控制语法结构，包括条件判断、循环与分支等逻辑控制结构。本文将简明介绍 Shell 的基本流程控制语法，适用于 bash 环境。</p><h2 id="1-条件判断语句-ifelse"><a class="markdownIt-Anchor" href="#1-条件判断语句-ifelse"></a> 1. 条件判断语句 if/else</h2><h3 id="11-基本语法"><a class="markdownIt-Anchor" href="#11-基本语法"></a> 1.1. 基本语法：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> 条件 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    命令1<span class="token keyword">elif</span> <span class="token punctuation">[</span> 条件 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    命令2<span class="token keyword">else</span>    命令3<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写成一行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token punctuation">;</span> <span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="12-示例"><a class="markdownIt-Anchor" href="#12-示例"></a> 1.2. 示例：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">"请输入一个数字: "</span> num<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$num</span>"</span> <span class="token parameter variable">-gt</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"正数"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$num</span>"</span> <span class="token parameter variable">-lt</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">"负数"</span><span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> <span class="token string">"零"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr /><h2 id="2-判断符号说明"><a class="markdownIt-Anchor" href="#2-判断符号说明"></a> 2. 判断符号说明</h2><table><thead><tr><th>条件表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>等于（整数）</td></tr><tr><td><code>-ne</code></td><td>不等于</td></tr><tr><td><code>-gt</code></td><td>大于</td></tr><tr><td><code>-lt</code></td><td>小于</td></tr><tr><td><code>-ge</code></td><td>大于等于</td></tr><tr><td><code>-le</code></td><td>小于等于</td></tr><tr><td><code>-z str</code></td><td>字符串是否为空</td></tr><tr><td><code>-n str</code></td><td>字符串是否非空</td></tr><tr><td><code>str1 = str2</code></td><td>字符串相等</td></tr><tr><td><code>-f file</code></td><td>是否为普通文件</td></tr><tr><td><code>-d dir</code></td><td>是否为目录</td></tr></tbody></table><blockquote><p>注意：<code>[</code> 和 <code>]</code> 要有空格；变量最好加引号防止空值。</p></blockquote><h2 id="3-case-分支结构"><a class="markdownIt-Anchor" href="#3-case-分支结构"></a> 3. case 分支结构</h2><p>用于多个条件的匹配处理。</p><h3 id="31-语法"><a class="markdownIt-Anchor" href="#31-语法"></a> 3.1. 语法：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">case</span> $变量 <span class="token keyword">in</span>    模式1<span class="token punctuation">)</span>        命令 <span class="token punctuation">;</span><span class="token punctuation">;</span>    模式2<span class="token punctuation">)</span>        命令 <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span>        默认命令 <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="32-示例"><a class="markdownIt-Anchor" href="#32-示例"></a> 3.2. 示例：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">"请输入选项[a/b/c]: "</span> choice<span class="token keyword">case</span> <span class="token variable">$choice</span> <span class="token keyword">in</span>    a<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"你选择了A"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>    b<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"你选择了B"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>    c<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"你选择了C"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span>    *<span class="token punctuation">)</span> <span class="token builtin class-name">echo</span> <span class="token string">"无效选项"</span> <span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">esac</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-for-循环"><a class="markdownIt-Anchor" href="#4-for-循环"></a> 4. for 循环</h2><h3 id="41-遍历列表"><a class="markdownIt-Anchor" href="#41-遍历列表"></a> 4.1. 遍历列表：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> 值1 值2 值3<span class="token punctuation">;</span> <span class="token keyword">do</span>    命令<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">name</span> <span class="token keyword">in</span> Alice Bob Charlie<span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"Hello, <span class="token variable">$name</span>"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="42-使用-c-风格语法"><a class="markdownIt-Anchor" href="#42-使用-c-风格语法"></a> 4.2. 使用 C 风格语法：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"第 <span class="token variable">$i</span> 次"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5-while-循环"><a class="markdownIt-Anchor" href="#5-while-循环"></a> 5. while 循环</h2><h3 id="51-基本语法"><a class="markdownIt-Anchor" href="#51-基本语法"></a> 5.1. 基本语法：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token punctuation">[</span> 条件 <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>    命令<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="52-示例"><a class="markdownIt-Anchor" href="#52-示例"></a> 5.2. 示例：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token parameter variable">-le</span> <span class="token number">5</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"循环第 <span class="token variable">$i</span> 次"</span>    <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-until-循环"><a class="markdownIt-Anchor" href="#6-until-循环"></a> 6. until 循环</h2><p>与 <code>while</code> 相反：<strong>条件为假时执行</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">i</span><span class="token operator">=</span><span class="token number">1</span><span class="token keyword">until</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token parameter variable">-gt</span> <span class="token number">5</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"第 <span class="token variable">$i</span> 次"</span>    <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-跳出循环break-和-continue"><a class="markdownIt-Anchor" href="#7-跳出循环break-和-continue"></a> 7. 跳出循环：break 和 continue</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token parameter variable">-eq</span> <span class="token number">5</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token builtin class-name">break</span>   <span class="token comment"># 提前结束循环</span>    <span class="token keyword">fi</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$i</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> <span class="token parameter variable">-eq</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token builtin class-name">continue</span>   <span class="token comment"># 跳过当前循环</span>    <span class="token keyword">fi</span>    <span class="token builtin class-name">echo</span> <span class="token variable">$i</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="入门" scheme="https://blog.godmao.top/categories/Linux/%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="shell" scheme="https://blog.godmao.top/Tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本入门</title>
    <link href="https://blog.godmao.top/posts/27290/"/>
    <id>https://blog.godmao.top/posts/27290/</id>
    <published>2025-06-18T08:22:15.000Z</published>
    <updated>2025-09-28T04:48:25.431Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>作为linux嵌入式开发，掌握一些shell脚本的基础是必要的。</p><ul><li><a href="#1-shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%86%99%E6%B3%95">1. shell脚本的写法</a></li><li><a href="#2-shell%E8%84%9A%E6%9C%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">2. shell脚本的一些基本用法</a><ul><li><a href="#21-%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0">2.1. 输入参数</a></li><li><a href="#22-%E6%95%B4%E5%BD%A2%E8%BF%90%E7%AE%97">2.2. 整形运算</a></li><li><a href="#23-test%E5%91%BD%E4%BB%A4">2.3. test命令</a><ul><li><a href="#231-%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95">2.3.1. 文件测试</a></li><li><a href="#232-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83">2.3.2. 字符串比较</a></li><li><a href="#233-%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83">2.3.3. 数值比较</a></li><li><a href="#234-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6">2.3.4. 逻辑操作符</a></li></ul></li><li><a href="#24-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">2.4. 条件判断</a></li></ul></li><li><a href="#3-%E6%8B%93%E5%B1%95shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">3. 拓展：shell脚本中<code>$</code>的作用</a><ul><li><a href="#31-%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8">3.1. 变量引用</a></li><li><a href="#32-%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2">3.2. 命令替换</a></li><li><a href="#33-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%92%8C%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F">3.3. 位置参数和特殊变量</a></li><li><a href="#34-%E7%AE%97%E6%9C%AF%E6%89%A9%E5%B1%95">3.4. 算术扩展</a></li><li><a href="#35-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC%E5%A4%84%E7%90%86">3.5. 字符串操作和默认值处理</a></li></ul></li></ul><h2 id="1-shell脚本的写法"><a class="markdownIt-Anchor" href="#1-shell脚本的写法"></a> 1. shell脚本的写法</h2><p>shell是个纯文本文件，命令从上而下，一行一行开始执行，<a href="http://xn--shell-iq1h016atuqd2mjsls84bdt0a.sh">shell脚本的扩展名为.sh</a><br />第一行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#！/bin/bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示使用bash</p><h2 id="2-shell脚本的一些基本用法"><a class="markdownIt-Anchor" href="#2-shell脚本的一些基本用法"></a> 2. shell脚本的一些基本用法</h2><h3 id="21-输入参数"><a class="markdownIt-Anchor" href="#21-输入参数"></a> 2.1. 输入参数</h3><p><code>read</code>常用选项：</p><ul><li>-a array 将输入的值作为数组赋值</li><li>-d delim 指定输入结束的标识符</li><li>-p prompt 在输入前打印提示信息</li><li>-t timeout 设置超时时间</li><li>-e 在输入的时候可以使用命令补全</li><li>-s silent 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。</li></ul><hr /><h3 id="22-整形运算"><a class="markdownIt-Anchor" href="#22-整形运算"></a> 2.2. 整形运算</h3><p>使用<code>$[]</code>进行算数扩展</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">"two num: "</span> num1 num2<span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$num1</span> + <span class="token variable">$num2</span> = $[num1 + num2]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr /><h3 id="23-test命令"><a class="markdownIt-Anchor" href="#23-test命令"></a> 2.3. test命令</h3><p>用于查看文件是否存在、权限等信息。可以对数值、字符、文件三方面测试，<strong>返回布尔值</strong><br />格式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">test</span> EXPRESSION<span class="token comment"># 或</span><span class="token punctuation">[</span> EXPRESSION <span class="token punctuation">]</span>  <span class="token comment"># 注意方括号内必须有空格</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="231-文件测试"><a class="markdownIt-Anchor" href="#231-文件测试"></a> 2.3.1. 文件测试</h4><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>-e</td><td>文件是否存在</td><td><code>[ -e file.txt ]</code></td></tr><tr><td>-f</td><td>是普通文件</td><td><code>[ -f /path/to/file ]</code></td></tr><tr><td>-d</td><td>是目录</td><td><code>[ -d /path/to/dir ]</code></td></tr><tr><td>-r</td><td>可读</td><td><code>[ -r file.txt ]</code></td></tr><tr><td>-w</td><td>可写</td><td><code>[ -w file.txt ]</code></td></tr><tr><td>-x</td><td>可执行</td><td><code>[ -x script.sh ]</code></td></tr><tr><td>-s</td><td>文件大小 &gt;0</td><td><code>[ -s logfile ]</code></td></tr><tr><td>-L</td><td>是符号链接</td><td><code>[ -L symlink ]</code></td></tr></tbody></table><h4 id="232-字符串比较"><a class="markdownIt-Anchor" href="#232-字符串比较"></a> 2.3.2. 字符串比较</h4><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>-z STRING</td><td>字符串为空</td><td><code>[ -z &quot;$var&quot; ]</code></td></tr><tr><td>-n STRING</td><td>字符串非空</td><td><code>[ -n &quot;$var&quot; ]</code></td></tr><tr><td>STRING1 = STRING2</td><td>字符串相等</td><td><code>[ &quot;$var1&quot; = &quot;$var2&quot; ]</code></td></tr><tr><td>STRING1 != STRING2</td><td>字符串不等</td><td><code>[ &quot;$var1&quot; != &quot;$var2&quot; ]</code></td></tr></tbody></table><h4 id="233-数值比较"><a class="markdownIt-Anchor" href="#233-数值比较"></a> 2.3.3. 数值比较</h4><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>-eq</td><td>等于</td><td><code>[ &quot;$a&quot; -eq &quot;$b&quot; ]</code></td></tr><tr><td>-ne</td><td>不等于</td><td><code>[ &quot;$a&quot; -ne &quot;$b&quot; ]</code></td></tr><tr><td>-gt</td><td>大于</td><td><code>[ &quot;$a&quot; -gt &quot;$b&quot; ]</code></td></tr><tr><td>-ge</td><td>大于或等于</td><td><code>[ &quot;$a&quot; -ge &quot;$b&quot; ]</code></td></tr><tr><td>-lt</td><td>小于</td><td><code>[ &quot;$a&quot; -lt &quot;$b&quot; ]</code></td></tr><tr><td>-le</td><td>小于或等于</td><td><code>[ &quot;$a&quot; -le &quot;$b&quot; ]</code></td></tr></tbody></table><h4 id="234-逻辑操作符"><a class="markdownIt-Anchor" href="#234-逻辑操作符"></a> 2.3.4. 逻辑操作符</h4><p><code>test</code> 支持逻辑组合：</p><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>!</td><td>逻辑非</td><td><code>[ ! -f &quot;$file&quot; ]</code></td></tr><tr><td>-a</td><td>逻辑与</td><td><code>[ &quot;$a&quot; -eq 1 -a &quot;$b&quot; -eq 2 ]</code></td></tr><tr><td>-o</td><td>逻辑或</td><td><code>[ &quot;$a&quot; -eq 1 -o &quot;$b&quot; -eq 2 ]</code></td></tr></tbody></table><p><strong>现代推荐写法</strong>：使用 <code>&amp;&amp;</code> 和 <code>||</code> 替代 <code>-a</code> 和 <code>-o</code>，更符合 POSIX 标准</p><hr /><h3 id="24-条件判断"><a class="markdownIt-Anchor" href="#24-条件判断"></a> 2.4. 条件判断</h3><p>:::warning<br />和 Java、PHP 等语言不一样，sh 的流程控制不可为空<br />:::</p><p><strong>这个我单独开一篇算了…</strong></p><h2 id="3-拓展shell脚本中的作用"><a class="markdownIt-Anchor" href="#3-拓展shell脚本中的作用"></a> 3. 拓展：shell脚本中<code>$</code>的作用</h2><p>在 Shell 中，<code>$</code> 是一个非常核心的符号，主要用于<strong>变量引用</strong>、<strong>命令替换</strong>、<strong>参数访问</strong>、<strong>字符串操作</strong>等。下面按不同用途分类说明：</p><h3 id="31-变量引用"><a class="markdownIt-Anchor" href="#31-变量引用"></a> 3.1. 变量引用</h3><p><code>$变量名</code> 用于获取变量的值：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">"lemon"</span><span class="token builtin class-name">echo</span> <span class="token variable">$name</span>     <span class="token comment"># 输出: lemon</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;name&#125;</span>world   <span class="token comment"># 输出: lemonworld</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="32-命令替换"><a class="markdownIt-Anchor" href="#32-命令替换"></a> 3.2. 命令替换</h3><p><code>$(command)</code> 会执行 <code>command</code> 命令，并将其标准输出结果替换为字符串：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"Today is <span class="token variable"><span class="token variable">$(</span><span class="token function">date</span><span class="token variable">)</span></span>"</span><span class="token comment"># 输出: Today is Wed Jun 18 17:00:00 CST 2025</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>等价于旧式：<code>`command`</code></p><h3 id="33-位置参数和特殊变量"><a class="markdownIt-Anchor" href="#33-位置参数和特殊变量"></a> 3.3. 位置参数和特殊变量</h3><p>Shell 脚本中 <code>$</code> 也用于获取传入脚本的参数或特殊含义变量：</p><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code></td><td>脚本名</td></tr><tr><td><code>$1</code> ~ <code>$9</code></td><td>脚本参数（第1~9个）</td></tr><tr><td><code>$@</code></td><td>所有参数（独立）</td></tr><tr><td><code>$*</code></td><td>所有参数（整体）</td></tr><tr><td><code>$#</code></td><td>参数个数</td></tr><tr><td><code>$$</code></td><td>当前脚本/进程的 PID</td></tr><tr><td><code>$?</code></td><td>上一个命令的返回值</td></tr><tr><td><code>$!</code></td><td>最近一个后台进程的 PID</td></tr></tbody></table><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token builtin class-name">echo</span> <span class="token string">"【\<span class="token variable">$0</span>】：脚本名称：<span class="token variable">$0</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"【\<span class="token variable">$1</span>】：第一个参数：<span class="token variable">$1</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"【\<span class="token variable">$2</span>】：第二个参数：<span class="token variable">$2</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"【\<span class="token variable">$#</span>】：参数总数：<span class="token variable">$#</span>"</span><span class="token builtin class-name">echo</span> <span class="token string">"【\<span class="token variable">$@</span>】：所有参数（逐个显示）"</span><span class="token keyword">for</span> <span class="token for-or-select variable">arg</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$@</span>"</span><span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"  - <span class="token variable">$arg</span>"</span><span class="token keyword">done</span><span class="token comment">#  或echo "【\$@】：所有参数:" "$@"</span><span class="token builtin class-name">echo</span> <span class="token string">"【\<span class="token variable">$*</span>】：所有参数（整体显示）"</span><span class="token keyword">for</span> <span class="token for-or-select variable">arg</span> <span class="token keyword">in</span> <span class="token string">"<span class="token variable">$*</span>"</span><span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token builtin class-name">echo</span> <span class="token string">"  - <span class="token variable">$arg</span>"</span><span class="token keyword">done</span><span class="token builtin class-name">echo</span> <span class="token string">"【\<span class="token variable">$$</span>】：当前脚本的 PID 是：<span class="token variable">$$</span>"</span><span class="token comment"># 模拟一个命令并查看返回值</span><span class="token builtin class-name">echo</span> <span class="token string">"执行 ls 命令："</span><span class="token function">ls</span> <span class="token operator">></span> /dev/null<span class="token builtin class-name">echo</span> <span class="token string">"【\<span class="token variable">$?</span>】：上一个命令的退出状态码：<span class="token variable">$?</span>"</span><span class="token comment"># 模拟后台命令并查看其 PID</span><span class="token function">sleep</span> <span class="token number">5</span> <span class="token operator">&amp;</span><span class="token builtin class-name">echo</span> <span class="token string">"【\<span class="token variable">$!</span>】：最近一个后台任务的 PID 是：<span class="token variable">$!</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常见问题：<code>$&#123;@&#125;</code>与 <code>$&#123;*&#125;</code>的区别</p><table><thead><tr><th>表达式</th><th>解释</th></tr></thead><tbody><tr><td><code>&quot;$&#123;@&#125;&quot;</code></td><td>把每个参数<strong>作为独立字符串</strong>处理，适合 for 循环</td></tr><tr><td><code>&quot;$&#123;*&#125;&quot;</code></td><td>把所有参数当作<strong>一个整体字符串</strong>处理，若带引号会合并成一个参数</td></tr></tbody></table><h3 id="34-算术扩展"><a class="markdownIt-Anchor" href="#34-算术扩展"></a> 3.4. 算术扩展</h3><p>用 <code>$(())</code> 或 <code>$[]</code> 进行算术运算：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">5</span><span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">3</span><span class="token builtin class-name">echo</span> $<span class="token punctuation">[</span>a + b<span class="token punctuation">]</span>  <span class="token comment"># 输出: 8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="35-字符串操作和默认值处理"><a class="markdownIt-Anchor" href="#35-字符串操作和默认值处理"></a> 3.5. 字符串操作和默认值处理</h3><p>支持 <code>:-</code>, <code>:=</code>, <code>:+</code>, <code>:?</code> 等操作：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$&#123;var<span class="token operator">:-</span>default&#125;</span>   <span class="token comment"># var未定义则使用"default"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="入门" scheme="https://blog.godmao.top/categories/Linux/%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="shell" scheme="https://blog.godmao.top/Tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下连接文件</title>
    <link href="https://blog.godmao.top/posts/36626/"/>
    <id>https://blog.godmao.top/posts/36626/</id>
    <published>2025-06-14T13:09:49.000Z</published>
    <updated>2025-09-28T04:47:39.372Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>在 Linux 系统中，我们常常需要在不同位置引用同一个文件，或者希望通过某种方式为某个文件设置别名。这时候，文件“连接（Link）”机制就派上用场了。本文将详细介绍 Linux 下的硬链接（Hard Link）与符号链接（Symbolic Link，又称软链接）的概念、区别以及实际用法。</p><hr /><h2 id="一-什么是文件连接"><a class="markdownIt-Anchor" href="#一-什么是文件连接"></a> 📌 一、什么是文件连接？</h2><p>Linux 中的“连接”指的是为某个文件创建一个别名或指针，使你可以通过多个路径访问同一个文件内容。</p><p>连接分为两种类型：</p><ul><li><strong>硬链接（Hard Link）</strong></li><li><strong>符号链接（Symbolic Link 或 Soft Link）</strong></li></ul><hr /><h2 id="二-硬链接hard-link"><a class="markdownIt-Anchor" href="#二-硬链接hard-link"></a> 🔗 二、硬链接（Hard Link）</h2><h3 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1. 概念</h3><p>硬链接是文件系统中的一种机制，它为<strong>同一个 inode（索引节点）</strong> 创建多个目录项。多个硬链接本质上是“平等的”，互为镜像。</p><h3 id="2-特点"><a class="markdownIt-Anchor" href="#2-特点"></a> 2. 特点</h3><ul><li>同一个 inode 号，表示指向同一个文件内容。</li><li>删除其中一个链接不会影响其他链接。</li><li>不支持对目录创建硬链接（为避免环形结构）。</li><li>只能对同一文件系统内的文件创建。</li></ul><h3 id="3-创建命令"><a class="markdownIt-Anchor" href="#3-创建命令"></a> 3. 创建命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ln</span> 源文件 目标文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4实验"><a class="markdownIt-Anchor" href="#4实验"></a> 4.实验</h3><p>查看链接数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二列显示的数字表示链接数（包括自己）。</p><p><img src="Snipaste_2025-06-14_21-30-04.png" alt="" /><br />可见其所占用的存储空间是相同的，说明它们本质是相同的，指向同一incode，删除链接源文件，其他文件依然可以运行。<br />例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> hello./ hello2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>依然正常输出</p><hr /><h2 id="三-符号链接symbolic-link-soft-link"><a class="markdownIt-Anchor" href="#三-符号链接symbolic-link-soft-link"></a> 三、符号链接（Symbolic Link / Soft Link）</h2><h3 id="1-概念-2"><a class="markdownIt-Anchor" href="#1-概念-2"></a> 1. 概念</h3><p>符号链接类似 Windows 的快捷方式，它是一个<strong>特殊类型的文件</strong>，包含了另一个文件的路径。</p><h3 id="2-特点-2"><a class="markdownIt-Anchor" href="#2-特点-2"></a> 2. 特点</h3><ul><li>是一个独立的文件，有自己的 inode。</li><li>链接路径，而非直接指向数据块。</li><li>删除源文件会导致符号链接失效（变成“悬挂链接”或“死链接”）。</li><li>可跨文件系统，也可指向目录。</li></ul><p>:::bug<br /><strong>请使用绝对路径，否则拷贝文件到另一目录时会失去软连接</strong><br />:::</p><h3 id="3-创建命令-2"><a class="markdownIt-Anchor" href="#3-创建命令-2"></a> 3. 创建命令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ln</span> <span class="token parameter variable">-s</span> 源文件 目标链接名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-实验"><a class="markdownIt-Anchor" href="#4-实验"></a> 4. 实验</h3><p>拷贝文件保留软链接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> <span class="token parameter variable">-d</span> <span class="token punctuation">[</span>源<span class="token punctuation">]</span> <span class="token punctuation">[</span>目的<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当使用相对路径时：<br /><img src="Snipaste_2025-06-14_21-42-53.png" alt="" /><br /><img src="Snipaste_2025-06-14_21-48-24.png" alt="" /><br />使用绝对路径：<br /><img src="Snipaste_2025-06-14_21-54-29.png" alt="" /></p><hr /><h2 id="四-硬链接-vs-符号链接"><a class="markdownIt-Anchor" href="#四-硬链接-vs-符号链接"></a> 🆚 四、硬链接 vs 符号链接</h2><table><thead><tr><th>特性</th><th>硬链接（Hard Link）</th><th>符号链接（Symbolic Link）</th></tr></thead><tbody><tr><td>是否有独立 inode</td><td>否</td><td>是</td></tr><tr><td>是否可跨文件系统</td><td>否</td><td>是</td></tr><tr><td>是否可链接目录</td><td>否</td><td>是（需管理员权限）</td></tr><tr><td>删除原文件后</td><td>内容仍保留</td><td>链接失效（悬挂链接）</td></tr><tr><td>作用</td><td>多个文件名共享内容</td><td>文件快捷方式</td></tr></tbody></table><hr /><h2 id="五-补充"><a class="markdownIt-Anchor" href="#五-补充"></a> 🧪 五、补充</h2><h3 id="查找所有指向同一-inode-的文件"><a class="markdownIt-Anchor" href="#查找所有指向同一-inode-的文件"></a> 查找所有指向同一 inode 的文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-inum</span> <span class="token operator">&lt;</span>inode号<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查找所有死链接"><a class="markdownIt-Anchor" href="#查找所有死链接"></a> 查找所有死链接</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> <span class="token builtin class-name">.</span> <span class="token parameter variable">-xtype</span> l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr /><h2 id="六-总结"><a class="markdownIt-Anchor" href="#六-总结"></a> ✅ 六、总结</h2><table><thead><tr><th>关键点</th><th>硬链接</th><th>符号链接</th></tr></thead><tbody><tr><td>安全性</td><td>内容冗余，较安全</td><td>容易产生死链接</td></tr><tr><td>灵活性</td><td>不支持跨系统和目录</td><td>灵活，可指向任意路径</td></tr><tr><td>适用场景</td><td>本地备份，核心文件</td><td>快捷方式，快捷访问</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="入门" scheme="https://blog.godmao.top/categories/Linux/%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="链接文件" scheme="https://blog.godmao.top/Tags/%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
</feed>

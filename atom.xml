<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GoDm@&#39;s Blog</title>
  
  <subtitle>记录自己所爱。</subtitle>
  <link href="https://blog.godmao.top/atom.xml" rel="self"/>
  
  <link href="https://blog.godmao.top/"/>
  <updated>2025-09-29T14:34:58.586Z</updated>
  <id>https://blog.godmao.top/</id>
  
  <author>
    <name>GoDm@</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大蟒蛇-sys/argparse库</title>
    <link href="https://blog.godmao.top/posts/22025/"/>
    <id>https://blog.godmao.top/posts/22025/</id>
    <published>2025-09-29T12:53:30.000Z</published>
    <updated>2025-09-29T14:34:58.586Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h1 id="sys库"><a class="markdownIt-Anchor" href="#sys库"></a> sys库</h1><p><code>sys</code> 是 Python 标准库中的一个模块，提供了与 Python 解释器及其环境交互的功能。<br />通过 <code>sys</code> 库，你可以访问与 Python 解释器相关的变量和函数，例如命令行参数、标准输入输出、程序退出等。命令行参数部分可用<code>argparse</code>库替代。</p><h2 id="sysargv"><a class="markdownIt-Anchor" href="#sysargv"></a> sys.argv</h2><p>描述：命令行参数的列表。<code>sys.argv[0]</code> 是脚本的名称，后续元素是传递给脚本的参数。<br />语法：<code>sys.argv[]</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"脚本名称:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"参数列表:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sysexit"><a class="markdownIt-Anchor" href="#sysexit"></a> sys.exit</h2><p>描述：用于退出程序。你可以传递一个整数作为退出状态码，通常 <code>0</code> 表示成功，非零值表示错误。<br />语法：<code>sys.exit(num）</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"程序开始"</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这行代码不会执行"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sysstdinstdoutstderr"><a class="markdownIt-Anchor" href="#sysstdinstdoutstderr"></a> sys.stdin/stdout/stderr</h2><p>描述：<code>sys.stdin</code>、<code>sys.stdout</code> 和 <code>sys.stderr</code> 分别代表标准输入、标准输出和标准错误流。你可以重定向这些流以实现自定义的输入输出行为。<br />语法：<code>sys.stderr.write(&quot;err&quot;)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token comment"># 重定向标准输出到文件</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'output.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    sys<span class="token punctuation">.</span>stdout <span class="token operator">=</span> f    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这行内容将写入 output.txt"</span><span class="token punctuation">)</span><span class="token comment"># 恢复标准输出</span>sys<span class="token punctuation">.</span>stdout <span class="token operator">=</span> sys<span class="token punctuation">.</span>__stdout__<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这行内容将显示在控制台"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sysversionversion_info"><a class="markdownIt-Anchor" href="#sysversionversion_info"></a> sys.version/version_info</h2><p>描述：提供了当前 Python 解释器的版本信息。<br />语法：<code>sys.version</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Python 版本:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"版本信息:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>version_info<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="syspath"><a class="markdownIt-Anchor" href="#syspath"></a> sys.path</h2><p>描述：列表，包含了 Python 解释器在导入模块时搜索的路径。可以修改这个列表来添加自定义的模块搜索路径。<br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"模块搜索路径:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>path<span class="token punctuation">)</span>sys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'/custom/path'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"更新后的模块搜索路径:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>sys.modules</code></td><td>已加载模块的字典</td></tr><tr><td><code>sys.platform</code></td><td>操作系统平台标识（如 <code>'win32'</code>, <code>'linux'</code>, <code>'darwin'</code>）</td></tr><tr><td><code>sys.executable</code></td><td>Python 解释器的绝对路径</td></tr><tr><td><code>sys.byteorder</code></td><td>字节序（<code>'little'</code> 或 <code>'big'</code>）</td></tr><tr><td><code>sys.maxsize</code></td><td>最大整数值（<code>2**31-1</code> 或 <code>2**63-1</code>）</td></tr></tbody></table><h1 id="argparser库"><a class="markdownIt-Anchor" href="#argparser库"></a> argparser库</h1><h2 id="argumentparser"><a class="markdownIt-Anchor" href="#argumentparser"></a> ArgumentParser</h2><p>描述：用于创建解析命令行参数的对象。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>prog<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> usage<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> description<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> epilog<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parents<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> formatter_class<span class="token operator">=</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'argparse.HelpFormatter'</span><span class="token operator">></span><span class="token punctuation">,</span> prefix_chars<span class="token operator">=</span><span class="token string">'-'</span><span class="token punctuation">,</span> fromfile_prefix_chars<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> argument_default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> conflict_handler<span class="token operator">=</span><span class="token string">'error'</span><span class="token punctuation">,</span> add_help<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> argparseparser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">"Example parser"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="add_argument重点"><a class="markdownIt-Anchor" href="#add_argument重点"></a> add_argument——重点</h2><p>描述：向ArgumentParser对象添加命令行参数。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span>name <span class="token keyword">or</span> flags<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store'</span><span class="token punctuation">,</span> nargs<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> const<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> choices<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> required<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> metavar<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--verbose'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'Increase output verbosity'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>补充：</p><table><thead><tr><th>键</th><th>接受的值</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td>name</td><td>字符串</td><td>变量的名字</td><td>‘radius’</td></tr><tr><td>nargs</td><td>数字或’?‘或’‘或’+’</td><td>用来说明传入的参数个数（符号意义和正则表达式里的一致)</td><td>nargs=’?’ nargs=2</td></tr><tr><td>type</td><td>list, str, tuple, set, dict等</td><td>设置读取参数的类型</td><td>type=int</td></tr><tr><td>default</td><td>类型跟type统一</td><td>设置默认值</td><td>default=1</td></tr><tr><td>choices</td><td>装选项的list</td><td>参数值只能从几个选项里面选择</td><td>choices=[1,2,3,4]</td></tr><tr><td>required</td><td>True或False</td><td>这个可选参数是否必须有（只能用于可选参数！否则报错）</td><td>required=True</td></tr><tr><td>help</td><td>字符串</td><td>说明一下这个参数是干嘛的</td><td>help=“I don’t know”</td></tr><tr><td>action</td><td>六种内置动作</td><td>一旦这个有参数，就会触发相应的动作</td><td>action=‘store_true’</td></tr></tbody></table><h2 id="parse_args"><a class="markdownIt-Anchor" href="#parse_args"></a> parse_args</h2><p>描述：解析命令行参数。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span>args<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> namespace<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">[</span>arg name<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="set_defaults"><a class="markdownIt-Anchor" href="#set_defaults"></a> set_defaults</h2><p>描述：为指定的参数设置默认值。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>set_defaults<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>set_defaults<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"John Doe"</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="print_help"><a class="markdownIt-Anchor" href="#print_help"></a> print_help</h2><p>描述：打印帮助信息。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>print_help<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>print_help<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="add_subparsers"><a class="markdownIt-Anchor" href="#add_subparsers"></a> add_subparsers</h2><p>描述：为ArgumentParser对象添加子命令解析器。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>add_subparsers<span class="token punctuation">(</span>dest<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parser_class<span class="token operator">=</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'argparse.ArgumentParser'</span><span class="token operator">></span><span class="token punctuation">,</span> required<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">subparsers <span class="token operator">=</span> parser<span class="token punctuation">.</span>add_subparsers<span class="token punctuation">(</span>dest<span class="token operator">=</span><span class="token string">'command'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这上面几个是最常用的。</p></blockquote><hr /><h2 id="add_mutually_exclusive_group"><a class="markdownIt-Anchor" href="#add_mutually_exclusive_group"></a> add_mutually_exclusive_group</h2><p>描述：创建一个互斥的参数组，同一时间只能使用组内一个参数。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>add_mutually_exclusive_group<span class="token punctuation">(</span>required<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">group <span class="token operator">=</span> parser<span class="token punctuation">.</span>add_mutually_exclusive_group<span class="token punctuation">(</span><span class="token punctuation">)</span>group<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--foo'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">)</span>group<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--bar'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="parse_known_args"><a class="markdownIt-Anchor" href="#parse_known_args"></a> parse_known_args</h2><p>描述：解析命令行参数，但返回一个包含已知参数和未知参数的元组。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>parse_known_args<span class="token punctuation">(</span>args<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> namespace<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">args<span class="token punctuation">,</span> unknown <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_known_args<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="convert_arg_line_to_args"><a class="markdownIt-Anchor" href="#convert_arg_line_to_args"></a> convert_arg_line_to_args</h2><p>描述：将从文件读取的一行转换为参数列表。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>convert_arg_line_to_args<span class="token punctuation">(</span>arg_line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">args <span class="token operator">=</span> parser<span class="token punctuation">.</span>convert_arg_line_to_args<span class="token punctuation">(</span><span class="token string">"foo --bar=3"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="error"><a class="markdownIt-Anchor" href="#error"></a> error</h2><p>描述：在命令行参数解析过程中发生错误时，抛出异常并输出错误信息。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>error<span class="token punctuation">(</span>message<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>error<span class="token punctuation">(</span><span class="token string">"Invalid argument"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="exit"><a class="markdownIt-Anchor" href="#exit"></a> exit</h2><p>描述：在解析命令行参数时遇到错误时，退出程序。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>exit<span class="token punctuation">(</span>status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> message<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>exit<span class="token punctuation">(</span>message<span class="token operator">=</span><span class="token string">"Exiting due to error"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="parse_args_from_file"><a class="markdownIt-Anchor" href="#parse_args_from_file"></a> parse_args_from_file</h2><p>描述：从文件中读取参数并解析。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>parse_args_from_file<span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>parse_args_from_file<span class="token punctuation">(</span><span class="token string">'args.txt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="add_argument_group"><a class="markdownIt-Anchor" href="#add_argument_group"></a> add_argument_group</h2><p>描述：创建一个参数组，用于组织和描述相关参数。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>add_argument_group<span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> description<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">group <span class="token operator">=</span> parser<span class="token punctuation">.</span>add_argument_group<span class="token punctuation">(</span><span class="token string">'Optional arguments'</span><span class="token punctuation">)</span>group<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--output'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'Output file'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="format_help"><a class="markdownIt-Anchor" href="#format_help"></a> format_help</h2><p>描述：返回当前帮助信息的格式化字符串。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>format_help<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">help_text <span class="token operator">=</span> parser<span class="token punctuation">.</span>format_help<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="python" scheme="https://blog.godmao.top/categories/python/"/>
    
    
    <category term="python" scheme="https://blog.godmao.top/Tags/python/"/>
    
    <category term="sys" scheme="https://blog.godmao.top/Tags/sys/"/>
    
    <category term="argparse" scheme="https://blog.godmao.top/Tags/argparse/"/>
    
  </entry>
  
  <entry>
    <title>大蟒蛇-shutil库</title>
    <link href="https://blog.godmao.top/posts/22415/"/>
    <id>https://blog.godmao.top/posts/22415/</id>
    <published>2025-09-29T12:41:07.000Z</published>
    <updated>2025-09-29T14:02:36.939Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><p>shutil库主要用于文件的高级操作，比如移动、复制、压缩和解压</p><h2 id="shutilcopy"><a class="markdownIt-Anchor" href="#shutilcopy"></a> shutil.copy</h2><p>描述：复制文件到指定路径。<br />语法：<code>shutil.copy(src, dst)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shutilshutil<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token string">'source.txt'</span><span class="token punctuation">,</span> <span class="token string">'destination.txt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="shutilcopy2"><a class="markdownIt-Anchor" href="#shutilcopy2"></a> shutil.copy2</h2><p>描述：复制文件到指定路径，同时保留文件的元数据。<br />语法：<code>shutil.copy2(src, dst)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shutilshutil<span class="token punctuation">.</span>copy2<span class="token punctuation">(</span><span class="token string">'source.txt'</span><span class="token punctuation">,</span> <span class="token string">'destination.txt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="shutilcopytree"><a class="markdownIt-Anchor" href="#shutilcopytree"></a> shutil.copytree</h2><p>描述：递归复制整个目录树。<br />语法：<code>shutil.copytree(src, dst)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shutilshutil<span class="token punctuation">.</span>copytree<span class="token punctuation">(</span><span class="token string">'source_dir'</span><span class="token punctuation">,</span> <span class="token string">'destination_dir'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="shutilmove"><a class="markdownIt-Anchor" href="#shutilmove"></a> shutil.move</h2><p>描述：移动文件或目录到指定路径。<br />语法：<code>shutil.move(src, dst)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shutilshutil<span class="token punctuation">.</span>move<span class="token punctuation">(</span><span class="token string">'source.txt'</span><span class="token punctuation">,</span> <span class="token string">'destination.txt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="shutilrmtree"><a class="markdownIt-Anchor" href="#shutilrmtree"></a> shutil.rmtree</h2><p>描述：递归删除目录树。慎用！<br />语法：<code>shutil.rmtree(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shutilshutil<span class="token punctuation">.</span>rmtree<span class="token punctuation">(</span><span class="token string">'directory'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="shutildisk_usage"><a class="markdownIt-Anchor" href="#shutildisk_usage"></a> shutil.disk_usage</h2><p>描述：返回磁盘的总容量、已用空间和剩余空间。<br />语法：<code>shutil.disk_usage(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shutiltotal<span class="token punctuation">,</span> used<span class="token punctuation">,</span> free <span class="token operator">=</span> shutil<span class="token punctuation">.</span>disk_usage<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Total: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>total<span class="token punctuation">&#125;</span></span><span class="token string">, Used: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>used<span class="token punctuation">&#125;</span></span><span class="token string">, Free: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>free<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="shutilchown"><a class="markdownIt-Anchor" href="#shutilchown"></a> shutil.chown</h2><p>描述：改变文件或目录的所有者和组。<br />语法：<code>shutil.chown(path, user=None, group=None)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shutilshutil<span class="token punctuation">.</span>chown<span class="token punctuation">(</span><span class="token string">'file.txt'</span><span class="token punctuation">,</span> user<span class="token operator">=</span><span class="token string">'username'</span><span class="token punctuation">,</span> group<span class="token operator">=</span><span class="token string">'groupname'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="shutilunpack_archive"><a class="markdownIt-Anchor" href="#shutilunpack_archive"></a> shutil.unpack_archive</h2><p>描述：解压归档文件。<br />语法：<code>shutil.unpack_archive(filename, extract_dir=None)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shutilshutil<span class="token punctuation">.</span>unpack_archive<span class="token punctuation">(</span><span class="token string">'archive.zip'</span><span class="token punctuation">,</span> <span class="token string">'destination_folder'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="shutilget_archive_formats"><a class="markdownIt-Anchor" href="#shutilget_archive_formats"></a> shutil.get_archive_formats</h2><p>描述：获取支持的归档格式列表。<br />语法：<code>shutil.get_archive_formats()</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shutilformats <span class="token operator">=</span> shutil<span class="token punctuation">.</span>get_archive_formats<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>formats<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="shutilmake_archive"><a class="markdownIt-Anchor" href="#shutilmake_archive"></a> shutil.make_archive</h2><p>描述：创建一个归档文件。<br />语法：<code>shutil.make_archive(base_name, format, root_dir=None, base_dir=None)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shutilshutil<span class="token punctuation">.</span>make_archive<span class="token punctuation">(</span><span class="token string">'archive_name'</span><span class="token punctuation">,</span> <span class="token string">'zip'</span><span class="token punctuation">,</span> <span class="token string">'folder_to_compress'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="shutilmove-2"><a class="markdownIt-Anchor" href="#shutilmove-2"></a> shutil.move</h2><p>描述：移动文件或目录到指定路径。<br />语法：<code>shutil.move(src, dst)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> shutilshutil<span class="token punctuation">.</span>move<span class="token punctuation">(</span><span class="token string">'source.txt'</span><span class="token punctuation">,</span> <span class="token string">'destination_folder'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="python" scheme="https://blog.godmao.top/categories/python/"/>
    
    
    <category term="python" scheme="https://blog.godmao.top/Tags/python/"/>
    
    <category term="shutil" scheme="https://blog.godmao.top/Tags/shutil/"/>
    
  </entry>
  
  <entry>
    <title>大蟒蛇-pathlib库</title>
    <link href="https://blog.godmao.top/posts/63515/"/>
    <id>https://blog.godmao.top/posts/63515/</id>
    <published>2025-09-28T11:21:17.000Z</published>
    <updated>2025-09-28T11:24:37.373Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h1 id="python-pathlib-模块常用函数速查表"><a class="markdownIt-Anchor" href="#python-pathlib-模块常用函数速查表"></a> Python pathlib 模块常用函数速查表</h1><h2 id="path"><a class="markdownIt-Anchor" href="#path"></a> Path()</h2><p>描述：创建一个路径对象<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pathlib <span class="token keyword">import</span> Pathp <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">"path/to/file"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">"/home/user/test.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="exists"><a class="markdownIt-Anchor" href="#exists"></a> .exists()</h2><p>描述：判断路径是否存在<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="is_file"><a class="markdownIt-Anchor" href="#is_file"></a> .is_file()</h2><p>描述：判断路径是否为文件<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>is_file<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>is_file<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="is_dir"><a class="markdownIt-Anchor" href="#is_dir"></a> .is_dir()</h2><p>描述：判断路径是否为目录<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="is_symlink"><a class="markdownIt-Anchor" href="#is_symlink"></a> .is_symlink()</h2><p>描述：判断路径是否为符号链接<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>is_symlink<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>is_symlink<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="iterdir"><a class="markdownIt-Anchor" href="#iterdir"></a> .iterdir()</h2><p>描述：遍历目录下的所有文件和文件夹<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>iterdir<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> child <span class="token keyword">in</span> p<span class="token punctuation">.</span>iterdir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="glob"><a class="markdownIt-Anchor" href="#glob"></a> .glob()</h2><p>描述：使用通配符匹配文件<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>glob<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> <span class="token builtin">file</span> <span class="token keyword">in</span> p<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">"*.txt"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="rglob"><a class="markdownIt-Anchor" href="#rglob"></a> .rglob()</h2><p>描述：递归匹配文件<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>rglob<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> <span class="token builtin">file</span> <span class="token keyword">in</span> p<span class="token punctuation">.</span>rglob<span class="token punctuation">(</span><span class="token string">"*.py"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="mkdir"><a class="markdownIt-Anchor" href="#mkdir"></a> .mkdir()</h2><p>描述：创建目录<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span>parents<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> exist_ok<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span>parents<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> exist_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="rmdir"><a class="markdownIt-Anchor" href="#rmdir"></a> .rmdir()</h2><p>描述：删除空目录<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>rmdir<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>rmdir<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="unlink"><a class="markdownIt-Anchor" href="#unlink"></a> .unlink()</h2><p>描述：删除文件<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>unlink<span class="token punctuation">(</span>missing_ok<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>unlink<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="rename"><a class="markdownIt-Anchor" href="#rename"></a> .rename()</h2><p>描述：重命名或移动文件<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>rename<span class="token punctuation">(</span><span class="token string">"new_name.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="replace"><a class="markdownIt-Anchor" href="#replace"></a> .replace()</h2><p>描述：重命名并覆盖目标文件<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>target<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"existing_file.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="read_text"><a class="markdownIt-Anchor" href="#read_text"></a> .read_text()</h2><p>描述：读取文本文件内容<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>read_text<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">content <span class="token operator">=</span> p<span class="token punctuation">.</span>read_text<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="write_text"><a class="markdownIt-Anchor" href="#write_text"></a> .write_text()</h2><p>描述：写入文本内容<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>write_text<span class="token punctuation">(</span>data<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>write_text<span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="read_bytes"><a class="markdownIt-Anchor" href="#read_bytes"></a> .read_bytes()</h2><p>描述：读取二进制文件内容<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>read_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> p<span class="token punctuation">.</span>read_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="write_bytes"><a class="markdownIt-Anchor" href="#write_bytes"></a> .write_bytes()</h2><p>描述：写入二进制内容<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>write_bytes<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>write_bytes<span class="token punctuation">(</span><span class="token string">b"binary data"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="joinpath"><a class="markdownIt-Anchor" href="#joinpath"></a> .joinpath()</h2><p>描述：拼接子路径<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token operator">*</span>other<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">new_path <span class="token operator">=</span> p<span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">"subdir"</span><span class="token punctuation">,</span> <span class="token string">"file.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="with_name"><a class="markdownIt-Anchor" href="#with_name"></a> .with_name()</h2><p>描述：返回同目录下更换名称的路径<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>with_name<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">new_p <span class="token operator">=</span> p<span class="token punctuation">.</span>with_name<span class="token punctuation">(</span><span class="token string">"new.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="with_suffix"><a class="markdownIt-Anchor" href="#with_suffix"></a> .with_suffix()</h2><p>描述：更改文件后缀<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>with_suffix<span class="token punctuation">(</span>suffix<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">new_p <span class="token operator">=</span> p<span class="token punctuation">.</span>with_suffix<span class="token punctuation">(</span><span class="token string">".md"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="with_stem"><a class="markdownIt-Anchor" href="#with_stem"></a> .with_stem()</h2><p>描述：更改文件主名<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>with_stem<span class="token punctuation">(</span>stem<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">new_p <span class="token operator">=</span> p<span class="token punctuation">.</span>with_stem<span class="token punctuation">(</span><span class="token string">"newfile"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="resolve"><a class="markdownIt-Anchor" href="#resolve"></a> .resolve()</h2><p>描述：返回绝对路径<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span>strict<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">abs_path <span class="token operator">=</span> p<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="absolute"><a class="markdownIt-Anchor" href="#absolute"></a> .absolute()</h2><p>描述：获取绝对路径（不解析符号链接）<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>absolute<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">abs_path <span class="token operator">=</span> p<span class="token punctuation">.</span>absolute<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="parent"><a class="markdownIt-Anchor" href="#parent"></a> .parent</h2><p>描述：返回父目录路径<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>parent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parent_dir <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="parents"><a class="markdownIt-Anchor" href="#parents"></a> .parents</h2><p>描述：返回所有上级目录<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>parents<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> parent <span class="token keyword">in</span> p<span class="token punctuation">.</span>parents<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="name"><a class="markdownIt-Anchor" href="#name"></a> .name</h2><p>描述：获取文件名（含后缀）<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="stem"><a class="markdownIt-Anchor" href="#stem"></a> .stem</h2><p>描述：获取文件主名（不含后缀）<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>stem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>stem<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="suffix"><a class="markdownIt-Anchor" href="#suffix"></a> .suffix</h2><p>描述：获取文件后缀<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>suffix<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>suffix<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="suffixes"><a class="markdownIt-Anchor" href="#suffixes"></a> .suffixes</h2><p>描述：获取所有后缀（适用于多重后缀）<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>suffixes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>suffixes<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="as_posix"><a class="markdownIt-Anchor" href="#as_posix"></a> .as_posix()</h2><p>描述：转换为POSIX风格路径字符串<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>as_posix<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>as_posix<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="as_uri"><a class="markdownIt-Anchor" href="#as_uri"></a> .as_uri()</h2><p>描述：转换为文件URI<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>as_uri<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>as_uri<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="relative_to"><a class="markdownIt-Anchor" href="#relative_to"></a> .relative_to()</h2><p>描述：计算相对路径<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>relative_to<span class="token punctuation">(</span><span class="token operator">*</span>other<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">rel <span class="token operator">=</span> p<span class="token punctuation">.</span>relative_to<span class="token punctuation">(</span><span class="token string">"/home/user"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="expanduser"><a class="markdownIt-Anchor" href="#expanduser"></a> .expanduser()</h2><p>描述：展开 <code>~</code> 为用户主目录<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">"~/file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="match"><a class="markdownIt-Anchor" href="#match"></a> .match()</h2><p>描述：路径是否匹配指定模式<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span><span class="token string">"*.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="chmod"><a class="markdownIt-Anchor" href="#chmod"></a> .chmod()</h2><p>描述：修改文件权限<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>chmod<span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>chmod<span class="token punctuation">(</span><span class="token number">0o755</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="stat"><a class="markdownIt-Anchor" href="#stat"></a> .stat()</h2><p>描述：获取文件的状态信息（大小、权限等）<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">info <span class="token operator">=</span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span>st_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="touch"><a class="markdownIt-Anchor" href="#touch"></a> .touch()</h2><p>描述：创建空文件或更新修改时间<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Path<span class="token punctuation">.</span>touch<span class="token punctuation">(</span>exist_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">p<span class="token punctuation">.</span>touch<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="python" scheme="https://blog.godmao.top/categories/python/"/>
    
    
    <category term="python" scheme="https://blog.godmao.top/Tags/python/"/>
    
    <category term="pathlib" scheme="https://blog.godmao.top/Tags/pathlib/"/>
    
  </entry>
  
  <entry>
    <title>Python中元组、列表、字典和集合的区别</title>
    <link href="https://blog.godmao.top/posts/53459/"/>
    <id>https://blog.godmao.top/posts/53459/</id>
    <published>2025-09-28T08:38:06.000Z</published>
    <updated>2025-09-28T08:41:37.862Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><p>在Python中，元组（Tuple）、列表（List）、字典（Dictionary）和集合（Set）是四种常用的数据结构，它们各自有不同的特点和应用场景。</p><h2 id="列表list"><a class="markdownIt-Anchor" href="#列表list"></a> 列表（List）</h2><p>列表是一种有序且可变的数据序列，允许存储重复元素。</p><ul><li>定义方式：使用方括号 <em>[]</em>，例如 <em>example_list = [1, 2, “apple”, True]</em>。</li><li>特点：支持通过索引访问元素，可以动态添加、删除或修改元素。</li><li>应用场景：适用于需要频繁修改的有序数据集，例如购物清单或动态数组。</li></ul><h2 id="元组tuple"><a class="markdownIt-Anchor" href="#元组tuple"></a> 元组（Tuple）</h2><p>元组是一种有序但不可变的数据序列，允许存储重复元素。</p><ul><li>定义方式：使用圆括号 <em>()</em>，例如 <em>example_tuple = (1, 2, “apple”, True)</em>。</li><li>特点：一旦创建后，内容无法更改，适合存储固定不变的数据。</li><li>应用场景：适用于需要保护数据不被修改的场景，例如坐标点或数据库查询结果。</li></ul><h2 id="集合set"><a class="markdownIt-Anchor" href="#集合set"></a> 集合（Set）</h2><p>集合是一种无序且不允许重复的元素集合。</p><ul><li>定义方式：使用大括号 <em>{}</em> 或 <em>set()</em> 函数，例如 <em>example_set = {1, 2, “apple”, True}</em>。</li><li>特点：不支持索引访问，但可以进行数学集合运算（如交集、并集）。</li><li>应用场景：适用于需要去重或快速判断元素是否存在的场景，例如处理唯一值集合。</li></ul><h2 id="字典dictionary"><a class="markdownIt-Anchor" href="#字典dictionary"></a> 字典（Dictionary）</h2><p>字典是一种键值对的映射容器，其中键必须唯一，值可以重复。</p><ul><li>定义方式：使用大括号 <em>{}</em>，例如 <em>example_dict = {“name”: “Alice”, “age”: 25}</em>。</li><li>特点：从Python 3.7开始，字典的插入顺序保持不变。支持通过键快速查找对应的值。</li><li>应用场景：适用于存储键值映射关系的数据，例如配置文件或数据库表结构。</li></ul><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li>有序性：列表和元组是有序的，集合和字典无序（但字典从Python 3.7起保持插入顺序）。</li><li>可变性：列表和字典是可变的，元组不可变，集合可变但不支持索引。</li><li>重复性：集合不允许重复元素，其他三种结构允许重复（字典的键必须唯一）。</li><li>应用场景：根据数据的有序性、可变性和重复性需求选择合适的数据结构。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="python" scheme="https://blog.godmao.top/categories/python/"/>
    
    
    <category term="python" scheme="https://blog.godmao.top/Tags/python/"/>
    
  </entry>
  
  <entry>
    <title>大蟒蛇-os库</title>
    <link href="https://blog.godmao.top/posts/37113/"/>
    <id>https://blog.godmao.top/posts/37113/</id>
    <published>2025-09-28T07:25:58.000Z</published>
    <updated>2025-09-28T11:21:43.056Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h1 id="python-os-模块函数大全速查表"><a class="markdownIt-Anchor" href="#python-os-模块函数大全速查表"></a> Python <code>os</code> 模块函数大全速查表</h1><p><code>os</code> 模块是 Python 标准库中用于与操作系统交互的接口，涵盖了文件/目录操作、环境变量管理、系统信息获取、进程控制等诸多功能。本文整理了常用函数及示例，便于查阅使用。</p><h2 id="osgetcwd"><a class="markdownIt-Anchor" href="#osgetcwd"></a> os.getcwd()</h2><p>描述：获取当前工作目录<br />语法：<code>os.getcwd()</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="oschdir"><a class="markdownIt-Anchor" href="#oschdir"></a> os.chdir()</h2><p>描述：改变当前工作目录<br />语法：<code>os.chdir(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">"/home/user"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="oslistdir"><a class="markdownIt-Anchor" href="#oslistdir"></a> os.listdir()</h2><p>描述：返回指定目录下的文件和文件夹列表<br />语法：<code>os.listdir(path=&quot;.&quot;)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osmkdir"><a class="markdownIt-Anchor" href="#osmkdir"></a> os.mkdir()</h2><p>描述：创建单层目录<br />语法：<code>os.mkdir(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>mkdir<span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osmakedirs"><a class="markdownIt-Anchor" href="#osmakedirs"></a> os.makedirs()</h2><p>描述：创建多级目录<br />语法：<code>os.makedirs(path, exist_ok=False)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span><span class="token string">"a/b/c"</span><span class="token punctuation">,</span> exist_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osrmdir"><a class="markdownIt-Anchor" href="#osrmdir"></a> os.rmdir()</h2><p>描述：删除空目录<br />语法：<code>os.rmdir(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>rmdir<span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osremovedirs"><a class="markdownIt-Anchor" href="#osremovedirs"></a> os.removedirs()</h2><p>描述：删除多级空目录<br />语法：<code>os.removedirs(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>removedirs<span class="token punctuation">(</span><span class="token string">"a/b/c"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osremove"><a class="markdownIt-Anchor" href="#osremove"></a> os.remove()</h2><p>描述：删除文件<br />语法：<code>os.remove(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osrename"><a class="markdownIt-Anchor" href="#osrename"></a> os.rename()</h2><p>描述：重命名文件或目录<br />语法：<code>os.rename(src, dst)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>rename<span class="token punctuation">(</span><span class="token string">"old.txt"</span><span class="token punctuation">,</span> <span class="token string">"new.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osreplace"><a class="markdownIt-Anchor" href="#osreplace"></a> os.replace()</h2><p>描述：重命名文件，如果目标已存在会被覆盖<br />语法：<code>os.replace(src, dst)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">,</span> <span class="token string">"b.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osstat"><a class="markdownIt-Anchor" href="#osstat"></a> os.stat()</h2><p>描述：获取文件状态信息<br />语法：<code>os.stat(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">info <span class="token operator">=</span> os<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span>st_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="oswalk"><a class="markdownIt-Anchor" href="#oswalk"></a> os.walk()</h2><p>描述：递归遍历目录树<br />语法：<code>os.walk(top, topdown=True, onerror=None, followlinks=False)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> root<span class="token punctuation">,</span> dirs<span class="token punctuation">,</span> files <span class="token keyword">in</span> os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> dirs<span class="token punctuation">,</span> files<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>补充：<br /><code>top</code>：要遍历的顶级目录的路径。<br /><code>topdown (可选)</code>：如果为 True（默认值），则从顶级开始向下遍历。如果为 False，则从底部的子目录开始向上遍历。<br /><code>onerror (可选)</code>：是一个函数，用于错误处理。如果指定，则应该是一个接受单个参数（异常实例）的函数。如果未指定或为 None，错误将被忽略。<br /><code>followlinks (可选)</code>：如果为 True，则会遍历符号链接指向的目录。</p><h2 id="osscandir"><a class="markdownIt-Anchor" href="#osscandir"></a> os.scandir()</h2><p>描述：高效迭代目录项<br />语法：<code>os.scandir(path=&quot;.&quot;)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">traversal_files</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> os<span class="token punctuation">.</span>scandir<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> item<span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          dirs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">.</span>path<span class="token punctuation">)</span>        <span class="token keyword">elif</span> item<span class="token punctuation">.</span>is_file<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>          files<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">.</span>path<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'dirs:'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>dirs<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'files:'</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">)</span>traversal_files<span class="token punctuation">(</span><span class="token string">r'./test'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ospathjoin"><a class="markdownIt-Anchor" href="#ospathjoin"></a> os.path.join()</h2><p>描述：拼接路径<br />语法：<code>os.path.join(path, *paths)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">"folder"</span><span class="token punctuation">,</span> <span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ospathabspath"><a class="markdownIt-Anchor" href="#ospathabspath"></a> os.path.abspath()</h2><p>描述：获取绝对路径<br />语法：<code>os.path.abspath(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>abspath<span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ospathbasename"><a class="markdownIt-Anchor" href="#ospathbasename"></a> os.path.basename()</h2><p>描述：获取路径中的文件名<br />语法：<code>os.path.basename(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>basename<span class="token punctuation">(</span><span class="token string">"/home/user/file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ospathdirname"><a class="markdownIt-Anchor" href="#ospathdirname"></a> os.path.dirname()</h2><p>描述：获取路径中的目录部分<br />语法：<code>os.path.dirname(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span><span class="token string">"/home/user/file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ospathexists"><a class="markdownIt-Anchor" href="#ospathexists"></a> os.path.exists()</h2><p>描述：判断路径是否存在<br />语法：<code>os.path.exists(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ospathisfile"><a class="markdownIt-Anchor" href="#ospathisfile"></a> os.path.isfile()</h2><p>描述：判断路径是否为文件<br />语法：<code>os.path.isfile(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isfile<span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ospathisdir"><a class="markdownIt-Anchor" href="#ospathisdir"></a> os.path.isdir()</h2><p>描述：判断路径是否为目录<br />语法：<code>os.path.isdir(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span><span class="token string">"folder"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ospathsplitext"><a class="markdownIt-Anchor" href="#ospathsplitext"></a> os.path.splitext()</h2><p>描述：分离文件名与扩展名<br />语法：<code>os.path.splitext(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>splitext<span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ospathgetsize"><a class="markdownIt-Anchor" href="#ospathgetsize"></a> os.path.getsize()</h2><p>描述：获取文件大小（字节）<br />语法：<code>os.path.getsize(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>getsize<span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osenviron"><a class="markdownIt-Anchor" href="#osenviron"></a> os.environ</h2><p>描述：环境变量相关<br />语法：<code>os.environ</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 获取环境变量</span>value <span class="token operator">=</span> os<span class="token punctuation">.</span>environ<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"HOME"</span><span class="token punctuation">)</span> <span class="token comment"># 如果不存在返回 None</span><span class="token comment"># 修改环境变量</span>os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"MY_VAR"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"123"</span>os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"PATH"</span><span class="token punctuation">]</span> <span class="token operator">=</span> os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"PATH"</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">":/my/custom/path"</span><span class="token comment"># 删除 MY_VAR</span><span class="token keyword">del</span> os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"MY_VAR"</span><span class="token punctuation">]</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ossystem"><a class="markdownIt-Anchor" href="#ossystem"></a> os.system()</h2><p>描述：执行系统命令  <strong>不推荐，推荐<code>subprocess</code></strong><br />语法：<code>os.system(command)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ospopen"><a class="markdownIt-Anchor" href="#ospopen"></a> os.popen()</h2><p>描述：执行命令并获取输出<br />语法：<code>os.popen(command)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">output <span class="token operator">=</span> os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="osgetpid"><a class="markdownIt-Anchor" href="#osgetpid"></a> os.getpid()</h2><p>描述：获取当前进程 ID<br />语法：<code>os.getpid()</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osgetppid"><a class="markdownIt-Anchor" href="#osgetppid"></a> os.getppid()</h2><p>描述：获取父进程 ID<br />语法：<code>os.getppid()</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>getppid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osgetlogin"><a class="markdownIt-Anchor" href="#osgetlogin"></a> os.getlogin()</h2><p>描述：获取当前登录用户<br />语法：<code>os.getlogin()</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>getlogin<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osgetuid-osgetgid"><a class="markdownIt-Anchor" href="#osgetuid-osgetgid"></a> os.getuid() / os.getgid()</h2><p>描述：获取当前进程用户/组 ID<br />语法：<code>os.getuid()</code> / <code>os.getgid()</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>getuid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>getgid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ossetuid-ossetgid"><a class="markdownIt-Anchor" href="#ossetuid-ossetgid"></a> os.setuid() / os.setgid()</h2><p>描述：设置用户/组 ID<br />语法：<code>os.setuid(uid)</code> / <code>os.setgid(gid)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>setuid<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osumask"><a class="markdownIt-Anchor" href="#osumask"></a> os.umask()</h2><p>描述：设置文件创建掩码<br />语法：<code>os.umask(mask)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>umask<span class="token punctuation">(</span><span class="token number">0o022</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="oschmod"><a class="markdownIt-Anchor" href="#oschmod"></a> os.chmod()</h2><p>描述：修改文件权限<br />语法：<code>os.chmod(path, mode)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>chmod<span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">,</span> <span class="token number">0o644</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="oslink"><a class="markdownIt-Anchor" href="#oslink"></a> os.link()</h2><p>描述：创建硬链接<br />语法：<code>os.link(src, dst)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>link<span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">,</span> <span class="token string">"b.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ossymlink"><a class="markdownIt-Anchor" href="#ossymlink"></a> os.symlink()</h2><p>描述：创建符号链接<br />语法：<code>os.symlink(src, dst)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>symlink<span class="token punctuation">(</span><span class="token string">"a.txt"</span><span class="token punctuation">,</span> <span class="token string">"link.txt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osreadlink"><a class="markdownIt-Anchor" href="#osreadlink"></a> os.readlink()</h2><p>描述：获取符号链接指向的路径<br />语法：<code>os.readlink(path)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>readlink<span class="token punctuation">(</span><span class="token string">"link.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osutime"><a class="markdownIt-Anchor" href="#osutime"></a> os.utime()</h2><p>描述：修改文件的访问和修改时间<br />语法：<code>os.utime(path, times=None)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>utime<span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1620000000</span><span class="token punctuation">,</span> <span class="token number">1620000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ostruncate"><a class="markdownIt-Anchor" href="#ostruncate"></a> os.truncate()</h2><p>描述：截断文件到指定大小<br />语法：<code>os.truncate(path, length)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">os<span class="token punctuation">.</span>truncate<span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osurandom"><a class="markdownIt-Anchor" href="#osurandom"></a> os.urandom()</h2><p>描述：生成随机字节数据<br />语法：<code>os.urandom(n)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>urandom<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="oscpu_count"><a class="markdownIt-Anchor" href="#oscpu_count"></a> os.cpu_count()</h2><p>描述：返回 CPU 核心数<br />语法：<code>os.cpu_count()</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osuname"><a class="markdownIt-Anchor" href="#osuname"></a> os.uname()</h2><p>描述：返回操作系统信息<br />语法：<code>os.uname()</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>uname<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osname"><a class="markdownIt-Anchor" href="#osname"></a> <a href="http://os.name">os.name</a></h2><p>描述：获取操作系统类型标识<br />语法：<code>os.name</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ossep"><a class="markdownIt-Anchor" href="#ossep"></a> os.sep</h2><p>描述：路径分隔符<br />语法：<code>os.sep</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>sep<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="oslinesep"><a class="markdownIt-Anchor" href="#oslinesep"></a> os.linesep</h2><p>描述：行分隔符<br />语法：<code>os.linesep</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">repr</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>linesep<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="ospathsep"><a class="markdownIt-Anchor" href="#ospathsep"></a> os.pathsep</h2><p>描述：系统路径分隔符<br />语法：<code>os.pathsep</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>pathsep<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="osdevnull"><a class="markdownIt-Anchor" href="#osdevnull"></a> os.devnull</h2><p>描述：空设备路径，用于丢弃输出<br />语法：<code>os.devnull</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>devnull<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">"This goes nowhere"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="python" scheme="https://blog.godmao.top/categories/python/"/>
    
    
    <category term="python" scheme="https://blog.godmao.top/Tags/python/"/>
    
    <category term="os" scheme="https://blog.godmao.top/Tags/os/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核模块初体验</title>
    <link href="https://blog.godmao.top/posts/49513/"/>
    <id>https://blog.godmao.top/posts/49513/</id>
    <published>2025-09-27T07:48:35.000Z</published>
    <updated>2025-10-01T11:59:17.596Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><blockquote><p>本篇摘自野火嵌入式Linux系列教程驱动开发篇</p></blockquote><h2 id="内核模块基本概念"><a class="markdownIt-Anchor" href="#内核模块基本概念"></a> 内核模块基本概念</h2><h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3><p>解决linux内核可扩展性和可维护性相对较差的缺陷</p><h3 id="现代内核派系"><a class="markdownIt-Anchor" href="#现代内核派系"></a> 现代内核派系</h3><p>宏内核：关键功能和服务功能均在内核空间提供</p><ul><li>运行效率高</li><li>扩展性较差</li></ul><p>微内核：内核空间只提供关键功能，服务功能在用户空间提供</p><ul><li>运行效率较低</li><li>安全性、扩展性较高</li></ul><h3 id="内核模块加载卸载"><a class="markdownIt-Anchor" href="#内核模块加载卸载"></a> 内核模块加载/卸载</h3><ul><li><p>使用insmod命令加载</p></li><li><p>使用rmmod命令卸载</p></li></ul><h3 id="内核模块入口出口"><a class="markdownIt-Anchor" href="#内核模块入口出口"></a> 内核模块入口/出口</h3><ul><li>module_init()：加载模块式该函数自动执行，进行初始化操作</li><li>module_exit()：卸载模块时函数自动执行，进行清理操作</li></ul><h3 id="内核模块信息声明"><a class="markdownIt-Anchor" href="#内核模块信息声明"></a> 内核模块信息声明</h3><ul><li>MODULE_LICENSE()：表示模块代码接受的软件许可协议，Linux内核遵循GPL V2开源协议，内核模块与linux内核保持一致即可。</li><li>MODULE_AUTHOR()：描述模块的作者信息</li><li>MODULE_DESCRIPTION()：对模块的简单介绍</li><li>MODULE_ALIAS()：给模块设置一个别名</li></ul><h2 id="内核模块实验1"><a class="markdownIt-Anchor" href="#内核模块实验1"></a> 内核模块实验1</h2><h3 id="实验环境"><a class="markdownIt-Anchor" href="#实验环境"></a> 实验环境</h3><ul><li>开发板烧录好Debian镜像。</li><li>SSH连接MobaXterm</li><li>启动开发板，搭建好SFTP。</li><li>获取Debian镜像的内核源码并编译。</li></ul><h3 id="编译41971版本内核"><a class="markdownIt-Anchor" href="#编译41971版本内核"></a> 编译4.19.71版本内核</h3><p>内核模块的功能需要依赖内核提供的各种底层接口</p><p>1.下载linux内核源码</p><p>​github:</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;Embedfire&#x2F;ebf-buster-linux.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​gitee:</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;gitee.com&#x2F;Embedfire&#x2F;ebf-buster-linux.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.安装必要环境工具库</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install make gcc-arm-linux-gnueabihf gcc bison flex libssl-dev dpkg-dev lzop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>gcc-arm-linux-gnueabihf 交叉编译器</li><li>bison 语法分析器</li><li>flex 词法分析器</li><li>libssl-dev OpenSSL通用库</li><li>lzop LZO压缩库的压缩软件</li></ul><p>3.一键编译内核</p><pre class="line-numbers language-none"><code class="language-none">sudo .&#x2F;make_deb.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果在电脑上编译不成功且无法解决，可以选择在开发板上编译，代价就是。。。嗯 it takes a long time</p></blockquote><p>4.获取编译出来的内核相关文件</p><pre class="line-numbers language-none"><code class="language-none">YOURPATH&#x2F;ebf_linux_kernel_6ull_depth1&#x2F;build_image&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="内核模块头文件"><a class="markdownIt-Anchor" href="#内核模块头文件"></a> 内核模块头文件</h3><ul><li><code>#include &lt;linux/module.h&gt;</code>：包含内核模块信息声明的相关函数</li><li><code>#include &lt;linux/init.h&gt;</code>：包含了 module_init()和 module_exit()函数的声明</li><li><code>#include &lt;linux/kernel.h&gt;</code>：包含内核提供的各种函数，如printk</li></ul><h3 id="内核模块打印函数"><a class="markdownIt-Anchor" href="#内核模块打印函数"></a> 内核模块打印函数</h3><ul><li><p><code>printf</code>：glibc实现的打印函数，工作于用户空间，不可在内核使用</p></li><li><p><code>printk</code>：内核模块无法使用glibc库函数，内核自身实现的一个类printf函数，但是需要指定打印等级。</p><ul><li><code>#define KERN_EMERG</code> “&lt;0&gt;” 通常是系统崩溃前的信息</li><li><code>#define KERN_ALERT</code>          “&lt;1&gt;” 需要立即处理的消息</li><li><code>#define KERN_CRIT</code>             “&lt;2&gt;” 严重情况</li><li><code>#define KERN_ERR</code>              “&lt;3&gt;” 错误情况</li><li><code>#define KERN_WARNING</code>      “&lt;4&gt;” 有问题的情况</li><li><code>#define KERN_NOTICE</code>       “&lt;5&gt;” 注意信息</li><li><code>#define KERN_INFO</code>            “&lt;6&gt;” 普通消息</li><li><code>#define KERN_DEBUG</code>        “&lt;7&gt;” 调试信息</li></ul></li></ul><p>查看当前系统printk打印等级：<code>cat /proc/sys/kernel/printk</code><br />输出</p><pre class="line-numbers language-none"><code class="language-none">7       4       1       7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示：</p><ul><li>当前控制台日志级别</li><li>默认消息日志级别</li><li>最小的控制台级别</li><li>默认控制台日志级别</li></ul><p>小于等于设定打印等级的消息不会被打印。<br />打印内核所有打印信息：dmesg</p><ul><li>内核log缓冲区大小有限制，缓冲区数据可能被冲掉</li></ul><h3 id="源码展示"><a class="markdownIt-Anchor" href="#源码展示"></a> 源码展示</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h></span></span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_EMERG<span class="token string">"[KERN_EMERG]Hello Kernel!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"[DEFAULT]Hello Kernel!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"[DEFAULT]Goodbye Kernel!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"MIT"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"gdm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MODULE_DESCRIPTION</span><span class="token punctuation">(</span><span class="token string">"print: hello kernel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MODULE_ALIAS</span><span class="token punctuation">(</span><span class="token string">"test_module"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="makefile分析"><a class="markdownIt-Anchor" href="#makefile分析"></a> Makefile分析</h3><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># 定义内核路径</span>KERNEL_DIR<span class="token operator">:=</span>/home/debian/linux/driver_learning/ebf_linux_kernel_6ull_depth1/build_image/build<span class="token comment"># 定义编译工具集</span>ARCH<span class="token operator">:=</span>armCROSS_COMPILE<span class="token operator">:=</span>arm-linux-gnueabihf-<span class="token comment"># 将变量导出，相当于作为环境变量，让内核Makefile继承此变量 否则变量只在当前文件可见。</span><span class="token keyword">export</span> ARCH CROSS_COMPILE<span class="token comment"># 内核模块编译的标准变量，告诉内核编译哪个模块。</span>obj-m<span class="token operator">:=</span>hellokernal.o<span class="token comment"># -C 命令指切换到目标目录的makefile</span><span class="token comment"># M= 可以理解为module，指定模块所在路径</span><span class="token comment"># modules 是内核makefile定义的目标，触发“构建外部模块”完整规则</span><span class="token target symbol">all</span><span class="token punctuation">:</span>    <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>KERNEL_DIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>CURDIR<span class="token punctuation">)</span> moudules<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span>clean<span class="token target symbol">clean</span><span class="token punctuation">:</span>    <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$</span><span class="token punctuation">(</span>KERNEL_DIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>CURDIR<span class="token punctuation">)</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>KERNEL_DIR</code>：指向linux内核具体路径</li><li><code>export</code>：导出变量给子Makefile使用</li><li><code>obj-m</code> := &lt;模块名&gt;.o：定义要生成的模块</li><li><code>$(MAKE)</code>：Makefile的默认变量，值为make</li><li><code>选项”-C”</code>：让make工具跳转到linux内核目录下读取顶层Makefile</li><li><code>M=</code>：表示内核模块源码目录</li><li><code>$(CURDIR)</code>：Makefile默认变量，值为当前目录所在路径</li><li><code>make modules</code>：执行Linux顶层Makefile的伪目标，它实现内核模块的源码读取并编译为.ko文件</li></ul><h3 id="编译内核模块"><a class="markdownIt-Anchor" href="#编译内核模块"></a> 编译内核模块</h3><pre class="line-numbers language-none"><code class="language-none">make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="开发板加载内核模块"><a class="markdownIt-Anchor" href="#开发板加载内核模块"></a> 开发板加载内核模块</h3><pre class="line-numbers language-none"><code class="language-none">insmod xxx.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="内核" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>WSL-Archlinux安装后应该做什么？</title>
    <link href="https://blog.godmao.top/posts/17327/"/>
    <id>https://blog.godmao.top/posts/17327/</id>
    <published>2025-09-18T12:21:15.000Z</published>
    <updated>2025-09-29T14:42:37.877Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><ul><li><a href="#1-%E5%9C%A8wsl%E4%B8%8A%E5%AE%89%E8%A3%85archlinux">1. 在WSL上安装Archlinux</a></li><li><a href="#2-%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F">2. 更新系统</a></li><li><a href="#3-%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE">3. 基础配置</a><ul><li><a href="#31-%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81">3.1. 设置root密码</a></li><li><a href="#32-%E5%88%9B%E5%BB%BA%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%B9%B6%E5%8A%A0%E5%85%A5-wheel-%E7%BB%84%E6%96%B9%E4%BE%BF%E5%90%8E%E7%BB%AD-sudo-%E6%9D%83%E9%99%90">3.2. 创建普通用户并加入 <code>wheel</code> 组（方便后续 sudo 权限）：</a></li><li><a href="#33-%E7%BC%96%E8%BE%91-sudo-%E6%9D%83%E9%99%90">3.3. 编辑 sudo 权限</a></li><li><a href="#34-%E8%AE%BE%E5%AE%9A%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7">3.4. 设定默认用户</a></li><li><a href="#35-%E8%AE%BE%E7%BD%AE%E8%AF%AD%E8%A8%80%E5%92%8C%E5%9C%B0%E5%8C%BA">3.5. 设置语言和地区</a></li><li><a href="#36-aur-%E6%94%AF%E6%8C%81">3.6. AUR 支持</a></li><li><a href="#37-%E5%85%B3%E4%BA%8E%E6%8D%A2%E6%BA%90">3.7. 关于换源</a></li></ul></li><li><a href="#4-%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE">4. 个性化设置</a><ul><li><a href="#41-%E4%BD%BF%E7%94%A8zsh%E6%9B%BF%E4%BB%A3bash">4.1. 使用zsh替代bash</a></li><li><a href="#42-%E4%BD%BF%E7%94%A8oh-my-zsh%E4%B8%BAzsh%E6%8F%90%E4%BE%9B%E6%8F%92%E4%BB%B6%E6%9C%8D%E5%8A%A1">4.2. 使用oh-my-zsh为zsh提供插件服务</a></li><li><a href="#43-%E4%BD%BF%E7%94%A8oh-my-posh%E4%B8%BAzsh%E6%8F%90%E4%BE%9B%E4%B8%BB%E9%A2%98">4.3. 使用oh-my-posh为zsh提供主题</a></li></ul></li></ul><h2 id="1-在wsl上安装archlinux"><a class="markdownIt-Anchor" href="#1-在wsl上安装archlinux"></a> 1. 在WSL上安装Archlinux</h2><p>请参见—— <a href="https://wiki.archlinuxcn.org/wiki/%E5%9C%A8_WSL_%E4%B8%8A%E5%AE%89%E8%A3%85_Arch_Linux">在 WSL 上安装 Arch Linux - Arch Linux 中文维基</a></p><h2 id="2-更新系统"><a class="markdownIt-Anchor" href="#2-更新系统"></a> 2. 更新系统</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pacman <span class="token parameter variable">-Syu</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-基础配置"><a class="markdownIt-Anchor" href="#3-基础配置"></a> 3. 基础配置</h2><h3 id="31-设置root密码"><a class="markdownIt-Anchor" href="#31-设置root密码"></a> 3.1. 设置root密码</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">passwd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="32-创建普通用户并加入-wheel-组方便后续-sudo-权限"><a class="markdownIt-Anchor" href="#32-创建普通用户并加入-wheel-组方便后续-sudo-权限"></a> 3.2. 创建普通用户并加入 <code>wheel</code> 组（方便后续 sudo 权限）：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">useradd</span> <span class="token parameter variable">-m</span> <span class="token parameter variable">-G</span> wheel <span class="token parameter variable">-s</span> /bin/bash yourname<span class="token function">passwd</span> yourname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>-m</code>：自动创建用户目录<br /><code>-G</code>：指定用户组<br /><code>-s</code>：指定shell</p><h3 id="33-编辑-sudo-权限"><a class="markdownIt-Anchor" href="#33-编辑-sudo-权限"></a> 3.3. 编辑 sudo 权限</h3><p>安装 <code>sudo</code>，再启用 <code>wheel</code> 组：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman <span class="token parameter variable">-S</span> <span class="token function">sudo</span> <span class="token function">nano</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">nano</span> /etc/sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>去掉 <code># %wheel ALL=(ALL:ALL) ALL</code> 前的注释</p><blockquote><p>前面带%(如%wheel)则表示这是一个用户组，不带则表示这是一个用户。</p></blockquote><h3 id="34-设定默认用户"><a class="markdownIt-Anchor" href="#34-设定默认用户"></a> 3.4. 设定默认用户</h3><p>不能总是用root用户登录。<br />首先确保该用户已被创建，然后将以下行添加到 <code>/etc/wsl.conf</code>：</p><pre class="line-numbers language-none"><code class="language-none">[user]default&#x3D;username<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="35-设置语言和地区"><a class="markdownIt-Anchor" href="#35-设置语言和地区"></a> 3.5. 设置语言和地区</h3><p>目的是正确显示中文字符</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">locale-gen<span class="token builtin class-name">echo</span> <span class="token string">"LANG=en_US.UTF-8"</span> <span class="token operator">></span> /etc/locale.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>请参见——<a href="https://wiki.archlinuxcn.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E6%9C%AC%E5%9C%B0%E5%8C%96">简体中文本地化 - Arch Linux 中文维基</a></p><h3 id="36-aur-支持"><a class="markdownIt-Anchor" href="#36-aur-支持"></a> 3.6. AUR 支持</h3><p>可以下载来自社区的软件包，这里选用AUR助手 yay<br />选择一个指定目录然后执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman <span class="token parameter variable">-S</span> <span class="token function">git</span> base-devel <span class="token parameter variable">--needed</span>  <span class="token comment">#&lt;-这是基本的开发工具包，如gcc、make</span><span class="token function">git</span> clone https://aur.archlinux.org/yay-bin.git<span class="token builtin class-name">cd</span> yay-binmakepkg <span class="token parameter variable">-si</span> <span class="token comment"># 构建包</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>-s</code>：自动安装依赖<br /><code>-i</code>：编译完成后自动安装生成的包</p><p>请参见——<a href="https://wiki.archlinuxcn.org/wiki/Yay">yay - Arch Linux 中文维基</a></p><h3 id="37-关于换源"><a class="markdownIt-Anchor" href="#37-关于换源"></a> 3.7. 关于换源</h3><p>打开<code>WSL-setting</code>（直接在win11里搜索）的网络设置，将网络模式由<code>NAT</code> 改为 <code>mirror</code>， 则可直接继承宿主机的网络环境。在宿主机使用网络安全工具即可，因此暂时没有换源。</p><h2 id="4-个性化设置"><a class="markdownIt-Anchor" href="#4-个性化设置"></a> 4. 个性化设置</h2><h3 id="41-使用zsh替代bash"><a class="markdownIt-Anchor" href="#41-使用zsh替代bash"></a> 4.1. 使用zsh替代bash</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pacman <span class="token parameter variable">-S</span> <span class="token function">zsh</span>chsh <span class="token parameter variable">-s</span> /bin/zsh <span class="token comment"># 改变默认shell</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="42-使用oh-my-zsh为zsh提供插件服务"><a class="markdownIt-Anchor" href="#42-使用oh-my-zsh为zsh提供插件服务"></a> 4.2. 使用oh-my-zsh为zsh提供插件服务</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yay <span class="token parameter variable">-S</span> oh-my-zsh.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后 可以在 <code>/usr/share/oh-my-zsh</code> 中查看主题文件和插件以及其提供的<code>zshrc</code>配置模板，直接使用配置模板。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /usr/share/oh-my-zsh/zshrc ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入<code>/usr/share/oh-my-zsh\plugins</code>目录 安装自动补全与语法高亮插件（不自带）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/zsh-users/zsh-autosuggestions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/zsh-users/zsh-syntax-highlighting.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>.zshrc</code> 里添加：</p><pre class="line-numbers language-none"><code class="language-none">plugins&#x3D;(git zsh-autosuggestions zsh-syntax-highlighting)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="43-使用oh-my-posh为zsh提供主题"><a class="markdownIt-Anchor" href="#43-使用oh-my-posh为zsh提供主题"></a> 4.3. 使用oh-my-posh为zsh提供主题</h3><p>你也可以使用<code>oh-my-zsh</code>的主题，只不过我更喜欢<code>oh-my-posh</code>的主题</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yay <span class="token parameter variable">-S</span> oh-my-posh-bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样，安装完成后 可以在 <code>/usr/share/oh-my-posh</code> 中查看主题文件，<br />编辑<code>~/.zshrc</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#注释掉ZSH_THEME="robbyrussell"</span><span class="token builtin class-name">eval</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span>oh-my-posh init <span class="token function">zsh</span> <span class="token parameter variable">--config</span> <span class="token string">'amro'</span><span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>建议不要使用类似于 <code>--config ~/.poshthemes/mytheme.omp.json</code>的选项，这可能会出现问题。</p></blockquote><p>重新加载：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="WSL2" scheme="https://blog.godmao.top/Tags/WSL2/"/>
    
    <category term="ArchLinux" scheme="https://blog.godmao.top/Tags/ArchLinux/"/>
    
  </entry>
  
  <entry>
    <title>POSIX IPC：System V 的继任者</title>
    <link href="https://blog.godmao.top/posts/26506/"/>
    <id>https://blog.godmao.top/posts/26506/</id>
    <published>2025-09-15T14:24:58.000Z</published>
    <updated>2025-09-15T14:45:59.965Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><ul><li><a href="#1-posix-ipcsystem-v-%E7%9A%84%E7%BB%A7%E4%BB%BB%E8%80%85">1. POSIX IPC：System V 的继任者</a><ul><li><a href="#11-posix-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">1.1. POSIX 消息队列</a><ul><li><a href="#111-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B1%9E%E6%80%A7">1.1.1. 消息队列属性</a></li></ul></li><li><a href="#12-posix-%E4%BF%A1%E5%8F%B7%E9%87%8F">1.2. POSIX 信号量</a></li><li><a href="#13-posix-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">1.3. POSIX 共享内存</a></li></ul></li></ul><h2 id="1-posix-ipcsystem-v-的继任者"><a class="markdownIt-Anchor" href="#1-posix-ipcsystem-v-的继任者"></a> 1. POSIX IPC：System V 的继任者</h2><p><strong>POSIX IPC</strong>（Portable Operating System Interface）是一套新的 IPC 标准，旨在解决 <strong>System V IPC</strong> 的一些局限性。它提供了一套更统一、更现代的 API，使用<strong>文件名</strong>作为标识符，而不是 System V 的<strong>键值</strong>，这使得 IPC 资源的管理更加直观。</p><h3 id="11-posix-消息队列"><a class="markdownIt-Anchor" href="#11-posix-消息队列"></a> 1.1. POSIX 消息队列</h3><p>与 System V 消息队列类似，但 API 更简洁。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>基于文件</strong>：通过 <code>/dev/mqueue</code> 目录下的文件名来标识。</p></li><li><p><strong>优先级</strong>：支持消息优先级，高优先级的消息会被优先处理。</p></li><li><p><strong>非阻塞模式</strong>：可以设置消息队列为非阻塞模式，防止 <code>mq_send</code> 或 <code>mq_receive</code> 阻塞进程。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>mq_open()</code></strong>：创建或打开一个消息队列。</p></li><li><p><strong><code>mq_send()</code></strong>：发送消息。</p></li><li><p><strong><code>mq_receive()</code></strong>：接收消息。</p></li><li><p><strong><code>mq_close()</code></strong>：关闭消息队列。</p></li><li><p><strong><code>mq_unlink()</code></strong>：删除消息队列。</p></li></ul></li></ul><h4 id="111-消息队列属性"><a class="markdownIt-Anchor" href="#111-消息队列属性"></a> 1.1.1. 消息队列属性</h4><p>在POSIX消息队列中，<strong>消息队列属性</strong>（<code>mq_attr</code>）是用来设置和获取消息队列的特性和参数的结构体。它的主要作用是控制消息队列的行为，例如最大消息数、消息大小等。<code>mq_attr</code>结构体包含了以下几个字段：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mq_attr</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span>    mq_flags<span class="token punctuation">;</span>      <span class="token comment">// 消息队列的标志</span>    <span class="token keyword">long</span>    mq_maxmsg<span class="token punctuation">;</span>     <span class="token comment">// 消息队列中最多可以容纳的消息数量</span>    <span class="token keyword">long</span>    mq_msgsize<span class="token punctuation">;</span>    <span class="token comment">// 队列中每条消息的最大大小</span>    <span class="token keyword">long</span>    mq_curmsgs<span class="token punctuation">;</span>    <span class="token comment">// 当前队列中的消息数</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p><code>mq_flags</code></p><p>这个字段用于设置消息队列的标志。常见的标志有：</p><ul><li><p><strong><code>O_NONBLOCK</code></strong>：以非阻塞模式打开消息队列。这意味着如果消息队列为空，接收操作（<code>mq_receive()</code>）会立即返回，而不是阻塞等待。</p></li><li><p><strong><code>O_RDWR</code></strong>：允许对消息队列进行读写操作。</p></li></ul><p>如果没有设置这些标志，消息队列将会默认阻塞模式操作。</p></li><li><p><code>mq_maxmsg</code></p><p>这个字段定义了消息队列可以容纳的最大消息数量。如果消息队列已经存满，且没有空间容纳新的消息，后续的消息发送（<code>mq_send()</code>）将会被阻塞，直到队列中有足够的空间。这个属性通常设置为你希望消息队列中能存储的消息个数。</p></li><li><p><code>mq_msgsize</code></p><p>此字段定义每条消息的最大字节数。在创建消息队列时，必须确保消息发送和接收操作的消息大小不会超过这个值。如果消息超过了这个大小，发送操作将返回错误。</p></li><li><p><code>mq_curmsgs</code></p><p>这个字段是一个只读属性，用于获取当前队列中的消息数量。它是一个动态更新的值，每次读取时会返回当前消息队列中实际存储的消息数。这个字段对应用程序来说很有用，尤其是在需要了解队列当前状态的场景。</p></li></ol><p>这个例子展示了两个不相关的进程如何通过 POSIX 消息队列进行通信。<br />发送方(sender.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span>          <span class="token comment">/* 动态内存管理及其他辅助功能如exit、abort */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span>           <span class="token comment">/* 提供 O_CREAT, O_RDWR 用于文件控制 */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span>        <span class="token comment">/* 文件属性操作 如chmod、umask */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mqueue.h></span>          <span class="token comment">/* 提供POSIX消息队列支持 */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>          <span class="token comment">/* 提供POSIX接口 */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MQ_NAME</span> <span class="token string">"/my_mq"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">mqd_t</span> mqd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">mq_attr</span> attr<span class="token punctuation">;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"Hello from sender!"</span><span class="token punctuation">;</span>    <span class="token comment">// 设置消息队列属性</span>    attr<span class="token punctuation">.</span>mq_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    attr<span class="token punctuation">.</span>mq_maxmsg <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    attr<span class="token punctuation">.</span>mq_msgsize <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">;</span>    attr<span class="token punctuation">.</span>mq_curmsgs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 创建或打开消息队列</span>    mqd <span class="token operator">=</span> <span class="token function">mq_open</span><span class="token punctuation">(</span>MQ_NAME<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_WRONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mqd <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token class-name">mqd_t</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mq_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sender: Sending message...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 发送消息，优先级为1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mq_send</span><span class="token punctuation">(</span>mqd<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mq_send"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 关闭消息队列描述符</span>    <span class="token function">mq_close</span><span class="token punctuation">(</span>mqd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sender: Message sent and mq closed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接收方(receiver.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mqueue.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MQ_NAME</span> <span class="token string">"/my_mq"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">mqd_t</span> mqd<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">mq_attr</span> attr<span class="token punctuation">;</span>    <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">256</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prio<span class="token punctuation">;</span>    <span class="token comment">// 打开消息队列</span>    mqd <span class="token operator">=</span> <span class="token function">mq_open</span><span class="token punctuation">(</span>MQ_NAME<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mqd <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token class-name">mqd_t</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mq_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 获取消息队列属性</span>    <span class="token function">mq_getattr</span><span class="token punctuation">(</span>mqd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receiver: Waiting for message...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 接收消息</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mq_receive</span><span class="token punctuation">(</span>mqd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> attr<span class="token punctuation">.</span>mq_msgsize<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prio<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mq_receive"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Receiver: Received message: %s (Priority: %u)\n"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭和删除消息队列</span>    <span class="token function">mq_close</span><span class="token punctuation">(</span>mqd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mq_unlink</span><span class="token punctuation">(</span>MQ_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>编译和运行</strong>： <code>gcc sender.c -o sender -lrt</code> <code>gcc receiver.c -o receiver -lrt</code> （需要链接实时库 <code>-lrt</code>） 先运行 <code>./sender</code>，再运行 <code>./receiver</code>。</p><h3 id="12-posix-信号量"><a class="markdownIt-Anchor" href="#12-posix-信号量"></a> 1.2. POSIX 信号量</h3><p>用于进程间的同步，功能与 System V 信号量类似，但提供了更简单的接口。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>有名信号量</strong>：通过一个文件名标识，可以用于非亲缘进程。</p></li><li><p><strong>无名信号量</strong>：常用于线程间的同步，存放在共享内存中，只能用于有亲缘关系的进程。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>sem_open()</code></strong>：创建或打开有名信号量。</p></li><li><p><strong><code>sem_wait()</code></strong>：原子性地减少信号量计数器，如果为0则阻塞。</p></li><li><p><strong><code>sem_post()</code></strong>：原子性地增加信号量计数器。</p></li><li><p><strong><code>sem_close()</code></strong>：关闭信号量。</p></li><li><p><strong><code>sem_unlink()</code></strong>：删除信号量。</p></li></ul></li></ul><p>这个例子展示了如何使用 POSIX 信号量来同步两个进程对一个共享资源的访问。</p><p>共享资源访问程序 (sem_client.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span>           <span class="token comment">/* For O_CREAT, O_RDWR */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span>        <span class="token comment">/* For mode constants */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_NAME</span> <span class="token string">"/my_semaphore"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">;</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token comment">// 打开信号量</span>    sem <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// O_CREAT is not needed here</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem <span class="token operator">==</span> SEM_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Client: Waiting to get semaphore...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// P 操作：等待信号量，如果值为0则阻塞</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sem_wait</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_wait"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Client: Got the semaphore. Accessing shared resource...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟访问共享资源</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Client: Finished. Releasing semaphore...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// V 操作：释放信号量，计数器加1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sem_post</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_post"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 关闭信号量</span>    <span class="token function">sem_close</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>信号量控制程序 (sem_main.c)：`</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_NAME</span> <span class="token string">"/my_semaphore"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token comment">// 创建并初始化信号量，初始值为1</span>    sem <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">,</span> O_CREAT<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem <span class="token operator">==</span> SEM_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: Semaphore created and initialized to 1.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建一个子进程</span>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 子进程运行另一个程序来访问信号量</span>        <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token string">"./sem_client"</span><span class="token punctuation">,</span> <span class="token string">"sem_client"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execlp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果执行失败</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 父进程也尝试访问信号量</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保子进程先运行</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: Waiting to get semaphore...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_wait</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: Got the semaphore. Accessing shared resource...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: Finished. Releasing semaphore...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sem_post</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待子进程结束</span>        <span class="token comment">// 删除信号量</span>        <span class="token function">sem_unlink</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: Child process finished. Semaphore unlinked.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 关闭信号量</span>    <span class="token function">sem_close</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>编译和运行</strong>： <code>gcc sem_client.c -o sem_client -lrt</code> <code>gcc sem_main.c -o sem_main -lrt</code> （同样需要链接实时库 <code>-lrt</code>） 运行 <code>./sem_main</code>。</p><h3 id="13-posix-共享内存"><a class="markdownIt-Anchor" href="#13-posix-共享内存"></a> 1.3. POSIX 共享内存</h3><p>和 System V 共享内存一样，都是最快的 IPC 方式，但 POSIX 版本使用了文件描述符。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>基于文件</strong>：通过 <code>shm_open</code> 创建或打开一个共享内存对象，返回一个文件描述符。</p></li><li><p><strong>内存映射</strong>：通过 <code>mmap()</code> 将文件描述符对应的内存映射到进程的地址空间。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>shm_open()</code></strong>：创建或打开共享内存对象。</p></li><li><p><strong><code>ftruncate()</code></strong>：调整共享内存对象的大小。</p></li><li><p><strong><code>mmap()</code></strong>：将共享内存映射到进程地址空间。</p></li><li><p><strong><code>munmap()</code></strong>：解除映射。</p></li><li><p><strong><code>shm_unlink()</code></strong>：删除共享内存对象。</p></li></ul></li></ul><p>这个例子展示了两个进程如何通过 POSIX 共享内存来共享一块内存区域，并用一个信号量来同步。</p><p>写入方 (shm_writer.c)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHM_NAME</span> <span class="token string">"/my_shm"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_NAME</span> <span class="token string">"/my_shm_sem"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHM_SIZE</span> <span class="token expression"><span class="token number">4096</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> shm_fd<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"Hello from shm writer!"</span><span class="token punctuation">;</span>    <span class="token comment">// 创建/打开共享内存对象</span>    shm_fd <span class="token operator">=</span> <span class="token function">shm_open</span><span class="token punctuation">(</span>SHM_NAME<span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shm_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"shm_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 设置共享内存大小</span>    <span class="token function">ftruncate</span><span class="token punctuation">(</span>shm_fd<span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将共享内存映射到进程地址空间</span>    ptr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">,</span> PROT_READ <span class="token operator">|</span> PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> shm_fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> MAP_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mmap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 创建/打开信号量，用于同步</span>    sem <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">,</span> O_CREAT<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始值为0，表示不可访问</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem <span class="token operator">==</span> SEM_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Writer: Writing to shared memory...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 写入数据</span>    <span class="token function">sprintf</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// V 操作：释放信号量，通知读者可以读取了</span>    <span class="token function">sem_post</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Writer: Data written and semaphore posted.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭</span>    <span class="token function">sem_close</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">munmap</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>shm_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取方 (shm_reader.c)：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHM_NAME</span> <span class="token string">"/my_shm"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEM_NAME</span> <span class="token string">"/my_shm_sem"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHM_SIZE</span> <span class="token expression"><span class="token number">4096</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> shm_fd<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">;</span>    <span class="token comment">// 打开共享内存对象</span>    shm_fd <span class="token operator">=</span> <span class="token function">shm_open</span><span class="token punctuation">(</span>SHM_NAME<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shm_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"shm_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将共享内存映射到进程地址空间</span>    ptr <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">,</span> PROT_READ<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> shm_fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> MAP_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"mmap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 打开信号量</span>    sem <span class="token operator">=</span> <span class="token function">sem_open</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sem <span class="token operator">==</span> SEM_FAILED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem_open"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Reader: Waiting for writer...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// P 操作：等待信号量，直到有数据可用</span>    <span class="token function">sem_wait</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Reader: Data received: %s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 关闭和清理</span>    <span class="token function">sem_close</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sem_unlink</span><span class="token punctuation">(</span>SEM_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除信号量</span>    <span class="token function">munmap</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> SHM_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>shm_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">shm_unlink</span><span class="token punctuation">(</span>SHM_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除共享内存对象</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>编译和运行</strong>： <code>gcc shm_writer.c -o shm_writer -lrt</code> <code>gcc shm_reader.c -o shm_reader -lrt</code> （同样需要链接实时库 <code>-lrt</code>） 先运行 <code>./shm_writer</code>，再运行 <code>./shm_reader</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="IPC" scheme="https://blog.godmao.top/Tags/IPC/"/>
    
    <category term="POSIX" scheme="https://blog.godmao.top/Tags/POSIX/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Linux IPC：进程间通信的艺术</title>
    <link href="https://blog.godmao.top/posts/46571/"/>
    <id>https://blog.godmao.top/posts/46571/</id>
    <published>2025-09-12T09:28:41.000Z</published>
    <updated>2025-09-15T14:35:23.508Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><ul><li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-ipc">1. 为什么需要 IPC？</a></li><li><a href="#2-%E5%B8%B8%E8%A7%81%E7%9A%84-linux-ipc-%E6%9C%BA%E5%88%B6">2. 常见的 Linux IPC 机制</a><ul><li><a href="#21-%E7%AE%A1%E9%81%93pipes">2.1. 管道（Pipes）</a></li><li><a href="#22-fifo%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93">2.2. FIFO（命名管道）</a></li><li><a href="#23-%E4%BF%A1%E5%8F%B7">2.3. 信号</a><ul><li><a href="#231-%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%88%86%E7%B1%BB">2.3.1. 信号的分类</a></li><li><a href="#232-%E4%BF%A1%E5%8F%B7%E4%B8%8E-ipc-%E7%9A%84%E5%85%B3%E7%B3%BB">2.3.2. 信号与 IPC 的关系</a></li><li><a href="#233-%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">2.3.3. 信号的三种处理方式</a></li><li><a href="#234-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7">2.3.4. 如何使用信号？</a><ul><li><a href="#2341-%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7kill-%E5%87%BD%E6%95%B0">2.3.4.1. 发送信号：<code>kill()</code> 函数</a></li><li><a href="#2342-%E6%B3%A8%E5%86%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0signal-%E5%92%8C-sigaction">2.3.4.2. 注册信号处理函数：<code>signal()</code> 和 <code>sigaction()</code></a></li></ul></li></ul></li><li><a href="#24-%E4%BF%A1%E5%8F%B7%E9%9B%86signal-set%E5%92%8C%E9%98%BB%E5%A1%9E">2.4. 信号集（Signal Set）和阻塞</a><ul><li><a href="#241-%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">2.4.1. 信号集操作函数</a></li><li><a href="#242-%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7sigprocmask">2.4.2. 阻塞信号：<code>sigprocmask()</code></a></li></ul></li><li><a href="#25-system-v-ipc-system-v-ipc">2.5. System V IPC (System V IPC)[^1]</a><ul><li><a href="#251-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97message-queues">2.5.1. 消息队列（Message Queues）</a></li><li><a href="#252-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphores">2.5.2. 信号量（Semaphores）</a></li><li><a href="#253-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98shared-memory">2.5.3. 共享内存（Shared Memory）</a></li></ul></li><li><a href="#26-ipc-%E6%80%BB%E7%BB%93%E4%B8%8E%E9%80%89%E6%8B%A9">2.6. IPC 总结与选择</a></li></ul></li></ul><p>在 Linux 世界中，进程是独立的执行单元，拥有自己的地址空间。但很多时候，为了完成一个复杂的任务，不同的进程需要协同工作，交换数据。这时，我们就需要<strong>进程间通信（IPC, Inter-Process Communication）</strong>。IPC 就像是进程之间的一座桥梁，让它们能够相互“交谈”，共享信息。</p><p>本文将带你深入了解 Linux 中常见的 IPC 机制，并以<strong>使用为导向</strong>，结合代码示例，让你能够快速掌握这些“通信”技术。</p><h2 id="1-为什么需要-ipc"><a class="markdownIt-Anchor" href="#1-为什么需要-ipc"></a> 1. 为什么需要 IPC？</h2><p>想象一个场景：你正在开发一个 Web 服务器。一个主进程负责监听网络请求，但处理这些请求非常耗时。如果主进程自己处理，服务器就会变得很慢，无法响应新的请求。一个更好的设计是，主进程每接收到一个请求，就创建一个新的子进程或将请求发送给一个工作进程池来处理。这样，主进程可以立即回去监听新的连接，而工作进程则专注于处理任务。</p><p>在这个例子中，主进程需要将请求数据传递给工作进程。这就是 IPC 发挥作用的地方。</p><h2 id="2-常见的-linux-ipc-机制"><a class="markdownIt-Anchor" href="#2-常见的-linux-ipc-机制"></a> 2. 常见的 Linux IPC 机制</h2><p>Linux 提供了多种 IPC 机制，每种都有其独特的优缺点和适用场景。我们可以将它们分为两大类：<strong>基于文件</strong>和<strong>基于内存</strong>。</p><h3 id="21-管道pipes"><a class="markdownIt-Anchor" href="#21-管道pipes"></a> 2.1. 管道（Pipes）</h3><p>管道可能是最简单、最古老的 IPC 形式。它就像一个单向的“水管”，一端用于写入，另一端用于读取。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>单向通信</strong>：数据只能从一端流向另一端。</p></li><li><p><strong>父子进程通信</strong>：管道通常用于有亲缘关系的进程之间，比如父进程和子进程。</p></li><li><p><strong>半双工</strong>：虽然是单向，但如果创建两个管道，就可以实现双向通信。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><strong><code>pipe()</code> 函数</strong>：这是创建管道的核心函数。</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>pipefd</code> 是一个包含两个文件描述符的数组，<code>pipefd[0]</code> 用于读取，<code>pipefd[1]</code> 用于写入。</p></li><li><p><strong>代码示例</strong>：一个简单的父子进程通信。</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"Hello from parent!"</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pipe</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"pipe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭读取端</span>        <span class="token function">write</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭写入端，如果不关，子进程读端收不到EOF信号，则会一直读导致程序阻塞</span>        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭写入端，如果不关</span>        <span class="token function">read</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child received: %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">close</span><span class="token punctuation">(</span>pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭读取端</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="22-fifo命名管道"><a class="markdownIt-Anchor" href="#22-fifo命名管道"></a> 2.2. FIFO（命名管道）</h3><p>管道只能用于有亲缘关系的进程，那如果两个毫不相关的进程想通信怎么办？答案就是 <strong>FIFO (First-In, First-Out)</strong>，也叫<strong>命名管道</strong>。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>文件系统路径</strong>：它在文件系统中有一个路径名，不同于匿名管道。</p></li><li><p><strong>非亲缘进程通信</strong>：任意两个进程都可以通过这个路径名打开并通信。</p></li><li><p><strong>单向</strong>：和管道一样，FIFO 也是单向的，需要两个 FIFO 来实现双向通信。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><strong><code>mkfifo()</code> 函数</strong>或 <strong><code>mkfifo</code> 命令</strong>：用来创建 FIFO。</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong><code>open()</code>, <code>read()</code>, <code>write()</code> 函数</strong>：像操作普通文件一样来操作 FIFO。</li></ul></li><li><p><strong>代码示例</strong>：</p><ul><li><strong><code>writer.c</code></strong>：</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FIFO_NAME</span> <span class="token string">"my_fifo"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>msg <span class="token operator">=</span> <span class="token string">"Hello from writer!"</span><span class="token punctuation">;</span>    <span class="token function">mkfifo</span><span class="token punctuation">(</span>FIFO_NAME<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>FIFO_NAME<span class="token punctuation">,</span> O_WRONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>FIFO_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除命名管道文件</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong><code>reader.c</code></strong>：</li></ul>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FIFO_NAME</span> <span class="token string">"my_fifo"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">mkfifo</span><span class="token punctuation">(</span>FIFO_NAME<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证文件存在</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>FIFO_NAME<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Reader received: %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以先运行 <code>writer.c</code>，再运行 <code>reader.c</code>。</p></li></ul><h3 id="23-信号"><a class="markdownIt-Anchor" href="#23-信号"></a> 2.3. 信号</h3><p><strong>信号（Signal）</strong> 是一种更轻量级、更异步的进程间通信和事件通知机制。它就像一个“软中断”，用来通知进程发生了某个事件。</p><p>想象一下，你正在专注地工作，突然有人拍了你一下肩膀。你停下手中的活，转头看看发生了什么事，然后根据情况做出反应（比如，对方是同事，你可能和他聊两句；对方是领导，你可能马上站起来）。</p><p>在 Linux 中，<strong>信号</strong>就是那个“拍肩膀”的动作。当一个进程收到一个信号时，它会暂停当前执行的任务，转而去处理这个信号，处理完后再恢复执行。</p><ul><li><p><strong>发送者</strong>：可以是内核（比如你按下 <code>Ctrl+C</code>，内核会发送 <code>SIGINT</code> 信号给前台进程）、也可以是其他进程（使用 <code>kill()</code> 函数）。</p></li><li><p><strong>接收者</strong>：任何一个进程都可以接收信号。</p></li></ul><h4 id="231-信号的分类"><a class="markdownIt-Anchor" href="#231-信号的分类"></a> 2.3.1. 信号的分类</h4><p>信号有很多种，每种都有其特定的用途。常见的信号及其作用如下：</p><table><thead><tr><th>信号名称</th><th>默认行为</th><th>解释</th></tr></thead><tbody><tr><td><strong><code>SIGHUP</code> (1)</strong></td><td>终止进程</td><td>当终端关闭时发送给关联的进程。</td></tr><tr><td><strong><code>SIGINT</code> (2)</strong></td><td>终止进程</td><td>来自键盘中断，通常是 <code>Ctrl+C</code>。</td></tr><tr><td><strong><code>SIGQUIT</code> (3)</strong></td><td>终止并生成核心转储文件</td><td>来自键盘退出，通常是 <code>Ctrl+\\</code>。</td></tr><tr><td><strong><code>SIGKILL</code> (9)</strong></td><td>强制终止进程</td><td>无法被捕获、阻塞或忽略，强制杀死进程。</td></tr><tr><td><strong><code>SIGTERM</code> (15)</strong></td><td>终止进程</td><td>友好的终止请求，可以被捕获。<code>kill</code> 命令默认发送此信号。</td></tr><tr><td><strong><code>SIGCHLD</code></strong></td><td>忽略</td><td>子进程终止或停止时发送给父进程。</td></tr><tr><td><strong><code>SIGSTOP</code></strong></td><td>停止进程</td><td>无法被捕获、忽略，暂停进程。</td></tr><tr><td><strong><code>SIGCONT</code></strong></td><td>继续进程</td><td>使停止的进程继续运行。</td></tr></tbody></table><h4 id="232-信号与-ipc-的关系"><a class="markdownIt-Anchor" href="#232-信号与-ipc-的关系"></a> 2.3.2. 信号与 IPC 的关系</h4><ul><li><p><strong>异步通知</strong>：信号是典型的异步 IPC 机制，它不像管道或共享内存那样传递数据，而是<strong>传递事件信息</strong>。</p></li><li><p><strong>轻量级</strong>：相比于其他 IPC，信号的开销非常小。</p></li><li><p><strong>同步</strong>：信号也可以用于同步目的，例如 <code>SIGCHLD</code> 信号常用于父进程等待子进程结束。</p></li></ul><p>理解信号，特别是信号集和阻塞的概念，对于编写健壮的多进程或多线程程序至关重要。它能让你更好地控制程序对外部事件的响应。</p><h4 id="233-信号的三种处理方式"><a class="markdownIt-Anchor" href="#233-信号的三种处理方式"></a> 2.3.3. 信号的三种处理方式</h4><p>当进程收到一个信号时，它可以有三种处理方式：</p><ol><li><p><strong>执行默认动作（Default）</strong>：大多数信号都有一个预定义的默认行为。例如，<code>SIGINT</code> 的默认行为就是终止进程。</p></li><li><p><strong>忽略信号（Ignore）</strong>：有些信号可以被忽略，即进程收到信号后不做任何处理。<code>SIGCHLD</code> 信号的默认行为就是忽略。</p></li><li><p><strong>捕获信号（Catch）</strong>：这是最灵活的方式。进程可以为某个信号注册一个<strong>信号处理函数（Signal Handler）</strong>。当信号到来时，进程会执行这个函数来处理信号，而不是执行默认动作。</p></li></ol><div class="admonition caution"><p class="admonition-title">caution</p><p><strong>注意</strong>：<code>SIGKILL</code> 和 <code>SIGSTOP</code> 这两个信号是<strong>不能被捕获、忽略或阻塞</strong>的。它们是系统管理员强制终止或停止进程的“最后手段”。</p></div><h4 id="234-如何使用信号"><a class="markdownIt-Anchor" href="#234-如何使用信号"></a> 2.3.4. 如何使用信号？</h4><h5 id="2341-发送信号kill-函数"><a class="markdownIt-Anchor" href="#2341-发送信号kill-函数"></a> 2.3.4.1. 发送信号：<code>kill()</code> 函数</h5><p>你可以使用 <code>kill()</code> 函数向另一个进程发送信号。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">int</span> <span class="token function">kill</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><code>pid</code>：目标进程的 ID。</p></li><li><p><code>sig</code>：要发送的信号编号。</p></li></ul><h5 id="2342-注册信号处理函数signal-和-sigaction"><a class="markdownIt-Anchor" href="#2342-注册信号处理函数signal-和-sigaction"></a> 2.3.4.2. 注册信号处理函数：<code>signal()</code> 和 <code>sigaction()</code></h5><ul><li><p><strong><code>signal()</code> 函数</strong>：这是最简单的注册方式，但它在不同系统上的行为可能不一致，不推荐在新代码中使用。</p></li><li><p><strong><code>sigaction()</code> 函数</strong>：这是 POSIX 标准推荐的方式，更强大，更可靠。</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">int</span> <span class="token function">sigaction</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>act<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>oldact<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p><code>signum</code>：要捕获的信号编号。</p></li><li><p><code>act</code>：指向 <code>struct sigaction</code> 结构体，该结构体定义了新的信号处理行为。</p></li><li><p><code>oldact</code>：可选，用于保存旧的信号处理行为。</p></li></ul><p><strong><code>struct sigaction</code> 结构体</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sa_handler<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 信号处理函数</span>    <span class="token class-name">sigset_t</span> sa_mask<span class="token punctuation">;</span>         <span class="token comment">// 信号集，在信号处理函数执行期间需要阻塞的信号</span>    <span class="token keyword">int</span> sa_flags<span class="token punctuation">;</span>             <span class="token comment">// 标志位</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="24-信号集signal-set和阻塞"><a class="markdownIt-Anchor" href="#24-信号集signal-set和阻塞"></a> 2.4. 信号集（Signal Set）和阻塞</h3><p>当你在处理一个信号时，你可能不希望被其他信号打断。<strong>信号集（<code>sigset_t</code>）</strong> 就是用来管理一组信号的。通过操作信号集，你可以<strong>阻塞（Block）</strong> 某些信号，让它们在进程处理完当前任务后才被传递。</p><h4 id="241-信号集操作函数"><a class="markdownIt-Anchor" href="#241-信号集操作函数"></a> 2.4.1. 信号集操作函数</h4><ul><li><p><strong><code>sigemptyset()</code></strong>：初始化一个空的信号集。</p></li><li><p><strong><code>sigaddset()</code></strong>：向信号集中添加一个信号。</p></li><li><p><strong><code>sigdelset()</code></strong>：从信号集中删除一个信号。</p></li><li><p><strong><code>sigismember()</code></strong>：检查一个信号是否在信号集中。</p></li></ul><h4 id="242-阻塞信号sigprocmask"><a class="markdownIt-Anchor" href="#242-阻塞信号sigprocmask"></a> 2.4.2. 阻塞信号：<code>sigprocmask()</code></h4><p><code>sigprocmask()</code> 函数用来设置进程的<strong>信号阻塞掩码（Signal Mask）</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token class-name">sigset_t</span> <span class="token operator">*</span>oldset<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p><code>how</code>：指定如何修改信号阻塞掩码，有以下几种：</p><ul><li><p><code>SIG_BLOCK</code>：将 <code>set</code> 中的信号添加到阻塞掩码中。</p></li><li><p><code>SIG_UNBLOCK</code>：将 <code>set</code> 中的信号从阻塞掩码中移除。</p></li><li><p><code>SIG_SETMASK</code>：将阻塞掩码设置为 <code>set</code>。</p></li></ul></li><li><p><code>set</code>：包含要阻塞或解除阻塞的信号集。</p></li><li><p><code>oldset</code>：可选，用于保存旧的阻塞掩码。</p></li></ul><p><strong>示例</strong>：在处理关键代码段时临时阻塞 <code>SIGINT</code>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span> <span class="token function">my_handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Caught signal %d\n"</span><span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">sigset_t</span> block_mask<span class="token punctuation">,</span> old_mask<span class="token punctuation">;</span>    <span class="token comment">// 1. 设置要阻塞的信号集</span>    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>block_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sigaddset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>block_mask<span class="token punctuation">,</span> SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 阻塞 SIGINT 信号</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_BLOCK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>block_mask<span class="token punctuation">,</span> <span class="token operator">&amp;</span>old_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SIGINT is blocked. Press Ctrl+C...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在这10秒内，Ctrl+C不会终止进程</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Unblocking SIGINT...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3. 解除阻塞，恢复旧的信号掩码</span>    <span class="token function">sigprocmask</span><span class="token punctuation">(</span>SIG_SETMASK<span class="token punctuation">,</span> <span class="token operator">&amp;</span>old_mask<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"SIGINT is unblocked. Press Ctrl+C again.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 4. 注册一个信号处理函数</span>    <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> sa<span class="token punctuation">;</span>    sa<span class="token punctuation">.</span>sa_handler <span class="token operator">=</span> my_handler<span class="token punctuation">;</span>    <span class="token function">sigemptyset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sa<span class="token punctuation">.</span>sa_mask<span class="token punctuation">)</span><span class="token punctuation">;</span>    sa<span class="token punctuation">.</span>sa_flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">sigaction</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sa<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Running...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行这段代码，你会看到在阻塞期间，<code>Ctrl+C</code> 无法终止进程。当解除阻塞后，<code>Ctrl+C</code> 才能触发信号处理函数。</p><h3 id="25-system-v-ipc-system-v-ipc"><a class="markdownIt-Anchor" href="#25-system-v-ipc-system-v-ipc"></a> 2.5. System V IPC (System V IPC)<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h3><p>System V IPC 是 Linux 系统中一组更高级、更强大的 IPC 机制，包括消息队列、信号量和共享内存。它们都是<strong>基于内核</strong>的，需要一个唯一的键值（key）来标识。</p><h4 id="251-消息队列message-queues"><a class="markdownIt-Anchor" href="#251-消息队列message-queues"></a> 2.5.1. 消息队列（Message Queues）</h4><p>消息队列就像一个链表，允许进程向其中添加消息或从中读取消息。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>异步通信</strong>：发送进程可以发送消息后立即返回，不需要等待接收进程。</p></li><li><p><strong>带类型</strong>：消息可以带有类型，接收进程可以只接收特定类型的消息。</p></li><li><p><strong>存储在内核中</strong>：即使发送进程结束，消息依然保留在队列中，直到被读取。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>ftok()</code></strong>：将文件路径和整数转换为一个唯一的 IPC 键值。</p></li><li><p><strong><code>msgget()</code></strong>：创建或获取一个消息队列。</p></li><li><p><strong><code>msgsnd()</code></strong>：发送消息。</p></li><li><p><strong><code>msgrcv()</code></strong>：接收消息。</p></li><li><p><strong><code>msgctl()</code></strong>：控制消息队列，如删除。</p></li></ul></li></ul><h4 id="252-信号量semaphores"><a class="markdownIt-Anchor" href="#252-信号量semaphores"></a> 2.5.2. 信号量（Semaphores）</h4><p>信号量主要用于<strong>同步</strong>，控制对共享资源的访问。它本身不传递数据，而是作为一种“计数器”。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>互斥和同步</strong>：常用于实现互斥锁，确保同一时间只有一个进程访问共享资源。</p></li><li><p><strong>原子操作</strong>：信号量的操作（P/V操作）是原子的，不会被中断。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>semget()</code></strong>：创建或获取一组信号量。</p></li><li><p><strong><code>semop()</code></strong>：对信号量进行操作，如加/减计数。</p></li><li><p><strong><code>semctl()</code></strong>：控制信号量。</p></li></ul></li></ul><h4 id="253-共享内存shared-memory"><a class="markdownIt-Anchor" href="#253-共享内存shared-memory"></a> 2.5.3. 共享内存（Shared Memory）</h4><p>共享内存是最高效的 IPC 方式。它允许两个或多个进程共享同一块物理内存。</p><ul><li><p><strong>特点</strong>：</p><ul><li><p><strong>最高效</strong>：一旦映射到进程的地址空间，读写操作就像访问普通内存一样，不需要内核的参与。</p></li><li><p><strong>需要同步</strong>：由于多个进程同时访问，需要用<strong>信号量</strong>等机制来同步访问，防止数据竞争。</p></li></ul></li><li><p><strong>使用</strong>：</p><ul><li><p><strong><code>shmget()</code></strong>：创建或获取一个共享内存段。</p></li><li><p><strong><code>shmat()</code></strong>：将共享内存段附加到进程的地址空间。</p></li><li><p><strong><code>shmdt()</code></strong>：将共享内存段从进程的地址空间分离。</p></li><li><p><strong><code>shmctl()</code></strong>：控制共享内存，如删除。</p></li></ul></li></ul><h3 id="26-ipc-总结与选择"><a class="markdownIt-Anchor" href="#26-ipc-总结与选择"></a> 2.6. IPC 总结与选择</h3><table><thead><tr><th>机制</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>管道</strong></td><td>有亲缘关系的进程</td><td>简单，易于使用</td><td>单向，仅限于亲缘进程</td></tr><tr><td><strong>FIFO</strong></td><td>无亲缘关系的进程</td><td>可以在文件系统中命名，灵活</td><td>单向，需要同步，读写时有阻塞</td></tr><tr><td><strong>消息队列</strong></td><td>异步通信，少量数据</td><td>消息带类型，无需同步</td><td>效率较低，有大小限制</td></tr><tr><td><strong>信号量</strong></td><td>进程间同步，互斥</td><td>用于控制访问，防止竞争</td><td>不传递数据</td></tr><tr><td><strong>共享内存</strong></td><td>大量数据传输</td><td>最高效，读写速度快</td><td>必须配合其他同步机制使用</td></tr></tbody></table><p><strong>如何选择？</strong></p><ul><li><p>如果是父子进程之间少量数据的通信，<strong>管道</strong>是最佳选择。</p></li><li><p>如果是两个不相关的进程，且数据量不大，<strong>消息队列</strong>是一个不错的方案。</p></li><li><p>如果需要传输大量数据，且对性能要求极高，<strong>共享内存</strong>是首选，但<strong>必须</strong>结合<strong>信号量</strong>或其他同步机制。</p></li><li><p>如果你只想解决资源访问的同步问题，<strong>信号量</strong>是专门为此设计的。</p></li></ul><p>了解这些 IPC 机制，就如同掌握了进程之间“沟通”的多种语言。在开发时，选择合适的“语言”能让你的程序更加健壮、高效。现在，你可以尝试用这些机制来解决你遇到的实际问题了！</p><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>作了解，重点使用POSIX IPC。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="IPC" scheme="https://blog.godmao.top/Tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>Linux-Process</title>
    <link href="https://blog.godmao.top/posts/43741/"/>
    <id>https://blog.godmao.top/posts/43741/</id>
    <published>2025-09-10T06:53:13.000Z</published>
    <updated>2025-09-12T11:32:56.501Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><div class="admonition info"><p>AI 辅助创作</p></div><p>在 Linux 编程中，<strong>进程（Process）</strong> 是操作系统分配资源和调度的基本单位。每个进程都有自己独立的内存空间、代码段、数据段和执行上下文。多个进程之间常常需要协作，这就涉及到 <strong>进程间通信（IPC, Inter-Process Communication）</strong>。本篇博客会系统介绍进程的基础操作，并对常见的 IPC 方式进行详细解释与示例，带你从零开始掌握。</p><hr /><h2 id="1-进程与-pid"><a class="markdownIt-Anchor" href="#1-进程与-pid"></a> 1. 进程与 PID</h2><p>每个进程都会有一个唯一的 <strong>进程号（PID）</strong>，可以通过 <code>getpid()</code> 获取当前进程号，通过 <code>getppid()</code> 获取父进程号。这在调试和进程管理时非常重要。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"当前进程PID=%d, 父进程PID=%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⚠️ 注意：如果父进程先退出，子进程会被 <code>init</code> 进程接管，<code>ppid</code> 会变为 1。</p><h2 id="2-创建进程-fork"><a class="markdownIt-Anchor" href="#2-创建进程-fork"></a> 2. 创建进程 — <code>fork()</code></h2><p><code>fork()</code> 是创建新进程的主要方式。它会复制当前进程（父进程）的大部分内容，生成一个几乎一模一样的子进程。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>在父进程中，<code>fork()</code> 返回子进程的 PID。</strong></p></li><li><p><strong>在子进程中，<code>fork()</code> 返回 0。</strong></p></li><li><p>如果失败，返回 -1。</p></li></ul><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[子进程] pid=%d, ppid=%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[父进程] pid=%d, 子进程pid=%d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork 失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="admonition caution"><p class="admonition-title">caution</p><ul><li><p>子进程不会继承父进程的所有资源，例如文件锁。</p></li><li><p><code>fork()</code> 之后，父子进程执行顺序不确定，需要通过 <code>wait()</code> 或其他机制控制。</p></li></ul></div><h2 id="3-程序替换-exec-系列"><a class="markdownIt-Anchor" href="#3-程序替换-exec-系列"></a> 3. 程序替换 — <code>exec()</code> 系列</h2><p>子进程常常需要运行一个新的程序，这就需要 <code>exec()</code> 系列函数（如 <code>execlp</code>, <code>execvp</code> 等）。<br /><code>exec</code> 系列函数的作用是：<strong>用新的程序替换当前进程的代码段</strong>，而进程的 PID、文件描述符（除非设置了 <code>FD_CLOEXEC</code>）等保持不变。它不会创建新进程，而是在当前进程内加载并运行新程序。</p><h3 id="常见函数"><a class="markdownIt-Anchor" href="#常见函数"></a> 常见函数</h3><p><code>exec</code> 系列一共有 6 个常用函数，主要区别在于 <strong>参数传递方式</strong> 和 <strong>是否依赖 PATH 环境变量</strong>。</p><table><thead><tr><th>函数</th><th>参数传递方式</th><th>是否搜索 PATH</th><th>说明</th></tr></thead><tbody><tr><td><code>execl(path, arg0, arg1, ..., NULL)</code></td><td>列表（逐个传参）</td><td>否</td><td>最常见，参数以不定长列表形式传递，最后必须以 <code>NULL</code> 结尾。</td></tr><tr><td><code>execv(path, argv[])</code></td><td>数组</td><td>否</td><td>参数通过字符串数组传递，方便动态构造参数。</td></tr><tr><td><code>execlp(file, arg0, arg1, ..., NULL)</code></td><td>列表</td><td>是</td><td>与 <code>execl</code> 类似，但会在 <code>PATH</code> 中搜索可执行文件。</td></tr><tr><td><code>execvp(file, argv[])</code></td><td>数组</td><td>是</td><td>与 <code>execv</code> 类似，但会在 <code>PATH</code> 中搜索可执行文件。</td></tr><tr><td><code>execle(path, arg0, arg1, ..., NULL, envp[])</code></td><td>列表</td><td>否</td><td>可以自定义环境变量，最后参数需提供 <code>envp</code>。</td></tr><tr><td><code>execve(path, argv[], envp[])</code></td><td>数组</td><td>否</td><td>最底层的系统调用，其它 <code>exec</code> 函数最终都调用它。</td></tr></tbody></table><p>说明：</p><ul><li><code>PATH</code>：系统环境变量</li><li><code>path</code>：要执行的程序路径（可以是绝对路径，也可以是相对路径）。</li><li><code>arg</code>：程序要输入的参数</li></ul><h3 id="使用示例"><a class="markdownIt-Anchor" href="#使用示例"></a> 使用示例</h3><ol><li><strong>execl：用绝对路径调用程序</strong></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span> </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Before exec\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/ls"</span><span class="token punctuation">,</span> <span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-l"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 只有 exec 调用失败时才会继续执行    </span><span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>execvp：在 PATH 中搜索命令</strong></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"ls"</span><span class="token punctuation">,</span> <span class="token string">"-a"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execvp failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>execle：传入自定义环境变量</strong></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>envp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"MYVAR=HelloExec"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/usr/bin/env"</span><span class="token punctuation">,</span> <span class="token string">"env"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> envp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execle failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ul><li><p><code>exec</code> 系列 <strong>不会返回</strong>，除非调用失败。</p></li><li><p>若调用成功，原进程的代码和数据段会被新程序替换。</p></li><li><p><strong>文件描述符默认继承</strong>，可以用于在父进程中设置好管道/重定向，让子进程在 exec 后继续使用。</p></li><li><p>需要保证参数列表最后有 <code>NULL</code>，否则会引发不可预期错误。</p></li></ul><h2 id="4-等待子进程-wait-waitpid"><a class="markdownIt-Anchor" href="#4-等待子进程-wait-waitpid"></a> 4. 等待子进程 — <code>wait()</code> / <code>waitpid()</code></h2><p><strong>父进程需要回收子进程退出时的资源，否则子进程会成为 僵尸进程（Zombie）。</strong></p><p>这两个函数用于 <strong>父进程等待子进程结束</strong> 并<strong>回收资源</strong>，避免僵尸进程。</p><h3 id="1-wait"><a class="markdownIt-Anchor" href="#1-wait"></a> 1. wait()</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>参数</strong></p><ul><li><code>status</code>：指向整数的指针，用于存储子进程退出状态。如果不关心状态，可以传 <code>NULL</code>。</li></ul></li><li><p><strong>返回值</strong></p><ul><li><p>成功：返回结束的子进程 PID</p></li><li><p>失败：返回 -1（例如没有子进程存在时）</p></li></ul></li><li><p><strong>使用示例</strong></p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child running...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        <span class="token class-name">pid_t</span> cpid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待子进程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 判断是否正常退出</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d exited with code %d\n"</span><span class="token punctuation">,</span> cpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="admonition caution"><p class="admonition-title">caution</p><ul><li><p><code>wait()</code> 会阻塞父进程，直到任意一个子进程退出。</p></li><li><p>如果父进程没有子进程，返回 -1 并设置 <code>errno = ECHILD</code>。</p></li></ul></div><h3 id="2-waitpid"><a class="markdownIt-Anchor" href="#2-waitpid"></a> 2. waitpid()</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>参数</strong></p><ul><li><p><code>pid</code>：</p><ul><li><p><code>&gt;0</code> ：等待指定 PID 的子进程</p></li><li><p>-1 ：等待任意子进程（功能类似 <code>wait()</code>）</p></li><li><p>0 ：等待与调用进程同组的任意子进程</p></li><li><p>&lt;-1：等待进程组 ID = |pid| 的任意子进程</p></li></ul></li><li><p><code>status</code>：指向整数的指针，用于保存退出状态</p></li><li><p><code>options</code>：控制函数行为，常用值：</p><ul><li><p><code>0</code>：阻塞等待（默认行为）</p></li><li><p><code>WNOHANG</code>：非阻塞，如果没有子进程退出立即返回 0</p></li><li><p><code>WUNTRACED</code>：返回被暂停的子进程（收到 SIGSTOP）</p></li><li><p><code>WCONTINUED</code>：返回继续运行的子进程（收到 SIGCONT）</p></li></ul></li></ul></li><li><p><strong>返回值</strong></p><ul><li><p>成功：返回子进程 PID</p></li><li><p>非阻塞且没有子进程退出：返回 0</p></li><li><p>失败：返回 -1，并设置 <code>errno</code></p></li></ul></li><li><p><strong>使用示例</strong></p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        <span class="token class-name">pid_t</span> cpid<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cpid <span class="token operator">=</span> <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child still running...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">WIFEXITED</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child %d exited with code %d\n"</span><span class="token punctuation">,</span> cpid<span class="token punctuation">,</span> <span class="token function">WEXITSTATUS</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="admonition caution"><p class="admonition-title">caution</p><ul><li><p><code>waitpid()</code> 可以实现 <strong>非阻塞等待</strong>，适合父进程同时管理多个子进程。</p></li><li><p><code>WIFEXITED(status)</code> 判断子进程是否正常退出。</p></li><li><p><code>WIFSIGNALED(status)</code> 判断子进程是否被信号终止。</p></li><li><p>使用 <code>waitpid()</code> 可以精准回收指定子进程，避免僵尸进程积累。</p></li></ul></div><div class="admonition note"><p class="admonition-title">tips</p><ul><li><p>父进程只需要等待任意子进程 → 用 <code>wait()</code> 即可。</p></li><li><p>父进程需要精确控制或非阻塞 → 用 <code>waitpid()</code>。</p></li><li><p>调用前一定要理解 <strong>阻塞 vs 非阻塞</strong>，避免父进程被卡住。</p></li></ul></div><h2 id="5-进程退出-exit-与-_exit"><a class="markdownIt-Anchor" href="#5-进程退出-exit-与-_exit"></a> 5. 进程退出 — <code>exit()</code> 与 <code>_exit()</code></h2><ul><li><p><code>exit()</code>：会刷新缓冲区，执行清理函数。</p></li><li><p><code>_exit()</code>：立即退出，不做清理，通常在子进程 <code>fork()</code> 后的错误处理中使用。</p></li></ul><p>⚠️ 区别：<code>exit()</code> 适合普通退出，<code>_exit()</code> 适合在 <code>fork()</code> 后不希望影响父进程的环境时使用。</p><div class="admonition caution"><p class="admonition-title">caution</p><ul><li>子进程执行退出函数后，子进程结束并变为僵尸🧟，内核保留子进程在进程表中的部分信息（PID、退出码等）占用少量系统资源，但不会再运行。需要父进程调用wait释放子进程资源，净化僵尸，释放灵魂👻</li></ul></div><h2 id="6-ps-命令简述"><a class="markdownIt-Anchor" href="#6-ps-命令简述"></a> 6. ps 命令简述</h2><h3 id="ps-命令的常见用法"><a class="markdownIt-Anchor" href="#ps-命令的常见用法"></a> <code>ps</code> 命令的常见用法</h3><h4 id="1-查看当前终端中的进程"><a class="markdownIt-Anchor" href="#1-查看当前终端中的进程"></a> 1. 查看当前终端中的进程</h4><p>这是最简单的用法，不加任何选项，<code>ps</code> 命令只会显示当前终端会话中运行的进程。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行后你可能会看到类似下面的输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PID TTY          TIME CMD<span class="token number">1234</span> pts/0    00:00:00 <span class="token function">bash</span><span class="token number">5678</span> pts/0    00:00:00 <span class="token function">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>PID</strong>：进程的唯一标识符（Process ID）。</p></li><li><p><strong>TTY</strong>：进程运行所在的终端。</p></li><li><p><strong>TIME</strong>：进程使用的 CPU 时间。</p></li><li><p><strong>CMD</strong>：启动进程的命令。</p></li></ul><h4 id="2-查看所有进程"><a class="markdownIt-Anchor" href="#2-查看所有进程"></a> 2. 查看所有进程</h4><p>如果你想查看系统中所有用户的所有进程，可以使用 <code>-e</code> 选项（代表所有进程）或 <code>-a</code> 选项（代表所有进程，除了会话引导进程）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-e</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用 <code>-ef</code> 组合，这是最常用的组合之一，它提供了更详细的信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-ef</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>UID</strong>：启动进程的用户 ID。</p></li><li><p><strong>PID</strong>：进程 ID。</p></li><li><p><strong>PPID</strong>：父进程 ID。</p></li><li><p><strong>C</strong>：CPU 利用率。</p></li><li><p><strong>STIME</strong>：进程启动时间。</p></li><li><p><strong>TTY</strong>：进程所在的终端。</p></li><li><p><strong>TIME</strong>：进程使用的 CPU 时间。</p></li><li><p><strong>CMD</strong>：启动进程的命令。</p></li></ul><h4 id="3-查看用户进程"><a class="markdownIt-Anchor" href="#3-查看用户进程"></a> 3. 查看用户进程</h4><p>如果你只想查看某个特定用户（例如 <code>root</code>）的进程，可以使用 <code>-u</code> 选项。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-u</span> root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-通过管道和-grep-查找特定进程"><a class="markdownIt-Anchor" href="#4-通过管道和-grep-查找特定进程"></a> 4. 通过管道和 <code>grep</code> 查找特定进程</h4><p>在实际工作中，你通常会需要查找某个特定的进程，比如 Nginx 或 MySQL。这时，<code>ps</code> 命令通常会配合 <code>grep</code> 命令一起使用。<code>grep</code> 可以从 <code>ps</code> 的输出中过滤出你想要的信息。</p><p>例如，查找所有与 Nginx 相关的进程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的 <code>|</code> 是管道符，它的作用是将 <code>ps -ef</code> 命令的输出作为 <code>grep</code> 命令的输入。</p><h3 id="ps-命令的常用选项总结"><a class="markdownIt-Anchor" href="#ps-命令的常用选项总结"></a> <code>ps</code> 命令的常用选项总结</h3><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-e</td><td>显示所有进程</td></tr><tr><td>-f</td><td>显示完整格式的列表</td></tr><tr><td>-a</td><td>显示所有进程（不包括会话引导进程）</td></tr><tr><td>-u</td><td>按用户过滤进程</td></tr><tr><td>-aux</td><td>最经典的组合，显示所有用户的详细进程信息</td></tr></tbody></table><h3 id="实际应用示例"><a class="markdownIt-Anchor" href="#实际应用示例"></a> 实际应用示例</h3><p>假设你想查看当前系统中 CPU 或内存占用最高的几个进程，<code>ps</code> 命令可以与 <code>head</code>、<code>sort</code> 等命令结合使用。</p><p><strong>查看 CPU 占用最高的 5 个进程：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-aux</span> <span class="token parameter variable">--sort</span><span class="token operator">=</span>-%cpu <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的 <code>--sort=-%cpu</code> 表示按 CPU 占用率降序排列，<code>head -n 6</code> 则取前 6 行（包括标题行）。</p><h3 id="解析-ps-aux-命令的输出"><a class="markdownIt-Anchor" href="#解析-ps-aux-命令的输出"></a> 解析 <code>ps -aux</code> 命令的输出</h3><p>当你运行 <code>ps -aux</code> 命令时，你会看到一个包含多个列的表格。每一列都提供了关于进程的重要信息。下面是对这些列的详细解释：</p><ul><li><p><strong>USER</strong>：启动该进程的用户。</p></li><li><p><strong>PID</strong>：进程的唯一标识符（<strong>P</strong>rocess <strong>ID</strong>）。当你需要杀死一个进程时，通常会用到这个 ID。</p></li><li><p><strong>%CPU</strong>：进程在最近一段时间内使用的 <strong>CPU</strong> 占用率。</p></li><li><p><strong>%MEM</strong>：进程使用的 <strong>物理内存</strong> 占用率。</p></li><li><p><strong>VSZ</strong>：进程使用的虚拟内存大小（<strong>V</strong>irtual <strong>S</strong>ize），单位为千字节（KB）。</p></li><li><p><strong>RSS</strong>：进程使用的 <strong>物理内存</strong> 大小（<strong>R</strong>esident <strong>S</strong>et <strong>S</strong>ize），单位为千字节（KB）。</p></li><li><p><strong>TTY</strong>：进程运行所在的终端。如果显示 <code>?</code>，表示该进程没有关联的终端，通常是系统进程。</p></li><li><p><strong>STAT</strong>：进程的当前状态（<strong>STAT</strong>us）。这是一个非常重要的列，常用的状态码有：</p><ul><li><p><strong>R</strong>：正在运行（<strong>R</strong>unning）或可运行（<strong>R</strong>unnable）。</p></li><li><p><strong>S</strong>：可中断的睡眠状态（<strong>S</strong>leeping）。</p></li><li><p><strong>D</strong>：不可中断的睡眠状态（<strong>D</strong>isk sleep），通常表示进程正在等待 I/O 操作。</p></li><li><p><strong>Z</strong>：僵尸进程（<strong>Z</strong>ombie），进程已终止，但其父进程还未对其进行善后处理。</p></li><li><p><strong>T</strong>：停止（<strong>S</strong>topped），进程被信号停止。</p></li><li><p><strong>&lt;</strong>：高优先级进程。</p></li><li><p><strong>N</strong>：低优先级进程。</p></li></ul></li><li><p><strong>START</strong>：进程启动的时间。</p></li><li><p><strong>TIME</strong>：进程已经消耗的 <strong>CPU 时间</strong> 总量。这与 %CPU 不同，%CPU 是瞬时值，而 TIME 是累积值。</p></li><li><p><strong>COMMAND</strong>：启动该进程的完整命令，包括所有参数。</p></li></ul><h3 id="示例解析"><a class="markdownIt-Anchor" href="#示例解析"></a> 示例解析</h3><p>假设你运行 <code>ps -aux</code> 看到以下一行输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root      <span class="token number">1234</span>  <span class="token number">0.0</span>  <span class="token number">0.1</span> <span class="token number">23456</span> <span class="token number">1234</span> ?        S    Sep01  <span class="token number">0</span>:05 /usr/sbin/sshd <span class="token parameter variable">-D</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>USER</strong>：<code>root</code> 用户。</p></li><li><p><strong>PID</strong>：进程 ID 是 <code>1234</code>。</p></li><li><p><strong>%CPU</strong>：CPU 占用率是 <code>0.0%</code>。</p></li><li><p><strong>%MEM</strong>：内存占用率是 <code>0.1%</code>。</p></li><li><p><strong>VSZ</strong>：虚拟内存大小是 <code>23456 KB</code>。</p></li><li><p><strong>RSS</strong>：物理内存大小是 <code>1234 KB</code>。</p></li><li><p><strong>TTY</strong>：<code>?</code>，表示没有关联的终端。</p></li><li><p><strong>STAT</strong>：<code>S</code>，表示进程处于可中断的睡眠状态。</p></li><li><p><strong>START</strong>：启动时间是 <code>Sep01</code>。</p></li><li><p><strong>TIME</strong>：总 CPU 时间是 <code>0:05</code>（5秒）。</p></li><li><p><strong>COMMAND</strong>：完整的命令是 <code>/usr/sbin/sshd -D</code>，这是一个 SSH 服务守护进程。</p></li></ul><p>通过这些信息，你可以快速了解一个进程是由谁运行的、它消耗了多少资源、处于什么状态，以及它是什么程序。这对于系统监控和故障排除非常有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="内核" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8/"/>
    
    <category term="进程" scheme="https://blog.godmao.top/Tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux C标准IO操作</title>
    <link href="https://blog.godmao.top/posts/45385/"/>
    <id>https://blog.godmao.top/posts/45385/</id>
    <published>2025-09-09T12:54:03.000Z</published>
    <updated>2025-09-09T12:58:06.832Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h1 id="c-标准库-io-函数基于-stdioh"><a class="markdownIt-Anchor" href="#c-标准库-io-函数基于-stdioh"></a> 📌 C 标准库 I/O 函数（基于 <code>&lt;stdio.h&gt;</code>）</h1><h2 id="1-打开和关闭文件"><a class="markdownIt-Anchor" href="#1-打开和关闭文件"></a> 1. 打开和关闭文件</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span>  </span>FILE <span class="token operator">*</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">fclose</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>fopen 参数 mode 常用值：</strong></p><ul><li><p><code>&quot;r&quot;</code>：只读（文件必须存在）</p></li><li><p><code>&quot;w&quot;</code>：只写（不存在则创建，存在则清空）</p></li><li><p><code>&quot;a&quot;</code>：追加写（不存在则创建）</p></li><li><p><code>&quot;r+&quot;</code>：读写（必须存在）</p></li><li><p><code>&quot;w+&quot;</code>：读写（不存在则创建，存在则清空）</p></li><li><p><code>&quot;a+&quot;</code>：读写（追加模式）</p></li></ul></li></ul><hr /><h2 id="2-读写字符"><a class="markdownIt-Anchor" href="#2-读写字符"></a> 2. 读写字符</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 读取一个字符</span><span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 写入一个字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token function">fgetc</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fputc</span><span class="token punctuation">(</span><span class="token char">'A'</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr /><h2 id="3-读写字符串"><a class="markdownIt-Anchor" href="#3-读写字符串"></a> 3. 读写字符串</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">fgets</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 读取一行（最多 size-1 个字符） </span><span class="token keyword">int</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 写入字符串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">fgets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token string">"Hello\n"</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr /><h2 id="4-格式化-io"><a class="markdownIt-Anchor" href="#4-格式化-io"></a> 4. 格式化 I/O</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fprintf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 格式化输出到文件 </span><span class="token keyword">int</span> <span class="token function">fscanf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 格式化读取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"name=%s age=%d\n"</span><span class="token punctuation">,</span> <span class="token string">"Tom"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s %d"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr /><h2 id="5-块读写适合二进制文件"><a class="markdownIt-Anchor" href="#5-块读写适合二进制文件"></a> 5. 块读写（适合二进制文件）</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">size_t</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">size_t</span> <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token function">fwrite</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 写10个整数 </span><span class="token function">fread</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 读10个整数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr /><h2 id="6-文件定位"><a class="markdownIt-Anchor" href="#6-文件定位"></a> 6. 文件定位</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fseek</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 移动文件指针</span><span class="token keyword">long</span> <span class="token function">ftell</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 获取当前位置 </span><span class="token keyword">void</span> <span class="token function">rewind</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 回到开头`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>whence</code> 可取：</p><ul><li><p><code>SEEK_SET</code>：文件开头</p></li><li><p><code>SEEK_CUR</code>：当前位置</p></li><li><p><code>SEEK_END</code>：文件末尾</p></li></ul><hr /><h2 id="7-缓冲刷新"><a class="markdownIt-Anchor" href="#7-缓冲刷新"></a> 7. 缓冲刷新</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fflush</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 强制把缓冲区写入文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用于写日志，避免异常退出时丢数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="IO" scheme="https://blog.godmao.top/Tags/IO/"/>
    
    <category term="内核" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统IO编程</title>
    <link href="https://blog.godmao.top/posts/7076/"/>
    <id>https://blog.godmao.top/posts/7076/</id>
    <published>2025-09-09T05:15:16.000Z</published>
    <updated>2025-09-09T13:04:05.999Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="文件描述符内核分发的身份证"><a class="markdownIt-Anchor" href="#文件描述符内核分发的身份证"></a> 文件描述符：内核分发的身份证</h2><p>在 Linux 系统中，<strong>文件描述符（File Descriptor，简称 FD）是一个核心概念，它是一个非负整数</strong>，用于唯一标识一个已打开的文件。这个文件可以是普通文件、目录、网络套接字（socket），甚至是设备（如键盘、显示器）。</p><p>文件描述符的设计主要有以下几个优点：</p><ol><li><p><strong>简化了 I/O 接口</strong>：无论是读写本地文件，还是进行网络通信，开发者都可以使用一套统一的系统调用（<code>read</code>, <code>write</code>, <code>close</code> 等），而无需关心底层的具体类型。这种“一切皆文件”的设计哲学是 Linux 简洁和强大的体现。</p></li><li><p><strong>隔离了应用程序与内核</strong>：应用程序只知道一个简单的整数，而不需要知道文件在磁盘上的物理位置，也不用关心内核是如何管理文件的。所有复杂的操作都由内核在幕后完成。</p></li><li><p><strong>管理系统资源</strong>：内核通过文件描述符表来管理每个进程打开的文件。当一个进程结束时，内核可以根据这个表自动关闭所有打开的文件，避免资源泄露。</p></li></ol><p>文件描述符的几个重要特点：</p><ul><li><p><strong>唯一性</strong>：在一个进程中，每个打开的文件都有一个独一无二的文件描述符。</p></li><li><p><strong>非负整数</strong>：文件描述符的值通常从 3 开始分配，因为 0、1、2 这三个描述符被系统预留给标准输入、标准输出和标准错误。</p><ul><li><p><strong>0</strong>：标准输入（<code>stdin</code>），通常是键盘。</p></li><li><p><strong>1</strong>：标准输出（<code>stdout</code>），通常是显示器。</p></li><li><p><strong>2</strong>：标准错误（<code>stderr</code>），也通常是显示器。</p></li></ul></li><li><p><strong>进程私有</strong>：文件描述符是在进程内部使用的，不同进程的文件描述符互不影响。例如，进程 A 的文件描述符 3 和进程 B 的文件描述符 3 可能指向完全不同的文件。</p></li></ul><h2 id="最基础的系统调用函数"><a class="markdownIt-Anchor" href="#最基础的系统调用函数"></a> 最基础的系统调用函数</h2><p><strong>Linux I/O 编程中常见的系统调用函数</strong>，这些函数位于 <strong><code>unistd.h</code></strong>（以及 <code>fcntl.h</code> 等）中，是用户态和内核态交互的基础接口。</p><h3 id="1-open"><a class="markdownIt-Anchor" href="#1-open"></a> 1. <code>open</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span>    <span class="token comment">// open flags</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h4><p>打开或创建一个文件，返回一个 <strong>文件描述符</strong>（fd，整数），后续 I/O 都依赖它。</p><h4 id="参数"><a class="markdownIt-Anchor" href="#参数"></a> 参数</h4><ul><li><p><code>pathname</code>：文件路径。</p></li><li><p><code>flags</code>：打开方式，常用值：</p><ul><li><p><code>O_RDONLY</code>：只读</p></li><li><p><code>O_WRONLY</code>：只写</p></li><li><p><code>O_RDWR</code>：读写</p></li><li><p><code>O_CREAT</code>：若文件不存在则创建，需要配合 <code>mode</code> 参数</p></li><li><p><code>O_TRUNC</code>：打开时清空文件</p></li><li><p><code>O_APPEND</code>：写时追加到文件尾部</p></li><li><p><code>O_NOBLOCK</code>：非阻塞模式</p></li></ul></li><li><p><code>mode</code>：创建文件时的权限（如 <code>0666</code>，受 umask 影响）。</p></li></ul><h4 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h4><ul><li><p>成功：文件描述符（非负整数）</p></li><li><p>失败：<code>-1</code>，并设置 <code>errno</code></p></li></ul><hr /><h3 id="2-write"><a class="markdownIt-Anchor" href="#2-write"></a> 2. <code>write</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token class-name">ssize_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2"></a> 作用</h4><p>向文件（或设备）写入数据。</p><h4 id="参数-2"><a class="markdownIt-Anchor" href="#参数-2"></a> 参数</h4><ul><li><p><code>fd</code>：文件描述符</p></li><li><p><code>buf</code>：要写入的数据缓冲区指针</p></li><li><p><code>count</code>：要写入的字节数</p></li></ul><h4 id="返回值-2"><a class="markdownIt-Anchor" href="#返回值-2"></a> 返回值</h4><ul><li><p>成功：实际写入的字节数（可能小于 <code>count</code>）</p></li><li><p>失败：<code>-1</code></p></li></ul><h4 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h4><ul><li><p>对于普通文件，通常会写入全部数据。</p></li><li><p>对于管道、socket 等，可能分多次写入，需要循环写。</p></li></ul><hr /><h3 id="3-read"><a class="markdownIt-Anchor" href="#3-read"></a> 3. <code>read</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>  <span class="token class-name">ssize_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="作用-3"><a class="markdownIt-Anchor" href="#作用-3"></a> 作用</h4><p>从文件（或设备）读取数据。</p><h4 id="参数-3"><a class="markdownIt-Anchor" href="#参数-3"></a> 参数</h4><ul><li><p><code>fd</code>：文件描述符</p></li><li><p><code>buf</code>：存放读出数据的缓冲区</p></li><li><p><code>count</code>：最大读取字节数</p></li></ul><h4 id="返回值-3"><a class="markdownIt-Anchor" href="#返回值-3"></a> 返回值</h4><ul><li><p>成功：实际读取的字节数</p><ul><li><code>0</code> 表示到达文件结尾 (EOF)</li></ul></li><li><p>失败：<code>-1</code></p></li></ul><h4 id="注意-2"><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h4><ul><li><p>实际读取字节数可能小于 <code>count</code>。</p></li><li><p>对于阻塞 I/O，如果没有数据，可能会挂起等待。</p></li></ul><hr /><h3 id="4-lseek"><a class="markdownIt-Anchor" href="#4-lseek"></a> 4. <code>lseek</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span>  </span><span class="token class-name">off_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="作用-4"><a class="markdownIt-Anchor" href="#作用-4"></a> 作用</h4><p>移动文件读写位置（文件指针）。</p><h4 id="参数-4"><a class="markdownIt-Anchor" href="#参数-4"></a> 参数</h4><ul><li><p><code>fd</code>：文件描述符</p></li><li><p><code>offset</code>：偏移量（可正可负）</p></li><li><p><code>whence</code>：偏移起始点</p><ul><li><p><code>SEEK_SET</code>：从文件开头</p></li><li><p><code>SEEK_CUR</code>：从当前位置</p></li><li><p><code>SEEK_END</code>：从文件末尾</p></li></ul></li></ul><h4 id="返回值-4"><a class="markdownIt-Anchor" href="#返回值-4"></a> 返回值</h4><ul><li><p>成功：新的文件偏移位置</p></li><li><p>失败：<code>-1</code></p></li></ul><h4 id="注意-3"><a class="markdownIt-Anchor" href="#注意-3"></a> 注意</h4><ul><li><p>常用来实现随机读写。</p></li><li><p>对某些设备文件可能不支持（如管道）。</p></li></ul><hr /><h3 id="5-close"><a class="markdownIt-Anchor" href="#5-close"></a> 5. <code>close</code></h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="作用-5"><a class="markdownIt-Anchor" href="#作用-5"></a> 作用</h4><p>关闭一个打开的文件描述符，释放内核资源。</p><h4 id="参数-5"><a class="markdownIt-Anchor" href="#参数-5"></a> 参数</h4><ul><li><code>fd</code>：文件描述符</li></ul><h4 id="返回值-5"><a class="markdownIt-Anchor" href="#返回值-5"></a> 返回值</h4><ul><li><p>成功：<code>0</code></p></li><li><p>失败：<code>-1</code></p></li></ul><h2 id="常见函数查找表"><a class="markdownIt-Anchor" href="#常见函数查找表"></a> 常见函数查找表</h2><table><thead><tr><th>函数</th><th>头文件</th><th>功能</th><th>主要参数</th><th>返回值</th><th>常见用途</th></tr></thead><tbody><tr><td><code>open</code></td><td><code>&lt;fcntl.h&gt;</code>, <code>&lt;unistd.h&gt;</code></td><td>打开或创建文件，返回文件描述符</td><td><code>pathname</code>：路径<code>flags</code>：打开方式（如 <code>O_RDONLY</code>）<code>mode</code>：权限（如 <code>0644</code>，仅在 <code>O_CREAT</code> 时有效）</td><td>成功：文件描述符 (≥0)失败：<code>-1</code></td><td>打开文件/设备，获得 <code>fd</code></td></tr><tr><td><code>write</code></td><td><code>&lt;unistd.h&gt;</code></td><td>向文件写入数据</td><td><code>fd</code>：文件描述符<code>buf</code>：数据缓冲区<code>count</code>：要写入字节数</td><td>成功：实际写入字节数失败：<code>-1</code></td><td>向文件、管道、socket 写数据</td></tr><tr><td><code>read</code></td><td><code>&lt;unistd.h&gt;</code></td><td>从文件读取数据</td><td><code>fd</code>：文件描述符<code>buf</code>：存放数据的缓冲区<code>count</code>：最大读取字节数</td><td>成功：实际读取字节数<code>0</code>：文件结尾失败：<code>-1</code></td><td>读取文件、键盘输入、网络数据</td></tr><tr><td><code>lseek</code></td><td><code>&lt;unistd.h&gt;</code></td><td>改变文件读写位置（文件指针）</td><td><code>fd</code>：文件描述符<code>offset</code>：偏移量<code>whence</code>：参考位置（<code>SEEK_SET</code>/<code>SEEK_CUR</code>/<code>SEEK_END</code>）</td><td>成功：新的偏移位置失败：<code>-1</code></td><td>随机读写文件、获取文件大小</td></tr><tr><td><code>close</code></td><td><code>&lt;unistd.h&gt;</code></td><td>关闭文件描述符，释放资源</td><td><code>fd</code>：文件描述符</td><td>成功：<code>0</code>失败：<code>-1</code></td><td>程序结束或文件不再使用时关闭</td></tr><tr><td><code>sync</code></td><td><code>&lt;unistd.h&gt;</code></td><td>将内核缓冲区中所有修改过的数据（脏页）写入磁盘</td><td>无</td><td>无返回值</td><td>全局刷新，影响所有文件，效率较低</td></tr><tr><td><code>fsync</code></td><td><code>&lt;unistd.h&gt;</code></td><td>将指定文件的缓存数据强制写入磁盘</td><td><code>fd</code>：文件描述符</td><td>成功：<code>0</code>，失败：<code>-1</code></td><td>精确到单个文件，常用于数据库、日志写入</td></tr><tr><td><code>pipe</code></td><td><code>&lt;unistd.h&gt;</code></td><td>创建匿名管道，用于进程间通信</td><td><code>int pipefd[2]</code></td><td>成功：0，失败：-1</td><td><code>pipefd[0]</code> 读端，<code>pipefd[1]</code> 写端</td></tr><tr><td><code>unlink</code></td><td><code>&lt;unistd.h&gt;</code></td><td>删除一个文件（目录用 <code>rmdir</code>）</td><td><code>pathname</code>：文件路径</td><td>成功：0，失败：-1</td><td>实际删除在引用计数归零时发生</td></tr><tr><td><code>access</code></td><td><code>&lt;unistd.h&gt;</code></td><td>检查文件是否存在及权限</td><td><code>pathname, mode</code></td><td>成功：0，失败：-1</td><td><code>mode</code> 可取 <code>R_OK, W_OK, X_OK, F_OK</code></td></tr></tbody></table><h2 id="对比c-标准库io操作"><a class="markdownIt-Anchor" href="#对比c-标准库io操作"></a> 对比C 标准库IO操作</h2><p>使用c标准库的IO操作，小量频繁读写的效率更高，因为其内部自带有缓冲区。<br />这可以理解为在系统IO上有封装了一层，进行文件操作时写入C自带缓冲区，满足一定条件再调用系统IO，将缓冲区的内容写入IO缓存区，再到内核的页缓存区，最后到物理的磁盘。</p><table><thead><tr><th>特性</th><th>Linux 系统调用 I/O</th><th>C 标准库文件操作</th></tr></thead><tbody><tr><td><strong>头文件</strong></td><td><code>&lt;unistd.h&gt;</code>, <code>&lt;fcntl.h&gt;</code></td><td><code>&lt;stdio.h&gt;</code></td></tr><tr><td><strong>函数示例</strong></td><td><code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code>, <code>close</code></td><td><code>fopen</code>, <code>fread</code>, <code>fwrite</code>, <code>fseek</code>, <code>fclose</code>, <code>fprintf</code>, <code>fscanf</code></td></tr><tr><td><strong>返回值</strong></td><td>直接返回字节数、文件描述符等，或 <code>-1</code></td><td>返回 <code>FILE*</code> 指针，或 <code>EOF</code> 等错误码</td></tr><tr><td><strong>数据单位</strong></td><td>以 <strong>字节（byte）</strong> 为单位</td><td>以 <strong>缓冲区 / 结构化数据</strong> 为单位（有缓冲机制）</td></tr><tr><td><strong>缓冲</strong></td><td><strong>无用户态缓冲</strong>，直接在用户空间和内核空间间传递数据</td><td><strong>带缓冲区</strong>（stdio 库内部维护缓存，加速小块读写）</td></tr><tr><td><strong>层次</strong></td><td>操作系统内核提供的 <strong>底层接口</strong></td><td>基于系统调用的 <strong>封装库函数</strong></td></tr><tr><td><strong>灵活性</strong></td><td>可操作普通文件、设备文件、socket、管道</td><td>主要操作普通文件和标准输入输出</td></tr><tr><td><strong>可移植性</strong></td><td>偏向 Unix/Linux 系统</td><td>跨平台（符合 ANSI C 标准，Windows/Linux 通用）</td></tr><tr><td><strong>典型用途</strong></td><td>驱动开发、系统编程、精确控制 I/O</td><td>应用层文件读写、文本处理、快速开发</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="IO" scheme="https://blog.godmao.top/Tags/IO/"/>
    
    <category term="内核" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>MakeFile简明指南</title>
    <link href="https://blog.godmao.top/posts/4341/"/>
    <id>https://blog.godmao.top/posts/4341/</id>
    <published>2025-09-07T13:48:09.000Z</published>
    <updated>2025-09-17T13:36:34.997Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><p>在软件开发中，项目通常包含很多源文件，如果每次编译都手动敲命令，不仅繁琐，还容易出错。<br /><strong>Makefile</strong> 可以帮助我们自动化构建流程，大幅提升效率。本文将介绍 Makefile 的基础语法与常用用法。</p><hr /><ul><li><a href="#1-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95">1. 基础用法</a></li><li><a href="#2-%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%911">2. 执行逻辑^1</a><ul><li><a href="#21--%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE">2.1. 🔄 执行流程示意图</a></li></ul></li><li><a href="#3-%E4%BC%AA%E7%9B%AE%E6%A0%87-phony">3. 伪目标 .PHONY</a></li><li><a href="#4-%E5%8F%98%E9%87%8F">4. 变量</a><ul><li><a href="#41-%E8%B5%8B%E5%80%BC%E7%AC%A6%E5%8F%B7">4.1. 赋值符号</a></li></ul></li><li><a href="#5-%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6">5. 隐含规则与通配符</a></li><li><a href="#6-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF">6. 条件分支</a><ul><li><a href="#61-%E8%AF%AD%E6%B3%95">6.1. 语法</a></li><li><a href="#62-%E7%A4%BA%E4%BE%8B%E4%B8%80%E6%A0%B9%E6%8D%AE%E5%B9%B3%E5%8F%B0%E9%80%89%E6%8B%A9clean%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F">6.2. 示例一：根据平台选择clean执行方式</a></li><li><a href="#63-%E7%A4%BA%E4%BE%8B%E4%BA%8C%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F">6.3. 示例二：调试模式与发布模式</a></li></ul></li><li><a href="#7-%E5%87%BD%E6%95%B0">7. 函数</a><ul><li><a href="#71-subst--%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2">7.1. <code>subst</code> —— 字符串替换</a></li><li><a href="#72-patsubst--%E6%A8%A1%E5%BC%8F%E6%9B%BF%E6%8D%A2">7.2. <code>patsubst</code> —— 模式替换</a></li><li><a href="#73-wildcard--%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8">7.3. <code>wildcard</code> —— 获取文件列表</a></li><li><a href="#74-notdir--%E5%8E%BB%E6%8E%89%E8%B7%AF%E5%BE%84%E5%8F%AA%E4%BF%9D%E7%95%99%E6%96%87%E4%BB%B6%E5%90%8D">7.4. <code>notdir</code> —— 去掉路径，只保留文件名</a></li><li><a href="#75-dir--%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E9%83%A8%E5%88%86">7.5. <code>dir</code> —— 获取路径部分</a></li><li><a href="#76-basename--addsuffix-%E5%92%8C-addprefix--%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E5%90%8D">7.6. <code>basename</code> 、 <code>addsuffix</code> 和 <code>addprefix</code> —— 批量处理文件名</a></li><li><a href="#77-shell--%E6%89%A7%E8%A1%8C-shell-%E5%91%BD%E4%BB%A4">7.7. <code>shell</code> —— 执行 shell 命令</a></li></ul></li><li><a href="#8-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F">8. 完整示例程序</a></li></ul><h2 id="1-基础用法"><a class="markdownIt-Anchor" href="#1-基础用法"></a> 1. 基础用法</h2><p>一个典型的规则格式如下：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">target: dependencies&lt;TAB&gt; command<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>target：目标文件，比如可执行文件或中间文件。</li><li>dependencies：依赖文件（源文件、头文件等）。</li><li>command：生成目标所需要执行的命令（必须以 TAB 缩进 开头）。</li></ul><p>示例：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">main.o: main.cgcc -c main.c -o main.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="admonition warning"><p class="admonition-title">warning</p><p>由于makfile对空格、tab极其敏感，建议编写时打开编辑器的空格、tab显示，并避免不必要的空格，规范化书写。</p></div><h2 id="2-执行逻辑"><a class="markdownIt-Anchor" href="#2-执行逻辑"></a> 2. 执行逻辑<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2><p>当我们执行 <code>make</code> 时，大致流程如下：</p><ol><li><p><strong>解析 Makefile</strong></p><ul><li><code>make</code> 会从当前目录寻找 <code>Makefile</code> 或 <code>makefile</code> 文件。</li><li>读取其中的规则、变量、伪目标等定义。</li></ul></li><li><p><strong>确定默认目标</strong></p><ul><li>一般是文件中的第一个目标（例如 <code>app</code>）。</li><li>也可以通过命令行指定，例如：</li></ul></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li><p><strong>检查依赖关系</strong></p><ul><li>从目标开始，逐层检查依赖文件是否存在、是否比目标文件更新。</li><li>如果依赖文件比目标文件“新”，说明目标需要重新生成。</li></ul></li><li><p><strong>执行命令</strong></p><ul><li>对需要更新的目标，执行其规则中定义的命令。</li><li>命令必须以 <strong>TAB 缩进</strong> 开头。</li></ul></li><li><p><strong>递归构建</strong></p><ul><li>如果依赖文件本身也是其他规则的目标，则会递归检查和执行。</li><li>直到所有依赖满足，才最终生成目标。</li></ul></li><li><p><strong>结束</strong></p><ul><li>如果所有目标都已是最新，则 <code>make</code> 会提示：</li></ul></li></ol><pre class="line-numbers language-none"><code class="language-none">make: &#39;app&#39; is up to date.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="21-执行流程示意图"><a class="markdownIt-Anchor" href="#21-执行流程示意图"></a> 2.1. 🔄 执行流程示意图</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">          make           │           ▼   读取并解析 Makefile           │           ▼   确定要构建的目标 (默认/指定)           │           ▼   检查目标的依赖文件           │    ┌──────┴────────┐    │               │依赖比目标旧      依赖比目标新/不存在    │               │目标已是最新    执行规则命令 → 生成新目标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="admonition info"><p class="admonition-title">tips</p><p>可以使用 make -f [makefile_name] 指定使用某个makefile文件。</p></div><h2 id="3-伪目标-phony"><a class="markdownIt-Anchor" href="#3-伪目标-phony"></a> 3. 伪目标 .PHONY</h2><p>有些目标不是实际文件，而只是一个操作，例如 <code>clean</code>。<br />这时建议使用 <strong>.PHONY</strong> 声明：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">.PHONY: clean  clean:  rm -r  [filepath]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>指定make目标文件：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">make clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-变量"><a class="markdownIt-Anchor" href="#4-变量"></a> 4. 变量</h2><p>Makefile 支持变量，常用于保存编译器或编译选项。<br />使用示例如下：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">CC &#x3D; gccCFLAGS &#x3D; -Wall -gapp: main.o utils.o$(CC) $(CFLAGS) main.o utils.o -o appmain.o: main.c$(CC) $(CFLAGS) -c main.c -o main.outils.o: utils.c$(CC) $(CFLAGS) -c utils.c -o utils.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="41-赋值符号"><a class="markdownIt-Anchor" href="#41-赋值符号"></a> 4.1. 赋值符号</h3><ul><li><strong>=</strong><br />我称之为最终赋值，同一个变量无论被赋值多次，永远取最后指定的值。<br />示例：</li></ul><pre class="line-numbers language-make" data-language="make"><code class="language-make">VIR_A &#x3D; AVIR_B &#x3D; $(VIR_A) BVIR_A &#x3D; AA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后VIR_B的值是AA B。</p><ul><li><strong>:=</strong><br />立即赋值，正常逻辑的赋值号，类似于c语言的赋值号。</li><li><strong>?=</strong><br />如果变量在之前没有被赋值则赋值。<br />可以理解为  <pre class="line-numbers language-none"><code class="language-none">#ifndef#define ...#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><strong>+=</strong><br />追加赋值，将值追加到变量中。</li></ul><h2 id="5-隐含规则与通配符"><a class="markdownIt-Anchor" href="#5-隐含规则与通配符"></a> 5. 隐含规则与通配符</h2><p>Make 内置了一些规则，可以用简写方式：</p><ul><li><code>$@</code>：目标文件名</li><li><code>$&lt;</code>：第一个依赖文件</li><li><code>$^</code>：所有依赖文件</li></ul><p><code>%</code> 表示可以匹配任意长度的字符串，用于定义一类文件的生成规则。例如：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">%.o: %.c     gcc -c $&lt; -o $@<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>含义：<ul><li><code>%.o</code> 表示所有以 <code>.o</code> 结尾的目标文件。</li><li><code>%.c</code> 表示所有以 <code>.c</code> 结尾的源文件。</li><li><code>$&lt;</code> 是第一个依赖文件（这里是 <code>.c</code> 文件）。</li><li><code>$@</code> 是目标文件（这里是 <code>.o</code> 文件）。</li></ul></li><li>作用：这条规则表示，所有 <code>.c</code> 文件可以通过编译生成对应的 <code>.o</code> 文件。</li></ul><hr /><p><code>%</code> 可以匹配文件名的某一部分，用于简化规则。例如：</p><pre class="line-numbers language-none"><code class="language-none">build&#x2F;%: src&#x2F;%     cp $&lt; $@<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>含义：<ul><li><code>build/%</code> 表示目标文件在 <code>build/</code> 目录下。</li><li><code>src/%</code> 表示依赖文件在 <code>src/</code> 目录下。</li><li><code>$&lt;</code> 是依赖文件，<code>$@</code> 是目标文件。</li></ul></li><li>作用：这条规则表示，将 <code>src/</code> 目录下的文件复制到 <code>build/</code> 目录下。</li></ul><hr /><p>在模式规则中，<code>%</code> 可以用于定义多个目标。例如：</p><pre class="line-numbers language-none"><code class="language-none">%.a: %.b %.c     cat $^ &gt; $@&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>含义：<ul><li><code>%.a</code> 是目标文件。</li><li><code>%.b</code> 和 <code>%.c</code> 是依赖文件。</li><li><code>$^</code> 表示所有依赖文件，<code>$@</code> 是目标文件。</li></ul></li><li>作用：这条规则表示，将 <code>.b</code> 和 <code>.c</code> 文件合并生成 <code>.a</code> 文件。</li></ul><hr /><h2 id="6-条件分支"><a class="markdownIt-Anchor" href="#6-条件分支"></a> 6. 条件分支</h2><p>在 Makefile 中，我们可以使用条件语句来根据不同情况执行不同规则或定义变量。常见的有 <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code>。</p><h3 id="61-语法"><a class="markdownIt-Anchor" href="#61-语法"></a> 6.1. 语法</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">ifeq (条件1, 条件2)    # 当 条件1 &#x3D;&#x3D; 条件2 时执行这里else    # 否则执行这里endififneq (条件1, 条件2)    # 当 条件1 !&#x3D; 条件2 时执行这里endififdef 变量名    # 当变量已定义时执行这里endififndef 变量名    # 当变量未定义时执行这里endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="62-示例一根据平台选择clean执行方式"><a class="markdownIt-Anchor" href="#62-示例一根据平台选择clean执行方式"></a> 6.2. 示例一：根据平台选择clean执行方式</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make"># 默认变量CC &#x3D; gcc# 判断系统ifeq ($(OS), Windows_NT)    RM &#x3D; delelse    RM &#x3D; rm -fendifapp: main.o$(CC) main.o -o appclean:$(RM) *.o app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="63-示例二调试模式与发布模式"><a class="markdownIt-Anchor" href="#63-示例二调试模式与发布模式"></a> 6.3. 示例二：调试模式与发布模式</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make"># 设置编译选项CFLAGS &#x3D; -Wallifeq ($(MODE), debug)    CFLAGS +&#x3D; -gelse    CFLAGS +&#x3D; -O2endifapp: main.o$(CC) $(CFLAGS) main.o -o app<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用方式：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">MODE</span><span class="token operator">=</span>debug   <span class="token comment"># 调试模式，带调试信息</span><span class="token function">make</span> <span class="token assign-left variable">MODE</span><span class="token operator">=</span>release <span class="token comment"># 默认优化模式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="7-函数"><a class="markdownIt-Anchor" href="#7-函数"></a> 7. 函数</h2><p>Makefile 内置了许多函数，用来处理字符串、文件名、路径等。<br />常见函数格式为：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">$(函数名 参数1 参数2 ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面介绍一些<strong>常用函数</strong></p><h3 id="71-subst-字符串替换"><a class="markdownIt-Anchor" href="#71-subst-字符串替换"></a> 7.1. <code>subst</code> —— 字符串替换</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">$(subst from,to,text)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>功能：将 <code>text</code> 中的 <code>from</code> 替换为 <code>to</code>。</p></li><li><p>示例：</p></li></ul><pre class="line-numbers language-none"><code class="language-none">SRC &#x3D; main.c utils.c OBJ &#x3D; $(subst .c,.o,$(SRC)) # 结果：OBJ &#x3D; main.o utils.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr /><h3 id="72-patsubst-模式替换"><a class="markdownIt-Anchor" href="#72-patsubst-模式替换"></a> 7.2. <code>patsubst</code> —— 模式替换</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">$(patsubst pattern,replacement,text)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>功能：更灵活的字符串替换，支持通配符 <code>%</code>。</p></li><li><p>示例：</p></li></ul><pre class="line-numbers language-make" data-language="make"><code class="language-make">SRC &#x3D; main.c utils.c test.cOBJ &#x3D; $(patsubst %.c,%.o,$(SRC))# 结果：OBJ &#x3D; main.o utils.o test.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr /><h3 id="73-wildcard-获取文件列表"><a class="markdownIt-Anchor" href="#73-wildcard-获取文件列表"></a> 7.3. <code>wildcard</code> —— 获取文件列表</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">$(wildcard pattern)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>功能：匹配符合模式的文件。</p></li><li><p>示例：</p></li></ul><pre class="line-numbers language-make" data-language="make"><code class="language-make">SRC &#x3D; $(wildcard *.c)# 结果：SRC &#x3D; 当前目录下所有 .c 文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr /><h3 id="74-notdir-去掉路径只保留文件名"><a class="markdownIt-Anchor" href="#74-notdir-去掉路径只保留文件名"></a> 7.4. <code>notdir</code> —— 去掉路径，只保留文件名</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">FILES &#x3D; src&#x2F;main.c src&#x2F;utils.cNAMES &#x3D; $(notdir $(FILES))# 结果：NAMES &#x3D; main.c utils.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr /><h3 id="75-dir-获取路径部分"><a class="markdownIt-Anchor" href="#75-dir-获取路径部分"></a> 7.5. <code>dir</code> —— 获取路径部分</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">FILES &#x3D; src&#x2F;main.c src&#x2F;utils.cPATHS &#x3D; $(dir $(FILES))# 结果：PATHS &#x3D; src&#x2F; src&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr /><h3 id="76-basename-addsuffix-和-addprefix-批量处理文件名"><a class="markdownIt-Anchor" href="#76-basename-addsuffix-和-addprefix-批量处理文件名"></a> 7.6. <code>basename</code> 、 <code>addsuffix</code> 和 <code>addprefix</code> —— 批量处理文件名</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">FILES &#x3D; main.c utils.c# 去掉后缀NAMES &#x3D; $(basename $(FILES))# NAMES &#x3D; main utils# 批量添加后缀OBJS &#x3D; $(addsuffix .o,$(NAMES))# OBJS &#x3D; main.o utils.o# 批量添加前缀OBJS &#x3D; $(addprefix -I,$(NAMES))# OBJS &#x3D; -Imain -Iutils<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr /><h3 id="77-shell-执行-shell-命令"><a class="markdownIt-Anchor" href="#77-shell-执行-shell-命令"></a> 7.7. <code>shell</code> —— 执行 shell 命令</h3><pre class="line-numbers language-make" data-language="make"><code class="language-make">DATE &#x3D; $(shell date +%Y-%m-%d)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样可以在 Makefile 中直接使用系统命令的输出。</p><h2 id="8-完整示例程序"><a class="markdownIt-Anchor" href="#8-完整示例程序"></a> 8. 完整示例程序</h2><p>这是一个完整Makefile示例程序，用于将c语言程序编译为可执行的二进制bin文件。它可以制成镜像供SoC烧录。</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">#0############################################################ 设置目录变量，方便统一管理和修改# 当前根目录:ROOT_DIR :&#x3D; .# 中间目标文件（.o）输出目录:BUILD_DIR :&#x3D; build# 最终生成的二进制文件（.bin）目录:BIN_DIR :&#x3D; bin# 工程名NAME :&#x3D; key# 指定链接脚本LDS &#x3D; imx.lds##############################################################1############################################################ 自动查找 src&#x2F; 目录下的所有 .c 文件SRCS &#x3D; $(shell find $(ROOT_DIR) -name &quot;*.c&quot;)# 将 SRC中的 xxx.c 转换为 build&#x2F;xxx.o# 同时添加 build&#x2F;startup.o（汇编启动文件）OBJS &#x3D; $(BUILD_DIR)&#x2F;startup.oOBJS +&#x3D; $(patsubst %.c,$(BUILD_DIR)&#x2F;%.o,$(SRCS))# 自动查找所有包含头文件的目录INC_DIRS &#x3D; $(shell find $(ROOT_DIR) -type f -name &quot;*.h&quot; -exec dirname &#123;&#125; \; | sort -u)INCLUDES &#x3D; $(addprefix -I, $(INC_DIRS))##############################################################2############################################################ 设置编译工具（使用 ARM 的交叉编译工具链）CC :&#x3D; arm-none-eabi-# 编译器（用于 .c 和 .S 文件）:GCC :&#x3D; $(CC)gcc# 链接器:LD :&#x3D; $(CC)ld# 用于将 elf 转为 bin 格式:OBJCOPY :&#x3D; $(CC)objcopy# 用于反汇编OBJDUMP :&#x3D; $(CC)objdump# 编译选项（GCC 编译阶段）# -I：指定头文件搜索目录# -Wall：打开所有警告# -O2：优化等级 2（推荐用于 release）# -nostdlib：不链接标准库（适用于裸机）# -c：只编译，不链接GCC_FLAGS &#x3D; $(INCLUDES) -Wall -nostdlib -c# 链接器选项LD_FLAGS &#x3D; -T$(LDS)# 使用 objdump 工具对生成的 ELF 文件进行反汇编# -D：反汇编所有节（包括代码段、启动代码等）# -m arm：指定目标架构为 ARM# .elf：输入的可执行文件# &gt; .dis：将反汇编结果输出为 .dis 文本文件OBJDUMP_FLAGS &#x3D; -D -m arm $(BUILD_DIR)&#x2F;$(NAME).elf &gt; $(BUILD_DIR)&#x2F;$(NAME).dis##############################################################3############################################################ 目标：生成最终的二进制文件 bin&#x2F;$(NAME).bin$(BIN_DIR)&#x2F;$(NAME).bin: $(OBJS)# 链接所有 .o 文件生成 elf 格式可执行文件    $(LD) $(LD_FLAGS) $(OBJS) -o $(BUILD_DIR)&#x2F;$(NAME).elf# 反汇编 调试用    $(OBJDUMP) $(OBJDUMP_FLAGS)# 把 elf 文件转换为裸机二进制文件（无符号、无头信息）    $(OBJCOPY) -O binary -S $(BUILD_DIR)&#x2F;$(NAME).elf $@ # 编译汇编启动文件 startup.S，生成 build&#x2F;startup.o$(BUILD_DIR)&#x2F;startup.o: startup.S# 注意 startup.S 是汇编文件，用 gcc 编译也可以，默认会调用汇编器    $(GCC) $(GCC_FLAGS) $&lt; -o $@# 编译每个 .c 文件到 build&#x2F;xxx.o# $@：目标文件（例如 build&#x2F;main.o）# $&lt;：依赖的源文件（例如 src&#x2F;main.c）$(BUILD_DIR)&#x2F;%.o: %.c# 修复由于没有文件夹报错    mkdir -p $(dir $@)    $(GCC) $(GCC_FLAGS) -c $&lt; -o $@#############################################################.PHONY: cleanclean:    rm -r $(BUILD_DIR)&#x2F;* $(BIN_DIR)&#x2F;*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个更通用的模板</p><pre class="line-numbers language-make" data-language="make"><code class="language-make"># 通用 Makefile 模板# 1. 编译器及选项CC      :&#x3D; gcc             # C 编译器 (可改成 g++)CFLAGS  :&#x3D; -Wall -O2       # 编译参数LDFLAGS :&#x3D;                 # 链接参数 (库路径)LDLIBS  :&#x3D; -lm             # 依赖的库 (-lpthread, -lrt 等)# 2. 目录结构SRC_DIR :&#x3D; src             # 源码目录OBJ_DIR :&#x3D; build           # 目标文件目录BIN_DIR :&#x3D; bin             # 可执行文件目录# 3. 自动收集源文件SRCS :&#x3D; $(wildcard $(SRC_DIR)&#x2F;*.c)OBJS :&#x3D; $(patsubst $(SRC_DIR)&#x2F;%.c,$(OBJ_DIR)&#x2F;%.o,$(SRCS))TARGET :&#x3D; $(BIN_DIR)&#x2F;app   # 生成的可执行文件名# 4. 默认目标all: $(TARGET)# 5. 链接规则$(TARGET): $(OBJS) | $(BIN_DIR)$(CC) $(LDFLAGS) -o $@ $^ $(LDLIBS)# 6. 编译规则$(OBJ_DIR)&#x2F;%.o: $(SRC_DIR)&#x2F;%.c | $(OBJ_DIR)$(CC) $(CFLAGS) -c $&lt; -o $@# 7. 目录生成$(OBJ_DIR) $(BIN_DIR):mkdir -p $@# 8. 清理.PHONY: clean runclean:rm -rf $(OBJ_DIR) $(BIN_DIR)# 9. 运行 (可选)run: all.&#x2F;$(TARGET)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>仅作了解 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="项目管理" scheme="https://blog.godmao.top/categories/Linux/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="MakeFile" scheme="https://blog.godmao.top/Tags/MakeFile/"/>
    
  </entry>
  
  <entry>
    <title>交叉编译器相关知识梳理</title>
    <link href="https://blog.godmao.top/posts/27939/"/>
    <id>https://blog.godmao.top/posts/27939/</id>
    <published>2025-09-07T09:18:55.000Z</published>
    <updated>2025-09-07T10:45:40.598Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于Linux开发板与上位机的连接方式</title>
    <link href="https://blog.godmao.top/posts/32814/"/>
    <id>https://blog.godmao.top/posts/32814/</id>
    <published>2025-09-07T09:17:17.000Z</published>
    <updated>2025-09-29T14:50:17.984Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><blockquote><p>本文旨在记录自己的IMX6ULL开发板上位机连接的过程。<s>为什么感觉是后端这一块呢？</s></p></blockquote><h2 id="1-前提条件"><a class="markdownIt-Anchor" href="#1-前提条件"></a> 1. 前提条件</h2><blockquote><ul><li>装有Debian/Ubuntu系统的、安装了ssh服务的、带有网络设备及驱动的开发板</li><li>MobaXterm工具</li><li>目前使用的上位机是Win11平台，后续再研究Linux平台。</li></ul></blockquote><h2 id="2-基本操作"><a class="markdownIt-Anchor" href="#2-基本操作"></a> 2. 基本操作</h2><h3 id="21-查询设备网络连接状态及ip地址"><a class="markdownIt-Anchor" href="#21-查询设备网络连接状态及ip地址"></a> 2.1. 查询设备网络连接状态及ip地址</h3><p><code>ifconfig</code> 命令</p><h3 id="22-连接测试"><a class="markdownIt-Anchor" href="#22-连接测试"></a> 2.2. 连接测试</h3><p><code>ping</code> 命令</p><h3 id="23-动态分配ip主动申请ip地址"><a class="markdownIt-Anchor" href="#23-动态分配ip主动申请ip地址"></a> 2.3. 动态分配ip/主动申请ip地址</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">udhcpc <span class="token parameter variable">-i</span> eth0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong><code>udhcpc</code></strong></p><ul><li>全称是 <em>Micro DHCP Client</em>，是 BusyBox 提供的一个轻量级 DHCP 客户端工具。</li><li>它会向局域网里的 DHCP 服务器（比如路由器、主机上的 Internet Connection Sharing 服务）发送请求，请求一个 IP 地址。</li></ul><p><strong><code>-i eth0</code></strong></p><ul><li>指定要使用的网络接口，这里是 <code>eth0</code>（开发板上的以太网网卡）。</li><li>如果你用的是其他网卡（比如 <code>eth1</code> 或 <code>enp0s3</code>），需要改成对应名字。</li></ul><p>成功的话，它会显示类似：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">udhcpc: sending discoverudhcpc: sending <span class="token keyword">select</span> <span class="token keyword">for</span> <span class="token number">192.168</span>.137.2udhcpc: lease of <span class="token number">192.168</span>.137.2 obtained, lease <span class="token function">time</span> <span class="token number">86400</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这表示网卡已经从 DHCP 服务器那里拿到了 IP（这里是 <code>192.168.137.2</code>）。如果没有 DHCP 服务器响应，就会一直 <code>sending discover</code>，说明没有可分配 IP。</p><h3 id="24-手动设置设备ip地址"><a class="markdownIt-Anchor" href="#24-手动设置设备ip地址"></a> 2.4. 手动设置设备ip地址</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ifconfig</span> eth0 <span class="token number">192.168</span>.10.2 netmask <span class="token number">255.255</span>.255.0 up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>up</code> 指启用</p><h3 id="25-查询ssh是否开启"><a class="markdownIt-Anchor" href="#25-查询ssh是否开启"></a> 2.5. 查询ssh是否开启</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl status <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="26-开启ssh服务"><a class="markdownIt-Anchor" href="#26-开启ssh服务"></a> 2.6. 开启ssh服务</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/etc/init.d/ssh start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="27-ssh远程连接"><a class="markdownIt-Anchor" href="#27-ssh远程连接"></a> 2.7. ssh远程连接</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> <span class="token punctuation">[</span>username<span class="token punctuation">]</span>@<span class="token punctuation">[</span>ip-addr/hostname<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="28-通过mobaxterm连接"><a class="markdownIt-Anchor" href="#28-通过mobaxterm连接"></a> 2.8. 通过MobaXterm连接</h3><p>填好即可。<br /><img src="Snipaste_2025-09-07_19-20-07.png" alt="" /></p><p><code>hostname</code> 可以输入同名指令查看。</p><h2 id="3-方式一无线网络连接"><a class="markdownIt-Anchor" href="#3-方式一无线网络连接"></a> 3. 方式一：无线网络连接</h2><blockquote><p>“优点”：无线通信。<br />“缺点”：延迟可能较高。</p></blockquote><h3 id="31-同一网络下"><a class="markdownIt-Anchor" href="#31-同一网络下"></a> 3.1. 同一网络下</h3><p>在同一网段下（连接同一个WIFI），通过ssh建立连接。简简单单。</p><h3 id="32-不同网络下"><a class="markdownIt-Anchor" href="#32-不同网络下"></a> 3.2. 不同网络下</h3><blockquote><p>待补充。</p></blockquote><h2 id="4-方式二通过网线与win电脑连接"><a class="markdownIt-Anchor" href="#4-方式二通过网线与win电脑连接"></a> 4. 方式二：通过网线与Win电脑连接</h2><blockquote><p>“优点”：延迟低。<br />“缺点”：有线通信。</p></blockquote><h3 id="41-点对点通信无需共享电脑网络"><a class="markdownIt-Anchor" href="#41-点对点通信无需共享电脑网络"></a> 4.1. 点对点通信（无需共享电脑网络）</h3><blockquote><p>“优点”：操作简单。<br />“缺点”：开发板不能共享电脑网络。</p></blockquote><p>将开发板网口和电脑网口用网线连接，进入电脑<code>网络和Internet</code>设置，选择<code>以太网</code></p><p>ip分配改为手动，ip地址可以分配为<code>192.168.10.1</code><br />掩码为<code>255.255.255.0</code><br /><img src="Snipaste_2025-09-07_19-29-57.png" alt="" /></p><p>开发板端同样指定ip地址和掩码，须在同一网段，例如<code>192.168.10.7</code> 。这样两个设备就能互相找到了。<br />再在电脑上进行ping测试。能ping通用ssh/MobaXterm连接即可。</p><h3 id="42-点对点通信并共享电脑网络电脑成网关"><a class="markdownIt-Anchor" href="#42-点对点通信并共享电脑网络电脑成网关"></a> 4.2. 点对点通信并共享电脑网络（电脑成网关）</h3><blockquote><p>“优点”：开发板不仅可以与电脑建立通信，还能共享电脑网络。<br />“缺点”：操作较复杂。</p></blockquote><p>电脑通过wifi连接网络，通过以太网接口连接开发板。<br />在电脑控制面板&gt;网络和Internet&gt;网络和共享中心 右侧更改适配器设置，双击无线网卡设备（连接网络的那个设备）选择属性&gt; 共享选项卡 勾选<br /><img src="Snipaste_2025-09-07_19-41-42.png" alt="" /></p><p>提示：<br /><img src="Snipaste_2025-09-07_19-41-53.png" alt="" /></p><p>意思是：当该功能被启用时，你的LAN口 ip地址 自动被设置为 <code>192.168.137.1</code>，要通过这个LAN口连接网络的设备需将自己ip地址设置为动态获取，也就是在开发板执行前面的动态获取ip地址的命令。</p><p>当开发版成功获取到ip地址（见基本操作节 分配ip地址）后，则可以正常建立连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="网络" scheme="https://blog.godmao.top/Tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="通信" scheme="https://blog.godmao.top/Tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>无聊随便打点字</title>
    <link href="https://blog.godmao.top/posts/7593/"/>
    <id>https://blog.godmao.top/posts/7593/</id>
    <published>2025-08-25T07:16:07.000Z</published>
    <updated>2025-09-12T11:32:30.195Z</updated>
    
    <content type="html"><![CDATA[<hr /><h1 id="和时间赛跑-林清玄"><a class="markdownIt-Anchor" href="#和时间赛跑-林清玄"></a> 和时间赛跑 林清玄</h1><p>读小学的时候，我的外祖母去世了。外祖母生前最疼爱我。我无法排除自己的忧伤，每天在学校的操场上一圈一圈地跑着，跑得累倒在地上，扑在草坪上痛哭。</p><p>那哀痛的日子持续了很久，爸爸妈妈也不知道如何安慰我。他们知道与其欺骗我说外祖母睡着了，还不如对我说实话：外祖母永远不会回来了。</p><p>“什么是永远不会回来了呢？”我问。</p><p>“所有时间里的事物，都永远不会回来了，你的昨天过去了，它就永远变成昨天，你再也不能回到昨天了。爸爸以前和你一样小，现在再也不能回到你这么小的童年了。有一天你会长大，你也会像外祖母一样老，有一天你度过了你的所有时间，也会像外祖母一样永远不能回来了。”爸爸说。</p><p>爸爸等于给我说了一个谜，这个谜比“一寸光阴一寸金，寸金难买寸光阴”还让我感到可怕，比“光阴似箭，日月如梭”更让我有一种说不出的滋味。</p><p>以后，我每天放学回家，在庭院时看着太阳一寸一寸地沉进了山头，就知道一天真的过完了。虽然明天还会有新的太阳，但永远不会有今天的太阳了。</p><p>我看到鸟儿飞到天空，它们飞得多块呀。明天它们再飞过同样的路线，也永远不是今天了。或许明天飞过这条路线的，不是老鸟，而是小鸟了。</p><p>时间过得飞快，使我的小心眼不只是着急，还有悲伤。有一天我放学回家，看到太阳快落山了，就下决心说：“我要比太阳更快地回家。”我狂奔回去，站在庭院里喘气的时候，看到太阳还露着半边脸，我高兴地跳起来。那一天我跑赢了太阳。以后我常做这样的游戏，有时和太阳赛跑，有时和西北风比赛，有时一个暑假的作业，我十天就做完了。那时我三年级，常把哥哥五年级的作业拿来做。每一次比赛胜过时间，我就快乐得不知道怎么形容。</p><p>后来二十年里，我因此受益无穷。虽然我知道人永远跑不过时间，但是可以比原来跑快一步，如果加把劲，有时可以快好几步。那几步虽然很小很小，用途却很大很大。</p><p>如果将来我有什么要教给孩子，我会告诉他：假若你一直和时间赛跑，你就可以成功。</p><h1 id="秋天的怀念-史铁生"><a class="markdownIt-Anchor" href="#秋天的怀念-史铁生"></a> 秋天的怀念 史铁生</h1><p>双腿瘫痪后，我的脾气变得暴怒无常。望着望着天上北归的雁阵，我会突然把面前的玻璃砸碎；听着听着李谷一甜美的歌声，我会猛地把手边的东西摔向四周的墙壁。母亲就悄悄地躲出去，在我看不见的地方偷偷地听着我的动静。当一切恢复沉寂，她又悄悄地进来，眼边红红的，看着我。“听说北海的花儿都开了，我推你去走走。”她总是这么说。母亲喜欢花，可自从我双腿瘫痪后，她侍弄的那些花都死了。“不，我不去！”我狠命地捶打这两条可恨的腿，喊着：“我活着有什么劲！”母亲扑过来抓住我的手，忍住哭声说：“咱娘儿俩在一块儿，好好儿活……”可我却一直都不知道，她的病已经到了那步田地。后来妹妹告诉我，她常常肝疼得整宿整宿翻来覆去地睡不了觉。</p><p>那天我又独自坐在屋里，看着窗外的树叶“唰唰啦啦”地飘落。母亲进来了，挡在窗前：“北海地菊花开了，我推着你去看看吧。”她憔悴的脸上现出央求般的神色。“什么时候？”你要是愿意，就明天？“她说。我的回答已经让她喜出望外了。”好吧，就明天。“我说。她高兴得一会坐下，一会站起：”那就赶紧准备准备。“”唉呀，烦不烦？几步路，有什么好准备的！“她也笑了，坐在我身边，絮絮叨叨地说着”看完菊花，咱们就去‘仿膳’，你小时候最爱吃那儿的豌豆黄儿。还记得那回我带你去北海吗？你偏说那杨树花是毛毛虫，跑着，一脚踩扁一个……“她忽然不说了。对于”跑“和”踩“一类的字眼儿。她比我还敏感。她又悄悄出去了。</p><p>她出去了。就再也没回来。</p><p>邻居们把她抬到车上时，她还在大口大口地吐着鲜血。我没想到她已经病成那样。看着三轮车远去，也绝没有想到那竟是永远的诀别。</p><p>邻居的小伙子背着我去看她的时候，她正艰难地呼吸着，像她那一生艰难的生活。别人告诉我，他昏迷前的最后一句话是：”我那个有病的儿子和我那个未成年的女儿……“</p><p>又是秋天，妹妹推着我去北海看了菊花。黄色的花淡雅、白色的花高洁、紫红色的花热烈而深沉，泼泼洒洒，秋风中正开的烂漫。我懂得母亲没有说完的话，妹妹也懂。我俩在一块儿，要好好儿活……</p>]]></content>
    
    
    <summary type="html">喵喵喵。</summary>
    
    
    
    <category term="其他" scheme="https://blog.godmao.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>I-MX6ULL的中断实验（下）</title>
    <link href="https://blog.godmao.top/posts/33465/"/>
    <id>https://blog.godmao.top/posts/33465/</id>
    <published>2025-08-24T14:17:34.000Z</published>
    <updated>2025-08-25T08:21:45.638Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="c语言下中断模块"><a class="markdownIt-Anchor" href="#c语言下中断模块"></a> C语言下中断模块</h2><h3 id="核心思路"><a class="markdownIt-Anchor" href="#核心思路"></a> 核心思路：</h3><p>每个中断对象包含：1个中断处理函数和需要传入的参数——一个函数指针+一个未定义类型指针。所以将中断对象打包成一个结构体：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 定义中断处理函数原型 */</span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token class-name">sys_irq_handler_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>para<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 定义中断函数结构体 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_sys_irq_handle</span><span class="token punctuation">&#123;</span>    <span class="token class-name">sys_irq_handler_t</span> irqHandler<span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> usrPara<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">sys_irq_handle_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指定一个默认中断处理函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 定义默认中断处理函数 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">default_irqHandler</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>para<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将所有中断对象归入一个表中，按中断id索引：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_OF_IT_VECTORS</span> <span class="token expression"><span class="token number">160</span></span></span><span class="token keyword">static</span> <span class="token class-name">sys_irq_handle_t</span> irqTable<span class="token punctuation">[</span>NUM_OF_IT_VECTORS<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>后续可能涉及到中断嵌套，因此定义一个中断嵌套计数器：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> irqNesting<span class="token punctuation">;</span> <span class="token comment">//中断嵌套计数器</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化中断对象表：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 初始化中断处理表 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sys_iqrTable_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    irqNesting <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//中断嵌套计数器</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> NUM_OF_IT_VECTORS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        irqTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>irqHandler <span class="token operator">=</span> default_irqHandler<span class="token punctuation">;</span>        irqTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>usrPara <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上一节中，我们实现了当进入中断时跳入一个名为<code>system_irqhandler</code>的函数处理中断。因此我们需要定义该函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/// @brief 中断处理函数</span><span class="token comment">/// @param gicciar 寄存器gicciar的值</span><span class="token comment">/// @note 进入irq中断后自动调用</span><span class="token keyword">void</span> <span class="token function">system_irqhandler</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> gicciar<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token class-name">uint32_t</span> id <span class="token operator">=</span> gicciar <span class="token operator">&amp;</span> <span class="token number">0x3ff</span><span class="token punctuation">;</span> <span class="token comment">//从gicciar寄存器中读取中断id号（0~9位 故&amp; 0x3ff）</span>    <span class="token comment">/* 安全检查 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">1023</span> <span class="token operator">||</span> id <span class="token operator">>=</span> NUM_OF_IT_VECTORS<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">//1023即没有中断，即0~9位全为1</span>    irqNesting<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">/* 开始处理 */</span>    irqTable<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">irqHandler</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> irqTable<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span>usrPara<span class="token punctuation">)</span><span class="token punctuation">;</span>    irqNesting<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们不可能只用默认中断处理函数，肯定要自己自定义，自定义完处理函数后，将该函数注册给中断对象，因此我们需要一个用于注册的函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/// @brief 用于注册你自定义的中断处理函数</span><span class="token comment">/// @param irq_id 你为哪个中断写好了处理函数，写入id</span><span class="token comment">/// @param handler 你写的处理函数的地址</span><span class="token comment">/// @param para 要传入的参数</span><span class="token keyword">void</span> <span class="token function">register_irqHandler</span><span class="token punctuation">(</span>IRQn_Type irq_id<span class="token punctuation">,</span> <span class="token class-name">sys_irq_handler_t</span> handler<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>para<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    irqTable<span class="token punctuation">[</span>irq_id<span class="token punctuation">]</span><span class="token punctuation">.</span>irqHandler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    irqTable<span class="token punctuation">[</span>irq_id<span class="token punctuation">]</span><span class="token punctuation">.</span>usrPara <span class="token operator">=</span> para<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置gpio外部中断"><a class="markdownIt-Anchor" href="#配置gpio外部中断"></a> 配置gpio外部中断</h2><p>通过原理图可知，应配置为上升沿触发。</p><h3 id="配置gpio_icr寄存器"><a class="markdownIt-Anchor" href="#配置gpio_icr寄存器"></a> 配置GPIO_ICR寄存器</h3><p>寄存器用于指定触发方式——上升沿触发。<br />我的开发板应指定GOIO5_ICR1_icr1 为 10。</p><h3 id="配置gpio_imr寄存器"><a class="markdownIt-Anchor" href="#配置gpio_imr寄存器"></a> 配置GPIO_IMR寄存器</h3><p>该寄存器用于使能中断。<br />我的开发板应指定GPIO5_IMR_imr1 为 1——UNMASKED</p><h2 id="中断后清除中断标志位"><a class="markdownIt-Anchor" href="#中断后清除中断标志位"></a> 中断后清除中断标志位</h2><p>参考手册中指出，处理完中断后，需清除GPIO_ISR寄存器的相应位。<br />需要注意的是<strong>通过对该位写1清除。</strong></p><h2 id="gic-配置"><a class="markdownIt-Anchor" href="#gic-配置"></a> GIC 配置</h2><p>just like NVIC… you must know cubemx right？</p><h3 id="使能相应的中断id"><a class="markdownIt-Anchor" href="#使能相应的中断id"></a> 使能相应的中断ID</h3><p>GPIO5_1对应的中断id为74<br /><img src="Snipaste_2025-08-24_23-51-22.png" alt="" /><br />但是注意这段话：<br /><img src="Snipaste_2025-08-24_23-53-41.png" alt="" /></p><p>告诉我们前面还有32个中断接到了CPU的接口 所以中断ID为 74+32 = 106。</p><h3 id="配置中断优先级"><a class="markdownIt-Anchor" href="#配置中断优先级"></a> 配置中断优先级</h3><h2 id="注册中断处理函数"><a class="markdownIt-Anchor" href="#注册中断处理函数"></a> 注册中断处理函数</h2>]]></content>
    
    
    <summary type="html">本篇编写c语言中的中断模块并配置GPIO外部中断。</summary>
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>I-MX6ULL的中断实验（上）</title>
    <link href="https://blog.godmao.top/posts/32440/"/>
    <id>https://blog.godmao.top/posts/32440/</id>
    <published>2025-08-11T13:17:21.000Z</published>
    <updated>2025-08-24T16:22:17.968Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><ul><li><a href="#1-cortex-a7%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F">1. Cortex-A7中断系统</a><ul><li><a href="#11-cortex-a%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8">1.1. Cortex-A中断向量表</a></li><li><a href="#12-%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%81%8F%E7%A7%BB">1.2. 中断向量表偏移</a></li><li><a href="#13-gic-v2%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8">1.3. GIC v2中断控制器</a><ul><li><a href="#131-gic-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">1.3.1. GIC 的主要功能</a></li><li><a href="#132-%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84">1.3.2. 核心结构</a></li><li><a href="#133-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E7%89%88">1.3.3. 核心原理（简单版）</a></li></ul></li><li><a href="#14-%E4%B8%AD%E6%96%AD%E5%8F%B7">1.4. 中断号</a></li></ul></li><li><a href="#2-%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8">2. 添加中断向量表</a></li><li><a href="#3-%E5%A4%8D%E4%BD%8D%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%96%E5%86%99">3. 复位中断函数的编写</a><ul><li><a href="#31-%E6%93%8D%E4%BD%9Ccp15%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8">3.1. 操作CP15协处理器</a></li><li><a href="#32-%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%81%8F%E7%A7%BB">3.2. 中断向量表偏移</a></li><li><a href="#33-%E8%AE%BE%E7%BD%AEsp%E6%8C%87%E9%92%88">3.3. 设置sp指针</a></li><li><a href="#34-%E6%B8%85%E9%99%A4bss%E6%AE%B5">3.4. 清除.bss段</a></li></ul></li><li><a href="#4-irq%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%96%E5%86%99">4. IRQ中断函数的编写</a><ul><li><a href="#41-%E4%BF%9D%E5%AD%98%E4%B8%AD%E6%96%AD%E7%8E%B0%E5%9C%BA%E9%98%B2%E6%AD%A2%E7%A0%B4%E5%9D%8F%E5%8E%9F%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81">4.1. 保存中断现场（防止破坏原任务状态）</a></li><li><a href="#42-%E4%BB%8E-gic%E9%80%9A%E7%94%A8%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AF%BB%E5%8F%96%E4%B8%AD%E6%96%AD%E5%8F%B7">4.2. 从 GIC（通用中断控制器）读取中断号</a></li><li><a href="#43-%E5%88%87%E6%8D%A2%E5%88%B0-svc-%E6%A8%A1%E5%BC%8F%E6%89%A7%E8%A1%8C-c-%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">4.3. 切换到 SVC 模式执行 C 语言中断处理函数</a></li><li><a href="#44-%E7%BB%93%E6%9D%9F%E4%B8%AD%E6%96%AD%E5%B9%B6%E6%81%A2%E5%A4%8D%E7%8E%B0%E5%9C%BA">4.4. 结束中断并恢复现场</a></li></ul></li><li><a href="#5-%E6%95%B4%E4%B8%AA%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6">5. 整个启动文件</a></li></ul><h2 id="1-cortex-a7中断系统"><a class="markdownIt-Anchor" href="#1-cortex-a7中断系统"></a> 1. Cortex-A7中断系统</h2><h3 id="11-cortex-a中断向量表"><a class="markdownIt-Anchor" href="#11-cortex-a中断向量表"></a> 1.1. Cortex-A中断向量表</h3><p>Cortex-A中断向量<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>表有8个中断，其中重点关注IRQ。Cortex-A的中断向量表需要用户自己去定义。</p><p><img src="Snipaste_2025-08-11_21-20-27.png" alt="" /></p><p>各中断的简单介绍：<br /><img src="Snipaste_2025-08-11_21-27-07.png" alt="" /></p><p>其中IRQ中断为非向量中断，所有中断共享同一入口，再软件判断来源。<br />大概是这样：<br /><img src="Snipaste_2025-08-11_21-27-26.png" alt="" /></p><h3 id="12-中断向量表偏移"><a class="markdownIt-Anchor" href="#12-中断向量表偏移"></a> 1.2. 中断向量表偏移</h3><p>通过设置中断向量表偏移，指定中断向量表的地址。</p><h3 id="13-gic-v2中断控制器"><a class="markdownIt-Anchor" href="#13-gic-v2中断控制器"></a> 1.3. GIC v2中断控制器</h3><p>类似于STM32的NVIC，CortexA7使用 GIC v2 作为中断控制器，比NVIC更强大因为GIC能处理多核的中断。</p><h4 id="131-gic-的主要功能"><a class="markdownIt-Anchor" href="#131-gic-的主要功能"></a> 1.3.1. GIC 的主要功能</h4><ol><li><strong>收集中断</strong><br />接收来自外设和 CPU 内部的各种中断请求（SPI、PPI、SGI）。</li><li><strong>优先级管理</strong><br />按优先级裁定哪个中断先被处理。</li><li><strong>目标选择</strong><br />把中断发给指定的 CPU 核，或广播给多个核。</li><li><strong>中断屏蔽与使能</strong><br />软件可选择屏蔽某个中断或所有中断。</li><li><strong>确认与结束</strong><br />CPU 核心在处理前向 GIC 确认（acknowledge），处理完向 GIC 报告结束（end of interrupt）。</li></ol><h4 id="132-核心结构"><a class="markdownIt-Anchor" href="#132-核心结构"></a> 1.3.2. 核心结构</h4><p>ARM GIC 主要由两部分组成：</p><ul><li><strong>Distributor（分发器）</strong><br />负责接收所有外设中断，决定送到哪一个 CPU。</li><li><strong>CPU Interface（CPU 接口）</strong><br />每个 CPU 核对应一个接口，负责和 Distributor 通信，接收/确认/结束中断。</li></ul><h4 id="133-核心原理简单版"><a class="markdownIt-Anchor" href="#133-核心原理简单版"></a> 1.3.3. 核心原理（简单版）</h4><p>GIC 的核心流程基本就是三步：</p><ol><li><strong>接收中断请求</strong><br />外设（SPI）、特定 CPU 相关的中断（PPI）、核间中断（SGI）都送进 GIC。</li><li><strong>仲裁优先级 + 选择目标 CPU</strong><ul><li>比较中断优先级（Priority）</li><li>检查中断是否被屏蔽（Enable Mask）</li><li>根据目标 CPU 配置（Target CPU Mask）决定发给谁</li></ul></li><li><strong>通知 CPU → CPU 响应 → 完成汇报</strong><ul><li>发信号到目标 CPU 接口</li><li>CPU 读取中断号（acknowledge）并执行 ISR</li><li>ISR 结束后 CPU 通知 GIC（end of interrupt）</li></ul></li></ol><h3 id="14-中断号"><a class="markdownIt-Anchor" href="#14-中断号"></a> 1.4. 中断号</h3><p>中断的 ID Card。<br /><img src="Snipaste_2025-08-11_21-54-28.png" alt="" /></p><h2 id="2-添加中断向量表"><a class="markdownIt-Anchor" href="#2-添加中断向量表"></a> 2. 添加中断向量表</h2><ul><li><p><strong>向量表的“表项”是指令，不是纯地址。</strong></p></li><li><p>每个向量入口的指令都指向某个具体的处理函数（Reset_Handler、IRQ_Handler 等）。</p></li><li><p>当发生异常，CPU 硬件会取指执行入口指令 → <code>ldr pc, =xxx</code> → 跳到真正的处理函数。</p></li></ul><p>这样，<strong>只要依次写好这些跳转指令，后续再告诉cpu这些指令在哪个位置，就等于告诉 CPU“各种异常该去哪”</strong>。</p><p>:::danger<br /><strong>中断向量表必须按固定顺序来定义</strong>，顺序是由 ARM 硬件架构规定的，不是随便排列的。这样CPU才能正确处理不同的异常<br />:::</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&#x2F;* 设置中断向量表，当中断来时，CPU就会执行对应指令 *&#x2F;    &#x2F;* 顺序不能改变，名字可以改变！ *&#x2F;    ldr pc, &#x3D;Reset_Handler      &#x2F;* 复位中断                     *&#x2F;      ldr pc, &#x3D;Undefined_Handler  &#x2F;* 未定义中断                    *&#x2F;    ldr pc, &#x3D;SVC_Handler        &#x2F;* SVC(Supervisor)中断        *&#x2F;    ldr pc, &#x3D;PrefAbort_Handler  &#x2F;* 预取终止中断                   *&#x2F;    ldr pc, &#x3D;DataAbort_Handler  &#x2F;* 数据终止中断                   *&#x2F;    ldr pc, &#x3D;NotUsed_Handler    &#x2F;* 未使用中断                    *&#x2F;    ldr pc, &#x3D;IRQ_Handler        &#x2F;* IRQ中断                    *&#x2F;    ldr pc, &#x3D;FIQ_Handler        &#x2F;* FIQ(快速中断)未定义中断           *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-复位中断函数的编写"><a class="markdownIt-Anchor" href="#3-复位中断函数的编写"></a> 3. 复位中断函数的编写</h2><h3 id="31-操作cp15协处理器"><a class="markdownIt-Anchor" href="#31-操作cp15协处理器"></a> 3.1. 操作CP15协处理器</h3><p><strong>关闭I、D Cache 和MMU</strong></p><details><summary>为什么要这样做？</summary><p>CP15 是 Cortex-A 系列处理器的 <strong>系统控制寄存器集</strong>，其中 <strong>SCTLR（System Control Register, c1）</strong> 控制了处理器的一些核心行为，例如：</p><table><thead><tr><th>位</th><th>功能</th></tr></thead><tbody><tr><td>M</td><td>MMU 使能位（Memory Management Unit）</td></tr><tr><td>C</td><td>数据缓存使能位</td></tr><tr><td>I</td><td>指令缓存使能位</td></tr><tr><td>A</td><td>对齐检查（Alignment）使能</td></tr><tr><td>Z</td><td>缓存清零 / 压缩乘法指令</td></tr><tr><td>V</td><td>高速异常向量表</td></tr><tr><td>…</td><td>其他一些调试、异常行为控制</td></tr></tbody></table><p>在复位后，SCTLR 寄存器的初始值不一定是你想要的运行状态。不同的 SoC 或板级支持包可能默认值不同，有些位可能 <strong>默认启用某些功能但不适合裸机启动阶段</strong>。</p><p>在裸机启动阶段，你通常需要：</p><ol><li><p><strong>禁用 MMU 和缓存</strong>：</p><ul><li>在初始化页表和内存映射前，启用 MMU 会导致访问非法地址或产生未定义行为。</li><li>数据缓存如果没有正确初始化，可能会导致数据写入内存不一致。</li></ul></li><li><p><strong>关闭对齐检查</strong>：</p><ul><li>对齐检查在裸机启动阶段可能会导致异常，因为启动代码可能使用非对齐访问。</li></ul></li><li><p><strong>保证指令执行顺序一致</strong>：</p><ul><li>SCTLR 的某些位会影响指令缓存和流水线行为。</li><li>在系统初始化阶段，确保缓存和 MMU关闭可以让你更容易调试和保证代码执行顺序。</li></ul></li><li><p><strong>统一系统行为</strong>：</p><ul><li>不同芯片可能在复位后 SCTLR 寄存器的默认值不同。</li><li>显式初始化可以保证启动代码在各种芯片上行为一致。</li></ul></li></ol><p>如果不重置这些位可能的风险：</p><ul><li><p><strong>访问未定义</strong>：</p><ul><li>如果 MMU 默认启用但页表未初始化，访问内存可能触发数据异常。</li></ul></li><li><p><strong>数据不一致</strong>：</p><ul><li>缓存启用但未正确设置缓存策略，读写内存可能得到错误数据。</li></ul></li><li><p><strong>异常频发</strong>：</p><ul><li>对齐检查默认启用，而启动代码中可能有非对齐访问，导致异常。</li></ul></li><li><p><strong>调试困难</strong>：</p><ul><li>程序执行行为不确定，难以定位启动问题。</li></ul></li></ul></details><p>代码如下：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">* 禁用MMU、cache、对齐检查等，配置适合裸机启动的环境，这样的启动代码移植性更好 *&#x2F;    mrc     p15, 0, r0, c1, c0, 0     &#x2F;*  读取CP15系统控制寄存器   *&#x2F;    bic     r0,  r0, #0x1000          &#x2F;*  清除第12位（I位）禁用 I Cache  *&#x2F;    bic     r0,  r0, #0x4             &#x2F;*  清除第 2位（C位）禁用 D Cache  *&#x2F;    bic     r0,  r0, #0x2             &#x2F;*  清除第 1位（A位）禁止严格对齐   *&#x2F;    bic     r0,  r0, #0x800           &#x2F;*  清除第11位（Z位）分支预测   *&#x2F;    bic     r0,  r0, #0x1             &#x2F;*  清除第 0位（M位）禁用 MMU   *&#x2F;    mcr     p15, 0, r0, c1, c0, 0     &#x2F;*  将修改后的值写回CP15寄存器   *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="32-中断向量表偏移"><a class="markdownIt-Anchor" href="#32-中断向量表偏移"></a> 3.2. 中断向量表偏移</h3><p>访问CP15 VBAR（Vector Base Address Register）寄存器，该寄存器是专门指定中断向量表偏移首地址的。</p><ul><li><code>dsb</code>（Data Synchronization Barrier）保证所有数据访问指令执行完再继续。</li><li><code>isb</code>（Instruction Synchronization Barrier）保证新的 VBAR 设置马上生效，不会被 CPU 指令流水线里的旧指令影响。</li></ul><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&#x2F;* 访问CP15 VBAR寄存器 设置中断向量表偏移 *&#x2F;    ldr r0, &#x3D;0x80000000    dsb    isb &#x2F;* 数据同步指令 *&#x2F;    mcr p15, 0, r0, c12, c0, 0    dsb    isb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="33-设置sp指针"><a class="markdownIt-Anchor" href="#33-设置sp指针"></a> 3.3. 设置sp指针</h3><p>内核工作在不同模式下，User模式和是Sys模式共用sp寄存器，而其他模式是独享一个sp寄存器。</p><ul><li>ARMv7-A 每个异常模式都有自己的栈指针寄存器，如果不设置，进入该模式时可能破坏未知内存。</li><li>给每种模式单独分配内存空间，可以防止中断嵌套、函数调用等操作时栈互相冲突。</li></ul><h3 id="34-清除bss段"><a class="markdownIt-Anchor" href="#34-清除bss段"></a> 3.4. 清除.bss段</h3><details><summary>bss段是什么？</summary><p>在编译链接后，程序的内存布局通常分为几个主要段：</p><ul><li><p><strong>.text</strong>：存放代码（只读）。</p></li><li><p><strong>.data</strong>：存放已初始化的全局/静态变量（初始值不为 0）。</p></li><li><p><strong>.bss</strong>：存放<strong>未初始化的</strong>或者<strong>初始化为 0</strong> 的全局/静态变量。</p></li></ul><p><code>.bss</code> 只在运行时需要分配内存，编译产物中不占用存储空间（只是记录了大小），这样可以减少可执行文件体积。</p></details><details><summary>为什么要这样做？</summary><p>根据 <strong>C 语言标准</strong>：</p><blockquote><p>所有未显式初始化的全局变量、静态变量在程序开始执行前必须被初始化为 0。</p></blockquote><p>这意味着：</p><ul><li><p>如果 <code>bss</code> 段中的内容不是全 0，程序可能会读到<strong>随机的旧内存内容</strong>。</p></li><li><p>硬件上，RAM 启动后可能是<strong>杂乱的值</strong>（上电状态、上次运行残留、调试器写入等）。</p></li></ul><p>因此，<strong>启动代码（crt0 或汇编 startup.s）通常会在 <code>main()</code> 之前清零 bss 段</strong>，保证所有这些变量是干净的 0。</p></details><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&#x2F;* 清除bss段 防止未初始化变量等数据访问错误 *&#x2F;    ldr r0, &#x3D;__bss_start    ldr r1, &#x3D;__bss_end    mov r2, #0bss_clear:          &#x2F;* ia: increse after *&#x2F;    stmia r0!, &#123;r2&#125; &#x2F;* stmia: 从r0所存地址开始，将r2的值写入该地址，写入后地址自动递增 *&#x2F;    cmp r0, r1    ble bss_clear &#x2F;* less &amp; equal *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-irq中断函数的编写"><a class="markdownIt-Anchor" href="#4-irq中断函数的编写"></a> 4. IRQ中断函数的编写</h2><details><summary>中断函数实现了什么？（详细版）</summary><h3 id="41-保存中断现场防止破坏原任务状态"><a class="markdownIt-Anchor" href="#41-保存中断现场防止破坏原任务状态"></a> 4.1. 保存中断现场（防止破坏原任务状态）</h3><p>一旦 CPU 进入 IRQ 模式，中断处理代码首先：</p><ul><li><p>把 <code>lr</code>（中断返回地址）、<code>r0</code>~<code>r3</code>、<code>r12</code> 等易被破坏的寄存器压栈保存。</p></li><li><p>保存 <code>SPSR</code>（中断进入时的 CPSR 状态），以便中断结束时恢复原任务的运行状态。</p></li></ul><p><strong>目的</strong>：防止中断服务过程破坏被中断的程序的寄存器内容和运行状态。</p><hr /><h3 id="42-从-gic通用中断控制器读取中断号"><a class="markdownIt-Anchor" href="#42-从-gic通用中断控制器读取中断号"></a> 4.2. 从 GIC（通用中断控制器）读取中断号</h3><ul><li><p>读取 <strong>GICC_IAR</strong>（Interrupt Acknowledge Register）寄存器。</p></li><li><p>这个寄存器会返回当前触发的中断 ID（是哪一个外设触发的 IRQ）。</p></li></ul><p><strong>目的</strong>：确定是哪个具体中断源发生了 IRQ。</p><hr /><h3 id="43-切换到-svc-模式执行-c-语言中断处理函数"><a class="markdownIt-Anchor" href="#43-切换到-svc-模式执行-c-语言中断处理函数"></a> 4.3. 切换到 SVC 模式执行 C 语言中断处理函数</h3><ul><li><p>ARMv7-A 的 IRQ 模式不适合直接运行通用 C 代码（栈、寄存器不统一），所以这里切到 SVC 模式。</p></li><li><p>在 SVC 模式下调用 <code>system_irqhandler</code>（C 写的总中断处理函数）。</p></li><li><p><code>system_irqhandler</code> 会根据中断号去调用具体外设的中断处理例程。</p></li></ul><p><strong>目的</strong>：统一用 SVC 模式的栈和环境执行中断逻辑，方便用 C 语言写 ISR 分发器。</p><hr /><h3 id="44-结束中断并恢复现场"><a class="markdownIt-Anchor" href="#44-结束中断并恢复现场"></a> 4.4. 结束中断并恢复现场</h3><ul><li><p>切回 IRQ 模式。</p></li><li><p>向 GIC 写 <strong>EOIR</strong>（End of Interrupt Register），通知 GIC 这个中断处理完成，可以接收新的中断。</p></li><li><p>从栈中弹出寄存器和 <code>SPSR</code>，恢复进入中断前的状态。</p></li><li><p>用 <code>subs pc, lr, #4</code> 返回到中断发生前的指令位置继续运行。</p></li></ul><p><strong>目的</strong>：</p><ul><li><p>告诉中断控制器“我处理完了”。</p></li><li><p>让 CPU 完整回到被打断的程序，像中断没发生一样继续执行。</p></li></ul></details><p>省流版：<br />当一个程序在 <strong>SVC 模式</strong> 下运行时，如果来了 IRQ：</p><ol><li>CPU 自动切到 IRQ 模式。</li><li>把 <strong>SVC 模式的 CPSR</strong> 存进 <strong>IRQ 模式的 SPSR</strong>。</li><li>把返回地址放进 IRQ 模式的 LR。</li><li>开始执行 IRQ 模式的向量入口代码（也就是 <code>IRQ_Handler</code>）。<br />irq_handler:</li></ol><ul><li>保存现场</li><li>查中断号</li><li>切换到svc模式 调用用c语言编写的中断分发函数 根据中断号分发到中断处理函数 来执行中断处理</li><li>结束中断、恢复现场<br />ps： 最后一行subs指令有点抽象。。。。。。。。</li></ul><h2 id="5-整个启动文件"><a class="markdownIt-Anchor" href="#5-整个启动文件"></a> 5. 整个启动文件</h2><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">.global _start&#x2F;* 以下两个变量在链接脚本中定义 *&#x2F;.global __bss_start.global __bss_end_start:    @ &#x2F;* 1.设置处理器模式为SVC模式(其实CotexA内核上电默认即为SVC模式故不需要写) *&#x2F;    @ mrs r0, cpsr                &#x2F;* 读取cpsr到r0 *&#x2F;    @ bic r0, r0, #0x1f           &#x2F;* bic bit-clear位清零 *&#x2F;              @                             &#x2F;* 等同于R0 &#x3D; R0 &amp; (~Operand2) 这个操作数2自己推算*&#x2F;    @                             &#x2F;* 现在这个操作相当于将r0的前5位清零了 *&#x2F;    @ orr r0, r0, #0x13           &#x2F;* orr 按位或 *&#x2F;    @ msr cpsr, r0                &#x2F;* 写入cpsr *&#x2F;      &#x2F;* 设置中断向量表，当中断来时，CPU就会执行对应指令 *&#x2F;    &#x2F;* 顺序不能改变，名字可以改变！ *&#x2F;    ldr pc, &#x3D;Reset_Handler      &#x2F;* 复位中断                     *&#x2F;      ldr pc, &#x3D;Undefined_Handler  &#x2F;* 未定义中断                    *&#x2F;    ldr pc, &#x3D;SVC_Handler        &#x2F;* SVC(Supervisor)中断        *&#x2F;    ldr pc, &#x3D;PrefAbort_Handler  &#x2F;* 预取终止中断                   *&#x2F;    ldr pc, &#x3D;DataAbort_Handler  &#x2F;* 数据终止中断                   *&#x2F;    ldr pc, &#x3D;NotUsed_Handler    &#x2F;* 未使用中断                    *&#x2F;    ldr pc, &#x3D;IRQ_Handler        &#x2F;* IRQ中断                    *&#x2F;    ldr pc, &#x3D;FIQ_Handler        &#x2F;* FIQ(快速中断)未定义中断           *&#x2F;Reset_Handler:      cpsid i                           &#x2F;* Change Processor State Interrupt or abort Disable irq *&#x2F;    &#x2F;* 禁用MMU、cache、对齐检查等，配置适合裸机启动的环境，这样的启动代码移植性更好 *&#x2F;    mrc     p15, 0, r0, c1, c0, 0     &#x2F;*  读取CP15系统控制寄存器   *&#x2F;    bic     r0,  r0, #0x1000          &#x2F;*  清除第12位（I位）禁用 I Cache  *&#x2F;    bic     r0,  r0, #0x4             &#x2F;*  清除第 2位（C位）禁用 D Cache  *&#x2F;    bic     r0,  r0, #0x2             &#x2F;*  清除第 1位（A位）禁止严格对齐   *&#x2F;    bic     r0,  r0, #0x800           &#x2F;*  清除第11位（Z位）分支预测   *&#x2F;    bic     r0,  r0, #0x1             &#x2F;*  清除第 0位（M位）禁用 MMU   *&#x2F;    mcr     p15, 0, r0, c1, c0, 0     &#x2F;*  将修改后的值写回CP15寄存器   *&#x2F;    &#x2F;* 访问CP15 VBAR寄存器 设置中断向量表偏移 *&#x2F;    ldr r0, &#x3D;0x80000000    dsb    isb &#x2F;* 数据同步指令 *&#x2F;    mcr p15, 0, r0, c12, c0, 0    dsb    isb    &#x2F;* 清除bss段 防止未初始化变量等数据访问错误 *&#x2F;    ldr r0, &#x3D;__bss_start    ldr r1, &#x3D;__bss_end    mov r2, #0bss_clear:          &#x2F;* ia: increse after *&#x2F;    stmia r0!, &#123;r2&#125; &#x2F;* stmia: 从r0所存地址开始，将r2的值写入该地址，写入后地址自动递增 *&#x2F;    cmp r0, r1    ble bss_clear &#x2F;* less &amp; equal *&#x2F;      &#x2F;* 设置各个模式下的栈指针，     * 注意：IMX6UL的堆栈是向下增长的！     * 堆栈指针地址一定要是4字节地址对齐的！！！     * DDR范围:0X80000000~0X9FFFFFFF     *&#x2F;    &#x2F;* 进入IRQ模式 *&#x2F;    mrs r0, cpsr    bic r0, r0, #0x1f   &#x2F;* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  *&#x2F;    orr r0, r0, #0x12   &#x2F;* r0或上0x13,表示使用IRQ模式                   *&#x2F;    msr cpsr, r0        &#x2F;* 将r0 的数据写入到cpsr_c中                    *&#x2F;    ldr sp, &#x3D;0x80600000 &#x2F;* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB *&#x2F;    &#x2F;* 进入SYS模式 *&#x2F;    mrs r0, cpsr    bic r0, r0, #0x1f   &#x2F;* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  *&#x2F;    orr r0, r0, #0x1f   &#x2F;* r0或上0x13,表示使用SYS模式                   *&#x2F;    msr cpsr, r0        &#x2F;* 将r0 的数据写入到cpsr_c中                    *&#x2F;    ldr sp, &#x3D;0x80500000 &#x2F;* 设置SYS模式下的栈首地址为0X80400000,大小为2MB *&#x2F;    &#x2F;* 进入SVC模式 *&#x2F;    mrs r0, cpsr    bic r0, r0, #0x1f   &#x2F;* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4  *&#x2F;    orr r0, r0, #0x13   &#x2F;* r0或上0x13,表示使用SVC模式                   *&#x2F;    msr cpsr, r0        &#x2F;* 将r0 的数据写入到cpsr_c中                    *&#x2F;    ldr sp, &#x3D;0X80400000 &#x2F;* 设置SVC模式下的栈首地址为0X80200000,大小为2MB *&#x2F;    cpsie i             &#x2F;* 打开全局中断 *&#x2F;    &#x2F;* 跳转到main函数 *&#x2F;    b main&#x2F;* 未定义中断 *&#x2F;Undefined_Handler:    ldr r0, &#x3D;Undefined_Handler    bx r0&#x2F;* SVC中断 *&#x2F;SVC_Handler:    ldr r0, &#x3D;SVC_Handler    bx r0&#x2F;* 预取终止中断 *&#x2F;PrefAbort_Handler:    ldr r0, &#x3D;PrefAbort_Handler      bx r0&#x2F;* 数据终止中断 *&#x2F;DataAbort_Handler:    ldr r0, &#x3D;DataAbort_Handler    bx r0  &#x2F;* 未使用的中断 *&#x2F;NotUsed_Handler:    ldr r0, &#x3D;NotUsed_Handler    bx r0  &#x2F;* IRQ中断！重点！！！！！ *&#x2F;IRQ_Handler:    &#x2F;* 保护现场 *&#x2F;    push &#123;lr&#125;                   &#x2F;* 保存lr地址 *&#x2F;    push &#123;r0-r3, r12&#125;           &#x2F;* 保存r0-r3，r12寄存器 *&#x2F;    mrs r0, spsr                &#x2F;* 读取spsr寄存器 *&#x2F;    push &#123;r0&#125;                   &#x2F;* 保存spsr寄存器 *&#x2F;     &#x2F;* 读取GIC控制器基地址 *&#x2F;    mrc p15, 4, r1, c15, c0, 0 &#x2F;* 从CP15的C0寄存器内的值到R1寄存器中                                * 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49                                * Cortex-A7 Technical ReferenceManua.pdf P68 P138                                *&#x2F;                              add r1, r1, #0X2000         &#x2F;* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 *&#x2F;    &#x2F;* 查询中断号 *&#x2F;    ldr r0, [r1, #0XC]          &#x2F;* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，                                 * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据                                 * 这个中断号来绝对调用哪个中断服务函数                                 *&#x2F;    push &#123;r0, r1&#125;               &#x2F;* 保存r0,r1 *&#x2F;    cps #0x13                   &#x2F;* 进入SVC模式，允许其他中断再次进去 *&#x2F;    push &#123;lr&#125;                   &#x2F;* 保存SVC模式的lr寄存器 *&#x2F;    ldr r2, &#x3D;system_irqhandler  &#x2F;* 加载C语言中断处理函数到r2寄存器中*&#x2F;    blx r2                      &#x2F;* 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 *&#x2F;    pop &#123;lr&#125;                    &#x2F;* 执行完C语言中断服务函数，lr出栈 *&#x2F;    cps #0x12                   &#x2F;* 进入IRQ模式 *&#x2F;    pop &#123;r0, r1&#125;                    str r0, [r1, #0X10]         &#x2F;* 中断执行完成，写EOIR，相当于确认中断执行完成 *&#x2F;    pop &#123;r0&#125;                            msr spsr_cxsf, r0           &#x2F;* 恢复spsr *&#x2F;    pop &#123;r0-r3, r12&#125;            &#x2F;* r0-r3,r12出栈 *&#x2F;    pop &#123;lr&#125;                    &#x2F;* lr出栈 *&#x2F;    subs pc, lr, #4             &#x2F;* 将lr-4赋给pc *&#x2F;&#x2F;* FIQ中断 *&#x2F;FIQ_Handler:    ldr r0, &#x3D;FIQ_Handler        bx r0loop:    b loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>中断向量，英文名为Interrupt Vector，在早期计算机体系结构里，“vector”常被用作“指针/地址索引”的意思，所以”向量“实际上就是地址指针的意思。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">本篇学习CortexA7中断系统和配置中断的启动文件的编写。</summary>
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>I-MX6ULL主频与时钟配置实验</title>
    <link href="https://blog.godmao.top/posts/33477/"/>
    <id>https://blog.godmao.top/posts/33477/</id>
    <published>2025-08-06T13:50:03.000Z</published>
    <updated>2025-08-14T14:51:38.995Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><h2 id="系统时钟浅析"><a class="markdownIt-Anchor" href="#系统时钟浅析"></a> 系统时钟浅析</h2><h3 id="7路pll"><a class="markdownIt-Anchor" href="#7路pll"></a> 7路PLL</h3><p>为了方便生成时钟，6从24MHz晶振生出来7路PLL。这7路PLL中有的又生出来PFD。</p><ul><li><code>PLL1</code>：ARM PLL供给ARM内核。</li><li><code>PLL2</code>：sysytem PLL，528MHz，528_PLL，此路PLL分出了4路PFD，分别为PLL2_PFD0~PFD3</li><li><code>PLL3</code>: USB1 PLL，480MHz 480_PLL，此路PLL分出了4路PFD，分别为PLL3_PFD0~PFD3。</li><li><code>PLL4</code>: Audio PLL，主供音频使用。</li><li><code>PLL5</code>: Video PLL，主供视频外设，比如RGB LCD接口，和图像处理有关的外设。</li><li><code>PLL6</code>：ENET PLL，主供网络外设。</li><li><code>PLL7</code>: USB2_PLL ,480MHz，无PFD。</li></ul><p>详见 IMX6ULL参考手册 Chapter 18 Clock Controller Module (CCM)</p><p>附 时钟树图：<br />t形为多路选择器</p><p><img src="Snipaste_2025-08-06_22-02-07.png" alt="" /><br /><img src="Snipaste_2025-08-06_22-03-45.png" alt="" /></p><h3 id="要初始化的pll和pfd"><a class="markdownIt-Anchor" href="#要初始化的pll和pfd"></a> 要初始化的PLL和PFD</h3><ul><li>PLL1，</li><li>PLL2，以及PLL2_PFD0~PFD3.</li><li>PLL3以及PLL3_PFD0~PFD3.<br />其他需要时再设置。<br />一般按照时钟树里面的值进行设置。</li></ul><h2 id="具体配置"><a class="markdownIt-Anchor" href="#具体配置"></a> 具体配置</h2><h3 id="系统主频的配置"><a class="markdownIt-Anchor" href="#系统主频的配置"></a> 系统主频的配置</h3><p>根据时钟树来设定系统主频。具体时钟配置的说明可以参见 IMX6ULL参考手册 18.5.1.5<br />CCM internal clock generation<br />下图为时钟切换器 （CCM_CLK_SWITCHER） 控制输出的示意图。</p><p><img src="Snipaste_2025-08-07_10-00-08.png" alt="" /></p><ol><li><p>要设置ARM内核主频为528MHz，设置CACRR寄存器的ARM_PODF位为2分频，然后设置PLL1=1056MHz即可。CACRR的bit3<sub>0为ARM_PODF位，可设置0</sub>7，分别对应1~8分频。应该设置CACRR寄存器的ARM_PODF=1。</p></li><li><p>切换时钟源。PLL1输出为pll1_sw_clk。pll1_sw_clk有两路可以选择，分别为pll1_main_clk，和step_clk，通过CCSR寄存器的pll1_sw_clk_sel位(bit2)来选择。为0的时候选择pll1_main_clk，为1的时候选额step_clk。</p></li><li><p>在修改PLL1的时候，也就是设置系统时钟的时候需要给6ULL一个临时的时钟，也就是step_clk。在修改PLL1的时候需要将pll1_sw_clk切换到step_clk上。</p></li><li><p>设置step_clk。Step_clk也有两路来源，由CCSR的step_sel位(bit8)来设置，为0的时候设置step_clk为osc=24MHz。为1的时候不重要，不用。</p></li><li><p>时钟切换成功以后就可以修改PLL1的值。</p></li><li><p>通过CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位(bit6~0)来设置PLL1的频率，公式为：</p><pre><code> Output = fref*DIV_SEL/2  1056=24*DIV_SEL/2=&gt;DIEV_SEL=88。  设置CCM_ANALOG_PLL_ARM寄存器的DIV_SELECT位=88即可。PLL1=1056MHz  还要设置CCM_ANALOG_PLL_ARM寄存器的ENABLE位(bit13)为1，也就是使能输出。</code></pre></li><li><p>在切换回PLL1之前，设置置CACRR寄存器的ARM_PODF=1！！切记。</p></li></ol><h3 id="其他pll设置"><a class="markdownIt-Anchor" href="#其他pll设置"></a> 其他PLL设置</h3><p>PLL2和PLL3。PLL2固定为528MHz，PLL3固定为480MHz。</p><ol><li>初始化PLL2_PFD0~PFD3。寄存器CCM_ANALOG_PFD_528用于设置4路PFD的时钟。比如PFD0= 528 * 18 / PFD0_FRAC。 设置PFD0_FRAC位即可。比如PLL2_PFD0=352M=528 *  18 / PFD0_FRAC，因此FPD0_FRAC=27。</li><li>同理初始化PLL3_PFD0~PFD3</li></ol><h2 id="外设时钟"><a class="markdownIt-Anchor" href="#外设时钟"></a> 外设时钟</h2><p>AHB_CLK_ROOT、PERCLK_CLK_ROOT以及IPG_CLK_ROOT。</p><p>因为PERCLK_CLK_ROOT和IPG_CLK_ROOT要用到AHB_CLK_ROOT，所以我们要初始化AHB_CLK_ROOT。</p><h3 id="ahb_clk_root的初始化"><a class="markdownIt-Anchor" href="#ahb_clk_root的初始化"></a> AHB_CLK_ROOT的初始化</h3><p>AHB_CLK_ROOT=132MHz。</p><p>设置CBCMR寄存器的PRE_PERIPH_CLK_SEL位，设置CBCDR寄存器的PERIPH_CLK_SEL位0。设置CBCDR寄存器的AHB_PODF位为2，也就是3分频，因此396/3=132MHz。</p><h3 id="ipg_clk_root初始化"><a class="markdownIt-Anchor" href="#ipg_clk_root初始化"></a> IPG_CLK_ROOT初始化</h3><p>设置CBCDR寄存器IPG_PODF=1，也就是2分频。</p><h3 id="perclk_clk_root初始化"><a class="markdownIt-Anchor" href="#perclk_clk_root初始化"></a> PERCLK_CLK_ROOT初始化</h3><p>设置CSCMR1寄存器的PERCLK_CLK_SEL位为0，表示PERCLK的时钟源为IPG。</p><h2 id="这篇文章写得很不错摘录一些"><a class="markdownIt-Anchor" href="#这篇文章写得很不错摘录一些"></a> 这篇文章写得很不错,摘录一些</h2><p><a href="https://blog.csdn.net/Beihai_Van/article/details/139868239">【嵌入式Linux】i.MX6ULL 时钟树——理论分析-CSDN博客</a></p><h3 id="总结pfd配置寄存器"><a class="markdownIt-Anchor" href="#总结pfd配置寄存器"></a> 总结PFD配置寄存器:</h3><p>CCM_ANALOG_PFD_528n 寄存器控制着 <a href="http://i.MX">i.MX</a> 6ULL 处理器中四个分数分频器的配置，包括时钟门控、稳定性状态和分数分频值。这些分频器用于生成不同频率的时钟信号，以满足各种外设的需求。</p><ol><li>CLKGATE 位 (Clock Gate): 时钟门控</li></ol><ul><li>作用: CLKGATE 位控制着对应 PFD 的时钟信号是否被开启或关闭。</li><li>值:<ul><li>0: 时钟信号开启，PFD 正常工作，可以输出分频后的时钟信号。</li><li>1: 时钟信号关闭，PFD 处于关闭状态，不输出时钟信号。</li></ul></li><li>目的:<ul><li>省电: 当某个外设不需要时钟信号时，可以通过设置 CLKGATE 位为 1 来关闭该 PFD 的时钟，从而减少功耗。</li><li>控制时钟信号: 在某些情况下，可能需要动态地控制某个外设的时钟信号，例如在系统启动或进入低功耗模式时。</li></ul></li></ul><ol start="2"><li>STABLE 位 (Stable): 稳定性状态</li></ol><ul><li>作用: STABLE 位指示对应 PFD 的输出时钟信号是否已经稳定。</li><li>值:<br />当新的分数分频值生效时，位域的值会反转（从 0 变为 1 或从 1 变为 0）。这个反转就像一个信号，表明分频器已经完成调整。</li><li>目的:<ul><li>诊断: STABLE 位是一个只读位，用于诊断 PFD 的稳定性。</li><li>确保时钟信号质量: 在修改 PFD 的分数分频值后，需要等待 STABLE 位反转，才能确保输出的时钟信号稳定可靠。</li></ul></li></ul><h3 id="imx6u-芯片-pll-时钟详解"><a class="markdownIt-Anchor" href="#imx6u-芯片-pll-时钟详解"></a> i.MX6U 芯片 PLL 时钟详解</h3><p>i.MX6U 芯片拥有多个 PLL（Phase-Locked Loop，锁相环）模块，用于生成各种频率的时钟信号，为芯片内部的不同模块和外设提供时钟源。下面整理了 i.MX6U 芯片的 7 个主要 PLL：</p><ol><li>ARM_PLL (PLL1)<ul><li>用途: 为 ARM 内核提供时钟信号。</li><li>倍频: 可编程，最高可倍频至 1.3GHz。</li><li>特点: ARM 内核的运行速度直接取决于此 PLL 的输出频率。</li></ul></li><li>528_PLL (PLL2)<ul><li>用途: 为系统总线、内部逻辑单元、DDR 接口、NAND/NOR 接口等提供时钟源。</li><li>倍频: 固定 22 倍频，不可编程。</li><li>输出频率: 24MHz * 22 = 528MHz。</li><li>特点: 该 PLL 以及其生成的 4 路 PFD (PLL2_PFD0~PLL2_PFD3) 是 i.MX6U 内部系统总线的核心时钟源。</li></ul></li><li>USB1_PLL (PLL3)<ul><li>用途: 主要用于 USB1PHY，但也可作为其他外设的时钟源。</li><li>倍频: 固定 20 倍频。</li><li>输出频率: 24MHz * 20 = 480MHz。</li><li>特点: 该 PLL 以及其生成的 4 路 PFD (PLL3_PFD0~PLL3_PFD3) 可用于多种外设。</li></ul></li><li>USB2_PLL (PLL7)<ul><li>用途: 为 USB2PHY 提供时钟信号。</li><li>倍频: 固定 20 倍频。</li><li>输出频率: 24MHz * 20 = 480MHz。</li><li>特点: 虽然序号标为 4，但实际是 PLL7。</li></ul></li><li>ENET_PLL (PLL6)<ul><li>用途: 用于生成网络所需的时钟信号。</li><li>倍频: 固定 20+5/6 倍频。</li><li>输出频率: 24MHz * (20+5/6) = 500MHz。</li><li>特点: 可在此 PLL 的基础上生成 25/50/100/125MHz 的网络时钟。</li></ul></li><li>VIDEO_PLL (PLL5)<ul><li>用途: 用于显示相关外设，例如 LCD。</li><li>倍频: 可调整，输出范围在 650MHz~1300MHz。</li><li>分频: 可选 1/2/4/8/16 分频。</li><li>特点: 可根据显示设备的需求调整输出频率和分频比。</li></ul></li><li>AUDIO_PLL (PLL4)<ul><li>用途: 用于音频相关外设。</li><li>倍频: 可调整，输出范围在 650MHz~1300MHz。</li><li>分频: 可选 1/2/4 分频。</li><li>特点: 可根据音频设备的需求调整输出频率和分频比。<br />总结:</li></ul></li></ol><p>i.MX6U 芯片通过多个 PLL 模块，生成各种频率的时钟信号，为芯片内部的不同模块和外设提供时钟源。每个 PLL 的倍频和分频都可以根据需要进行配置，以满足不同外设的需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>I-MX6ULL开发板C语言运行环境搭建并点灯</title>
    <link href="https://blog.godmao.top/posts/2969/"/>
    <id>https://blog.godmao.top/posts/2969/</id>
    <published>2025-07-28T09:03:51.000Z</published>
    <updated>2025-07-29T16:53:01.625Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>:::info<br />学习笔记记录，非教程。<br />:::</p><h2 id="c语言运行环境搭建"><a class="markdownIt-Anchor" href="#c语言运行环境搭建"></a> C语言运行环境搭建</h2><p>前面我们讲解了如何用汇编语言编写 LED 灯实验，但是实际开发过程中汇编用的很少，大部分都是 C 语言开发，汇编只是用来完成 C 语言环境的初始化。本文我们就来学习如何用汇编来完成 C 语言环境的初始化工作，然后从汇编跳转到 C 语言代码里面去。</p><h3 id="设置处理器模式"><a class="markdownIt-Anchor" href="#设置处理器模式"></a> 设置处理器模式</h3><p>对于Cortex-A处理器，有多种运行模式，例如User模式、中断模式等。除用户（User）模式为非特权模式，其余均为特权模式，特权模式下程序可以访问所有系统资源，还有自己独有的寄存器组，而非特权模式下访问受限。</p><p><img src="Snipaste_2025-07-28_17-13-11.png" alt="" /></p><p>而现在我们需要将处理器模式设置为SVC模式。<br />这就需要了解到内核寄存器组中的CPSR寄存器，其低四位为处理器运行模式控制位。</p><p><img src="Snipaste_2025-07-28_17-16-59.png" alt="" /></p><p><img src="Snipaste_2025-07-28_17-19-33%201.png" alt="" /></p><p><img src="Snipaste_2025-07-28_17-20-27.png" alt="" /></p><p>设置CPSR寄存器的bit4-0，也就是M[4:0]为10011=0X13。读写状态寄存器需要用到 MRS<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 和 MSR<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 指令。MRS将CPSR寄存器数据读出到通用寄存器里面，MSR指令将通用寄存器的值写入到CPSR寄存器里面去。</p><p>为啥不用SDR、LDR？因为这他妈属于处理器内部自己在传输数据，而不是从寄存器与存储器！而且它只能操作通用寄存器。</p><p><img src="Snipaste_2025-07-28_17-26-03.png" alt="" /></p><h3 id="设置sp寄存器"><a class="markdownIt-Anchor" href="#设置sp寄存器"></a> 设置sp寄存器</h3><p>也就是栈的起始地址。<br />Sp可以指向内部RAM，也可以指向DDR，我们将其指向DDR。Sp设置到哪里？512MB的范围0x80000000~0x9FFFFFFF。栈大小，0x200000=2MB，很大大大大了。</p><p>再提一嘴，由于NXP给我们提供的SDK包里面有初始化DDR等一系列操作，所以这里我们可以方便的设置sp寄存器，其他处理器（启动方式设置为DDR的情况下）如果没有初始化DDR，还需要先初始化DDR。</p><p>这里再说一下栈的特性，有点抽象……</p><ul><li>向上增长：即从低地址往高地址增长。以此判断即可。</li><li>向下增长：从高地址往低地址增长。</li><li>栈底：栈的起始位置。根据定义，如果是向下增长的，那么栈底为高地址。以此类推。</li><li>栈顶：程序运行时sp指针所指示的位置，不断变化。<br />处理器栈增长方式，对于A7而言是向下增长的。设置sp指向0x80200000。</li></ul><h3 id="跳转到c语言"><a class="markdownIt-Anchor" href="#跳转到c语言"></a> 跳转到C语言</h3><p>使用b指令，跳转到C语言函数，比如main函数。</p><p>其实我们在stm32的启动文件中也可以看到这些操作，提一嘴……</p><h2 id="实操"><a class="markdownIt-Anchor" href="#实操"></a> 实操</h2><p>我的文件结构长这样：</p><pre class="line-numbers language-none"><code class="language-none">project&#x2F;├── Makefile、lds├── src&#x2F;│   └── main.c├── inc&#x2F;│   └── main.h├── build&#x2F;└── bin&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时为了学习makefile，makefile就写得比较复杂：<br />注意makefile文件对缩进、空格非常敏感！</p><pre class="line-numbers language-Makefile" data-language="Makefile"><code class="language-Makefile"># 设置目录变量，方便统一管理和修改# 源代码目录:SRC_DIR :&#x3D; src# 头文件目录:INC_DIR :&#x3D; inc# 中间目标文件（.o）输出目录:BUILD_DIR :&#x3D; build# 最终生成的二进制文件（.bin）目录:BIN_DIR :&#x3D; bin# 设置编译工具（使用 ARM 的交叉编译工具链）# 编译器（用于 .c 和 .S 文件）:CC &#x3D; arm-none-eabi-gcc# 链接器:LD &#x3D; arm-none-eabi-ld# 用于将 elf 转为 bin 格式:OBJCOPY &#x3D; arm-none-eabi-objcopy# 编译选项（GCC 编译阶段）# -I：指定头文件搜索目录# -Wall：打开所有警告# -nostdlib：不链接标准库（适用于裸机）# -c：只编译，不链接GCC_FLAGS &#x3D; -I$(INC_DIR) -Wall -nostdlib -c# 链接器选项# -Ttext&#x3D;0x80000000：设置代码段的起始地址（你设备上运行程序的入口地址）# -e _start：显式设置程序入口点（防止链接器猜测）LD_FLAGS &#x3D; -Timx.lds# 自动查找 src&#x2F; 目录下的所有 .c 文件SRCS &#x3D; $(wildcard $(SRC_DIR)&#x2F;*.c)# 将 src&#x2F;xxx.c 转换为 build&#x2F;xxx.o# 例如：src&#x2F;main.c → build&#x2F;main.o# 同时添加 build&#x2F;startup.o（汇编启动文件）# 这里注意是按顺序链接的，所以startup一定要在第一个否则链接到的地址不对（查看反汇编可知）OBJS &#x3D; $(BUILD_DIR)&#x2F;startup.oOBJS +&#x3D; $(patsubst $(SRC_DIR)&#x2F;%.c,$(BUILD_DIR)&#x2F;%.o,$(SRCS))# 目标：生成最终的二进制文件 bin&#x2F;ledc.bin$(BIN_DIR)&#x2F;ledc.bin: $(OBJS)# 链接所有 .o 文件生成 elf 格式可执行文件    $(LD) $(LD_FLAGS) $(OBJS) -o $(BUILD_DIR)&#x2F;ledc.elf# 反汇编 调试用    arm-none-eabi-objdump -D -m arm $(BUILD_DIR)&#x2F;ledc.elf &gt; $(BUILD_DIR)&#x2F;ledc.dis# 把 elf 文件转换为裸机二进制文件（无符号、无头信息）    $(OBJCOPY) -O binary -S $(BUILD_DIR)&#x2F;ledc.elf $@# 编译汇编启动文件 startup.S，生成 build&#x2F;startup.o$(BUILD_DIR)&#x2F;startup.o: startup.S# 注意 startup.S 是汇编文件，用 gcc 编译也可以，默认会调用汇编器    $(CC) $(GCC_FLAGS) $&lt; -o $@# 编译每个 .c 文件到 build&#x2F;xxx.o# $@：目标文件（例如 build&#x2F;main.o）# $&lt;：依赖的源文件（例如 src&#x2F;main.c）$(BUILD_DIR)&#x2F;%.o: $(SRC_DIR)&#x2F;%.c    $(CC) $(GCC_FLAGS) $&lt; -o $@.PHONY: cleanclean:    rm $(BUILD_DIR)&#x2F;*.o $(BUILD_DIR)&#x2F;*.elf $(BIN_DIR)&#x2F;*.bin $(BUILD_DIR)&#x2F;*.dis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"main.h"</span></span><span class="token keyword">void</span> <span class="token function">clk_enable</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LED_CLK_REG <span class="token operator">=</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">led_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LED_MUX_REG <span class="token operator">=</span> <span class="token number">0x5</span><span class="token punctuation">;</span>          <span class="token comment">//复用为GPIO1_IO4</span>    LED_PAD_REG <span class="token operator">=</span> <span class="token number">0x10b0</span><span class="token punctuation">;</span>       <span class="token comment">//设置电气属性</span>    LED_GPIO_DIR_REG <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">;</span>    <span class="token comment">//io4设置为输出</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">clk_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">led_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LED_GPIO_DATA_REG <span class="token operator">=</span> <span class="token number">0x0</span><span class="token punctuation">;</span>      <span class="token comment">//输出为低电平</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.h</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__MAIN_H_  </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__MAIN_H_</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_CLK_REG</span> <span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x020c406c</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_MUX_REG</span> <span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x020e006c</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_PAD_REG</span> <span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x020e02f8</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_GPIO_DIR_REG</span> <span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x0209c004</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_GPIO_DATA_REG</span> <span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x0209c000</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>startup.S</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">  .global _start_start:    @ &#x2F;* 1.设置处理器模式为SVC模式(其实CotexA内核上电默认即为SVC模式故不需要写) *&#x2F;    @ mrs r0, cpsr                &#x2F;* 读取cpsr到r0 *&#x2F;    @ bic r0, r0, #0x1f           &#x2F;* bic bit-clear位清零 *&#x2F;              @                             &#x2F;* 等同于R0 &#x3D; R0 &amp; (~Operand2) 这个操作数2自己推算*&#x2F;    @                             &#x2F;* 现在这个操作相当于将r0的前5位清零了 *&#x2F;    @ orr r0, r0, #0x13           &#x2F;* orr 按位或 *&#x2F;    @ msr cpsr, r0                &#x2F;* 写入cpsr *&#x2F;    @下面这段是重置CP15寄存器的一些位，好像加了更保险一些。目前还没弄明白，但是实测不需要也可以运行。    @ mrc     p15, 0, r0, c1, c0, 0     &#x2F;*读取CP15系统控制寄存器   *&#x2F;    @ bic     r0,  r0, #0x1000     &#x2F;*  清除第12位（I位）禁用 I Cache  *&#x2F;    @ bic     r0,  r0, #0x4     &#x2F;*  清除第 2位（C位）禁用 D Cache  *&#x2F;    @ bic     r0,  r0, #0x2             &#x2F;*  清除第 1位（A位）禁止严格对齐   *&#x2F;    @ bic     r0,  r0, #0x800     &#x2F;*  清除第11位（Z位）分支预测   *&#x2F;    @ bic     r0,  r0, #0x1             &#x2F;*  清除第 0位（M位）禁用 MMU   *&#x2F;    @ mcr     p15, 0, r0, c1, c0, 0     &#x2F;*  将修改后的值写回CP15寄存器   *&#x2F;    &#x2F;* 2.设置sp寄存器 *&#x2F;    ldr sp, &#x3D;0x80100000         &#x2F;* 栈大小1M *&#x2F;        &#x2F;* 3.跳转到main函数 *&#x2F;    b mainloop:    b loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>链接脚本：</p><pre class="line-numbers language-lds" data-language="lds"><code class="language-lds">ENTRY(_start)SECTIONS &#123;    . &#x3D; 0x80000000;        . &#x3D; ALIGN(4);    .text :    &#123;        build&#x2F;startup.o        *(.text)    &#125;    . &#x3D; ALIGN(4);    .rodata :     &#123;        *(.rodata*)    &#125;        . &#x3D; ALIGN(4);    .data :     &#123;        *(.data)    &#125;    . &#x3D; ALIGN(4);    __bss_start &#x3D; .;      .bss :    &#123;        *(.bss)        *(COMMON)    &#125;    __bss_end &#x3D; .; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><strong>M</strong>ove to <strong>R</strong>egister from <strong>S</strong>pecial register.  加载到通用寄存器 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><strong>M</strong>ove to <strong>S</strong>pecial register from <strong>R</strong>egister.  恢复到特殊寄存器 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GoDm@&#39;s Blog</title>
  
  <subtitle>记录自己所爱。</subtitle>
  <link href="https://blog.godmao.top/atom.xml" rel="self"/>
  
  <link href="https://blog.godmao.top/"/>
  <updated>2025-12-05T05:17:57.667Z</updated>
  <id>https://blog.godmao.top/</id>
  
  <author>
    <name>GoDm@</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux内核中的并发与竞争</title>
    <link href="https://blog.godmao.top/posts/17521/"/>
    <id>https://blog.godmao.top/posts/17521/</id>
    <published>2025-12-02T14:03:42.000Z</published>
    <updated>2025-12-05T05:17:57.667Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本篇参考</strong></p><ul><li>【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.81</li><li><a href="https://zhuanlan.zhihu.com/p/561865798">一文读懂Linux内核中的并发和竞争 - 知乎 作者：Linux嵌入式</a></li></ul></blockquote><h2 id="1-内核中的并发和竞争简介"><a class="markdownIt-Anchor" href="#1-内核中的并发和竞争简介"></a> 1. 内核中的并发和竞争简介</h2><p>在早期的 Linux内核中，并发的来源相对较少。早期内核不支持对称多处理（ symmetric multi processing,SMP），因此，导致并发执行的唯一原因是对硬件中断的服务。这种情况处理起来较为简单，但并不适用于为获得更好的性能而使用更多处理器且强调快速响应事件的系统。</p><p>为了响应现代硬件和应用程序的需求， Linux内核已经发展到同时处理更多事情的时代。Linux系统是个多任务操作系统，会存在多个任务同时访问同一片内存区域的情况，这些任务可能会相互覆盖这段内存中的数据，造成内存数据混乱。针对这个问题必须要做处理，严重的话可能会导致系统崩溃。现在的 Linux系统并发产生的原因很复杂，总结一下有下面几个主要原因：</p><ol><li><p><strong>多线程并发访问</strong>:<br />Linux是多任务（线程）的系统，所以多线程访问是最基本的原因。</p></li><li><p><strong>抢占式并发访问</strong>：<br />内核代码是可抢占的，因此，我们的驱动程序代码可能在任何时候丢失对处理器的独占</p></li><li><p><strong>中断程序并发访问</strong>：<br />设备中断是异步事件，也会导致代码的并发执行。</p></li><li><p><strong>SMP（多核）核间并发访问</strong>：<br />现在ARM架构的多核SOC很常见，多核CPU存在核间并发访问。正在运行的多个用户空间进程可能以一种令人惊讶的组合方式访问我们的代码，SMP系统甚至可在不同的处理器上同时执行我们的代码。</p></li></ol><p>对于并发问题的处理方法，我们现在就来介绍最基础的四种。</p><h2 id="2-原子操作"><a class="markdownIt-Anchor" href="#2-原子操作"></a> 2. 原子操作</h2><h3 id="21-原子操作简介"><a class="markdownIt-Anchor" href="#21-原子操作简介"></a> 2.1. 原子操作简介</h3><p>原子，在早接触到是在化学概念中。原子指化学反应不可再分的基本微粒。同样的，在内核中所说的原子操作表示这一个访问是一个步骤，必须一次性执行完，不能被打断，不能再进行拆分。 例如，在多线程访问中，我们的线程一对a进行赋值操作，a=10，线程二也对a进行赋值操作a=20，我们理想的执行顺序是线程一先执行，线程二再执行。但是很有可能在线程一执行的时候被其他操作打断，使得线程一最后的执行结果变为a=20。要解决这个问题，必须保证我们的线程一在对数据访问的过程中不能被其他的操作打断，一次性执行完成。</p><p><img src="Snipaste_2025-12-02_22-11-21.png" alt="" /></p><p>Linux 内核定义了叫做 <code>atomic_t</code> 的结构体来完成整形数据的原子操作，在使用中用原子变量来代替整形变量，此结构体定义在 include/linux/types.h 文件中，定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> counter<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token class-name">atomic_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果要使用原子操作 API 函数，首先要先定义一个 atomic_t 的变量，如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">atomic_t</span> a<span class="token punctuation">;</span> <span class="token comment">//定义 a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也可以在定义原子变量的时候给原子变量赋初值，如下所示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">atomic_t</span> b <span class="token operator">=</span> <span class="token function">ATOMIC_INIT</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//定义原子变量 b 并赋初值为 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="22-原子操作相关api"><a class="markdownIt-Anchor" href="#22-原子操作相关api"></a> 2.2. 原子操作相关API</h3><h4 id="221-整型原子操作api"><a class="markdownIt-Anchor" href="#221-整型原子操作api"></a> 2.2.1. 整型原子操作API</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>ATOMIC_INIT(int i)</code></td><td>定义原子变量的时候对其初始化。</td></tr><tr><td><code>int atomic_read(atomic_t*v)</code></td><td>读取 v的值，并且返回</td></tr><tr><td><code>void atomic_set(atomic_t *v, int i)</code></td><td>向 v写入 i值。</td></tr><tr><td><code>void atomic_add(int i, atomic_t *v)</code></td><td>给 v加上 i值。</td></tr><tr><td><code>void atomic_sub(int i, atomic_t *v)</code></td><td>从 v减去 i值。</td></tr><tr><td><code>void atomic_inc(atomic_t *v)</code></td><td>给 v加 1，也就是自增。</td></tr><tr><td><code>void atomic_dec(atomic_t *v)</code></td><td>从 v减 1，也就是自减 。</td></tr><tr><td><code>int atomic_dec_return(atomic_t *v)</code></td><td>从 v减 1，并且返回v的值 。</td></tr><tr><td><code>int atomic_inc_return(atomic_t *v)</code></td><td>给 v加 1，并且返回 v的值。</td></tr><tr><td><code>int atomic_sub_and_test(int i, atomic_t *v)</code></td><td>从 v减 i，如果结果为0就返回真，否则就返回假</td></tr><tr><td><code>int atomic_dec_and_test(atomic_t *v)</code></td><td>从 v减 1，如果结果为0就返回真，否则就返回假</td></tr><tr><td><code>int atomic_inc_and_test(atomic_t *v)</code></td><td>给 v加 1，如果结果为0就返回真，否则就返回假</td></tr><tr><td><code>int atomic_add_negative(int i, atomic_t *v)</code></td><td>给 v加 i，如果结果为负就返回真，否则返回假</td></tr><tr><td><code>int atomic_cmpxchg(atomic_t *v, int old, int new)</code></td><td>看 v指向的值是不是 old，如果是，就把它改成 new。否则不改。总是返回v指向的未修改的原始值。</td></tr></tbody></table><blockquote><p>64位的整型原子操作只是将“atomic_”前缀换成“atomic64_”，将int换成long long。</p></blockquote><h4 id="222-位原子操作相关api"><a class="markdownIt-Anchor" href="#222-位原子操作相关api"></a> 2.2.2. 位原子操作相关API</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>void set_bit(int nr, void *p)</code></td><td>将p地址的nr位置1</td></tr><tr><td><code>void clear_bit(int nr,void *p)</code></td><td>将p地址的nr位清零</td></tr><tr><td><code>void change_bit(int nr, void *p)</code></td><td>将p地址的nr位反转</td></tr><tr><td><code>int test_bit(int nr, void *p)</code></td><td>获取p地址的nr位的值</td></tr><tr><td><code>int test_and_set_bit(int nr, void *p)</code></td><td>将p地址的nr位置1，并且返回nr位原来的值</td></tr><tr><td><code>int test_and_clear_bit(int nr, void *p)</code></td><td>将p地址的nr位清0，并且返回nr位原来的值</td></tr><tr><td><code>int test_and_change_bit(int nr, void *p)</code></td><td>将p地址的nr位翻转，并且返回nr位原来的值</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="23-小实验1"><a class="markdownIt-Anchor" href="#23-小实验1"></a> 2.3. 小实验1</h3><ul><li>实验目的：了解原子操作。</li><li>实验内容：实现led灯设备在同一时间只能由一个进程访问。</li><li>实验原理：<br />我们在led设备的数据结构体里添加一个标志位 <code>busy</code>，该标志位反应该设备是否被占用，如果被占用则<code>busy</code>为1，否则为0。当我们在led的open函数中判断是否被占用以及设定标志位时，如果操作不是原子的，那么可能会出现这种情况：<br />1. -&gt;进程a（第一个访问led）运行到判断语句成功进入未占用分支并准备赋值标志位为1<br />2. -&gt;进程b打断进程a开始运行<br />3. -&gt;进程b运行判断语句并赋值<code>busy</code>为1，占用该设备<br />4. -&gt;进程a由于先前已进入未占用分支，则继续赋值标志位为1，占用该设备<br />为了杜绝这种事发生，我们必须保证判断、修改<code>busy</code>标志位这两个步骤是统一的、原子的，不能被打断。</li><li>实验步骤：<ol><li>在led私有变量结构体(struct led_dev)中，定义原子变量busy</li><li>在led设备初始化函数中，初始化busy为0：<code>atomic_set()</code></li><li>在led设备open函数中，判断、修改busy，这两个操作必须是连续的、不可被打断的：<code>atomic_cmpxchg()</code></li><li>则led设备release函数中，重新置busy为0，代表解除占用</li></ol></li><li>实验现象：当一个进程占用led设备时，另一个进程会无法打开该设备，然后退出。（可以自己编写一个程序open设备然后用sleep模拟占用几秒）<br />头文件：</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/of.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/of_gpio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/atomic.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEV_NAME</span> <span class="token string">"led_atomic"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><details><summary>参考代码，只展示了一些关键代码。</summary><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">led_dev</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/*...含各种私有数据，略*/</span>    <span class="token class-name">atomic_t</span> busy<span class="token punctuation">;</span>  <span class="token comment">//new: 原子变量</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token operator">*</span> led<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">led_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>nd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token operator">*</span> this_devp<span class="token punctuation">;</span>    this_devp <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>nd<span class="token operator">-></span>i_cdev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token punctuation">,</span> cdev<span class="token punctuation">)</span><span class="token punctuation">;</span>    fp<span class="token operator">-></span>private_data <span class="token operator">=</span> this_devp<span class="token punctuation">;</span>    <span class="token comment">/* atomic_cmpxchg(ptr, old, new):     * 看 ptr 指向的值是不是 old，如果是，就把它改成 new。     * 返回值：ptr指向的值的原始值。     * 如果busy=0，0=old，会将busy改成new值，返回原始值0     * 如果busy=1，1!=old，不会改值，返回原始值1     * busy!=0的情况：只能是被其他的进程置为1了     * busy=0的情况：没有进程占用这个设备，这种情况下会这个函数会将busy=1     */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">atomic_cmpxchg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>this_devp<span class="token operator">-></span>busy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"this dev is occupied by another guy."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">led_rel</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>nd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token operator">*</span> this_devp <span class="token operator">=</span> fp<span class="token operator">-></span>private_data<span class="token punctuation">;</span>    <span class="token comment">/* 释放原子变量 */</span>    <span class="token function">atomic_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>this_devp<span class="token operator">-></span>busy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"release！ now busy = %d"</span><span class="token punctuation">,</span> <span class="token function">atomic_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>this_devp<span class="token operator">-></span>busy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">ssize_t</span> <span class="token function">led_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/*...略*/</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">led_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>fp<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> cnt<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/*...略，含控制亮灭的逻辑*/</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> led_fops <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span>open <span class="token operator">=</span> led_open<span class="token punctuation">,</span>    <span class="token punctuation">.</span>release <span class="token operator">=</span> led_rel<span class="token punctuation">,</span>    <span class="token punctuation">.</span>read <span class="token operator">=</span> led_read<span class="token punctuation">,</span>    <span class="token punctuation">.</span>write <span class="token operator">=</span> led_write<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add_dev</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">/*...添加字符设备的一般步骤，略*/</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> __init <span class="token keyword">int</span> <span class="token function">led_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// ！！！！在此处为我们的私有数据结构体分配内存！！！！否则指针指向NULL</span>    led <span class="token operator">=</span> <span class="token function">kzalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>led<span class="token punctuation">)</span><span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">add_dev</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token comment">/* 初始化原子变量为0 */</span>    <span class="token function">atomic_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>led<span class="token operator">-></span>busy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">/*...含查找节点并申请gpio子系统控制gpio，略*/</span>       <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> __exit <span class="token keyword">void</span> <span class="token function">led_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/*...含各种释放，略*/</span><span class="token punctuation">&#125;</span><span class="token function">module_init</span><span class="token punctuation">(</span>led_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">module_exit</span><span class="token punctuation">(</span>led_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"gdm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></details><h2 id="3-自旋锁"><a class="markdownIt-Anchor" href="#3-自旋锁"></a> 3. 自旋锁</h2><h3 id="31-自旋锁简介"><a class="markdownIt-Anchor" href="#31-自旋锁简介"></a> 3.1. 自旋锁简介</h3><p>自旋锁，顾名思义，我们可以把他理解成厕所门上的一把锁。这个厕所门只有一把钥匙，当我们进去时，把钥匙取下来，进去后反锁。那么当第二个人想进来，必须等我们出去后才可以。当第二个人在外面等待时，可能会一直等待在门口转圈。</p><p>我们的自旋锁也是这样，自旋锁只有锁定和解锁两个状态。当我们进入拿上钥匙进入厕所，这就相当于自旋锁锁定的状态，期间谁也不可以进来。当第二个人想要进来，这相当于线程B想要访问这个共享资源但是目前不能访问，所以线程B就一直在原地等待，一直查询是否可以访问这个共享资源（占用CPU）。当我们从厕所出来后，这个时候就“解锁”了，只有再这个时候线程B才能访问。</p><p>假如，在厕所的人待的时间太长怎么办？外面的人一直等待吗？如果换做是我们，肯定不会这样，简直浪费时间，可能我们会寻找其他方法解决问题。自旋锁也是这样的，如果线程A持有<strong>自旋锁时间过长，显然会浪费处理器的时间，降低了系统性能</strong>。我们知道CPU最伟大的发明就在于多线程操作，这个时候让线程B在这里傻傻的不知道还要等待多久，显然是不合理的。因此，如果<strong>自旋锁只适合短期持有</strong>，如果遇到需要长时间持有的情况，我们就要换一种方式了（下文的互斥体）。</p><h3 id="32-自旋锁api"><a class="markdownIt-Anchor" href="#32-自旋锁api"></a> 3.2. 自旋锁API</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_SPINLOCK(spinlock_t lock)</code></td><td>定义并初始化一个自旋变量</td></tr><tr><td><code>int spin_lock_init(spinlock_t *lock)</code></td><td>初始化自旋锁</td></tr><tr><td><code>void spin_lock(spinlock_t *lock)</code></td><td>获取指定的自旋锁，也叫加锁</td></tr><tr><td><code>void spin_unlock(spinlock_t *lock)</code></td><td>释放指定的自旋锁。</td></tr><tr><td><code>int spin_trylock(spinlock_t *lock)</code></td><td>尝试获取指定的锁，如果没有获取到，返回0</td></tr><tr><td><code>int spin_is_locked(spinlock_t *lock)</code></td><td>检查指定的自旋锁是否被获取，如果没有被获取返回非0，否则返回0.</td></tr></tbody></table><p>自旋锁是主要为了<strong>多处理器系统</strong>设计的。对于<strong>单处理器且内核不支持抢占的系统</strong>，一旦进入了自旋状态，则会永远自旋下去。</p><blockquote><p><strong>注意</strong> 非抢占 ≠ 不切换。非抢占式只是不能在内核中任意抢占，但线程仍然可能主动睡眠、阻塞、被调度切换。</p></blockquote><p>举个例子，线程A获取了锁，A 在持锁状态下被切到进程 B，B 就可能自旋占着 CPU，使 A 无法继续执行释放锁 → 死锁。</p><p>因此，在单处理器且内核不支持抢占的系统中，<strong>自旋锁会被设置为空操作</strong>。</p><p>以上列表中的函数<strong>适用于SMP或支持抢占的单CPU</strong>下线程之间的并发访问，也就是用于线程与线程之间，被自旋锁保护的临界区<strong>一定不能调用任何能够引起睡眠和阻塞（其实本质仍然是睡眠）的API函数</strong>，否则的话会可能会导致死锁现象的发生。自旋锁会<strong>自动禁止抢占</strong>，也就说当线程A得到锁以后会<strong>暂时禁止内核抢占</strong>。如果线程A在持有锁期间进入了<strong>休眠状态</strong>，那么线程A会<strong>自动放弃CPU使用权</strong>。CPU此时将使用权赋予线程B，线程B开始运行，线程B也想要获取锁，但是此时锁被A线程持有，而且<strong>内核抢占还被禁止了</strong>！线程B无法被调度岀去，那么线程A就无法运行，锁也就无法释放<strong>死锁</strong>发生了！</p><p>当线程之间发生并发访问时，如果此时中断也要插一脚，中断也想访问共享资源，那该怎么办呢？首先可以肯定的是，中断里面使用自旋锁，但是在中断里面使用自旋锁的时候，在获取锁之前一定要<strong>先禁止本地中断</strong>（也就是<strong>本CPU中断</strong>，对于多核SOC来说会有多个CPU核），否则可能导致锁死现象的发生。看下下面一个例子：</p><p><img src="Snipaste_2025-12-03_23-11-21.png" alt="" /></p><p>线程A先运行，并且获取到了lock这个锁，当线程A运行 functionA函数的时候中断发生了，<strong>中断抢走了CPU使用权</strong>。下边的中断服务函数也要获取lock这个锁，但是这个锁被线程A占有着，中断就会一直自旋，等待锁有效。但是在中断服务函数执行完之前，线程A是不可能执行的，线程A说“你先放手”，中断说“你先放手”，场面就这么僵持着死锁发生！</p><p>使用了自旋锁之后可以保证临界区不受别的CPU和本CPU内的抢占进程的打扰，但是得到锁的代码在执行临界区的时候，还可能受到中断和底半部的影响，为了防止这种影响，建议使用以下列表中的函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>void spin_lock_irq(spinlock_t *lock)</code></td><td>禁止本地中断，并获取自旋锁</td></tr><tr><td><code>void spin_unlock_irq(spinlock_t *lock)</code></td><td>激活本地中断，并释放自旋锁</td></tr><tr><td><code>void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)</code></td><td>保存中断状态，禁止本地中断，并获取自旋锁</td></tr><tr><td><code>void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)</code></td><td>将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁</td></tr></tbody></table><p>其中 <code>flags</code> 就是用于保存中断状态寄存器（具体是哪个个寄存器忘了，反正肯定有个保存中断状态的寄存器）的值。</p><p>下半部(BH)也会竞争共享资源，有些资料也会将下半部叫做底半部。如果要在下半部里面使用自旋锁，可以使用这些 API 函数：</p><p><code>void spin_lock_bh(spinlock_t *lock)</code><br />关闭下半部，并获取自旋锁。</p><p><code>void spin_unlock_bh(spinlock_t *lock)</code><br />打开下半部，并释放自旋锁。</p><p>在多核编程的时候，如果进程和中断可能访问同一片临界资源，我们一般需要在进程上下文中调用<code>spin_lock irqsave()</code> <code>spin_unlock_irqrestore()</code>，在中断上下文中调用 <code>spin_lock()</code> <code>spin_unlock()</code>。这样，在CPU上，无论是进程上下文，还是中断上下文获得了自旋锁，此后，如果CPU1无论是进程上下文，还是中断上下文，想获得同一自旋锁，都必须忙等待，这避免一切核间并发的可能性。同时，由于每个核的进程上下文持有锁的时候用的是 <code>spin_lock_irgsave()</code>，所以该核上的中断是不可能进入的，这避免了核内并发的可能性。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_SPINLOCK</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token comment">/* 定义并初始化一个锁 */</span><span class="token comment">/* 线程A */</span><span class="token keyword">void</span> <span class="token function">functionA</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 中断状态 */</span><span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token comment">/* 获取锁 */</span><span class="token comment">/* 临界区 */</span><span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token comment">/* 释放锁 */</span><span class="token punctuation">&#125;</span><span class="token comment">/* 中断服务函数 */</span><span class="token keyword">void</span> <span class="token function">irq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span> <span class="token comment">/* 获取锁 */</span><span class="token comment">/* 临界区 */</span><span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span> <span class="token comment">/* 释放锁 */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="33-小实验2"><a class="markdownIt-Anchor" href="#33-小实验2"></a> 3.3. 小实验2</h3><p>我们在小实验1的例子上修改。</p><ul><li>实验目的：了解自旋锁。</li><li>实验内容：实现led灯设备在同一时间只能由一个进程访问。</li><li>实验原理：同实验1，只不过我们采用自旋锁来实现判断、赋值的原子性。</li><li>实验步骤：<ol><li>包含头文件 <code>#include &lt;linux/spinlock.h&gt;</code></li><li>在led私有变量结构体(struct led_dev)中，定义整形变量busy；定义自旋锁类型 <code>spinlock_t lock</code>。</li><li>在led设备初始化函数中，初始化busy为0；初始化自旋锁：<code>spin_lock_init()</code>。</li><li>在led设备open函数中，判断、修改busy前上锁：<code>spin_lock_irqsave()</code>，修改完成后释放锁：<code>spin_unlock_irqrestore()</code></li><li>则led设备release函数中，上锁，重新置busy为0，释放锁。</li></ol></li><li>实验现象：当一个进程占用led设备时，另一个进程会无法打开该设备。第一个进程占用结束后，进程b才继续运行（可以自己编写一个程序open设备然后用sleep模拟占用几秒</li></ul><p>关键的open函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">led_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>nd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token operator">*</span> this_devp<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>    this_devp <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>nd<span class="token operator">-></span>i_cdev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token punctuation">,</span> cdev<span class="token punctuation">)</span><span class="token punctuation">;</span>    fp<span class="token operator">-></span>private_data <span class="token operator">=</span> this_devp<span class="token punctuation">;</span>    <span class="token function">spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>this_devp<span class="token operator">-></span>spinlock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 如果发现该设备已经被占用了： */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>this_devp<span class="token operator">-></span>busy<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/* 解锁并恢复中断状态 */</span>        <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>this_devp<span class="token operator">-></span>spinlock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"this dev is occupied by another guy."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    this_devp<span class="token operator">-></span>busy <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//标记占用</span>    <span class="token function">spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>this_devp<span class="token operator">-></span>spinlock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="34-自旋锁的衍生"><a class="markdownIt-Anchor" href="#34-自旋锁的衍生"></a> 3.4. 自旋锁的衍生</h3><p>在自旋锁的基础上还衍生出了其他特定场合使用的锁，这些锁在驱动中其实用的不多，更多的是在 Linux 内核中使用，本节我们简单来了解一下这些衍生出来的锁。</p><h4 id="341-读写锁"><a class="markdownIt-Anchor" href="#341-读写锁"></a> 3.4.1. 读写锁</h4><p>当临界区的一个文件可以被<strong>同时读取</strong>，但是并<strong>不能被同时读和写</strong>。如果一个线程在读，另一个线程在写，那么很可能会读取到错误的<strong>不完整的数据</strong>。读写自旋锁是可以<strong>允许对临界区的共享资源进行并发读操作的。但是并不允许多个线程并发读写操作</strong>。如果想要并发读写，就要用到了顺序锁。 读写自旋锁的<strong>读</strong>操作函数如下所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_RWLOCK(rwlock_t lock)</code></td><td>定义并初始化读写锁</td></tr><tr><td><code>void rwlock_init(rwlock_t *lock)</code></td><td>初始化读写锁</td></tr><tr><td><code>void read_lock(rwlock_t *lock)</code></td><td>获取读锁</td></tr><tr><td><code>void read_unlock(rwlock_t *lock</code></td><td>释放读锁</td></tr><tr><td><code>void read_unlock_irq(rwlock_t *lock)</code></td><td>打开本地中断，并且释放读锁</td></tr><tr><td><code>void read_lock_irqsave(rwlock_t *lock,unsigned long flags)</code></td><td>保存中断状态，禁止本地中断，并获取读锁</td></tr><tr><td><code>void read_unlock_irqrestore(rwlock_t *lock,unsigned long flags)</code></td><td>将中断状态恢复到以前的状态，并且激活本地中断，释放读锁</td></tr><tr><td><code>void read_lock_bh(rwlock_t *lock)</code></td><td>关闭下半部，并获取读锁</td></tr><tr><td><code>void read_unlock_bh(rwlock_t *lock)</code></td><td>打开下半部，并释放读锁</td></tr></tbody></table><p>读写自旋锁的<strong>写</strong>操作函数如下所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>void write_lock(rwlock_t *lock)</code></td><td>获取写锁</td></tr><tr><td><code>void write_unlock(rwlock_t *lock)</code></td><td>释放写锁</td></tr><tr><td><code>void write_lock_irq(rwlock_t *lock)</code></td><td>禁止本地中断，并且获取写锁。</td></tr><tr><td><code>void write_unlock_irq(rwlock_t *lock)</code></td><td>打开本地中断，并且释放写锁</td></tr><tr><td><code>void write_lock_irqsave(rwlock_t *lock,unsigned long flags)</code></td><td>保存中断状态，禁止本地中断，并获取写锁</td></tr><tr><td><code>void write_unlock_irqrestore(rwlock_t *lock,unsigned long flags)</code></td><td>将中断状态恢复到以前的状态，并且激活本地中断，释放写锁</td></tr><tr><td><code>void write_lock_bh(rwlock_t *lock)</code></td><td>关闭下半部，并获取写锁</td></tr><tr><td><code>void write_unlock_bh(rwlock_t *lock)</code></td><td>打开下半部，并释放写锁</td></tr></tbody></table><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">rwlock_t</span> lock<span class="token punctuation">;</span> <span class="token comment">/* 定义rwlock */</span><span class="token function">rwlock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 初始化rwlock */</span><span class="token comment">/* 读时获取锁*/</span><span class="token function">read_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* 临界资源 */</span><span class="token function">read_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 写时获取锁*/</span><span class="token function">write_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* 临界资源 */</span> <span class="token function">write_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="342-顺序锁"><a class="markdownIt-Anchor" href="#342-顺序锁"></a> 3.4.2. 顺序锁</h4><p>顺序锁是读写锁的优化版本，读写锁不允许同时读写，而使用<strong>顺序锁可以完成同时进行读和写的操作</strong>，<strong>但并不允许同时的写</strong>。虽然顺序锁可以同时进行读写操作，但并不建议这样，读取的过程并不能保证数据的完整性。</p><p>顺序锁的<strong>读</strong>操作函数如下所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_SEQLOCK(seqlock_t sl)</code></td><td>定义并初始化顺序锁</td></tr><tr><td><code>void seqlock_ini seqlock_t *sl)</code></td><td>初始化顺序锁</td></tr><tr><td><code>void write_seqlock(seqlock_t *sl)</code></td><td>顺序锁写操作</td></tr><tr><td><code>void write_sequnlock(seqlock_t *sl)</code></td><td>获取写顺序锁</td></tr><tr><td><code>void write_seqlock_irq(seqlock_t *sl)</code></td><td>禁止本地中断，并且获取写顺序锁</td></tr><tr><td><code>void write_sequnlock_irq(seqlock_t *sl)</code></td><td>打开本地中断，并且释放写顺序锁</td></tr><tr><td><code>void write_seqlock_irqsave(seqlock_t *sl,unsigned long flags)</code></td><td>保存中断状态，禁止本地中断，并获取写顺序</td></tr><tr><td><code>void write_sequnlock_irqrestore(seqlock_t *sl,unsigned long flags)</code></td><td>将中断状态恢复到以前的状态，并且激活本地中断，释放写顺序锁</td></tr><tr><td><code>void write_seqlock_bh(seqlock_t *sl)</code></td><td>关闭下半部，并获取写读锁</td></tr><tr><td><code>void write_sequnlock_bh(seqlock_t *sl)</code></td><td>打开下半部，并释放写读锁</td></tr></tbody></table><p>顺序锁的<strong>写</strong>操作函数如下所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_RWLOCK(rwlock_t lock)</code></td><td>读单元访问共享资源的时候调用此函数，此函数会返回顺序锁的顺序号</td></tr><tr><td><code>unsigned read_seqretry(const seqlock_t *sl,unsigned start)</code></td><td>读结束以后调用此函数检查在读的过程中有没有对资源进行写操作，如果有的话就要重读</td></tr></tbody></table><h3 id="35-自旋锁使用注意事项"><a class="markdownIt-Anchor" href="#35-自旋锁使用注意事项"></a> 3.5. 自旋锁使用注意事项</h3><ol><li>因为在等待自旋锁的时候处于“自旋”状态，因此锁的持有时间不能太长，一定要短，否则的话会降低系统性能。如果临界区比较大，运行时间比较长的话要选择其他的并发处理方式，比如稍后要讲的信号量和互斥体。</li><li>自旋锁保护的临界区内不能调用任何可能导致线程休眠的API函数，比如copy_from_user（）、copy_to_user（）、kmalloc（）和msleep（）等函数，否则的话可能导致死锁。</li><li>不能递归申请自旋锁，因为一旦通过递归的方式申请一个你正在持有的锁，那么你就必须“自旋”，等待锁被释放，然而你正处于“自旋”状态，根本没法释放锁。结果就是自己把自己锁死了</li><li>在编写驱动程序的时候我们必须考虑到驱动的可移植性，因此不管你用的是单核的还是多核的SOC，都将其当做多核SOC来编写驱动程序。</li></ol><blockquote><p>copy_from_user的使用是结合进程上下文的，因为他们要访问“user”的内存空间，这个“user”必须是某个特定的进程。如果在驱动中使用这两个函数，必须是在实现系统调用的函数中使用，不可在实现中断处理的函数中使用。如果在中断上下文中使用了，那代码就很可能操作了根本不相关的进程地址空间。其次由于操作的页面可能被换出，这两个函数可能会休眠，所以同样不可在中断上下文中使用。</p></blockquote><h2 id="4-信号量"><a class="markdownIt-Anchor" href="#4-信号量"></a> 4. 信号量</h2><h3 id="41-信号量简介"><a class="markdownIt-Anchor" href="#41-信号量简介"></a> 4.1. 信号量简介</h3><p>信号量和自旋锁有些相似，不同的是使用自旋锁时：</p><ul><li>当前 CPU 会在循环中 <strong>不停检查锁是否释放</strong></li><li><strong>不会睡眠</strong></li><li><strong>不会切换任务</strong></li><li>CPU 一直高负载自旋<br />而使用信号量时：</li><li>当前进程会 <strong>睡眠（TASK_INTERRUPTIBLE）</strong></li><li>CPU 让给其他任务</li><li>等待唤醒（资源可用 or 收到 signal）</li></ul><p>信号量可以指定同时能访问的进程数。比如，有100个停车位的停车场，门口电子显示屏上实时更新的停车数量就是一个信号量，他允许100个车辆访问。当有车开进去，信号量减一，当有车开出来，信号量加一。 信号量具有以下特点：</p><ol><li>因为信号量可以使等待资源线程进入休眠状态，因此适用于那些<strong>占用资源比较久</strong>的场合。</li><li>因此信号量不能用于中断中，因为信号量会引起休眠，<strong>中断不能休眠</strong>。</li><li><strong>如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势</strong>。</li></ol><blockquote><p>在没有激烈锁争用的情况下，自旋锁的性能要大大优于信号量； 因为没有锁拥塞，获取自旋锁的开销仅为几十个CPU周期， 而上下文切换的开销则至少几百/上千个时钟周期，而且操作系统的时间片切换周期还有可能会丢弃几千万个时钟周期。<br />如果拥塞程度很高，或者锁会被长时间持有（有时候真的没办法！），在这种场景下，使用自旋锁则会消耗大量的CPU时间，却什么活都没干。这时候使用信号量（或互斥锁）是一种更好的解决办法，因为没有抢占CPU，其他线程在这段时间内就可以有效运行。</p></blockquote><h3 id="42-信号量api"><a class="markdownIt-Anchor" href="#42-信号量api"></a> 4.2. 信号量API</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_SEAMPHORE(name)</code></td><td>定义一个信号量，并且设置信号量的值为1</td></tr><tr><td><code>void sema_init(struct semaphore *sem, int val)</code></td><td>初始化信号量sem，设置信号量值为val</td></tr><tr><td><code>void down(struct semaphore *sem)</code></td><td>获取信号量，因为会导致休眠，因此不能在中断中使用</td></tr><tr><td><code>int down_trylock(struct semaphore *sem);</code></td><td>尝试获取信号量，如果能获取到信号量就获取，并且返回0.如果不能就返回非0，并且不会进入休眠</td></tr><tr><td><code>int down_interruptible(struct semaphore</code></td><td>获取信号量，和down类似，只是使用dow进入休眠状态的线程不能被信号打断。而使用此函数进入休眠以后是可以被信号打断的</td></tr><tr><td><code>void up(struct semaphore *sem)</code></td><td>释放信号量</td></tr></tbody></table><h3 id="43-小实验3"><a class="markdownIt-Anchor" href="#43-小实验3"></a> 4.3. 小实验3</h3><p>我们在小实验1的例子上修改。</p><ul><li>实验目的：了解信号量。</li><li>实验内容：实现led灯设备在同一时间只能由一个进程访问。</li><li>实验原理：<br />进程获取完所有信号量后，其他进程进入休眠状态等待信号量，因此无法访问设备。</li><li>实验步骤：<ol><li>包含头文件 <code>#include &lt;linux/semaphore.h&gt;</code></li><li>在led私有变量结构体(struct led_dev)中，定义信号量类型 <code>struct semaphore sem</code>。</li><li>在led设备初始化函数中，初始化信号量：<code>sema_init()</code>。</li><li>在led设备open函数中，获取信号量：<code>down_interruptible()</code>。</li><li>则led设备release函数中，释放信号量：<code>up()</code>。</li></ol></li><li>实验现象：当一个进程占用led设备时，另一个进程会进入休眠状态等待信号量。第一个进程占用结束后，进程b才继续运行（可以自己编写一个程序open设备然后用sleep模拟占用几秒）</li></ul><p>关键open函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">led_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>nd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token operator">*</span> this_devp<span class="token punctuation">;</span>    this_devp <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>nd<span class="token operator">-></span>i_cdev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token punctuation">,</span> cdev<span class="token punctuation">)</span><span class="token punctuation">;</span>    fp<span class="token operator">-></span>private_data <span class="token operator">=</span> this_devp<span class="token punctuation">;</span>    <span class="token comment">/* 获取信号量，进入休眠等待状态的进程可以被信号打断，不建议用down()，因为在等待信号量的过程中，不可以被信号打断 */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">down_interruptible</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>this_devp<span class="token operator">-></span>sem<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span>EBUSY<span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-互斥体"><a class="markdownIt-Anchor" href="#5-互斥体"></a> 5. 互斥体</h2><h3 id="51-互斥体简介"><a class="markdownIt-Anchor" href="#51-互斥体简介"></a> 5.1. 互斥体简介</h3><p>互斥体表示一次只有一个线程访问共享资源，<strong>不可以递归申请互斥体</strong>。 信号量也可以用于互斥体，当信号量用于互斥时（即避免多个进程同时在一个临界区中运行），信号量的值应初始化为1.这种信号量在任何给定时刻只能由单个进程或线程拥有。在这种使用模式下，一个信号量有时也称为一个“互斥体（ mutex）”，它是互斥（mutual exclusion）的简称。Linux内核中<strong>几平所有的信号量均用于互斥</strong>。</p><h3 id="52-互斥体api"><a class="markdownIt-Anchor" href="#52-互斥体api"></a> 5.2. 互斥体API</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>DEFINE_MUTEX(name)</code></td><td>定义并初始化一个 mutex变量</td></tr><tr><td><code>void mutex_init(mutex *lock)</code></td><td>初始化 mutex</td></tr><tr><td><code>void mutex_lock(struct mutex *lock)</code></td><td>获取 mutex，也就是给 mutex上锁。如果获取不到就进休眠</td></tr><tr><td><code>void mutex_unlock(struct mutex *lock)</code></td><td>释放 mutex，也就给 mutex解锁</td></tr><tr><td><code>int mutex_trylock(struct mutex *lock)</code></td><td>判断 mutex是否被获取，如果是的话就返回，否则返回0</td></tr><tr><td><code>int mutex_lock_interruptible(struct mutex *lock)</code></td><td>使用此函数获取信号量失败进入休眠以后可以被信号打断</td></tr></tbody></table><h3 id="53-小实验4"><a class="markdownIt-Anchor" href="#53-小实验4"></a> 5.3. 小实验4</h3><p>我们在小实验1的例子上修改。</p><ul><li>实验目的：了解互斥体。</li><li>实验内容：实现led灯设备在同一时间只能由一个进程访问。</li><li>实验原理：<br />进程占用互斥体后，其他进程进入休眠状态等待，因此无法访问设备。</li><li>实验步骤：<ol><li>包含头文件 <code>#include &lt;linux/mutex.h&gt;</code></li><li>在led私有变量结构体(struct led_dev)中，定义互斥体类型 <code>struct mutex lock</code>。</li><li>在led设备初始化函数中，初始化互斥体：<code>mutex_init()</code>。</li><li>在led设备open函数中，上锁：<code>mutex_lock()</code>。</li><li>则led设备release函数中，释放锁：<code>mutex_unlock()</code>。</li></ol></li><li>实验现象：当一个进程占用led设备时，另一个进程会进入休眠状态等待信号量。第一个进程占用结束后，进程b才继续运行（可以自己编写一个程序open设备然后用sleep模拟占用几秒）</li></ul><h3 id="54-互斥体的注意事项"><a class="markdownIt-Anchor" href="#54-互斥体的注意事项"></a> 5.4. 互斥体的注意事项</h3><p>互斥体的使用限制和场景基本上和信号量一样。可以近似看作信号量为1的信号量，但是既然单独设计出互斥体这么一个概念，肯定有它独特的地方。</p><h2 id="6-总结及常见问题"><a class="markdownIt-Anchor" href="#6-总结及常见问题"></a> 6. 总结及常见问题</h2><h3 id="61-自旋锁-信号量-互斥体的主要特性"><a class="markdownIt-Anchor" href="#61-自旋锁-信号量-互斥体的主要特性"></a> 6.1. 自旋锁、信号量、互斥体的主要特性</h3><table><thead><tr><th>特性</th><th>spinlock</th><th>mutex</th><th>semaphore</th></tr></thead><tbody><tr><td>临界区可睡眠？</td><td>❌ 不行</td><td>✔ 可以</td><td>✔ 可以</td></tr><tr><td>可在中断里用？</td><td>✔ 可以</td><td>❌ 不行</td><td>❌ 不行</td></tr><tr><td>可保护阻塞操作？</td><td>❌ 不行</td><td>✔ 可以</td><td>✔ 可以</td></tr><tr><td>临界区长短</td><td>很短</td><td>可长</td><td>可长</td></tr><tr><td>内核等待方式</td><td>忙等</td><td>睡眠</td><td>睡眠</td></tr></tbody></table><h2 id="7-互斥体与信号量的区别"><a class="markdownIt-Anchor" href="#7-互斥体与信号量的区别"></a> 7. 互斥体与信号量的区别</h2><p><strong>mutex ≠ semaphore(1)</strong><br />因为 mutex 有严格的“锁所有权（ownership）”语义，而 semaphore 没有。</p><p>内核为了实现更安全、可靠的同步机制，引入了 mutex。<br />信号量适用范围大但危险，而 mutex 是专为“互斥”设计的安全锁。</p><p>mutex 系统中：</p><ul><li>如果同一个线程重复 lock，会进入死锁检测路径</li><li>如果 unlock 不是 owner，会警告</li><li>CONFIG_DEBUG_MUTEX 提供完整检测</li></ul><p>semaphore 则完全不管你：</p><ul><li>同一线程 down 两次？ → 直接死锁</li><li>无 owner unlock → 完全无法检测</li><li>无 debug 机制</li></ul><p>信号量太“万能”了——所以容易被误用，也更难优化。</p><p>mutex 则是：</p><ul><li>只用于互斥</li><li>更快</li><li>更安全</li><li>有调试能力</li><li>支持优先级继承</li><li>语义明确</li></ul><blockquote><p><strong>如果你只是想保护一个共享变量，只应该用 mutex，而不是 semaphore。</strong></p></blockquote><p>这是为什么 Linux 内核在新代码中强烈推荐 mutex，而不是 semaphore(1)。</p><table><thead><tr><th>特点</th><th>mutex</th><th>semaphore(1)</th></tr></thead><tbody><tr><td>专为互斥</td><td>✔ 是</td><td>❌ 不是</td></tr><tr><td>有严格语义</td><td>✔ lock/unlock owner 必须一致</td><td>❌ 无 owner 概念</td></tr><tr><td>误用时有检测</td><td>✔ 多重检测</td><td>❌ 没检测</td></tr><tr><td>允许阻塞操作</td><td>✔</td><td>✔</td></tr><tr><td>性能</td><td>⭐ 较高</td><td>⭐ 普通</td></tr><tr><td>适用场景</td><td>保护共享资源</td><td>信号同步、多个资源</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇参考&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.81&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/561865798&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>【点灯大师】设备树和Pinctrl</title>
    <link href="https://blog.godmao.top/posts/64795/"/>
    <id>https://blog.godmao.top/posts/64795/</id>
    <published>2025-11-28T08:46:16.000Z</published>
    <updated>2025-12-05T05:14:16.932Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="ERROR。" data-whm="这个文章不能被校验, 不过你还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="63d9ac3f7507924d6a0060aebfc49df195db9eff982ad5733a25b6000caa0d36">472f0d2124ee617a2f29ff331422d5d3c786bf02d6cb05b48659c7bd0efc234c66e4d05e5e352805b8be7fb548f5db1dc6ce19185f33969b60366e77544d242a4ad3617be960d1cc6fb50f20f9bc3fa3dc4611c1b7fe65e71a5a3a53a2361ac23d01b5245c304a9c64d1f2d42467b313e7b98b9941501c7f62ba70ae803acc1147cacc437bdd5678ef1810bb19b628c6a4bce1bcb2f217b0631590f4a05267a7a121c769458bb6d0d3a007991a4e5946e6e80bfdd70ada16fe8b7f425cd91ff2fd2c0d96e6a7a61f2a495ff7c5d17f33392096a74bcf83fe0a2a1b47dd5a8cc11585947ae9ce708ca44fe807a441afd12f8304730781830b4f9cc4f4cdf370535e05cecdcdde5fb485d559476d4a130b41d70fc5d6999e8bb9a1105d9fc8bad1acf6b48e4bca65932d62ce795949be362d42d3c4aa5b1a3df4213ed5be2d1da2e61473992a40a821237717333de4627358fc2994316e97947ee4226e077242b96fc92af9a92972b0d4c2b58461ad536d501a7de483e9969ee84db90aa658a85742ff836087cd9bd437e8df1de6e85134b4841acb71c6b03655e4bdf65d7b514f59597510434f32a3cd8fccfbd69b6f48bd1d6c034aa63a2813d9fe725bcac35d09f737f8005eb27675b1d28c6b43a108dc3b15aef4e279a3289fe23363d1b11756648140125cfc1594a0e6c4ce86ea5a633c126ef44d4a82f5e90b5193612cc3d5397b3cfc5cd1f52df79646c7692c94a5f8436a310067bdd4a7674f0baf60599bf65b57ad2cd770e4da596d1a2f73ec3cfc592384ec1af53dd72296f3a85060a3a294625ca56c049546038162c1f65a1cd29c0d8b60c13591025e54056222cac2ce7b8aa6ebb832d55683946e17c37c8a080e6ffc4ac68980b091931d597aa2ded01fa5c3aede635fe2eb128becb43ed99a0b383c61fcd87b5a02ce04d0c851011adb6a44ef555bd852d7b77408c1fe3703810d3490f10353588c035f46c4e729201556ce7dfa6029eb5cd0a9cd5248c90d32912def4404f20a031a88327ad50e83b13d443a6eb394eaf51b1319463a155e0630e20c87b73cc3a4d9da55f9189f3fdb87dfc96ff8eff7499535cef2bb461db7ac14bbc2a4e23aa74c740654bfb34ad78afdc2474fcb23e2fbbc6143d83c9d479bbaecf2deb39667569113ec05249abec006df5395fedf341b2de43494b4dbed28e46d466c99329ba81d8ce949d2081b7bdf73991cf6e764bad1d11a5f583ee0e24bc7170c6fb0d3efbac444e218046e64ed1581d1d29bbeb3ab3459c095c330c432cb1a351e3ad014bc661eb9c60e0ac5f47e283f0e471a80f178c9c40ea97222d2f8fbc45f61ed64f5c6fca58bdd9b1d47068fa2c417c5b02142c4098c9acba1769b6fe9f46df7aa1a34a5acf231bff352410c6e95b8efcb7b368c03c6859dbff99097e8c298d61095cfc6cb06f7d19f5ac6dd68ecb77cd9476a708f0677def6094a2ee38864df6f420739e4778e9cd70d5aa2f9a76bf269d818bbf1839d533fb3aad45107b3304e488ba680449e892570fde17bdef1ff65948f80159d78ad2a775424de0232c5111d193797b7d18d7021522f060fed671ffdbf469028f8fcc94289f737b5bda13cc3b7234fad398cc79b59fc7eef14ba30903110e3b66e115d36401fc24b977875e5dae3a4456d9f4273ac84e281af9efef72c6a5591f7e80dbfcd8a61c3171fc61361b5be5b21061c8cabbe29342ac74788ff86cd1e173e34134977354c6a8f97fce94d436041614027b516a844b5b7828ece16e2a577133f71437aa52eb74f97fe503dc2b41aec89a6631f34bdac933dd46946141c247f95c690da1bc7750bed67c33c42ce8022cb99f571f4f38cd1c0f691abdb486565de6e18ca0977d52ab019faffb673647f66212e40b85bad3ae51bc4824833084d0230f87239bdf3a8d3360a6f1a8f21c41b9a493512cf23aebd4fcc701038a9b86652b85bc917579097c623119647c754a84435f37d99bfc69c3b6296b5a6063e69aabc490f84e84f62d71c8efec9d711818ec390deb475fba7778b3a49f84ea8968d45797500f8d23400a515223735237ff30c3414ca244c86f96ffa4bcc47819726b7409bafec722463a4429da89cb67cac51937f707bc17d915d317eab437a75e2651402fd9216f25a40a5f94b07b747637cd48292c86885f183d7894415276b6dcdbc36c7baf6478c362bac445f16aadf903826c5e72cb03bda60c657dd083867350e1c501efc8ece926cae9821438a46a08d3be312c9d2964f7295c9d81144501f18aa24752d3e4850cf28d9f7914ea863f687ba2116777f8f66b7545379c07adaf6041cefc03d9f07b03110f1fb1684431fb11b801a912e1d689ca91da3571d029d95caaa7421583d9fd93572e55ffd6731719643ea21138f90d11447631342ffb40d9396e2ab722f8366779a840e78ec5880a2007d07c437cf56a824b2162255b87a7d848a766e52a9e4d8d17ae65bfa865f57010cd23219a699bf1503be864d8bb85f6d661d42209032f7f8577258c2760d47c738e02563a22a09f818e1cfa3d9da3e818fa97242892ce75d62769fa507383c470e46d59a320462a71e8d7d51b4d2558efe3dad3a9b19a651fef31c21b859d899dd42f2efee12bd6a54e0ce083ac139b46581bb035babfeaa09de49e693f40fe5e49b35e5ec63b0f059e9e37bca767e02ec243457ee257506f45dc1a4ff8a6c68bceac7bbeef223a75d10aadbe394f6d66a9ad832d7295e2e9164d774f6c65cc6d953937da38b34500939da22c1b990825cdd45f0aca0b2a086c34beb776f185d04e5f3bc0a2c3edeaa08cbcbb6764211fe91c2d142481f3712ac678283f277f223310d9d206707d5e75d565dc62e505dcbe246e489c6037454fbcdd6499804046ed92066e3b573f2fe9d2f5845344381610648a81efe1cdba35aeea374e02ba47785db28c551ed03065bac09f6228e02a1f8824c468738120eef05ffd33693432b6b2f06d280b97003f7e5a76cdaaae6abe73c49dc4a45d5e4608bb1bca9d0c0590ec7f706ed5f92d1cf75d92372c17be19fdf99d29c5a19fe49e8e6cf0915221e8222f239ec1116e54b541e4960303f4cbb678a7be89d9ab5e9debcefa9f474035554ae9f620375b648d9293ad99b1712ae8c5c6fde22ebfab24846ff9aa7152e13cc89012fbf8c05810bd257cd2c0b42d2e24e21c3630aa5cab1cad571730839adfe1d74210140fd4a4bfb9761ac4cc3b02ad7bdf007a820f15c024961a36cc3425d6e9c202334e8cad026aa9ac77bce5133dce9c4858a8b7b3abce0c2fc6b184822fca287d5e06824d4e2a09d4438a7eb1cff9f396553edce8abc537ae86c6255c595814a2a5dc3744497640451f01414d947156b236ac04a831ed7e57baa58082a90d5415e91c794690f731276bbde7719006fd18a71259e82a6ec5ece97c5ee2887862cc244ab72bba0f5da07008e154c6c3cfaa82e761ebf46f97519248a6a58eae304cfca09764cd883bc657482063036ee1cab27f97699318dc00876c519cd251a6e78dda3cd8375cb66de4fd86526d3353b47b5b7fbef97b7a4c67ed5c0a8c3995057c7e80c6d97866e148cdf2fdaef3a0b264f3b58be771ae0f2ed82641f80740e8ad2ac9162721f2623ce13a039ea4de13addc034787fb459ee260df6779a9ca15127460bbee244e6772d5ded6ee1d3ab12c181591d2e7037130dd047a402f86bd48a11146197b9172d3263549e357f1d2e5dce4594178b174af42939fdec1683516bbd09a42a87d0b7273ffdcaec47eebe9235d2d954db17ce291222fd9d05da77c72ed22efd530c811be3a3bf236c93265b2bc2ccd3e6d24474fb9fa3ef87eb0311174503fec069312de4a4fb728e2961834eae3314ac1e7b28eb44ecd3f00c9a153b7e93850945d9a07977778d6bf8127b0f88c321d069ff553ed5865d585a5382bdb1385d9827f356fbed7f26f40b778fdb57e2b33b111c905db31b8233b3e059b2fac2001ba3d455600f624329a2067df648172332688483ef4e7305d9f0c3c1b43c6345b812c6e76661706b914e21f195b011fb4493978052e9464342e1bd508e2043850c2d697509f32de8f114cb6f8f4978fb0c2d7e3c8cd0d6aeb32c795e94b3385f9bc1eb0e11f426d01361b70a5717b6e9f93defbabbe32f59f2c2a4a143b9a6eefda1bba8d3b0fbf77ce906fe04f62fb9e4b034b2e2c2b299d3abdd1e4381cae50c19d4598e7f20513ba2988bf6eafcab78a422d9d515f061e66cc18fbb7710c0995e5fa4a8c4c621c9f69035cda27c9ddb4b3e8c74949837a4fc4a46b566c4872a85ca66d4d4e42fd2a29c0d48ca47286dfb232ed8e908d4c3b6473d17068f126a2003f5f1a6ff6edd79481f809868d9f5c083f8805b37c982403c19ae15cc52c08ade418a66a74c2c3d90678ef92350ec9bf0de6365043cb26c024d40116deade5f3eff47a0cb6d5d764719aee8314f1327aa1a8086e9f2b326b1b01eb9d0d322a2cfa9242258b1ea52596355f238dbf3e91fc2501b208eddef69f3eacaed53ba1dce5b27918a490ecbe044369a8aa7a64ad11479e23c3eaf76ee6131c743f920a2f2d56fb5800f0f1b17ed48ceaf17a03896dd25df766ad0c9021ceb47f3449991c469e48c00de18d1178b85e1da771d33c71ed4683402c19703f10e30db3fe6dc5d867e9c8d2266505945175688d097fa330df09795344ae7fd7467537d19b441e45e8bc1e01deeb81ba7115a68f8ed4aa471e1d618411348bc8c29c7495a70f60657a2f710e51d8d81d8e78cf8585275443296184ee1b715981655433bd2a4167f349c6a63b8eeb1e5b131d5d33888dbf2ccdb9ef083d849d15ba9787591b0ac21f3da5f1a88ebc7f626117e6a8f041148e6bbd4cfbefbea7c5f6ee169c5bc95553ac620ff5d9aee6ac00f67e223e9062aed78b1b1068b9f2be2b8d5ad64604aa01654f6e0ce87a15cd6f2adcff03bd48723a5cb47677bf8d0df334204ff7a1fc792699d418069756d04e03bffae0d081ab4022980a37711756a01ae6e19e5e5814df7645f734cac5c56f28f7077380cd22e04b065342b9216d583755590e3fd6ed8dbe66a7f45db8c9e8917344964ad53dcd88c272b1c77e483e15ac9813e49b168753447a3797ed838c86a3a8d722d9a9c38934bde5d27c4969e564f58dba3e2e1b57238feb79a9efd77307655fead1946c33a29b90739dc7451bc6208405477b7f409f16eb42296e48b9fe544972364fcb0d574891fe7a3bf3258948c84d257e11020b2242b7340105c4631c088fb04a309b6b0ed99e5a3893ae61b5141fdafe6c954409eff2fbabdaf5cf5c9c11d8539561f39edf240bc8004e4d1191ccc47b15a6fe5f77b8759709a7c5d0f54a0cc9e716ae529cad7708fbf019bb5346ca4fbf999a4341adb04793c3adb8f65a812b6e80c4b62518bb59da323b35229c923d50541af1a60e063c83ed9ae26a3acab6a41b82206de807c6d364311fd10de1a4849ad0aeb6e8bde32ab7b75dbeecb24b03f9003f9dfe40d001339c84606f8ff59ee5137c1e60e0a6b91b466efd7a3634e21c843eb055437e2583be750c64d3f3304678d73d2fa200575427f84f6276598c290b886d0d827bc8b2d182230bbcfcd23bf1f3f2a9d7bdf05949fb0ee9ffef70a3e21ccf959043b7d18fa4f77ea4e7d1d0227268adfe09ee382f837901c4c8a8450a10ec85992a207a1642d1bd4acb5f33c8e6b622d42cd662132bd993cbfdc0a6b01e1754da819fc914f36d0c81a63c324a6205ab8961ccbcb66cbe44bea8a951e950712d2897a80270dc30c967bdb0009f8b0847ff1aa15210e02022ae6e3b01440beda1e575fff899ba0b6c16bfbdb3535fbff0975ade7885515331cf0f367aa6ff41dc6f7d18b34b01303cb99bf0ddfb246068f2bb3e2f5a944b3f53c8ab5343c69e3c9c9f37f663f0dc5b8f1b26d0bd33559f86fa8a2dc906bee463aaf1c87e2a837e13b584876b6cf2236408b5aca8fb3ce279234fa37e339b6f623ab8a7a12e57a982feeea208239840c35f96da63240c3326dcef87a1bda9def14515281ce2f985bbc87e5aa4f48a0e39d0513f6a9e6e05ee5ca99adf72138870bad19a191b678cb4346d36caf5ee2712ec80f9b6d968855fa046299c1cd2ee7a6ca666fe53bcd11a1bb77ae191261eed75a6d635690441360fff6af61b12eccab3dbc6aab89a6b5c24059a857ab76a2331652b1c679f46d18859849f701394415b2979450334f9644068f444c24ab564ab2e68faa8ca3158a93d6e589adfc4878cc8a710bfd50d68aca91d247a605584791cfbd82d04fea9877319154696c7dce95db071afbf6ca9018b5bac2d171dc6edc35eecf6e3b2212256c706d8b7139ce9ce68c27b94f03a97ce7ff8521a7169a7fe3b713ef2d911c3e603534b8a5d7c450ba76ca604ab0ecab86240596c60dc598f31807b3c24972482f1d44bed9719da4d3ebd92c0b8758ac7d3609c1b5c05c7bc61329c56813ef4e3d7d16735411147a6c68d18ed7b391f55b7f162a626bf302d87a816455b96989785abb83b50081720dad79eb4cac93fbd27a1074e145cf2bdbfd6ec2a11633827d5b73acabf30150a555da75aeff85a8b6fc451e730757dc683c66ef631a9f35b35aaa459b82dd79bfe13c66d2ad1c3b4a59a17813b8f5e4f97ef6877d6265001db0bf09cb021d6ad9dab247c57abbb411af32c591ee6d92f45ce217f26d659aded314f7f7ff1d7ed8c15a0f04da77e3d3edec1dfd57670434ad78db2e04f13ee9da4fb49ef69a2b6861265504934a0ccf001fdaf7ef35f3654a5eeb9ec3af6339292c83905a5aa2ae498c8234e92219bc1b315e40a2dc0be63fc5cf6ccfab0d28f1fe5fcdee95ce1762ea9c1a5354b42b576ae7ac14946a1a47d9aa4164e90e70e7e60d005b51a569c2fbe40fbdc870c23214239eed230e293c77aa91bb8f32401d1b487248c8425175c47a2a8241d33357151a03c33f6073db51a680a0c4aa7b5caef56eec2ba2ddc94161896cb4a0d671668a33adbfef8a5b147db00f8f721ef728cb470de9c800366eac8eb1ba6b639b20d0f2feda0166b9db7617d7314d3e5a6a9e8779f0840c2eb6a6d63beab5983e06adac577686594bf96e20c483b0f1c315490a2369c3bac708cb34d367792e4f38c7dc92ea9f34609f7906c3a31380fe63f56a8e6df9b4d57a441d3d7b776e0fde1092a9e53c5c42942a336bf57b3ff19832878c6ff0f071b2f5ef7ee7dc6a3ea0e2c0c5014cf410cec46a488c3f04348e7f1f1ce6c3b29a0749a21c06ddcd44bc087e791024775bc5b8f59b39a39ca5a53cb0aa3e32abe9a175d30d31af39e3110834fefde64b3b957a4d147002daa722d628d5be333915b2b2222a08999e321434d80aaff299fb6767df5103485698410a64b8e6aff489436b59b49c0deaf8bfdd478e5c28b9141fb580bad254753968c10222dd9c17d2f6e48045d0fda688e46cee5483e25d382cd89e0e869f0b3d3ec34e79895f8addc668f57b85300a6c0cfd9c854a6d29845e52e28e5f318db3409127ff5dec1f2ceb8b8c49b14a6594ea3a2603a10d62282e950e0ae8c9190cc22496b543cee97cbbe833d57ff2c6b1ec17732fe02aff7a7a2c57deef215ebd41d44f6846430bccee0e65a883898a631b8f1468f469506c07924fe39b24b778b86b7aa1b0e1d742d631353343d981c4aa5d304ba5dfa53be50ff4462c28a7405c96d709688de47eec7966923effda4cd71c6e66b4ce4ca84eb0ca3e75ab3d3b20baaadeee8d6d8ebd45b5d334f80726ee6d23124175eae3b97eb23a3aee3279f9f197ca301ae550dc0da9036a1e5a77716f8f59533ed9569acb97a5dae6baa29456d4cfe98f2f63b0d0e5a4abf8945a6e14dda01efef50b951908b2c01069783bd158874152ca4d7ea41c71fa89a94c9037803028785d5b71c902e98d1d37187328b775f1df3cbb702565c5c5c64d4fea7f9ff7bd9eb4dedb29405df6be87625c867634b8c28e341b89c6fab31f2d78dd62fde299e06c5a8e68bca77b7739fd4f9e062abdd8919ec1da4f0885e8dc41bf752af782e201f9284aa2bad0c8c0f471205eb18f1cd71567ce0698f76a97b6ebc4c5e2f86be4fa6a32403269574cc8a35a02301636e2708b0f0b22dc1e41edf0425b61e62128b663d21b60821351a8f8a710323ecebc4c167e56ac24ac9cc82faf6260d7e562b51d343ec00a5dce8e8cafa4f096de060e7ab9c9cb6043b79d1d1e40ab8892c66f90532d732feb7008c23924dd41af99b9bff52185d31b5f2b62b364c2b8bc060de0c51b6282a9f2337a6f6b9f53416c75d6440f25be4a1db873342bd13936f5f7c71299c460087022a8d2052a96ee5823b623ac1baede1564b108255c14870a702af3abf47aba45f560a67d53254ba60ad01b23a388e75b32fc1f3e7cb5ea22e34bf6bf348226cf512de53e4b7b45f73b74d73a5fa2b0695ee0e7e3a5378a64ee20c69e4802e54faf417ff39ea060f8d14a1e5d46df250ad41ed20d177d9bed99a299eb9d3fb7510e05552b94dadb7b0486c2a30cebde0d974030969fe5134d1193bdff1e835bb1aae99fb4066863aa2c9542daa25e9cc3d75661b4733cb0b8e89aaf95ad</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">文章已被隐藏，可能为私密内容或还未完成。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">???</summary>
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>创建一个字符设备与地址映射</title>
    <link href="https://blog.godmao.top/posts/26367/"/>
    <id>https://blog.godmao.top/posts/26367/</id>
    <published>2025-11-25T13:31:12.000Z</published>
    <updated>2025-11-28T13:23:07.456Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><blockquote><p>本篇文章主要讲解创建字符驱动设备的一个代码框架，配置一个GPIO的方式依然是最原始的配置寄存器方式（配合讲解地址映射）。</p></blockquote><h2 id="1-地址映射介绍"><a class="markdownIt-Anchor" href="#1-地址映射介绍"></a> 1. 地址映射介绍</h2><h3 id="11-地址映射究竟在干什么"><a class="markdownIt-Anchor" href="#11-地址映射究竟在干什么"></a> 1.1. 地址映射究竟在干什么？</h3><p>Linux 世界里，任何外设的寄存器都不允许你“像裸机一样”随便拿地址就写。物理地址只是硬件的地盘，而用户空间、内核空间都活在自己的“虚拟地址”里。</p><p>虚拟地址这个东西，只是对 CPU 说的一套语言；真实的电路是物理地址。所以得靠 MMU（内存管理单元）做翻译，把虚拟地址 → 物理地址挂上关系。这一步就叫 <strong>地址映射（memory mapping）</strong>。</p><p>简单描述一下：</p><p>虚拟地址（进程眼里看到的） → 通过页表（内核维护的一堆数据结构） → 映射到物理地址（板子上的真实寄存器）</p><p><strong>为什么要这么麻烦？</strong></p><p>因为 Linux 要保证：</p><ol><li>每个进程互不干扰，不会互相写爆对方。</li><li>不让用户程序直接摸外设，保证系统稳定。</li><li>内核可以把物理地址重新分布，不影响程序。</li></ol><h3 id="12-那如何访问外设寄存器"><a class="markdownIt-Anchor" href="#12-那如何访问外设寄存器"></a> 1.2. 那如何访问外设寄存器？</h3><p>访问寄存器通常需要两步：</p><ol><li><strong>获得物理地址</strong>（比如 datasheet 会写某个 GPIO 控制寄存器的地址）</li><li><strong>将物理地址映射成虚拟地址</strong> → 才能读写</li></ol><p>在 Linux 内核中，这个动作由 <code>ioremap()</code> 完成。</p><h3 id="13-常用函数"><a class="markdownIt-Anchor" href="#13-常用函数"></a> 1.3. 常用函数</h3><h4 id="131-ioremap"><a class="markdownIt-Anchor" href="#131-ioremap"></a> 1.3.1. ioremap()</h4><p>把“物理地址段”映射到“内核虚拟地址空间” 你传入基地址和大小，它返回一段能访问的虚拟地址。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __iomem <span class="token operator">*</span>virt <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>phys_addr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="132-iounmap"><a class="markdownIt-Anchor" href="#132-iounmap"></a> 1.3.2. iounmap()</h4><p>释放映射。</p><h4 id="133-readlwritel"><a class="markdownIt-Anchor" href="#133-readlwritel"></a> 1.3.3. readl()/writel()</h4><p>读写 32bit 寄存器的常用函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">value <span class="token operator">=</span> <span class="token function">readl</span><span class="token punctuation">(</span>virt_addr <span class="token operator">+</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">writel</span><span class="token punctuation">(</span><span class="token number">0x1</span><span class="token punctuation">,</span> virt_addr <span class="token operator">+</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>比直接解引用指针更安全。</p><h2 id="2-创建一个字符设备"><a class="markdownIt-Anchor" href="#2-创建一个字符设备"></a> 2. 创建一个字符设备</h2><h3 id="21-step1定义操作集合"><a class="markdownIt-Anchor" href="#21-step1定义操作集合"></a> 2.1. step1.定义操作集合</h3><p>就是大名鼎鼎的 file_operations。让内核知道当用户空间调用open、close等文件操作函数时实际应该怎么操作。</p><p>示例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> led_fops <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>    <span class="token punctuation">.</span>open <span class="token operator">=</span> led_open<span class="token punctuation">,</span>    <span class="token punctuation">.</span>read <span class="token operator">=</span> led_read<span class="token punctuation">,</span><span class="token comment">// 对应用户空间的 open()</span>    <span class="token punctuation">.</span>write <span class="token operator">=</span> led_write<span class="token punctuation">,</span><span class="token comment">// 对应用户空间的 write()</span>    <span class="token punctuation">.</span>release <span class="token operator">=</span> led_release<span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 对应用户空间的 close()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要理清楚这些操作函数与对应用户空间的函数的关系。</p><h3 id="22-step2编写实际操作函数"><a class="markdownIt-Anchor" href="#22-step2编写实际操作函数"></a> 2.2. step2.编写实际操作函数</h3><p>我们确定好要编写哪些操作函数后就可以开始编写了，函数名字要和file_operations里的一样。</p><blockquote><p>我们编写实际操作函数时，要填形参，可以进入到“file_operations”的定义里面看操作函数对应的形参。</p></blockquote><h3 id="23-step3四个关键结构体"><a class="markdownIt-Anchor" href="#23-step3四个关键结构体"></a> 2.3. step3.四个关键结构体</h3><p>我们首先定义四个关键结构体：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">dev_t</span> devno<span class="token punctuation">;</span> <span class="token comment">// 用于存储设备号</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev<span class="token punctuation">;</span> <span class="token comment">//申请一个cdev对象</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 类</span><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device <span class="token comment">//设备节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们将其统一包装在一个结构体，作为该设备的私有数据，例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token punctuation">&#123;</span>    <span class="token class-name">dev_t</span> devno<span class="token punctuation">;</span>      <span class="token comment">// 用于存储设备号</span>    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev<span class="token punctuation">;</span> <span class="token comment">// 申请一个cdev对象</span>    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span> <span class="token comment">// 类</span>    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备节点</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token operator">*</span> led_dev<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="24-step4确定设备号"><a class="markdownIt-Anchor" href="#24-step4确定设备号"></a> 2.4. step4.确定设备号</h3><p>有两种方式：静态和动态。<strong>用到step3的第一个结构体</strong>。</p><p>此步只是 <strong>在内核中预留了数字，没有创建任何对象</strong>；这是字符设备的“身份证号码”。</p><h4 id="241-alloc_chrdev_region"><a class="markdownIt-Anchor" href="#241-alloc_chrdev_region"></a> 2.4.1. alloc_chrdev_region()：</h4><p><strong>动态分配</strong>一个未被占用的主设备号，并注册设备号区域。建议使用此方法，避免与现有设备冲突。</p><p>用法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token class-name">dev_t</span> <span class="token operator">*</span>dev<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> baseminor<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> count<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><em>*dev：用于返回设备号</em></li><li><em>baseminor：指定次设备号起始值</em></li><li><em>count：申请的次设备号个数</em></li><li><em>name: 设备名称</em></li></ul><h4 id="242-register_chrdev_region"><a class="markdownIt-Anchor" href="#242-register_chrdev_region"></a> 2.4.2. register_chrdev_region():</h4><p><strong>静态注册</strong>一个已知的主设备号。如果知道分配给设备的设备号，可以使用此方法.</p><p>用法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">register_chrdev_region</span><span class="token punctuation">(</span><span class="token class-name">dev_t</span> from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> count<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><em>from：设备号，一般在调用之前就得通过一个主设备号和次设备号得到一个设备号</em></li><li><em>count: 次设备个数 以major为主设备号，以0~0+count的次设备号</em></li><li><em>name: 设备名称</em></li></ul><h3 id="25-step5注册字符设备"><a class="markdownIt-Anchor" href="#25-step5注册字符设备"></a> 2.5. step5.注册字符设备</h3><p>此步包含 初始化cdev结构体 和 将设备添加到内核。</p><h4 id="251-cdev_init"><a class="markdownIt-Anchor" href="#251-cdev_init"></a> 2.5.1. cdev_init()</h4><p>用于初始化我们<strong>step3提供的第二个结构体</strong>，将设备与对应的操作集合（step1、2）绑定。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><em>cdev*：字符设备结构体地址</em></li><li><em>struct file_operations* ：操作集合地址</em></li></ul><h4 id="252-cdev_add"><a class="markdownIt-Anchor" href="#252-cdev_add"></a> 2.5.2. cdev_add()</h4><p>此步正式将设备添加到内核。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">dev_t</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><em>cdev*：字符设备结构体地址</em></li><li><em>dev_t：设备号</em></li><li><em>count：注册的次设备数量</em></li></ul><h3 id="26-step5创建设备节点"><a class="markdownIt-Anchor" href="#26-step5创建设备节点"></a> 2.6. step5.创建设备节点</h3><p>向内核添加字符设备后，在用户空间使用仍然不方便，因为它没有暴露接口，也就是<code>/dev/</code>目录下没有它的身影。</p><h4 id="261-class_create"><a class="markdownIt-Anchor" href="#261-class_create"></a> 2.6.1. class_create()</h4><p>创建设备节点前要求必须有对应的类。它会在在 sysfs 中创建一个类目录。class 本质上只是一个目录 + 一些描述信息。此处用到<strong>step3提供的第三个结构体</strong>。</p><p>用法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span><span class="token function">class_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><em>name：类名</em></li><li><em><strong>返回</strong>：类结构体指针</em></li></ul><p><strong>同一类的设备 = 功能相似、统一管理、统一呈现、自动创建节点</strong></p><ul><li>sysfs 中统一目录</li><li>设备节点命名统一</li><li>用户态可自动识别</li><li>驱动文件不同也能加入同一类</li><li>便于 udev/systemd/应用程序管理设备</li></ul><p>tips：</p><p>想要将不同设备添加到同一类，可以在申请类的那个初始化文件里提供一个接口函数然后 <code>extern</code>，例如：</p><p>a.c:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>my_class<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span><span class="token function">get_my_class</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> my_class<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">main_dev_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    my_class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span>THIS_MODULE<span class="token punctuation">,</span> <span class="token string">"myclass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>my_class<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>my_class<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b.c:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span><span class="token function">get_my_class</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">device_create</span><span class="token punctuation">(</span><span class="token function">get_my_class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> devno<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"otherdev"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="262-device_create"><a class="markdownIt-Anchor" href="#262-device_create"></a> 2.6.2. device_create()</h4><p>正式创建设备节点。<strong>用到step3提供的第四个结构体</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span><span class="token function">device_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>cls<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>parent<span class="token punctuation">,</span> <span class="token class-name">dev_t</span> devt<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>drvdata<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>cls: 类结构体指针</em><br /><em>parent：父设备，一般为 NULL</em><br /><em>devt：设备号</em><br /><em>drvdata：驱动私有数据，可为 NULL</em><br /><em>fmt：设备名格式化字符串，即在dev目录下显示的设备名。</em></p><h2 id="3-销毁一个字符设备"><a class="markdownIt-Anchor" href="#3-销毁一个字符设备"></a> 3. 销毁一个字符设备</h2><p>举一反三，不再过多赘述<br />销毁需要按创建时的顺序 反顺序销毁。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//删除设备节点</span><span class="token keyword">void</span> <span class="token function">device_destroy</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>cls<span class="token punctuation">,</span> <span class="token class-name">dev_t</span> devt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除类</span><span class="token keyword">void</span> <span class="token function">class_destroy</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>cls<span class="token punctuation">)</span><span class="token comment">//删除字符设备</span><span class="token keyword">void</span> <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">cdev</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放设备号</span><span class="token keyword">void</span> <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span><span class="token class-name">dev_t</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-完整示例程序包含地址映射"><a class="markdownIt-Anchor" href="#4-完整示例程序包含地址映射"></a> 4. 完整示例程序，包含地址映射</h2><p>注意的细节：goto的错误处理，私有数据。</p><p>说明一下使用私有数据后，怎么在open函数中获取这些私有数据：</p><p><code>container_of</code>关键宏：已知某个结构体成员的指针，反推出整个结构体的指针。它定义在 <code>include/linux/kernel.h</code> 中。</p><p>在led_open()中，我们通过<code>container_of</code> 反推出 装有cdev成员的 struct led_dev 结构体指针（因为这里的cdev正好是struct led_dev的成员，为什么cdev不是其他结构体的成员呢？因为我们在cdev_add中指定的就是struct led_dev中的cdev的地址），也就是我们在step3中定义的结构体。即私有数据，并将这个指针指向fp的privatedata成员变量。这样read、write就可以通过fp-&gt;privatedata访问这些数据。</p><blockquote><p>使用container_of在几个设备共用一个驱动时更具有通用性。</p></blockquote><p>还有这个常用的函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> __user <span class="token operator">*</span>from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><em>to：目标地址（内核空间）</em></li><li><em>from：源地址（用户空间）</em></li><li><em>n：要拷贝的字节数</em></li><li><em>返回值：成功返回0，失败返回未拷贝的字节数</em></li></ul><p>表示从用户空间拷贝到内核空间，防止用户程序直接访问或修改内核数据结构和硬件资源。</p><p>相应的也有</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">copy_to_user</span><span class="token punctuation">(</span><span class="token keyword">void</span> __user <span class="token operator">*</span>to<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示从内核空间复制到用户空间。当目标地址无效时，<code>copy_to_user</code>会将目标内核缓冲区清零，防止信息泄漏。</p><p>除了上述两个主要函数外，Linux还提供了一系列简化函数：</p><p><code>get_user</code>：获取简单变量（char/int/long等）<br /><code>put_user</code>：写入简单变量<br /><code>get_user/put_user</code>：不进行地址检查的版本<br />这些函数适用于简单数据类型的传输，效率更高。</p><p><s>—终于他妈写完了，草— 写得真是依托。。。。。不管了</s></p><p>led.c</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/cdev.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/io.h></span> <span class="token comment">//io映射相关</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/uaccess.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm-generic/int-ll64.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEV_NAME</span> <span class="token string">"led"</span></span><span class="token comment">// 定义开关状态</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_OFF</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LED_ON</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token comment">// 定义寄存器物理地址</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CCM_CCGR1_BASE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">0X020C406C</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SW_MUX_GPIO1_IO03_BASE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">0X020E006C</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SW_PAD_GPIO1_IO03_BASE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">0X020E02F8</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GPIO1_DR_BASE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">0X0209C000</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GPIO1_GDIR_BASE</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">0X0209C004</span><span class="token punctuation">)</span></span></span><span class="token comment">// 定义映射后的虚拟地址</span><span class="token keyword">static</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>IMX6U_CCM_CCGR1<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>SW_MUX_GPIO1_IO03<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>SW_PAD_GPIO1_IO03<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>GPIO1_DR<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> __iomem <span class="token operator">*</span>GPIO1_GDIR<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token punctuation">&#123;</span>    <span class="token class-name">dev_t</span> devno<span class="token punctuation">;</span>      <span class="token comment">// 用于存储设备号</span>    <span class="token keyword">struct</span> <span class="token class-name">cdev</span> cdev<span class="token punctuation">;</span> <span class="token comment">// 申请一个cdev对象</span>    <span class="token keyword">struct</span> <span class="token class-name">class</span> <span class="token operator">*</span>class<span class="token punctuation">;</span> <span class="token comment">// 类</span>    <span class="token keyword">struct</span> <span class="token class-name">device</span> <span class="token operator">*</span>device<span class="token punctuation">;</span> <span class="token comment">//设备节点</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token operator">*</span> led_dev<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">led_switch</span><span class="token punctuation">(</span>u8 sta<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    u32 temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sta <span class="token operator">==</span> LED_ON<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        temp <span class="token operator">=</span> <span class="token function">readl</span><span class="token punctuation">(</span>GPIO1_DR<span class="token punctuation">)</span><span class="token punctuation">;</span>        temp <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">writel</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> GPIO1_DR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sta <span class="token operator">==</span> LED_OFF<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        temp <span class="token operator">=</span> <span class="token function">readl</span><span class="token punctuation">(</span>GPIO1_DR<span class="token punctuation">)</span><span class="token punctuation">;</span>        temp <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">writel</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> GPIO1_DR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">led_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token operator">*</span> this_devp<span class="token punctuation">;</span>    <span class="token comment">// container_of:已知某个结构体成员的指针，反推出整个结构体的指针。</span>    this_devp <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>inode<span class="token operator">-></span>i_cdev<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">led_dev</span><span class="token punctuation">,</span> cdev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 指定私有数据，后续read/write函数均可以直接读取</span>    fp<span class="token operator">-></span>private_data <span class="token operator">=</span> this_devp<span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"led dev open!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">led_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>fp<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> cnt<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>offt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token keyword">char</span> databuf<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token operator">*</span> ledstat<span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">copy_from_user</span><span class="token punctuation">(</span>databuf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"kernel write failed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span>EFAULT<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ledstat <span class="token operator">=</span> databuf<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>ledstat<span class="token punctuation">,</span> <span class="token string">"on"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">led_switch</span><span class="token punctuation">(</span>LED_ON<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>ledstat<span class="token punctuation">,</span> <span class="token string">"off"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">led_switch</span><span class="token punctuation">(</span>LED_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"E: only can write \"off\" or \"on\"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token class-name">ssize_t</span> <span class="token function">led_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>fp<span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nt<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>offt<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"it's unnecessary to read led!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">led_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"led dev release!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> led_fops <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>    <span class="token punctuation">.</span>open <span class="token operator">=</span> led_open<span class="token punctuation">,</span>    <span class="token punctuation">.</span>read <span class="token operator">=</span> led_read<span class="token punctuation">,</span>    <span class="token punctuation">.</span>write <span class="token operator">=</span> led_write<span class="token punctuation">,</span>    <span class="token punctuation">.</span>release <span class="token operator">=</span> led_release<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">led_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    u32 temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 映射 */</span>    IMX6U_CCM_CCGR1 <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>CCM_CCGR1_BASE<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SW_MUX_GPIO1_IO03 <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>SW_MUX_GPIO1_IO03_BASE<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SW_PAD_GPIO1_IO03 <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>SW_PAD_GPIO1_IO03_BASE<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO1_DR <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>GPIO1_DR_BASE<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    GPIO1_GDIR <span class="token operator">=</span> <span class="token function">ioremap</span><span class="token punctuation">(</span>GPIO1_GDIR_BASE<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 设置寄存器值 */</span>    <span class="token comment">/* 1. 使能时钟 */</span>    <span class="token comment">// 这是通用寄存器，最好不要直接写入，要保证其他值不变，否则可能会影响其他外设,以下同理</span>    temp <span class="token operator">=</span> <span class="token function">readl</span><span class="token punctuation">(</span>IMX6U_CCM_CCGR1<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清除设置</span>    temp <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设定26-27为1，使能时钟</span>    <span class="token function">writel</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> IMX6U_CCM_CCGR1<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 2. 引脚复用为GPIO */</span>    <span class="token function">writel</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> SW_MUX_GPIO1_IO03<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 3. 设置电气属性 */</span>    <span class="token function">writel</span><span class="token punctuation">(</span><span class="token number">0x10b0</span><span class="token punctuation">,</span> SW_PAD_GPIO1_IO03<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 4. 设置为输出 */</span>    temp <span class="token operator">=</span> <span class="token function">readl</span><span class="token punctuation">(</span>GPIO1_GDIR<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清除设定</span>    temp <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writel</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> GPIO1_GDIR<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 5. 设置为输出低电平（开启LED） */</span>    temp <span class="token operator">=</span> <span class="token function">readl</span><span class="token punctuation">(</span>GPIO1_DR<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">writel</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> GPIO1_DR<span class="token punctuation">)</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 向系统添加字符设备 */</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"led load!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 获取设备号 */</span>    ret <span class="token operator">=</span> <span class="token function">alloc_chrdev_region</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>led_dev<span class="token operator">-></span>devno<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> DEV_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 成功后，主设备号存储在MAJOR(devno)，次设备号为1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"Failed to alloc dev number!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> err_alloc<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 注册字符设备 */</span>    <span class="token function">cdev_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>led_dev<span class="token operator">-></span>cdev<span class="token punctuation">,</span> <span class="token operator">&amp;</span>led_fops<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化cdev结构体</span>    led_dev<span class="token operator">-></span>cdev<span class="token punctuation">.</span>owner <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">cdev_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>led_dev<span class="token operator">-></span>cdev<span class="token punctuation">,</span> led_dev<span class="token operator">-></span>devno<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此步正式将设备添加到内核</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"Failed to add cdev!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> err_cdev<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 创建设备节点 */</span>    led_dev<span class="token operator">-></span>class <span class="token operator">=</span> <span class="token function">class_create</span><span class="token punctuation">(</span><span class="token string">"led"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建设备节点前要求必须有对应的类</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>led_dev<span class="token operator">-></span>class<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"Failed to create class \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>led_dev<span class="token operator">-></span>class<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置返回值，否则返回0</span>        <span class="token keyword">goto</span> err_class<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    led_dev<span class="token operator">-></span>device <span class="token operator">=</span> <span class="token function">device_create</span><span class="token punctuation">(</span>led_dev<span class="token operator">-></span>class<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> led_dev<span class="token operator">-></span>devno<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> DEV_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>led_dev<span class="token operator">-></span>device<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ERR <span class="token string">"Failed to create device\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>led_dev<span class="token operator">-></span>device<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> err_device<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>err_device<span class="token operator">:</span>    <span class="token function">class_destroy</span><span class="token punctuation">(</span>led_dev<span class="token operator">-></span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>err_class<span class="token operator">:</span>    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>led_dev<span class="token operator">-></span>cdev<span class="token punctuation">)</span><span class="token punctuation">;</span>err_cdev<span class="token operator">:</span>    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>led_dev<span class="token operator">-></span>devno<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放设备号</span>err_alloc<span class="token operator">:</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">led_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">/* 关灯 */</span>    <span class="token function">led_switch</span><span class="token punctuation">(</span>LED_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 取消映射 */</span>    <span class="token function">iounmap</span><span class="token punctuation">(</span>IMX6U_CCM_CCGR1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">iounmap</span><span class="token punctuation">(</span>SW_MUX_GPIO1_IO03<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">iounmap</span><span class="token punctuation">(</span>SW_PAD_GPIO1_IO03<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">iounmap</span><span class="token punctuation">(</span>GPIO1_DR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">iounmap</span><span class="token punctuation">(</span>GPIO1_GDIR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 释放资源 */</span>    <span class="token function">device_destroy</span><span class="token punctuation">(</span>led_dev<span class="token operator">-></span>class<span class="token punctuation">,</span> led_dev<span class="token operator">-></span>devno<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">class_destroy</span><span class="token punctuation">(</span>led_dev<span class="token operator">-></span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cdev_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>led_dev<span class="token operator">-></span>cdev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">unregister_chrdev_region</span><span class="token punctuation">(</span>led_dev<span class="token operator">-></span>devno<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放设备号</span>    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"led dev closed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">module_init</span><span class="token punctuation">(</span>led_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">module_exit</span><span class="token punctuation">(</span>led_exit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"gdm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试程序chrdevbaseAPP，用于写入字符串</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> ret<span class="token punctuation">;</span>    <span class="token keyword">char</span> readbuf<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">,</span> writebuf<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* 打开 */</span>    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可读可写打开</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"E: Can not open %s\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 读取选项 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>readbuf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>readbuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> readbuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>writebuf<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"E: read %s filed!\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"read data with %d byte: %s \n"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>readbuf<span class="token punctuation">)</span><span class="token punctuation">,</span> readbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 写入选项 */</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>writebuf<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> writebuf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>writebuf<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"E: write %s filed!\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"write data with %d byte: %s \n"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>writebuf<span class="token punctuation">)</span><span class="token punctuation">,</span> writebuf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 关闭 */</span>    ret <span class="token operator">=</span> <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"E: Can't close file %s\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"===%s:now running test APP for chrdevbase===\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 参数判断 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"E: wrong usage! now argc = %d! argv[2] = %s\n usage:\n\t read:%s %s r \n\t write:%s %s w [str_data]\n"</span><span class="token punctuation">,</span>            argc<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">test</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Makefile</p><pre class="line-numbers language-make" data-language="make"><code class="language-make"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# Makefile for building a Linux Kernel Module# Module Name: led# &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;# KERNEL_SOURCE 指向你的内核源码或头文件路径# 如果你使用系统默认内核头，直接用 &#x2F;lib&#x2F;modules&#x2F;$(shell uname -r)&#x2F;buildKERNEL_SOURCE :&#x3D; &#x2F;home&#x2F;gdm&#x2F;prjts&#x2F;linux&#x2F;driver_learning&#x2F;kernel&#x2F;linux-imx-lf-6.6.52-2.2.1OUTPUT_DIR :&#x3D; $(PWD)&#x2F;..&#x2F;output# 模块源文件obj-m :&#x3D; led.o  # obj-m 用于告诉内核模块系统需要编译 chrdevbase.c 成为模块# 默认目标# 使用内核的 Makefile 来构建模块# -C 指定内核源码路径# M&#x3D;$(PWD) 告诉内核在当前目录下查找源文件all:    arm-none-linux-gnueabihf-gcc -static chrdevbaseAPP.c -o chrdevbaseAPP    $(MAKE) -C $(KERNEL_SOURCE) M&#x3D;$(PWD) modules    mv .*.cmd *.mod *mod.c *.o *.symvers *.order $(OUTPUT_DIR)# 清理生成文件clean:# 使用内核 Makefile 清理模块相关文件    $(MAKE) -C $(KERNEL_SOURCE) M&#x3D;$(PWD) clean    rm chrdevbaseAPP    rm $(OUTPUT_DIR)&#x2F;* $(OUTPUT_DIR)&#x2F;.*.cmdapp:    arm-none-linux-gnueabihf-gcc -static chrdevbaseAPP.c -o chrdevbaseAPPcleanapp:    rm chrdevbaseAPP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="设备驱动程序" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>gpio子系统</title>
    <link href="https://blog.godmao.top/posts/45361/"/>
    <id>https://blog.godmao.top/posts/45361/</id>
    <published>2025-11-25T12:19:34.000Z</published>
    <updated>2025-11-25T14:24:02.427Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><blockquote><p>衔接上一篇介绍 Pinctrl 子系统的文章。</p></blockquote><h2 id="1-gpio-子系统简介"><a class="markdownIt-Anchor" href="#1-gpio-子系统简介"></a> 1. GPIO 子系统简介</h2><p>如果说 Pinctrl 子系统是负责把“路”铺好（配置引脚模式、电气属性），那么 GPIO 子系统就是负责在路上“跑车”（控制高低电平、读取输入状态）。</p><p>对于嵌入式工程师来说，GPIO（通用输入输出）是最简单、最基础，但也是使用频率最高的子系统。</p><h2 id="2-gpio-子系统的使用"><a class="markdownIt-Anchor" href="#2-gpio-子系统的使用"></a> 2. GPIO 子系统的使用</h2><h3 id="21-step0查阅规范"><a class="markdownIt-Anchor" href="#21-step0查阅规范"></a> 2.1. step0.查阅规范</h3><p>不多说。上篇文章已经提到过。</p><h3 id="22-step1在设备树-dts-中描述"><a class="markdownIt-Anchor" href="#22-step1在设备树-dts-中描述"></a> 2.2. step1.在设备树 (DTS) 中描述</h3><blockquote><p>我们默认已经配置好了GPIO控制器节点。一般来说也不需要配置，官方已配置好。如果想要配置GPIO控制器节点，请查阅编写规范文档，官方已给出例子和要求。控制器基地址查阅参考手册。</p></blockquote><p>我们需要告诉内核：这个设备用到了哪个 GPIO，以及它是高电平有效还是低电平有效。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* 例子：一个由 GPIO 控制的蜂鸣器节点 *&#x2F;beep_device &#123;    compatible &#x3D; &quot;my-beep-driver&quot;;    &#x2F;* 1. 引用 Pinctrl (先铺路) *&#x2F;    pinctrl-names &#x3D; &quot;default&quot;;    pinctrl-0 &#x3D; &lt;&amp;beep_gpio_pin&gt;;    &#x2F;* 2. 定义 GPIO (后跑车) *&#x2F;    &#x2F;* 格式：&lt;&amp;gpio控制器 引脚索引 标志位&gt; *&#x2F;    enable-gpios &#x3D; &lt;&amp;gpio1 0 GPIO_ACTIVE_HIGH&gt;;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>不同厂商写法不同，请对应的参见规范文档。</p></blockquote><p>关于 <code>enable-gpios</code> 这个名字：</p><ul><li>前缀 “enable” 可以自定义，这是我们后续使用API函数查找这个GPIO的索引关键字。</li><li>后缀“-gpios” 是规范的，固定的。</li></ul><h3 id="23-step2在驱动中调用api函数"><a class="markdownIt-Anchor" href="#23-step2在驱动中调用api函数"></a> 2.3. step2.在驱动中调用API函数</h3><p>请转到第4小节。</p><h2 id="3-gpio子系统的工作原理浅析"><a class="markdownIt-Anchor" href="#3-gpio子系统的工作原理浅析"></a> 3. GPIO子系统的工作原理浅析</h2><h3 id="31-系统结构"><a class="markdownIt-Anchor" href="#31-系统结构"></a> 3.1. 系统结构</h3><p>Linux 内核通过 <strong>gpiolib</strong> 框架统一管理 GPIO。该框架包括三部分：</p><ul><li><p><strong>GPIO 控制器驱动</strong>：芯片厂商提供底层的 GPIO 控制器驱动。硬件相关的代码（位于 <code>drivers/gpio/</code> 目录），负责初始化和操作具体的 GPIO 控制器，实现了“读寄存器、写寄存器”的具体函数。</p></li><li><p><strong>GPIO 核心库（gpiolib）</strong>：处于中间的连接层。gpiolib 是 Linux GPIO 子系统的核心，它管理着一张大表，维护所有 GPIO 控制器（gpio_chip）、所有 GPIO 描述符（gpio_desc）、控制器之间的映射关系。提供API函数并转换为底层驱动的调用。</p></li><li><p><strong>GPIO 字符设备接口驱动</strong>：也就是我们写的设备驱动。</p></li></ul><blockquote><p>Pinctrl 和 GPIO 的底层交互:在某些 SoC 架构中，当你调用<code>gpiod_direction_output()</code> 时，GPIO 子系统会在后台自动调用 Pinctrl 子系统的接口，确保引脚复用被强制切回 GPIO 模式。这是一种保险机制，但我们在写 DTS 时，最好还是显式地写清楚 Pinctrl 配置。</p></blockquote><h3 id="32-工作流程"><a class="markdownIt-Anchor" href="#32-工作流程"></a> 3.2. 工作流程</h3><p>一般来说，gpio控制器节点都会有以下两个属性：</p><ul><li><code>gpio-controller</code>：告诉内核这是一个 GPIO 控制器。</li><li><code>#gpio-cells</code>：告诉内核控制器使用几个参数描述 GPIO（如编号和 flags），用于解析。</li></ul><p>从代码层面看，GPIO 子系统的工作流程其实就是<strong>三个核心结构体</strong>之间的交互：</p><ol><li><strong>struct gpio_chip</strong>：代表<strong>硬件控制器</strong>（Provider，厂商写的）。</li><li><strong>struct gpio_desc</strong>：代表<strong>每一个具体的引脚</strong>（Core，内核维护的）。</li><li><strong>struct gpio_ops</strong>：代表<strong>底层操作方法</strong>（读/写寄存器的函数指针）。</li></ol><h4 id="321-注册阶段硬件上线-provider"><a class="markdownIt-Anchor" href="#321-注册阶段硬件上线-provider"></a> 3.2.1. 注册阶段：硬件上线 (Provider)</h4><p>在系统启动时，芯片厂商的驱动加载。它初始化了一个核心结构体 <code>struct gpio_chip</code> 并注册给内核。</p><p><strong>核心结构体：struct gpio_chip</strong><br />这是底层驱动与 GPIO 子系统的接口。它包含了“怎么操作硬件”的所有函数指针。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct gpio_chip &#123;    const char *label;     &#x2F;&#x2F; 芯片名字，如 &quot;gpio-rockchip&quot;    struct module *owner;    &#x2F;&#x2F; 核心操作函数指针（这是它的灵魂）    int (*get)(struct gpio_chip *gc, unsigned int offset); &#x2F;&#x2F; 读引脚    void (*set)(struct gpio_chip *gc, unsigned int offset, int value); &#x2F;&#x2F; 写引脚    int (*direction_output)(struct gpio_chip *gc, unsigned int offset, int value);    int base;              &#x2F;&#x2F; 全局 GPIO 编号基址（现代内核多用 -1 动态分配）    u16 ngpio;             &#x2F;&#x2F; 这个控制器有多少个引脚（比如 32 个）    &#x2F;&#x2F; ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>动作</strong>：调用 <code>gpiochip_add_data(chip)</code>。</li><li><strong>结果</strong>：内核收到这个 <code>chip</code>，知道有 32 个引脚可用，并为每一个引脚创建了下一步的 <code>struct gpio_desc</code>。</li></ul><h4 id="322-初始化阶段生成描述符-core"><a class="markdownIt-Anchor" href="#322-初始化阶段生成描述符-core"></a> 3.2.2. 初始化阶段：生成描述符 (Core)</h4><p>内核为了管理这 32 个引脚，会分配一个数组，数组里存的就是 <code>struct gpio_desc</code>。</p><p><strong>核心结构体：struct gpio_desc</strong><br />这是 GPIO 子系统中<strong>最重要</strong>的对象。每一个物理引脚对应一个 <code>gpio_desc</code>。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct gpio_desc &#123;    struct gpio_device *gdev;  &#x2F;&#x2F; 指回所属的 gpio_chip&#x2F;device    unsigned long flags;       &#x2F;&#x2F; 记录状态：是输入还是输出？是 Active Low 吗？有没有被占用？    const char *label;         &#x2F;&#x2F; 谁在使用它？(用于 debug 显示)    const char *name;          &#x2F;&#x2F; 引脚名字    &#x2F;&#x2F; ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>状态</strong>：此时这些 <code>desc</code> 都在内存里躺着，<code>flags</code> 是空的，等待被申请。</li></ul><h4 id="323-获取阶段驱动申请-consumer"><a class="markdownIt-Anchor" href="#323-获取阶段驱动申请-consumer"></a> 3.2.3. 获取阶段：驱动申请 (Consumer)</h4><p>现在轮到你的驱动代码运行了。</p><ul><li><strong>你的代码</strong>：<code>desc = devm_gpiod_get(dev, &quot;reset&quot;, GPIOD_OUT_LOW);</code></li><li><strong>内核流程</strong>：<ul><li><strong>解析 DTS</strong>：内核依据 <code>#gpio-cells</code> 解析设备树，找到 <code>reset-gpios = &lt;gpio1 5 ...&gt;</code></li><li><strong>定位</strong>：根据 handle 找到对应的 <code>gpio_chip</code>（控制器 1），再根据偏移量（5）在数组中找到第 5 个 <strong>struct gpio_desc</strong>。</li><li><strong>配置 Flags</strong>：读取 DTS 里的 <code>GPIO_ACTIVE_LOW</code>，把这个信息记录在 <code>desc-&gt;flags</code> 里的 <code>FLAG_ACTIVE_LOW</code> 位。</li><li><strong>绑定</strong>：把你的驱动名字填入 <code>desc-&gt;label</code>（标记占用）。</li><li><strong>结果</strong>：你拿到了指向这个 <strong>struct gpio_desc</strong> 的指针。</li></ul></li></ul><h4 id="324-控制阶段函数调用链-runtime"><a class="markdownIt-Anchor" href="#324-控制阶段函数调用链-runtime"></a> 3.2.4. 控制阶段：函数调用链 (Runtime)</h4><p>当你调用 <code>gpiod_set_value(desc, 1)</code> 时，内核发生了一次完整的“结构体跳跃”：</p><ol><li><strong>逻辑判断 (GPIOLIB 层)</strong>：函数 <code>gpiod_set_value</code> 接收到你的 <code>desc</code> 和 <code>1</code>。<br />它检查 <code>desc-&gt;flags</code>：</li></ol><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 伪代码逻辑if (test_bit(FLAG_ACTIVE_LOW, &amp;desc-&gt;flags))    value &#x3D; !value; &#x2F;&#x2F; 如果是低有效，把逻辑 1 翻转为物理 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>硬件操作 (Driver 层)</strong>：它通过 <code>desc</code> 找到所属的 <code>chip</code>，然后调用 <code>chip</code> 里注册的函数指针：</li></ol><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 伪代码逻辑chip-&gt;set(chip, gpio_index, value);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li><strong>寄存器写入</strong>：最终执行到了厂商驱动里具体的代码（例如 <code>rockchip_gpio_set</code>），向物理地址写入电平。</li></ol><h4 id="325-总结"><a class="markdownIt-Anchor" href="#325-总结"></a> 3.2.5. 总结</h4><p>对于工程师来说，只要记住这个链条：</p><ol><li><strong>Provider</strong> 提供 <strong>struct gpio_chip</strong>（含操作函数 <code>set/get</code>）。</li><li><strong>Core</strong> 维护 <strong>struct gpio_desc</strong>（含状态标志 <code>flags</code>，如 Active Low）。</li><li><strong>Consumer</strong> 持有 **struct gpio_desc ***（句柄）。</li><li><strong>调用链</strong>：</li></ol><pre class="line-numbers language-none"><code class="language-none">gpiod_set_value()⬇️检查 desc-&gt;flags (处理极性)⬇️调用 desc-&gt;gdev-&gt;chip-&gt;set() (硬件回调)⬇️writel(REG) (物理生效)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-相关api函数"><a class="markdownIt-Anchor" href="#4-相关api函数"></a> 4. 相关API函数</h2><p>这些 API 定义在头文件 <code>#include &lt;linux/gpio/consumer.h&gt;</code> 中。相比老的 <code>gpio_</code> 接口（基于整数索引），<code>gpiod_</code> 接口（基于描述符）是目前内核推荐的标准用法。</p><h3 id="41-核心头文件"><a class="markdownIt-Anchor" href="#41-核心头文件"></a> 4.1. 核心头文件</h3><p>在驱动代码中，必须包含：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;linux&#x2F;gpio&#x2F;consumer.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="42-获取与释放-acquire-release"><a class="markdownIt-Anchor" href="#42-获取与释放-acquire-release"></a> 4.2. 获取与释放 (Acquire &amp; Release)</h3><p>在驱动的 <code>probe</code> 函数中，我们需要获取 GPIO 的句柄（Descriptor）。</p><h4 id="421-a-资源托管方式-推荐"><a class="markdownIt-Anchor" href="#421-a-资源托管方式-推荐"></a> 4.2.1. A. 资源托管方式 (推荐)</h4><p>使用 <code>devm_</code> 前缀的函数，驱动卸载时内核会自动释放 GPIO，无需手动调用 <code>put</code>，防止内存泄漏。</p><ul><li><strong>devm_gpiod_get</strong>:</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct gpio_desc *devm_gpiod_get(struct device *dev, const char *con_id, enum gpiod_flags flags);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：获取一个 GPIO 描述符。<br /><strong>参数</strong>：<br />- <strong>dev</strong>: 设备指针 (通常是 &amp;pdev-&gt;dev)。<br />- <strong>con_id</strong>: 字符串 ID。对应 DTS 中的 xxx-gpios 中的 xxx。如果传 NULL，则匹配 gpios 属性。<br />- <strong>flags</strong>: 初始化标志（见下文）。<br /><strong>返回值</strong>：成功返回描述符指针；失败返回 ERR_PTR。</p><ul><li><strong>devm_gpiod_get_optional</strong>:</li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">struct gpio_desc *devm_gpiod_get_optional(struct device *dev, const char *con_id, enum gpiod_flags flags);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：同上，但如果 DTS 里没有定义这个 GPIO，它<strong>不会报错</strong>，而是返回 <code>NULL</code>。<br /><strong>场景</strong>：用于某些非必须的功能（例如：有的板子有 LED，有的没有，驱动想兼容两者）。</p><h4 id="422-b-初始化标志-flags"><a class="markdownIt-Anchor" href="#422-b-初始化标志-flags"></a> 4.2.2. B. 初始化标志 (Flags)</h4><p>在获取 GPIO 时，可以直接指定初始状态：</p><ul><li><code>GPIOD_ASIS</code>: 不改变当前状态（保持原样）。</li><li><code>GPIOD_IN</code>: 配置为输入。</li><li><code>GPIOD_OUT_LOW</code>: 配置为输出，且初始值为<strong>逻辑低</strong>（关闭）。</li><li><code>GPIOD_OUT_HIGH</code>: 配置为输出，且初始值为<strong>逻辑高</strong>（开启）。</li></ul><h3 id="43-读写控制-read-write"><a class="markdownIt-Anchor" href="#43-读写控制-read-write"></a> 4.3. 读写控制 (Read &amp; Write)</h3><p>拿到 <code>struct gpio_desc *</code> 指针后，就可以操作它了。</p><h4 id="431-a-设置输出值"><a class="markdownIt-Anchor" href="#431-a-设置输出值"></a> 4.3.1. A. 设置输出值</h4><ul><li><strong>gpiod_set_value</strong></li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">void gpiod_set_value(struct gpio_desc *desc, int value);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：设置 GPIO 输出电平。<br /><strong>参数 value</strong>：<br />- 1: 设置为 <strong>逻辑有效 (Active)</strong>。<br />- 0: 设置为 <strong>逻辑无效 (Inactive)</strong>。<br /><strong>注意</strong>：内核会自动处理“高电平有效”还是“低电平有效”。如果 DTS 定义了 <code>GPIO_ACTIVE_LOW</code>，你写 <code>1</code>，实际物理引脚会输出低电平。</p><h4 id="432-b-读取输入值"><a class="markdownIt-Anchor" href="#432-b-读取输入值"></a> 4.3.2. B. 读取输入值</h4><ul><li><strong>gpiod_get_value</strong></li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">int gpiod_get_value(const struct gpio_desc *desc);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：读取 GPIO 当前电平。<br /><strong>返回值</strong>：<code>1</code> 表示逻辑有效，<code>0</code> 表示逻辑无效。</p><h4 id="433-c-修改方向"><a class="markdownIt-Anchor" href="#433-c-修改方向"></a> 4.3.3. C. 修改方向</h4><ul><li><code>int gpiod_direction_input(struct gpio_desc *desc)</code></li><li><code>int gpiod_direction_output(struct gpio_desc *desc, int value)</code></li></ul><h3 id="44-睡眠与原子操作-sleeping-vs-atomic"><a class="markdownIt-Anchor" href="#44-睡眠与原子操作-sleeping-vs-atomic"></a> 4.4. 睡眠与原子操作 (Sleeping vs Atomic)</h3><p>这是一个容易踩坑的地方。</p><ul><li><strong>SoC 内部 GPIO</strong>：读写速度极快，可以在中断上下文（Atomic Context）中调用。</li><li><strong>扩展芯片 GPIO (如 I2C/SPI 扩展器)</strong>：读写需要通过 I2C/SPI 总线，耗时较长，<strong>会引起睡眠</strong>，不能在中断或自旋锁中调用。</li></ul><p>为了代码的健壮性，如果你不确定 GPIO 是 SoC 内部的还是外部扩展的，或者你在非原子上下文（如线程化的中断、工作队列、普通进程），<strong>建议使用 cansleep 后缀的函数</strong>：</p><ul><li><p><code>gpiod_set_value_cansleep(desc, value)</code></p></li><li><p><code>gpiod_get_value_cansleep(desc)</code></p></li></ul><blockquote><p>如果你的 GPIO 确实连在 I2C 扩展器上，而你用了普通的 gpiod_set_value，内核会打印警告栈回溯 (WARN_ON)。</p></blockquote><h3 id="45-中断相关-interrupts"><a class="markdownIt-Anchor" href="#45-中断相关-interrupts"></a> 4.5. 中断相关 (Interrupts)</h3><p>如果要把 GPIO 当作中断源（比如按键）：</p><ul><li><strong>gpiod_to_irq</strong></li></ul><pre class="line-numbers language-C" data-language="C"><code class="language-C">int gpiod_to_irq(const struct gpio_desc *desc);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>功能</strong>：将 GPIO 描述符转换为 Linux 中断号 (IRQ Number)。<br /><strong>用法</strong>：拿到返回值 <code>irq</code> 后，传给 <code>request_irq()</code> 或 <code>devm_request_threaded_irq()</code> 来注册中断服务函数。</p><h3 id="46-常用api函数总结"><a class="markdownIt-Anchor" href="#46-常用api函数总结"></a> 4.6. 常用API函数总结</h3><table><thead><tr><th><strong>功能</strong></th><th><strong>普通 API (原子上下文)</strong></th><th><strong>允许睡眠 API (进程上下文)</strong></th></tr></thead><tbody><tr><td><strong>设置值</strong></td><td><code>gpiod_set_value</code></td><td><code>gpiod_set_value_cansleep</code></td></tr><tr><td><strong>读取值</strong></td><td><code>gpiod_get_value</code></td><td><code>gpiod_get_value_cansleep</code></td></tr><tr><td><strong>设置方向</strong></td><td><code>gpiod_direction_output</code></td><td>N/A (通常初始化时设定)</td></tr><tr><td><strong>转中断号</strong></td><td><code>gpiod_to_irq</code></td><td>N/A</td></tr><tr><td><strong>获取句柄</strong></td><td><code>devm_gpiod_get</code></td><td>N/A</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="设备驱动程序" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>pinctrl子系统</title>
    <link href="https://blog.godmao.top/posts/30124/"/>
    <id>https://blog.godmao.top/posts/30124/</id>
    <published>2025-11-24T05:59:51.000Z</published>
    <updated>2025-11-28T09:39:40.945Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="1-linux-内核-pinctrl-子系统简介"><a class="markdownIt-Anchor" href="#1-linux-内核-pinctrl-子系统简介"></a> 1. Linux 内核 Pinctrl 子系统简介</h2><p>现代 SoC 中的 GPIO 引脚通常具有多功能（多路复用）属性，例如一个引脚既可以用作通用 GPIO，也可以用作某个外设（如 UART、I2C、SPI 等）的信号线。传统做法需要驱动直接访问寄存器完成引脚功能和属性配置，但这种方式繁琐且易错。为此，Linux 内核引入了 pinctrl（pin control）子系统，负责解析设备树中的引脚配置，并在系统启动时自动完成引脚的复用和电气属性设置。换言之，开发者只需在设备树中描述引脚功能和特性，pinctrl 子系统就会在后台枚举所有可控引脚、设置对应的复用模式和上下拉、驱动强度等电气特性，从而简化驱动开发过程。</p><p>综上，我们现在总结出 <strong>Pinctrl 的两大核心任务</strong>：</p><ol><li><strong>引脚复用 (Pin Muxing)：</strong> 决定某个物理引脚当前是作为普通 GPIO，还是作为 UART 的 TX 线，或者是 I2C 的 SCL 线。</li><li><strong>引脚配置 (Pin Configuration)：</strong> 设置引脚的电气特性，例如：上拉/下拉电阻、驱动能力（电流大小）、防抖动等。</li></ol><h2 id="2-理解-pinctrl"><a class="markdownIt-Anchor" href="#2-理解-pinctrl"></a> 2. 理解 Pinctrl</h2><p>理解 Pinctrl，需要掌握以下几个关键概念。我们尽量避开复杂的 C 语言结构体，从逻辑层面来理解：</p><h3 id="21-关键术语"><a class="markdownIt-Anchor" href="#21-关键术语"></a> 2.1. 关键术语</h3><ul><li><strong>Pin（引脚）：</strong> 芯片上最小的物理单元。</li><li><strong>Group（引脚组）：</strong> 有些功能需要多个引脚配合（例如 I2C 需要 SCL 和 SDA 两根线）。我们将这两根线打包，称为一个 Group。</li><li><strong>Function（功能）：</strong> 这一组引脚要干什么？是做 <code>i2c0</code>，还是做 <code>uart1</code>？这就是 Function。</li><li><strong>State（状态）：</strong> 这是应用层最常接触的概念。一个设备可能有多种状态，最常见的是：<code>default</code>：设备正常工作时的引脚配置。<code>sleep</code>：设备休眠时，为了省电，将引脚配置为低功耗模式（如断开连接或弱下拉）。</li></ul><h3 id="22-用于pinctrl的设备树节点"><a class="markdownIt-Anchor" href="#22-用于pinctrl的设备树节点"></a> 2.2. 用于Pinctrl的设备树节点</h3><p>一般来说，要使用pinctrl，在设备树里面会有一个节点专门来描述 PIN 的配置信息。</p><p>对于不同厂商，这个节点的命名是不同的，比如有些直接以“pinctrl”命名，而像imx6系列就是以“iomuxc”来命名的。</p><p>我们以 nxp 的 imx6ull 为例，来看看这个节点定义在哪里（本篇均以该SoC为例）。它这个包含关系比较抽象，这个节点的定义在<br /><code>arch/arm/boot/dts/nxp/imx/imx6ul.dtsi</code></p><p>具体包含关系是这样的：imx6ull-14x14-evk-emmc.dts(最终使用的设备树文件) -&gt; imx6ull-14x14-evk.dts -&gt; imx6ull.dtsi -&gt; imx6ul.dtsi</p><p>那么在 imx6ul.dtsi 文件中具体代码是这样写的：</p><pre class="line-numbers language-none"><code class="language-none">soc: soc&#123;...iomuxc: pinctrl@20e0000 &#123;compatible &#x3D; &quot;fsl,imx6ul-iomuxc&quot;;reg &#x3D; &lt;0x020e0000 0x4000&gt;;&#125;;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们向这个节点添加我们想要的配置，pinctrl 系统就能自动配置引脚属性，我们这个SoC就在 <code>arch/arm/boot/dts/nxp/imx/imx6ul-14x14-evk.dtsi</code> 这个文件里面添加了许多引脚配置信息：</p><pre class="line-numbers language-none"><code class="language-none">...&amp;iomuxc &#123;    pinctrl-names &#x3D; &quot;default&quot;;    pinctrl_camera_clock: cameraclockgrp &#123;        fsl,pins &#x3D; &lt;            MX6UL_PAD_CSI_MCLK__CSI_MCLK        0x1b088        &gt;;    &#125;;       pinctrl_csi1: csi1grp &#123;        fsl,pins &#x3D; &lt;            MX6UL_PAD_CSI_PIXCLK__CSI_PIXCLK    0x1b088            MX6UL_PAD_CSI_VSYNC__CSI_VSYNC      0x1b088            MX6UL_PAD_CSI_HSYNC__CSI_HSYNC      0x1b088            MX6UL_PAD_CSI_DATA00__CSI_DATA02    0x1b088            MX6UL_PAD_CSI_DATA01__CSI_DATA03    0x1b088            MX6UL_PAD_CSI_DATA02__CSI_DATA04    0x1b088            MX6UL_PAD_CSI_DATA03__CSI_DATA05    0x1b088            MX6UL_PAD_CSI_DATA04__CSI_DATA06    0x1b088            MX6UL_PAD_CSI_DATA05__CSI_DATA07    0x1b088            MX6UL_PAD_CSI_DATA06__CSI_DATA08    0x1b088            MX6UL_PAD_CSI_DATA07__CSI_DATA09    0x1b088        &gt;;    &#125;;...&#125;;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="23-pinctrl-的实现"><a class="markdownIt-Anchor" href="#23-pinctrl-的实现"></a> 2.3. Pinctrl 的实现</h3><h4 id="231-pinctrl-provider服务端"><a class="markdownIt-Anchor" href="#231-pinctrl-provider服务端"></a> 2.3.1. Pinctrl Provider（服务端）</h4><p>通常由芯片厂商（如瑞芯微、恩智浦、高通）编写的驱动。它知道芯片底层每一个寄存器怎么写，知道“引脚A”怎么切换成“功能B”。<strong>我们通常不需要写这部分代码，只需使用。</strong></p><p>这部分就相当于 pinctrl 的驱动程序，本质就是使用of函数搜索设备节点，找到用于pinctrl的设备节点，并根据该节点里的子节点信息来配置寄存器，具体的实现我们就不去深究了，附一张调用链图，来自正点原子：</p><p><img src="Snipaste_2025-11-24_15-21-27.png" alt="" /></p><h4 id="232-pinctrl-consumer客户端"><a class="markdownIt-Anchor" href="#232-pinctrl-consumer客户端"></a> 2.3.2. Pinctrl Consumer（客户端）</h4><p>这是我们需要关心的部分。具体的设备驱动（如 UART 驱动、LED 驱动）就是客户端。它们向 Pinctrl 子系统发出申请：“我要用这组引脚，帮我切到 UART 模式。”</p><h4 id="233-总结"><a class="markdownIt-Anchor" href="#233-总结"></a> 2.3.3. 总结</h4><p>从原理上看，pinctrl 子系统分为<strong>核心层（core）</strong> 和 <strong>控制器驱动层（provider）</strong> 、<strong>客户端层（consumer）</strong>。</p><p>内核启动时，pinctrl core 会扫描设备树，收集所有 pin 控制器节点和它们定义的引脚组。</p><p>各 SoC 厂商提供的 pinctrl 驱动（位于 <code>drivers/pinctrl/</code> 目录）负责与具体硬件交互。在驱动 probe 阶段，pin 控制器驱动会根据设备树提供的组配置向硬件寄存器写入正确的复用模式和引脚参数。这样，无论是 GPIO、UART、SPI 等功能，只要设备树指定了 pinctrl 组和状态，内核都会在初始化时调用对应驱动完成配置。</p><p>用户态程序或驱动只需通过抽象好的接口申请和切换状态，而不必关心寄存器细节。</p><p>总体上，pinctrl 子系统实现了“设备树描述 → pin 配置 → 驱动使用”这一流程的统一化管理，让引脚配置从驱动代码中解耦，提升了代码可移植性和可维护性。</p><h3 id="24-pinctrl-的工作流程"><a class="markdownIt-Anchor" href="#24-pinctrl-的工作流程"></a> 2.4. Pinctrl 的工作流程</h3><p>Pinctrl 子系统在内核中起到了“中间人”的作用，它屏蔽了底层硬件的复杂性。</p><p><strong>流程如下：</strong></p><ol><li><strong>系统启动</strong>：Linux 内核解析设备树（DTS）。</li><li><strong>设备加载</strong>：当一个设备驱动（比如 I2C 驱动）加载时，内核会检查该设备在设备树中关联的 Pinctrl 信息。</li><li><strong>自动申请</strong>：在驱动的 <code>probe</code> 阶段，驱动核心（Driver Core）会自动向 Pinctrl 核心申请将该设备的引脚切换到 <code>default</code> 状态。</li><li><strong>底层执行</strong>：Pinctrl 核心找到对应的Pinctrl驱动（Provider），写入寄存器，完成复用和电气配置。 <strong>这就意味着，作为驱动开发者，你甚至不需要在 C 代码里写一行关于配置引脚的代码，一切都已经在设备树加载时自动完成了。</strong></li></ol><h2 id="3-使用-pinctrl-以imx6ull为例"><a class="markdownIt-Anchor" href="#3-使用-pinctrl-以imx6ull为例"></a> 3. 使用 Pinctrl （以IMX6ULL为例）</h2><h3 id="31-step0查阅编写说明书"><a class="markdownIt-Anchor" href="#31-step0查阅编写说明书"></a> 3.1. step0.查阅编写说明书</h3><p>要使用 Pinctrl ，必不可少的就是我们在前面介绍设备树一文中提到的编写规范文档，<strong>必须按照编写规范来写！</strong> 对于本文使用的SoC来说，这个文档就是 <code>Documentation/devicetree/bindings/pinctrl/fsl,imx6ul-pinctrl.txt</code></p><p>原文是这样描述的：</p><pre class="line-numbers language-none"><code class="language-none">* Freescale i.MX6 UltraLite IOMUX ControllerPlease refer to fsl,imx-pinctrl.txt in this directory for common binding partand usage.Required properties:- compatible: &quot;fsl,imx6ul-iomuxc&quot; for main IOMUX controller or  &quot;fsl,imx6ull-iomuxc-snvs&quot; for i.MX 6ULL&#39;s SNVS IOMUX controller.- fsl,pins: each entry consists of 6 integers and represents the mux and config  setting for one pin.  The first 5 integers &lt;mux_reg conf_reg input_reg mux_val  input_val&gt; are specified using a PIN_FUNC_ID macro, which can be found in  imx6ul-pinfunc.h under device tree source folder.  The last integer CONFIG is  the pad setting value like pull-up on this pin.  Please refer to i.MX6 UltraLite  Reference Manual for detailed CONFIG settings.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>翻译如下：</p><pre class="line-numbers language-none"><code class="language-none">* Freescale i.MX6 UltraLite IOMUX 控制器本目录中的 fsl,imx-pinctrl.txt 文件提供了通用绑定部分及使用说明，请参考该文档。必需属性：- compatible：  主 IOMUX 控制器应使用 &quot;fsl,imx6ul-iomuxc&quot;，  i.MX6ULL 的 SNVS IOMUX 控制器则使用 &quot;fsl,imx6ull-iomuxc-snvs&quot;- fsl,pins：  每个条目由6个整数组成，代表单个引脚的多路复用和配置设置。  前5个整数 &lt;mux_reg conf_reg input_reg mux_val input_val&gt;  使用 PIN_FUNC_ID 宏定义（该宏定义位于设备树源文件夹下的 imx6ul-pinfunc.h 文件中），  最后一个整数 CONFIG 为焊盘配置值（例如该引脚的上拉设置）。  详细 CONFIG 设置请参阅 i.MX6 UltraLite 参考手册。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>意思是你要在pinctrl节点下添加你的pin配置，你必须有两个属性：</p><ul><li>compatible：<strong>这是主控制器也就是IOMUXC节点所需属性，子节点无需指定。</strong><ul><li>如果使用主 IOMUX 控制器，值必须为“fsl,imx6ul-iomuxc”。</li><li>如果使用 SNVS IOMUX 控制器，值必须为“fsl,imx6ull-iomuxc-snvs”</li></ul></li><li>fsl,pins：<strong>子节点必需属性。</strong> 由6个寄存器值组成，前5个值已被官方包装为宏定义，最后一个寄存器值需要我们手动设置。</li></ul><p>它还提到这个宏定义就在 <code>imx6ul-pinfunc.h</code>，我们截取一段看看，就拿一个GPIO的配置来看一下吧：</p><pre class="line-numbers language-none"><code class="language-none">#define MX6UL_PAD_GPIO1_IO04__GPIO1_IO04        0x006c 0x02f8 0x0000 5 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这五个数是这样组织的:</p><table><thead><tr><th><strong>名字</strong></th><th><strong>mux_reg</strong></th><th><strong>conf_reg</strong></th><th><strong>input_reg</strong></th><th><strong>mux_val</strong></th><th><strong>input_val</strong></th></tr></thead><tbody><tr><td><strong>值</strong></td><td>0x006c</td><td>0x02f8</td><td>0</td><td>5</td><td>0</td></tr><tr><td><strong>意义</strong></td><td>引脚复用寄存器相对偏移地址</td><td>引脚配置寄存器相对偏移地址</td><td>输入选择控制寄存器偏移地址</td><td>引脚复用寄存器值</td><td>输入选择控制寄存器值</td></tr></tbody></table><p><strong>备注：</strong></p><ol><li>相对 主io控制器 iomuxc 的地址 0x020e0000 偏移。</li><li>输入选择寄存器为0，为无效值，表示这个配置不需要输入选择。</li><li>什么时候需要输入选择寄存器呢？假设芯片内部有一个 UART1_RX（串口1接收）信号。根据芯片设计，这个 UART1_RX 信号可能可以从 GPIO1_IO01 这个引脚输入，也可以从 GPIO1_IO02 这个引脚输入。这两个引脚都具备复用为 UART1_RX 的能力。这个寄存器的作用就是指定输入路径。</li><li>写入寄存器的这些值是厂商帮我们写好了的，填入这些值到相应的寄存器，引脚就能复用为我们想要的功能。我们再也不需要去找寄存器、看位定义了！</li><li>擅长找规律的同学肯定注意到了，第六个值，也就是自己配置的值其实就是 conf_val。</li></ol><p>不同的厂商有不同的编写方式，但通过阅读厂商为我们写好的编写文档，我们就可以很快速的跟上厂商的节奏。</p><h3 id="32-step1在-pinctrl-节点中定义引脚配置"><a class="markdownIt-Anchor" href="#32-step1在-pinctrl-节点中定义引脚配置"></a> 3.2. step1.在 Pinctrl 节点中定义引脚配置</h3><p>首先，在 SoC 厂商提供的 pinctrl 节点下，定义你需要的引脚组。</p><pre class="line-numbers language-DTS" data-language="DTS"><code class="language-DTS">&amp;iomuxc &#123;pinctrl_i2c1: i2c1grp &#123;fsl,pins &#x3D; &lt;MX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x4001b8b0MX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x4001b8b0        &gt;;&#125;;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>不同厂商的语法（如 rockchip,pins 或 fsl,pins）略有不同，但逻辑一致。</p></blockquote><h3 id="33-step2在设备节点中引用-pinctrl"><a class="markdownIt-Anchor" href="#33-step2在设备节点中引用-pinctrl"></a> 3.3. step2.在设备节点中引用 Pinctrl</h3><p>接下来，在你具体的设备节点中，告诉内核：“我要用上面定义的那些引脚”。</p><pre class="line-numbers language-DTS" data-language="DTS"><code class="language-DTS">&amp;i2c1 &#123;    status &#x3D; &quot;okay&quot;;    &#x2F;* 1. 指定引脚配置名称列表 *&#x2F;    pinctrl-names &#x3D; &quot;default&quot;;    &#x2F;* 2. 引用步骤一中定义的句柄 *&#x2F;    pinctrl-0 &#x3D; &lt;&amp;pinctrl_i2c1&gt;;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码解读：</strong></p><ul><li><code>pinctrl-names = &quot;default&quot;</code>：告诉内核，这组配置叫 “default”。内核加载驱动时，会自动查找并激活名为 “default” 的配置。</li><li><code>pinctrl-0 = &lt;&amp;pinctrl_i2c1&gt;;</code>：这对应着 “default” 状态下具体的硬件引脚设置。</li></ul><h3 id="34-进阶多状态切换休眠模式"><a class="markdownIt-Anchor" href="#34-进阶多状态切换休眠模式"></a> 3.4. 进阶：多状态切换（休眠模式）</h3><p>如果你的设备支持电源管理，你可以定义两个状态：</p><pre class="line-numbers language-DTS" data-language="DTS"><code class="language-DTS">&amp;some_device &#123;    pinctrl-names &#x3D; &quot;default&quot;, &quot;sleep&quot;; &#x2F;* 定义了两个名字 *&#x2F;    pinctrl-0 &#x3D; &lt;&amp;pin_conf_active&gt;;     &#x2F;* default 对应这组 *&#x2F;    pinctrl-1 &#x3D; &lt;&amp;pin_conf_sleep&gt;;      &#x2F;* sleep 对应这组 *&#x2F;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当设备驱动调用 <code>pinctrl_pm_select_sleep_state()</code> 时，引脚会自动切换到 <code>pinctrl-1</code> 指定的配置（例如关闭上拉电阻以省电）。</p><h2 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4. 总结</h2><p>Linux Pinctrl 子系统虽然底层复杂，但对应用和驱动开发者的接口非常友好。</p><ul><li><strong>核心作用：</strong> 管理引脚复用（Mux）和电气配置（Config）。</li><li><strong>工作方式：</strong> 基于设备树（DTS）描述，内核自动在驱动加载时应用。</li><li><strong>你的任务：</strong> 作为开发者，你主要的工作是<strong>查阅芯片手册</strong>，确定引脚功能，然后在<strong>设备树</strong>中正确填写 <code>pinctrl-names</code> 和 <code>pinctrl-0</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="设备驱动程序" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>VSCODE-Linux驱动开发环境设置</title>
    <link href="https://blog.godmao.top/posts/2591/"/>
    <id>https://blog.godmao.top/posts/2591/</id>
    <published>2025-11-23T11:38:10.000Z</published>
    <updated>2025-11-24T06:04:46.179Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><p>VSCODE的C/C++插件对于在Linux源码环境下的Linux驱动开发支持并不是很好，主要体现在文件查找和错误的“错误提示”（红色波浪线真的逼死强迫症，本篇记录一下对VSCODE的环境设置。</p><p>此篇主要介绍</p><ol><li>指定内核源码路径</li><li>指定编译器路径</li><li>添加一些宏定义让编辑器不再错误地划红色波浪线（“报错”）</li></ol><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><p>通过这个按钮选择配置集或打开设置：</p><p><img src="Snipaste_2025-11-23_19-50-49.png" alt="" /></p><p>具体的设置大概是这样，这里我新建了一个配置集 <code>linux-arm</code></p><p><img src="Snipaste_2025-11-23_19-51-13.png" alt="" /><br /><img src="Snipaste_2025-11-23_19-53-24.png" alt="" /></p><p>如果使用json设置的话：（c_cpp_properties.json）</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Linux-arm"</span><span class="token punctuation">,</span>            <span class="token property">"includePath"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"$&#123;workspaceFolder&#125;/**"</span><span class="token punctuation">,</span>                <span class="token string">"/home/gdm/prjts/linux/driver_learning/kernel/linux-imx-lf-6.6.52-2.2.1/include/**"</span><span class="token punctuation">,</span>                <span class="token string">"/home/gdm/prjts/linux/driver_learning/kernel/linux-imx-lf-6.6.52-2.2.1/arch/arm/include/**"</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"defines"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"__KERNEL__"</span><span class="token punctuation">,</span>                <span class="token string">"__GNUC__"</span><span class="token punctuation">,</span>                <span class="token string">"MODULE"</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"compilerPath"</span><span class="token operator">:</span> <span class="token string">"/home/gdm/prjts/ARM_TOOLCHAIN/AArch32-BareMetal/arm-none-eabi-PATH/arm-none-eabi-gcc"</span><span class="token punctuation">,</span>            <span class="token property">"cStandard"</span><span class="token operator">:</span> <span class="token string">"gnu11"</span><span class="token punctuation">,</span>            <span class="token property">"cppStandard"</span><span class="token operator">:</span> <span class="token string">"gnu++17"</span><span class="token punctuation">,</span>            <span class="token property">"intelliSenseMode"</span><span class="token operator">:</span> <span class="token string">"linux-gcc-x64"</span><span class="token punctuation">,</span>            <span class="token property">"mergeConfigurations"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token property">"recursiveIncludes"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token property">"browse"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token property">"limitSymbolsToIncludedHeaders"</span><span class="token operator">:</span> <span class="token boolean">true</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注意的要点"><a class="markdownIt-Anchor" href="#注意的要点"></a> 注意的要点</h2><h3 id="1-编译器路径指定"><a class="markdownIt-Anchor" href="#1-编译器路径指定"></a> 1. 编译器路径指定</h3><p>指定用于编译裸机的交叉编译器！比如我的ARM官方工具链的用于裸机编译的 <code>arm-none-eabi-gcc</code> 。这个指定编译器不重要，真正用于编译的是我们在linux内核源码的makefile里指定的编译器，只是VSCODE要在这个编译器的路径下找一些头文件啥的，如果你使用带有linux目录的编译器的话，比如 <code>arm-none-linux-eabihf-gcc</code>，它的目录下有linux文件夹，而VSCODE优先搜索编译器路径，会导致跳转的文件不是指定的源码路径下的文件。还会提示找不到文件。。。。</p><h3 id="2-指定一些宏定义避免vscode错误地划红色波浪线"><a class="markdownIt-Anchor" href="#2-指定一些宏定义避免vscode错误地划红色波浪线"></a> 2. 指定一些宏定义避免VSCODE错误地划红色波浪线</h3><p>指定上图的三个宏定义，否则VSCODE会错误地画红色波浪线（编译可通过，但是VSCODE报错。</p><h3 id="3-包含的路径"><a class="markdownIt-Anchor" href="#3-包含的路径"></a> 3. 包含的路径</h3><p>一般包含：</p><ul><li>linux源码根目录下的 <code>include</code></li><li>对应架构下的 <code>include</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="设备驱动程序" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="VSCODE" scheme="https://blog.godmao.top/Tags/VSCODE/"/>
    
    <category term="开发环境" scheme="https://blog.godmao.top/Tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>dts设备树入门</title>
    <link href="https://blog.godmao.top/posts/50610/"/>
    <id>https://blog.godmao.top/posts/50610/</id>
    <published>2025-11-19T07:24:50.000Z</published>
    <updated>2025-11-24T06:04:32.425Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="1-设备树简介"><a class="markdownIt-Anchor" href="#1-设备树简介"></a> 1. 设备树简介</h2><h3 id="11-什么是设备树"><a class="markdownIt-Anchor" href="#11-什么是设备树"></a> 1.1. 什么是设备树</h3><p>在 Linux 内核（特别是 ARM 架构）开发中，设备树（Device Tree）是描述硬件信息的“地图”。它的核心目的是<strong>将硬件描述与驱动代码分离</strong>。</p><p>简单来说：</p><ul><li><strong>以前</strong>：你在 <code>.c</code> 代码里写死“这个引脚是 GPIO 5，内存地址是 0x1000”。</li><li><strong>现在</strong>：驱动代码只写逻辑（“我要读取一个 GPIO”），而具体的“GPIO 5”写在设备树文件（<code>.dts</code>）里。</li></ul><p>设备树可以理解为<strong>一个硬件描述文件：告诉内核板级外设的位置、参数、使用方式。</strong></p><p>例如：</p><ul><li>GPIO 属于哪个控制器？</li><li>串口 1 的寄存器基地址在哪里？</li><li>I2C 的速度是多少？</li><li>一个 LED 接在哪个 GPIO 引脚？</li></ul><p>这些都通过设备树告诉内核。</p><h3 id="12-设备树的由来"><a class="markdownIt-Anchor" href="#12-设备树的由来"></a> 1.2. 设备树的由来</h3><p>在 2011 年之前（Linux 3.x 版本之前），ARM 架构的 Linux 内核源码中并没有设备树。那时候，描述板子硬件信息是直接写在 C 文件里的。本来ARM架构的板子就多，还他妈每个板子都要提交一个硬件描述文件，而且硬件描述文件大部分都是一些硬件地址的结构体，同一厂家生产的SoC提交的硬件描述文件还有很多重复的内容。</p><p>在这种情况下，Linux 之父 Linus Torvalds 在检查 ARM 架构的代码合并请求时，终于忍无可忍。他在邮件列表里发出了那封著名的邮件，痛斥 ARM 社区：</p><blockquote><p><strong>&quot; This whole ARM thing is a f*cking pain in the ass.&quot;</strong> (“这整个 ARM 的东西简直就是屁股上的痛（极其痛苦）。”)</p></blockquote><p>他指出 ARM 社区没有像 x86 那样有统一的硬件描述标准（x86 有 BIOS/ACPI），导致内核充斥着无关紧要的板级细节。他威胁说，如果不解决这个问题，就不再合并 ARM 的代码。</p><p>面对 Linus 的压力，ARM 社区的大佬们开始寻找解决方案。他们将 PowerPC 的这套机制移植到了 ARM 架构上。从此，硬件描述不再写在 C 代码里，而是写在独立的文本文件（<code>.dts</code>）里，经过单独编译成二进制（<code>.dtb</code>），由 Bootloader 传给内核。</p><p>我们还可以注意到即使是现在的6.x内核，其源码目录中的 <code>/linux/arch/arm/mach-xxx</code> 仍有许多.c文件，这些文件并不是硬件描述文件，而是负责让 SoC 能够正常启动并运行内核。比如CPU 初始化、timer 初始化、中断控制器初始化、电源管理等等。</p><h2 id="2-核心文件类型"><a class="markdownIt-Anchor" href="#2-核心文件类型"></a> 2. 核心文件类型</h2><p>在使用设备树之前，需要区分三种文件后缀：</p><table><thead><tr><th><strong>后缀</strong></th><th><strong>全称</strong></th><th><strong>作用</strong></th><th><strong>类比</strong></th></tr></thead><tbody><tr><td><strong>.dts</strong></td><td>Device Tree Source</td><td>板级定义文件，描述具体的电路板硬件。</td><td><code>.c</code> 源文件</td></tr><tr><td><strong>.dtsi</strong></td><td>Device Tree Source Include</td><td>SoC 级或<strong>通用</strong>的头文件，可被多个 dts 复用。</td><td><code>.h</code> 头文件</td></tr><tr><td><strong>.dtb</strong></td><td>Device Tree Blob</td><td>编译后的二进制文件，Bootloader 会把它传给内核。</td><td><code>.o</code> 或可执行文件</td></tr></tbody></table><blockquote><p>一般 .dtsi 文件用于描述 SOC 的内部外设信息，比如 CPU 架构、主频、外设寄存器地址范围，比如 UART、IIC 等等。这些信息在某些板子上是通用的，比如 imx6ul-14x14-evk.dtsi 就被 I.MX6ULL 的 dts 文件包含。</p></blockquote><h2 id="3-编译设备树"><a class="markdownIt-Anchor" href="#3-编译设备树"></a> 3. 编译设备树</h2><p>在 Linux 内核源码中，ARM 架构的设备树通常位于 <code>arch/arm/boot/dts/</code> (或 <code>arch/arm64/boot/dts/</code>)。</p><p>我们打开 <code>arch/arm/boot/dts/nxp/imx/Makefile</code></p><p>这里的 Makefile 就记录了该平台下所有板子的设备树文件：</p><pre class="line-numbers language-make" data-language="make"><code class="language-make">...dtb-$(CONFIG_SOC_IMX6UL) +&#x3D; \    imx6ul-14x14-evk.dtb \    imx6ul-ccimx6ulsbcexpress.dtb \    imx6ul-ccimx6ulsbcpro.dtb \    imx6ul-geam.dtb \   ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，当选中 I.MX6ULL 这个 SOC 以后(CONFIG_SOC_IMX6ULL=y)，所有使用到<br />I.MX6ULL 这个 SOC 的板子对应的.dts 文件都会被编译为.dtb。如果我们使用I.MX6ULL 新做了一个板子，只需要新建一个此板子对应的.dts 文件，然后将对应的.dtb 文件名添加到 dtb-$(CONFIG_SOC_IMX6ULL)下，这样在编译设备树的时候就会找到对应的.dts 编译为二进制的 .dtb 文件。</p><p>只编译设备树文件：<code>make dtbs</code> 或 <code>make [具体的设备树文件名]</code></p><p><strong>系统启动后，内核会将解析后的设备树以文件系统形式展示在 <code>/proc/device-tree</code>。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看刚才添加的 LED 节点</span><span class="token function">ls</span> /proc/device-tree/leds/<span class="token comment"># 查看 compatible 属性</span><span class="token function">cat</span> /proc/device-tree/leds/compatible<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-基本语法"><a class="markdownIt-Anchor" href="#4-基本语法"></a> 4. 基本语法</h2><p>设备树是一个树状结构，由<strong>节点</strong>（Node）和<strong>属性</strong>（Property）组成。</p><h3 id="41-节点"><a class="markdownIt-Anchor" href="#41-节点"></a> 4.1. 节点</h3><p>一个硬件模块就是一个节点：</p><pre class="line-numbers language-dts" data-language="dts"><code class="language-dts">&#x2F;dts-v1&#x2F;;                &#x2F;&#x2F; 版本号#include &quot;soc.dtsi&quot;      &#x2F;&#x2F; 包含头文件&#x2F;&#123;aliases&#123;can0 &#x3D; &flexcan1;&#125;;cpus&#123;#address-cells &#x3D; &lt;1&gt;;#size-cells &#x3D; &lt;0&gt;;cpu0: cpu@0 &#123;compatible &#x3D; &quot;arm,cortex-a7&quot;;device_type &#x3D; &quot;cpu&quot;;reg &#x3D; &lt;0&gt;;&#125;;&#125;;intc: interrupt-controller@00a01000 &#123;compatible &#x3D; &quot;arm,cortex-a7-gic&quot;;#interrupt-cells &#x3D; &lt;3&gt;;interrupt-controller;reg &#x3D; &lt;0x00a01000 0x1000&gt;,  &lt;0x00a02000 0x100&gt;;&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>“/”是根节点，每个设备树文件只有一个根节点。根节点会合并。</p><p>我们可以看到一些常见写法，如：</p><ul><li><p><code>label: node-name@unit-address</code></p><p>其中“node-name”是节点名字，为 ASCII 字符串，节点名字应该能够清晰的描述出节点的功能，比如“uart1”就表示这个节点是 UART1 外设。</p><p>“unit-address”一般表示设备的地址或寄存器首地址，如果某个节点没有地址或者寄存器的话“unit-address”可以不要，比如“cpu@0”“interrupt-controller@00a01000”。</p><p>引入 “label” 的目的是为了方便访问节点，可以直接通过 &amp;label 来访问这个节点，比如通过 &amp;cpu0 就可以访问“cpu@0”这个节点，而不需要输入完整的节点名字。</p></li><li><p><code>&lt;number&gt;</code>：32 位无符号整数。可以设置为一组值，比如：、<br />“reg = &lt;0 0x123456 100&gt;;”</p></li></ul><h3 id="42-两个特殊节点"><a class="markdownIt-Anchor" href="#42-两个特殊节点"></a> 4.2. 两个特殊节点</h3><h4 id="421-aliases"><a class="markdownIt-Anchor" href="#421-aliases"></a> 4.2.1. aliases</h4><p>用于定义别名。不过我们一般会在节点命名的时候会加上 label，然后通过&amp;label<br />来访问节点，这样也很方便。</p><h4 id="422-chosen"><a class="markdownIt-Anchor" href="#422-chosen"></a> 4.2.2. chosen</h4><p>chosen 并不是一个真实的设备，chosen 节点主要是为了 uboot 向 Linux 内核传递数据，重点是 bootargs 参数。</p><p>下图为 uboot 向 chosen 节点添加 bootargs 参数的调用链：</p><p><img src="Snipaste_2025-11-23_17-32-22.png" alt="" /></p><h3 id="43-属性"><a class="markdownIt-Anchor" href="#43-属性"></a> 4.3. 属性</h3><p>这是在修改设备树时最常用的几个属性：</p><h4 id="431-compatible-兼容性"><a class="markdownIt-Anchor" href="#431-compatible-兼容性"></a> 4.3.1. compatible (兼容性)：</h4><ul><li><strong>作用</strong>：这是设备树与驱动程序的“暗号”。内核通过这个字符串将设备节点与驱动程序匹配起来。</li><li><strong>格式</strong>：<code>&quot;厂商,模块驱动名&quot;</code>。</li><li><strong>例子</strong>：<code>compatible = &quot;fsl,imx6ul-evk-wm8960&quot;,&quot;fsl,imx-audio-wm8960&quot;;</code></li></ul><p>一般驱动程序文件都会有一个 OF 匹配表，此 OF 匹配表保存着一些 compatible 值，如果设备节点的 compatible 属性值和 OF 匹配表中的任何一个值相等，那么就表示设备可以使用这个驱动。</p><p>属性值有两个的话，首先使用第一个兼容值在 Linux 内核里面查找，看看能不能找到与之匹配的驱动文件，如果没有找到的话就使用第二个兼容值查。</p><h4 id="432-status-状态"><a class="markdownIt-Anchor" href="#432-status-状态"></a> 4.3.2. status (状态)：</h4><ul><li><strong>作用</strong>：控制设备是否启用。</li><li><strong>常用值</strong>：<code>&quot;okay&quot;</code> (启用), <code>&quot;disabled&quot;</code> (禁用)，<code>“fail”</code> 。</li><li><strong>场景</strong>：SoC 内部有很多控制器（如 I2C3），板子没用到，就在 <code>.dts</code> 里设为 <code>disabled</code>；如果用到了，就改为 <code>okay</code>。</li></ul><h4 id="433-reg-寄存器地址"><a class="markdownIt-Anchor" href="#433-reg-寄存器地址"></a> 4.3.3. reg (寄存器/地址)：</h4><ul><li><strong>作用</strong>：描述设备的地址资源（内存映射地址、I2C 地址等）。</li><li><strong>格式</strong>：通常是 <code>&lt;地址 长度&gt;</code> 或 <code>&lt;I2C地址&gt;</code>。</li></ul><h4 id="434-label-与-phandle-引用"><a class="markdownIt-Anchor" href="#434-label-与-phandle-引用"></a> 4.3.4. label 与 phandle (引用)：</h4><ul><li><strong>作用</strong>：让节点之间互相引用。</li><li><strong>符号</strong>：<code>&amp;</code>。例如 <code>&amp;i2c1</code> 表示引用标签为 <code>i2c1</code> 的节点。</li></ul><h4 id="435-address-cells-和-size-cells"><a class="markdownIt-Anchor" href="#435-address-cells-和-size-cells"></a> 4.3.5. #address-cells 和 #size-cells ：</h4><ul><li><strong>作用</strong>：决定了<strong>子节点</strong> reg 属性中地址信息和长度信息所占用的字长(32 位)。</li><li><strong>例子</strong>：<code>#address-cells = &lt;1&gt;;</code> <code>#size-cells = &lt;0&gt;;</code>，表明子节点 reg 值，地址占一个字长，长度无。</li></ul><h4 id="436-ranges"><a class="markdownIt-Anchor" href="#436-ranges"></a> 4.3.6. ranges</h4><ul><li><strong>作用</strong>：表示将子节点地址向父节点地址的转换。</li><li><strong>格式</strong>：<code>&lt;local地址， parent地址， size&gt;</code></li></ul><p>比如对于 <code>#address-cells</code> 和 <code>#size-cells</code> 都为1，以<code>&lt;0x0  0x10 0x20&gt;</code>为例，表示将 local 的 从 0x0~(0x0 + 0x20) 的地址空间映射到 parent 的 0x10~(0x10 + 0x20)。<br />ranges属性值为空的话，表示1:1映射。</p><h3 id="44-追加内容"><a class="markdownIt-Anchor" href="#44-追加内容"></a> 4.4. 追加内容</h3><p>相在某一父节点下添加一个子节点，你可以直接在那个父节点下添加。<br />或者直接使用 <code>&amp;</code> 符号+label名，表示在这个节点下追加属性。<br />肥肠的煎蛋。</p><pre class="line-numbers language-none"><code class="language-none">&amp;i2c1 &#123;&#x2F;* 要追加或修改的内容 *&#x2F;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5-设备树的编写规范"><a class="markdownIt-Anchor" href="#5-设备树的编写规范"></a> 5. 设备树的编写规范</h2><h3 id="51-查阅编写规范"><a class="markdownIt-Anchor" href="#51-查阅编写规范"></a> 5.1. 查阅编写规范</h3><p>打开linux源码目录 <code>Documentation/devicetree/bindings</code> 它是设备树（Device Tree）规范的“官方说明书”，里面定义着不同厂商的不同设备的设备树的编写规范。</p><p>具体来说，里面的每一个 <code>.yaml</code> 或 <code>.txt</code> 文件，都在描述某一类硬件设备在设备树中应该如何被正确地写出来。</p><p>也就是：</p><ul><li>它有哪些必需属性（<code>reg</code>、<code>compatible</code>…）</li><li>可选属性有哪些</li><li>各个属性是什么含义</li><li>属性的类型和合法取值是什么</li><li>示例（示范 devicetree 节点怎么写）</li></ul><p>Linux 内核靠它们来<strong>校验设备树 DTS 文件是否符合规范</strong>。</p><blockquote><p>当你 <code>make dtbs</code> 或 <code>dt-validate</code> 时，<code>dt-schema</code> 工具会检查 DTS 是否按照 bindings 的要求去写。若有问题，会直接报错。</p></blockquote><h3 id="52-为什么有编写规范"><a class="markdownIt-Anchor" href="#52-为什么有编写规范"></a> 5.2. 为什么有编写规范</h3><p>因为世界上 SoC/外设千千万，每个设备的写法不同。<br />为了避免不同厂家乱写导致兼容性和维护困难，内核社区采用：</p><ul><li>统一规范（binding）</li><li>统一校验（dt-schema）</li></ul><p>这样：</p><ul><li>社区可以维护通用格式</li><li>DTS 文件编译时可以自动报错（提示写法不规范）</li><li>驱动开发者知道设备树应该怎样写</li></ul><h3 id="53-看懂编写规范"><a class="markdownIt-Anchor" href="#53-看懂编写规范"></a> 5.3. 看懂编写规范</h3><p>以一个典型的 YAML binding 为例，它会包含：</p><h4 id="531-compatible-字段"><a class="markdownIt-Anchor" href="#531-compatible-字段"></a> 5.3.1. compatible 字段</h4><p>列出这个驱动支持的硬件型号</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">compatible</span><span class="token punctuation">:</span>  <span class="token key atrule">const</span><span class="token punctuation">:</span> <span class="token string">"nxp,imx6ull-uart"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="532-必须的属性"><a class="markdownIt-Anchor" href="#532-必须的属性"></a> 5.3.2. 必须的属性</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">properties</span><span class="token punctuation">:</span>  <span class="token key atrule">reg</span><span class="token punctuation">:</span>    <span class="token key atrule">maxItems</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">interrupts</span><span class="token punctuation">:</span>    <span class="token key atrule">maxItems</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token key atrule">required</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> compatible  <span class="token punctuation">-</span> reg  <span class="token punctuation">-</span> interrupts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="533-可选属性"><a class="markdownIt-Anchor" href="#533-可选属性"></a> 5.3.3. 可选属性</h4><p>如 <code>clocks</code>、<code>dmas</code> 等。</p><h4 id="534-示例"><a class="markdownIt-Anchor" href="#534-示例"></a> 5.3.4. 示例</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">examples</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token punctuation">|</span><span class="token scalar string">    uart1: serial@02020000 &#123;        compatible = "nxp,imx6ull-uart";        reg = &lt;0x02020000 0x4000>;        interrupts = ;    &#125;;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些示例是你写 DTS 时最可靠的参考。</p><h2 id="6-驱动程序获取设备树属性"><a class="markdownIt-Anchor" href="#6-驱动程序获取设备树属性"></a> 6. 驱动程序获取设备树属性</h2><p>设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必须先获取到这个设备的节点。Linux 内核使用 <code>device_node</code> 结构体来描述一个节点，此结构体定义在文件 <code>include/linux/of.h</code> 中。</p><p>通过 <strong>OF(OpenFirmware)</strong> 系列函数，我们可以查找这些 <code>device_node</code> 变量类型的结构体，并从中获取对应设备的属性。</p><p>这些函数的用途在函数名已有体现。<br />例如常用的一些查找函数：<br />of_find_node_by_name</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">device_node</span><span class="token operator">*</span><span class="token function">of_find_node_by_name</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_node</span><span class="token operator">*</span> from<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>of_find_compatible_node</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">device_node</span><span class="token operator">*</span><span class="token function">of_find_compatible_node</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">device_node</span><span class="token operator">*</span> from<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> type<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> compatible<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>of_find_matching_node_and_match</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">device_node</span><span class="token operator">*</span> <span class="token function">of_find_matching_node_and_match</span><span class="token punctuation">(</span>structdevice_node<span class="token operator">*</span> from<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">of_device_id</span><span class="token operator">*</span> matches<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">of_device_id</span><span class="token operator">*</span><span class="token operator">*</span> match<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>of_find_node_by_path</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">inline</span> <span class="token keyword">struct</span> <span class="token class-name">device_node</span><span class="token operator">*</span> <span class="token function">of_find_node_by_path</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>OF函数在驱动的编写中很重要，受限于篇幅原因就不一一介绍了，有可能后续再开一篇来介绍。</p><p>最后来一张表格总结常用的：</p><table><thead><tr><th>功能</th><th>函数</th></tr></thead><tbody><tr><td>查找节点</td><td><code>of_find_compatible_node()</code></td></tr><tr><td>基础属性读取</td><td><code>of_get_property()</code></td></tr><tr><td>读 u32</td><td><code>of_property_read_u32()</code></td></tr><tr><td>读字符串</td><td><code>of_property_read_string()</code></td></tr><tr><td>读 reg → resource</td><td><code>of_address_to_resource()</code></td></tr><tr><td>读 reg → 虚拟地址</td><td><code>of_iomap()</code></td></tr><tr><td>获取 IRQ</td><td><code>of_irq_get()</code></td></tr><tr><td>是否有某属性</td><td><code>of_property_read_bool()</code></td></tr><tr><td>匹配 compatible</td><td><code>of_match_device()</code></td></tr><tr><td>遍历节点</td><td><code>for_each_child_of_node()</code></td></tr></tbody></table><h2 id="7-参考资料"><a class="markdownIt-Anchor" href="#7-参考资料"></a> 7. 参考资料</h2><p><a href="https://file.godmao.top/d/Shared/%E3%80%90%E6%AD%A3%E7%82%B9%E5%8E%9F%E5%AD%90%E3%80%91I.MX6U%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97V1.81.pdf?sign=vS7F10MHWkaown10OD4dmMjwRFwoYbLzzYmfpRvex_I=:0">【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.81</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="设备驱动程序" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="设备树" scheme="https://blog.godmao.top/Tags/%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
    
    <category term="dts" scheme="https://blog.godmao.top/Tags/dts/"/>
    
  </entry>
  
  <entry>
    <title>使用mfgtool烧写完整系统到IMX的EMMC</title>
    <link href="https://blog.godmao.top/posts/19983/"/>
    <id>https://blog.godmao.top/posts/19983/</id>
    <published>2025-11-11T11:34:13.000Z</published>
    <updated>2025-11-13T12:20:22.603Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="mfgtool-介绍"><a class="markdownIt-Anchor" href="#mfgtool-介绍"></a> mfgtool 介绍</h2><p>mfgtool 是 NXP 提供的专门用于给 <a href="http://I.MX">I.MX</a> 系列 CPU 烧写系统的软件。</p><h2 id="mfgtool-工作流程"><a class="markdownIt-Anchor" href="#mfgtool-工作流程"></a> mfgtool 工作流程</h2><ol><li>首先 mfgtool 将 firmware 目录中的 uboot、linux kernel 和.dtb(设备树)，然后通过 USB OTG 将这个文件下载到开发板的 DDR 中，目的就是在 DDR 中启动 Linux 系统，为后面的烧写做准备。</li><li>经过第一步的操作，此时 Linux 系统已经运行起来了，系统运行起来以后就可以很方便的完成对 EMMC 的格式化、分区等操作。EMMC 分区建立好以后就可以从 files 中读取要烧写的 uboot、linux kernel、.dtb(设备树)和 rootfs 这 4 个文件，然后将其烧写到 EMMC 中。</li><li>files 和 firmware 目录下有众多的 uboot 和设备树，那么烧写的时候究竟选择哪一个呢？这个工作就是由 ucl2.xml 文件来完成的。ucl2.xml 以“<code>&lt;UCL&gt;</code>”开始，以“<code>&lt;/UCL&gt;</code>”结束。“<code>&lt;CFG&gt;</code>”和“<code>&lt;/CFG&gt;</code>”之间是配置相关内容，主要是判断当前是给 <a href="http://I.MX">I.MX</a> 系列的哪个芯片烧写系统。“<code>&lt;LIST&gt;</code>”和“<code>&lt;/LIST&gt;</code>”之间的是针对不同存储芯片的烧写命令。</li></ol><p>这个就是 mfgTool 的大概工作流程。</p><p>总结：</p><p><code>firmware</code>：烧写到DDR中的Linux文件，用于操作EMMC。</p><p><code>file</code>：真正烧写到EMMC中的文件。</p><p><code>ucl2.xml</code>：指示mfgtool烧写哪些文件。</p><h2 id="烧写自己的系统"><a class="markdownIt-Anchor" href="#烧写自己的系统"></a> 烧写自己的系统</h2><p>以IMX6ULL为例。</p><p>查看 <code>ucl2.xml</code>，再打开：</p><p><code>/mfgtools/Profiles/Linux/OS Firmware/firmware</code> 及</p><p><code>/mfgtools/Profiles/Linux/OS Firmware/files</code>，</p><p>易知：</p><p>要烧写的文件在 files 目录下和 firmware 目录下同名<br />且要烧写的文件名如下：</p><h3 id="u-boot"><a class="markdownIt-Anchor" href="#u-boot"></a> u-boot</h3><p>官方u-boot名称：<code>u-boot-imx6ull14x14evk_emmc.imx</code></p><h3 id="内核镜像"><a class="markdownIt-Anchor" href="#内核镜像"></a> 内核镜像</h3><p>官方内核名称：<code>zImage</code></p><h3 id="设备树"><a class="markdownIt-Anchor" href="#设备树"></a> 设备树</h3><p>官方设备树名称：<code>zImage-imx6ull-14x14-evk-emmc.dtb</code></p><h3 id="根文件系统"><a class="markdownIt-Anchor" href="#根文件系统"></a> 根文件系统</h3><p>官方根文件系统名称：<code>rootfs_nogpu.tar.bz2</code></p><p>注：先将根文件系统使用 <code>tar -vcjf</code> 命令打包。该项只存在于 files 中，无需烧写到DDR中。</p><h3 id="烧写方法"><a class="markdownIt-Anchor" href="#烧写方法"></a> 烧写方法</h3><p>直接将自己确认好可以用的 dtb、kernel、uboot、rootfs 文件改为上面的官方名称并覆盖到firmware 及 files 文件夹。<br />然后双击对应的烧写脚本（我的是： <code>mfgtool2-yocto-mx-evk-emmc.vbs</code>） 烧写。</p><h3 id="issue1内核启动3s后卡死无法挂载根文件系统"><a class="markdownIt-Anchor" href="#issue1内核启动3s后卡死无法挂载根文件系统"></a> issue#1：内核启动3s后卡死，无法挂载根文件系统。</h3><h4 id="排查过程"><a class="markdownIt-Anchor" href="#排查过程"></a> 排查过程：</h4><p>起初怀疑是根文件系统问题。排查如下：</p><ol><li><p>检查根文件系统是否烧写成功或文件系统格式错误。<br />在uboot中输入命令：<code>ext4ls mmc 1:2 /</code> 成功输出根文件系统内容，排除。</p></li><li><p>怀疑根文件系统初始化脚本无法执行。<br />在uboot的bootargs 参数中添加：<code>init=/bin/sh</code>，依旧无法启动，排除。说明根本还没到这一步就死了，确认问题是根文件系统无法挂载。</p></li><li><p>控制变量法：<br />替换根文件系统为正点原子官方的根文件系统并烧写，依旧启动卡死。怀疑是内核问题。</p></li><li><p>替换内核为官方Linux内核；uboot、根文件系统、dtb使用自己的并烧写——成功启动。</p></li><li><p>懵逼。按理来说内核4.0跨到6.0版本，时间跨度很大，dtb文件应该不适用才对。也就是说我使用 4.0 的内核应该不能适配 6.0 的 dtb 文件。</p></li></ol><h4 id="最后排查原因"><a class="markdownIt-Anchor" href="#最后排查原因"></a> 最后排查原因：</h4><p>dtb文件烧写错误。。。。。我错误的将<code>zImage-imx6ull-14x14-evk-emmc.dtb</code> 命名为了 <code>zImage-imx6ull-14x14-evk.dtb</code>，导致我使用新内核启动时，使用的还是是nxp官方的旧的内核的dtb文件，而不是新的。。。两者不适配。</p><p>最后还得感谢ai的质疑精神）我给ai说我确认dtb文件正确，ai看了我的日志后提出了质疑，并帮助我排查出了原因，也是nb。。。。</p><p><img src="Snipaste_2025-11-13_20-11-17.png" alt="" /></p><h2 id="定制化脚本"><a class="markdownIt-Anchor" href="#定制化脚本"></a> 定制化脚本</h2><p>待补充。。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="系统移植" scheme="https://blog.godmao.top/categories/Linux/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="mfgtool" scheme="https://blog.godmao.top/Tags/mfgtool/"/>
    
  </entry>
  
  <entry>
    <title>编程随想</title>
    <link href="https://blog.godmao.top/posts/42114/"/>
    <id>https://blog.godmao.top/posts/42114/</id>
    <published>2025-11-02T11:20:06.000Z</published>
    <updated>2025-11-02T13:08:22.117Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><p>在一切开始之前，只有一片寂静的“原初之石”（嵌入式设备）。</p><h2 id="第一章启程者uboot的誓约"><a class="markdownIt-Anchor" href="#第一章启程者uboot的誓约"></a> 第一章：启程者U·Boot的誓约</h2><p>在永恒的黑暗中，第一位生灵觉醒了，他是启程者U·Boot。U·Boot是一位不朽的守誓人，他的存在只有一个目的：开启世界。</p><p>当启动的信号闪烁，U·Boot立刻开始了他的神圣仪式：他首先叩击了“原初之石”的脉络（初始化硬件），确认每一个节点——从宏大的记忆之河到微小的时钟之弦——都已准备就绪。</p><p>U·Boot知道，他无法独自构建世界。他必须唤醒那位沉睡的，真正的造物主。他奔向古老的智慧之塔（存储器），找到并抬起了沉重的命运之卷。他将这卷轴——那是核心法则的记录——庄严地放置在清醒之所（内存）的中央。</p><p>U·Boot深深地鞠躬，他望向那卷轴，低语道：“我的使命已终。核心啊，醒来吧，时间已到。” 他将所有的力量和权限，都倾注给了这卷轴，然后，U·Boot的光芒隐去，他完成了对黎明的誓约。</p><h2 id="第二章律法之魂kernel的诞生"><a class="markdownIt-Anchor" href="#第二章律法之魂kernel的诞生"></a> 第二章：律法之魂Kernel的诞生</h2><p>当U·Boot的光芒熄灭，律法之魂Kernel被唤醒了。</p><p>Kernel是世界的内在灵魂，它没有具体的形态，却是一切秩序的源泉。Kernel诞生的第一件事，就是建立律法。</p><p>它向四周伸出无数看不见的触手，拥抱并驾驭了整个“原初之石”（加载驱动程序，接管硬件）。现在，它能听到每一次输入，能控制每一次输出。</p><p>它在广阔的空间内划定了界限（内存管理），制定了时间分配的铁律（进程调度），确保每一个未来的思绪和行动都能得到公平的资源。</p><p>Kernel拥有了管理世界的绝对能力，但它环顾四周，发现自己身处一个有法则却无色彩的空旷世界。它像一位孤独的君王，拥有无上的权力，却没有臣民，没有诗歌，没有生命存在的意义。</p><p>“我的律法需要一个国度来承载，需要一个故事来讲述。” Kernel低语。</p><h2 id="第三章世界之华rootfs的盛开"><a class="markdownIt-Anchor" href="#第三章世界之华rootfs的盛开"></a> 第三章：世界之华RootFS的盛开</h2><p>Kernel沿着旧日信标指引的道路，找到了那片被尘封的宝库——那里储存着人类文明所有的积淀与梦想，它就是世界之华RootFS。</p><p>Kernel用律法的力量，将宝库的大门打开（挂载 RootFS），并伸出触手，唤醒了宝库中沉睡的第一个声音：先知 init。</p><p>先知 init 醒来，在Kernel律法的框架下开始了他的工作。</p><p>他迅速地摆放了日常所需的工具（基础命令、配置），让世界有了可操作的逻辑。</p><p>他依次唤醒了吟游诗人的歌谣（应用程序）、哲人的手稿（配置文件）和工匠的工具（服务进程）。</p><p>至此，Kernel的律法框架与RootFS的丰富内容完美结合。世界不再是空洞的法则，而是充满生机、可以感知、可以创造的完整存在。</p><p>启程者U·Boot开启了诞生；律法之魂Kernel赋予了秩序；世界之华RootFS成就了意义。三位一体，构成了完整的生命觉醒之旅。</p><h2 id="附录1世界之华的十大景观"><a class="markdownIt-Anchor" href="#附录1世界之华的十大景观"></a> 附录1：世界之华的十大景观</h2><h3 id="root-和-home君王和臣民的私域"><a class="markdownIt-Anchor" href="#root-和-home君王和臣民的私域"></a> /root 和 /home：君王和臣民的私域</h3><p>/root(君王的静室)：这是律法之魂Kernel的私人居所。只有他拥有最高的权限，用于处理最核心、最私密的政务。外人不得擅入。</p><p>/home(臣民的村落)：这是所有在国度中生活和创造的个体（用户）的专属领地。每个臣民在自己的屋子里书写自己的故事，彼此独立，但都在科恩的律法之下。</p><h3 id="bin-和-sbin勇士和祭司的武器库"><a class="markdownIt-Anchor" href="#bin-和-sbin勇士和祭司的武器库"></a> /bin 和 /sbin：勇士和祭司的武器库</h3><p>/bin(勇士的佩剑)：存放着所有普通居民（用户）都可以使用的日常工具和技能。比如：ls（点清财物）、cp（搬运物品）。它们是国度最常用的动作。</p><p>/sbin(祭司的法杖)：存放着只有最高祭司（系统管理员或 Kernel）才能动用的神圣工具。这些工具用于维护国度的根本稳定，如格式化土地、修复城墙等。</p><h3 id="etc国度的古老法典"><a class="markdownIt-Anchor" href="#etc国度的古老法典"></a> /etc：国度的古老法典</h3><p>/etc(古老的法典与契约)：存放着国度运行的所有规定和契约（配置文件）。它规定了谁（用户）能做什么，何时（服务）启动，以及如何（网络配置）与外界交流。它是世界的运行蓝图。</p><h3 id="usr知识与文化的殿堂"><a class="markdownIt-Anchor" href="#usr知识与文化的殿堂"></a> /usr：知识与文化的殿堂</h3><p>/usr(文化的宝库与学院)：Unix Software Resourse 存放着非核心但极其庞大的知识、艺术和工具。所有的吟游诗人的歌谣（库文件 /usr/lib）、学者的手稿（头文件 /usr/include）和复杂的巨型应用（/usr/bin）都集中于此，是国度的文明象征。</p><h3 id="dev与生俱来的感知器官"><a class="markdownIt-Anchor" href="#dev与生俱来的感知器官"></a> /dev：与生俱来的感知器官</h3><p>/dev(与生俱来的感知器官)：它不是真正的文件，而是Kernel与生俱来的“感知器官”（设备文件）。通过这些器官，灵魂可以直接触摸（读写）外界的光线（显示器）、倾听外界的声音（声卡）和感受外界的震动（键盘）。</p><h3 id="proc-和-sys世界的实时心跳与镜像"><a class="markdownIt-Anchor" href="#proc-和-sys世界的实时心跳与镜像"></a> /proc 和 /sys：世界的实时心跳与镜像</h3><p>/proc(世界的实时心跳)：它是一个魔法的镜子，实时映射出Kernel的每一个思绪和每一次呼吸（进程信息）。它不存储任何实物，只是Kernel当前状态的投影。</p><p>/sys(世界的生理数据)：它是一个精密的温度计和测量仪，详细展示国度的生理数据（硬件和驱动状态）。</p><h3 id="tmp-和-var时间的沙漏与变化"><a class="markdownIt-Anchor" href="#tmp-和-var时间的沙漏与变化"></a> /tmp 和 /var：时间的沙漏与变化</h3><p>/tmp(流逝的沙漏)： 存放着短暂的、易逝的思绪（临时文件）。一旦日出日落（重启），这些思绪便会随风消逝。</p><p>/var(变化的记录簿)： 存放着所有不断增长、不断变化的历史记录。比如：守夜人的日志（日志文件 /var/log）和来往的信件（邮件 /var/mail）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="系统移植" scheme="https://blog.godmao.top/categories/Linux/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用BusyBox构建根文件系统</title>
    <link href="https://blog.godmao.top/posts/30149/"/>
    <id>https://blog.godmao.top/posts/30149/</id>
    <published>2025-11-02T10:57:57.000Z</published>
    <updated>2025-11-13T13:12:12.354Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1. 前言</h2><h3 id="11-最小根文件系统"><a class="markdownIt-Anchor" href="#11-最小根文件系统"></a> 1.1. 最小根文件系统</h3><p>一个最精简的文件系统包含什么呢？<br />我们知道，内核挂载根文件系统后，第一件事是就是启动 /sbin 目录下的 init 程序作为第一个进程，init 程序读取 /etc 目录下的配置文件，再根据配置文件启动其他 app。同时这些app又有可能是动态链接的，所以我们还需要 /lib 文件夹，包含一些头文件。<br />此外，bootloader 也会在根文件系统启动内核，内核需要在根文件系统中读取设备树文件以控制硬件，这有了 /boot 文件夹。<br />有了设备树，自然少不了 /dev 目录。最小的/dev目录，只要包含 console 与 null。<br />综上，我们可以总结出一个最小的根文件系统有什么：</p><ol><li>init 程序</li><li>其他的必要app</li><li>配置文件</li><li>lib库（用于动态链接）</li><li>内核zImage</li><li>dtb设备树文件</li><li>/dev</li></ol><p>1点属于/sbin，2点属于/bin ，3点属于/etc，4点属于/lib，5、6点属于/boot。</p><p>如果更极致的话，甚至可以使用静态链接，静态编译应用程序，这样就不用 /lib ，也不使用其他app，就一个init程序实现想要的功能即可——当然这是理想化的。</p><h3 id="12-关于-systemv-和-systemd"><a class="markdownIt-Anchor" href="#12-关于-systemv-和-systemd"></a> 1.2. 关于 systemV 和 systemd</h3><p>我们上面所说的 init 其实说的就是 system V 的启动方式——串行启动，一个脚本执行完再启动下一个。与 system V 相比，systemd 更加现代化且更好——并行启动，通过依赖关系图同时启动多个服务、启动速度快、依赖关系明确等等…<br />但是，在嵌入式linux坏境中却并不一定好用，因为它太重了，依赖也多。而且对于使用 systemd 的嵌入式系统来说，根文件系统也不应该用 busybox 来构建。busybox生成的 init 实际上就是类似于 system V 的 init 实现。</p><h3 id="13-what-is-busybox"><a class="markdownIt-Anchor" href="#13-what-is-busybox"></a> 1.3. What is BusyBox？</h3><p>BusyBox<strong>并不是一个根文件系统制作工具</strong>，它只是极大地简化了 /bin、/sbin 等目录的搭建。<br />BusyBox 是一个集成了上百个常用 UNIX 命令的小型可执行文件。</p><p>当你在 shell 中输入：<code>ls</code><br />实际上调用：<code>/bin/busybox ls</code><br />BusyBox 会根据你执行的命令名自动表现成对应工具的行为。</p><p>它的设计哲学是：</p><ul><li>只实现最核心的功能；</li><li>去掉冗余；</li><li>用最小的代码体积覆盖最大功能。</li></ul><p>从这里可以看出，它非常适合嵌入式系统。</p><h2 id="2-编译busybox"><a class="markdownIt-Anchor" href="#2-编译busybox"></a> 2. 编译BusyBox</h2><p>首先在makefile中指定交叉编译器，避免每次make都要传入编译器参数。</p><p><img src="Snipaste_2025-11-05_18-15-55.png" alt="" /></p><p>使用命令 <code>make help</code> 查看make选项。</p><h3 id="21-生成配置文件"><a class="markdownIt-Anchor" href="#21-生成配置文件"></a> 2.1. 生成配置文件</h3><p>我们先使用默认的配置文件。</p><p>使用命令 <code>make menuconfig</code> 或者 <code>make defconfig</code> 都可以。我们选择menuconfig，方便我们配置一些选项：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入配置界面后，我们可以指定一下编译器前缀 ：<br />将 Settings → Build Options → Cross Compiler prefix 中指定为 <code>arm-none-linux-gnueabihf-</code>。</p><p>也可以启用 Build static binary (no shared libs) 以实现静态编译，不用使用动态共享库省去自己构建库文件的步骤，代价是根文件系统大小大一些。空间换时间（bushi</p><p>其他的根据自己需求修改（如果看得懂的话）。</p><p>同时最好关闭硬件加速项SHA，也就是这两项：</p><p><img src="Snipaste_2025-11-05_18-22-47.png" alt="" /></p><p>我使用的1.37.0版本 busybox，即使使用默认配置文件，什么也不做修改，也无法编译成功，会报错：“libbb/hash_md5_sha.c:1316:35: error: ‘sha1_process_block64_shaNI’ undeclared (first use in this function);”</p><p>查阅后发现可能是CPU不支持硬件加速的问题，所以就将 Settings 选项里的两个硬件加速选项关了。不知道是官方的bug还是什么…</p><h3 id="22-编译并安装busybox"><a class="markdownIt-Anchor" href="#22-编译并安装busybox"></a> 2.2. 编译并安装BusyBox</h3><p>编译没啥好说的，<code>make</code> 即可。</p><p>用 <code>CONFIG_PREFIX</code> 指定文件夹。将busybox 安装到指定文件夹，也就是拟用于构建根文件系统的那个文件夹嘛，前面我们也说了，busybox就相当于把 /sbin /bin 这两块拼图做好了。</p><blockquote><p>安装实际上就是建立软链接，链接到 /bin/busybox 。所以一定要确定好路径，要是不小心指定到本机Linux的根目录下不就废了吗。😦</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">CONFIG_PREFIX</span><span class="token operator">=~</span>/shared/rootfs_tmp  <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="Snipaste_2025-11-05_18-43-14.png" alt="" /></p><p><img src="Snipaste_2025-11-10_14-54-29.png" alt="" /></p><h2 id="3-完善根文件系统"><a class="markdownIt-Anchor" href="#3-完善根文件系统"></a> 3. 完善根文件系统</h2><p>目前根文件系统最基本的操作工具就有了，但是还缺少必要的文件夹，比如dev、sys等。</p><p>但是我们不必在这里创建这些文件夹。还记得之前提到的初始化脚本吗，内核启动并挂载根文件系统后，做的第一件事就是运行 /sbin/init 。而这个程序又在做什么呢，busybox的init程序大概做这三件事：</p><ol><li>读取 <code>/etc/inittab</code>（如果有）；</li><li>启动第一个初始化脚本 <code>/etc/init.d/rcS</code>；</li><li>最后启动 shell。</li></ol><p><code>inittab</code>：init 程序的配置文件</p><p><code>/etc/init.d/rcS</code>：run commands for system。一个普通的 shell 脚本，但它是由 init 启动的第一个脚本，负责初始化系统的环境。</p><p>因此我们可以在rcS脚本中添加这些必要文件。所以我们只需要在现在的根文件系统中添加以下几个文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> etc/init.d/rcS<span class="token function">mkdir</span> etc/inittab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="31-rcs-的编写"><a class="markdownIt-Anchor" href="#31-rcs-的编写"></a> 3.1. rcS 的编写</h3><p>大致内容如下，已附详细注释及常见问题：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token comment"># rcS - minimal BusyBox startup script</span><span class="token comment"># 这些文件夹的具体用途可以参见我的另一篇文章《编程随想》</span><span class="token builtin class-name">echo</span> <span class="token string">">>> Create the necessary folder if it does not exist..."</span><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /sys /dev /proc /tmp /run /var<span class="token comment"># mount -t &lt;文件系统类型> &lt;设备> &lt;挂载点></span><span class="token comment"># none：占位符。因为这里并不是“挂载某个磁盘”，</span><span class="token comment"># 而是在请求内核“把它内部的数据结构以文件形式呈现出来”</span><span class="token comment"># 文件系统类型 (`proc`, `sysfs`) 是内核内置的。</span><span class="token comment"># 系统并不会去磁盘上找“proc”，</span><span class="token comment"># 它调用的是内核内部的 `procfs_mount()` 函数。</span><span class="token comment"># 这里挂载的并不是设备，而是VFS，所以设备为“none”。</span><span class="token builtin class-name">echo</span> <span class="token string">">>> Mounting proc to /proc..."</span><span class="token function">mount</span> <span class="token parameter variable">-t</span> proc none /proc<span class="token builtin class-name">echo</span> <span class="token string">">>> Mounting sysfs to /sys..."</span><span class="token function">mount</span> <span class="token parameter variable">-t</span> sysfs none /sys<span class="token comment"># devtmpfs介绍：</span><span class="token comment"># 这是一个内核级的临时文件系统，</span><span class="token comment"># 自动由内核在设备注册时创建对应的设备节点。</span><span class="token comment"># 而无需什么mknod，udev，mdev。</span><span class="token comment"># 为什么是“临时”？因为它是重启后就需要重新生成。</span><span class="token comment"># 我发现在内核启动过程中已自动挂载devtmpfs，</span><span class="token comment"># 所以就不用再挂一遍。</span><span class="token comment"># --devtmpfs has already auto mounted.--</span><span class="token keyword">if</span> <span class="token operator">!</span> <span class="token function">mount</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-q</span> <span class="token string">"on /dev "</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token builtin class-name">echo</span> <span class="token string">">>> Mounting devtmpfs to /dev..."</span>    <span class="token function">mount</span> <span class="token parameter variable">-t</span> devtmpfs devtmpfs /dev<span class="token keyword">else</span>    <span class="token builtin class-name">echo</span> <span class="token string">">>> /dev already mounted by kernel"</span><span class="token keyword">fi</span><span class="token builtin class-name">echo</span> <span class="token string">">>> Setting up essential directories..."</span><span class="token function">mount</span> <span class="token parameter variable">-t</span> tmpfs tmpfs /tmp<span class="token function">mount</span> <span class="token parameter variable">-t</span> tmpfs tmpfs /run<span class="token comment"># setting hostname</span><span class="token builtin class-name">echo</span> <span class="token string">"mark1"</span> <span class="token operator">></span> /proc/sys/kernel/hostname<span class="token comment"># exec命令功能：</span><span class="token comment">#- 执行命令并替换掉当前进程（不会新建子进程）；</span><span class="token comment">#- 如果只带重定向而没有命令，</span><span class="token comment">#则会改变当前 shell 的文件描述符绑定。</span><span class="token comment">#这里的作用是把当前脚本进程直接替换为`/bin/sh`。</span><span class="token comment">#不再返回，也不再继续执行后续脚本。</span><span class="token comment"># Unix 的进程默认有三条流：</span><span class="token comment">#- `0` — 标准输入（stdin）</span><span class="token comment">#- `1` — 标准输出（stdout）</span><span class="token comment">#- `2` — 标准错误（stderr）</span><span class="token comment">#&lt; /dev/ttymxc0：</span><span class="token comment">#表示把标准输入改为从`/dev/ttymxc0`读取。</span><span class="token comment">#> /dev/ttymxc0：</span><span class="token comment">#表示把标准输出改为写入`/dev/ttymxc0`。</span><span class="token comment">#2>&amp;1：</span><span class="token comment">#表示把标准错误也重定向到标准输出的同一个地方。</span><span class="token comment"># 为什么这样做：</span><span class="token comment"># 如果直接exec到sh，则会提示：</span><span class="token comment"># /bin/sh: can't access tty;job control turned off</span><span class="token comment"># 意思是当前 shell 没有绑定到一个真正的终端（tty），</span><span class="token comment"># 所以 Ctrl+C、Ctrl+Z、作业控制等功能无法使用。</span><span class="token builtin class-name">echo</span> <span class="token string">">>> System ready. Starting shell..."</span><span class="token builtin class-name">exec</span> /bin/sh <span class="token operator">&lt;</span> /dev/ttymxc0 <span class="token operator">></span> /dev/ttymxc0 <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="32-inittab的编写"><a class="markdownIt-Anchor" href="#32-inittab的编写"></a> 3.2. inittab的编写</h3><p>当内核启动 <code>/sbin/init</code>（比如 BusyBox 的 init）时，init 会读取这个文件，<br />决定应该执行哪些命令、启动哪些脚本、在哪些终端上提供登录。</p><p>换句话说，它定义了：</p><ul><li>系统开机时做什么；</li><li>哪些脚本要执行；</li><li>哪些终端需要打开 shell。<br />所以，它就像系统启动的“行动计划表”。</li></ul><h4 id="321-inittab-的基本格式"><a class="markdownIt-Anchor" href="#321-inittab-的基本格式"></a> 3.2.1. <code>inittab</code> 的基本格式</h4><p>每一行是一条指令，格式通常是：</p><p><code>&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</code></p><p>但在 BusyBox 的简化版本中，<code>runlevels</code> 通常被忽略，<br />所以我们常见的是这样的：</p><p><code>::action:/path/to/command</code></p><h4 id="322-常见的-action-类型"><a class="markdownIt-Anchor" href="#322-常见的-action-类型"></a> 3.2.2. 常见的 action 类型</h4><p>让我们来看几个经典例子（尤其在 BusyBox 系统中）：</p><ol><li><p><code>sysinit</code></p><p>系统初始化时运行，通常挂载虚拟文件系统、创建目录等：</p><p><code>::sysinit:/etc/init.d/rcS</code></p><p>表示：在系统启动时，执行 <code>/etc/init.d/rcS</code> 脚本。</p></li><li><p><code>respawn</code></p><p>表示该进程如果退出，init 会重新启动它（循环重启）。<br />常用于启动终端或守护进程：</p><p><code>ttyS0::respawn:/sbin/getty -L ttyS0 115200 vt100</code></p><p>表示：在串口 ttyS0 上启动一个终端，波特率 115200，终端类型 vt100。</p></li><li><p><code>askfirst</code></p><p>和 <code>respawn</code> 类似，但在启动前会提示 “Press ENTER to activate this console”。<br />常用于开发板上的交互式 shell：</p><p><code>tty1::askfirst:/bin/sh</code></p></li><li><p><code>wait</code></p><p>表示执行完后等待命令退出再继续。<br />通常在系统初始化阶段使用：</p><p><code>::wait:/etc/init.d/rc.local</code></p></li></ol><h4 id="323-例子"><a class="markdownIt-Anchor" href="#323-例子"></a> 3.2.3. 例子</h4><pre class="line-numbers language-none"><code class="language-none">::sysinit:&#x2F;etc&#x2F;init.d&#x2F;rcS::askfirst:-&#x2F;bin&#x2F;sh::ctrlaltdel:&#x2F;bin&#x2F;umount -a -r::shutdown:&#x2F;bin&#x2F;umount -a -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-构建lib目录如果是动态编译"><a class="markdownIt-Anchor" href="#4-构建lib目录如果是动态编译"></a> 4. 构建lib目录（如果是动态编译）</h2><p>busybox默认是动态编译的，当然你可以在menuconfig中指定静态编译。</p><p>那么库在哪里呢？我们在使用工具链编译链接的时候，并没有报错，说明我们使用的工具链中含有这些库。我们从工具链中复制这些库到 /lib 。</p><p>那我们工具链的库又在哪呢？我们可以输入这么一行命令来获取到库路径：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"void main()&#123;&#125;"</span> <span class="token operator">|</span> arm-none-linux-gnueabihf-gcc <span class="token parameter variable">-E</span> <span class="token parameter variable">-v</span> -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">LIBRARY_PATH&#x3D;&#x2F;home&#x2F;gdm&#x2F;prjts&#x2F;ARM_TOOLCHAIN&#x2F;AArch32-Linux&#x2F;arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;arm-none-linux-gnueabihf&#x2F;14.3.1&#x2F;:&#x2F;home&#x2F;gdm&#x2F;prjts&#x2F;ARM_TOOLCHAIN&#x2F;AArch32-Linux&#x2F;arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;:&#x2F;home&#x2F;gdm&#x2F;prjts&#x2F;ARM_TOOLCHAIN&#x2F;AArch32-Linux&#x2F;arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;arm-none-linux-gnueabihf&#x2F;14.3.1&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;arm-none-linux-gnueabihf&#x2F;lib&#x2F;:&#x2F;home&#x2F;gdm&#x2F;prjts&#x2F;ARM_TOOLCHAIN&#x2F;AArch32-Linux&#x2F;arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf&#x2F;bin&#x2F;..&#x2F;arm-none-linux-gnueabihf&#x2F;libc&#x2F;lib&#x2F;:&#x2F;home&#x2F;gdm&#x2F;prjts&#x2F;ARM_TOOLCHAIN&#x2F;AArch32-Linux&#x2F;arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf&#x2F;bin&#x2F;..&#x2F;arm-none-linux-gnueabihf&#x2F;libc&#x2F;usr&#x2F;lib&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>他们都是以 /home/gdm/prjts/ARM_TOOLCHAIN/AArch32-Linux/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf/bin/…/ 开头。也就是工具链源路径。</p><p>令 “/home/gdm/prjts/ARM_TOOLCHAIN/AArch32-Linux/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-linux-gnueabihf/bin/…/” = [工具链源路径]</p><p>化简整理得：</p><pre class="line-numbers language-none"><code class="language-none">[工具链源路径]&#x2F;lib&#x2F;gcc&#x2F;arm-none-linux-gnueabihf&#x2F;14.3.1&#x2F;[工具链源路径]&#x2F;lib&#x2F;gcc&#x2F;[工具链源路径]&#x2F;lib&#x2F;gcc&#x2F;arm-none-linux-gnueabihf&#x2F;14.3.1&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;arm-none-linux-gnueabihf&#x2F;lib&#x2F;[工具链源路径]&#x2F;arm-none-linux-gnueabihf&#x2F;libc&#x2F;lib&#x2F;[工具链源路径]&#x2F;arm-none-linux-gnueabihf&#x2F;libc&#x2F;usr&#x2F;lib&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>ldd</code> 命令介绍：<code>ldd</code> 是 Linux 系统中用于显示可执行文件或共享库所依赖的动态链接库的命令行工具。它可以帮助开发者快速了解程序运行时的依赖关系，解决库缺失或版本冲突等问题。</p></blockquote><p>我们使用工具链中提供的 <code>readelf</code> 工具来查看 busybox 所需的动态链接库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">arm-none-linux-gnueabihf-readelf <span class="token parameter variable">-d</span> bin/busybox <span class="token operator">|</span> <span class="token function">grep</span> NEEDED<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>-d 就是显示动态库。</p></blockquote><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">0x00000001 (NEEDED) Shared library: [libm.so.6]0x00000001 (NEEDED) Shared library: [libresolv.so.2]0x00000001 (NEEDED) Shared library: [libc.so.6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接着就在上面提到的工具链库中找呀找，最后在倒数第二个库中找到了这几个依赖。</p><p><img src="Snipaste_2025-11-05_21-48-39.png" alt="" /></p><p>还要注意的是这些文件是不是软链接，如果是软链接，则需要将链接到的源文件也拷贝到 /lib。并在使用cp命令时加上 <code>-d</code> 选项，使其保持链接特性。</p><p>这里我用 <code>ls -l</code> 查看了，都不是软链接。</p><p>直接cp：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> libc.so.6 libm.so.6 libresolv.so.2 ~/shared/rootfs_tmp/lib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还要cp一个链接器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> ld-linux-armhf.so.3 ~/shared/rootfs_tmp/lib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr /><p style="font-size:30px"> <strong>下面的内容已不再适用。但是有一些内容值得做一些参考。</strong></p><hr /><h2 id="old5-构建boot目录"><a class="markdownIt-Anchor" href="#old5-构建boot目录"></a> [old]5. 构建boot目录</h2><p>把之前编译好的内核生成的dtb文件和zImage文件拷贝到根文件的 /boot 目录即可。</p><h2 id="old6-构建dev目录"><a class="markdownIt-Anchor" href="#old6-构建dev目录"></a> [old]6. 构建dev目录</h2><p>最小dev目录我们只要满足标准输出就好了，也就是能够输出信息。</p><p>我们可以先查看我们 linux 系统里的 console 设备是怎么创建的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /dev/console <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">crw------- 1 root root 5, 1 Nov  6 15:35 &#x2F;dev&#x2F;console<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们仿照这个用 <code>mknod</code> 命令在rootfs/dev目录创建：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mknod</span> console c <span class="token number">5</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同理创建 null 设备，</p><p>仿照：</p><pre class="line-numbers language-none"><code class="language-none">crw-rw-rw- 1 root root 1, 3 Nov  6 15:35 &#x2F;dev&#x2F;null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mknod</span> null c <span class="token number">1</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="old7-刻录映像文件"><a class="markdownIt-Anchor" href="#old7-刻录映像文件"></a> [old]7. 刻录映像文件</h2><h3 id="71-刻录"><a class="markdownIt-Anchor" href="#71-刻录"></a> 7.1. 刻录</h3><p>使用genimage这个工具来生成image文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> genimage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">image emmc.img&#123;hdimage &#123;                 &#x2F;&#x2F;生成DOS分区images。&#125;partition rootfs-1 &#123;partition-type &#x3D; 0xCbootable &#x3D; &quot;yes&quot;image &#x3D; &quot;boot.vfat&quot;  &#x2F;&#x2F;路径由 $&#123;INPUTPATH&#125; 指定size &#x3D; 12M&#125;partition rootfs-2 &#123;partition-type &#x3D; 0x83bootable &#x3D; &quot;yes&quot;image &#x3D; &quot;myrootfs.ext4&quot;size &#x3D; 34M&#125;&#125;image boot.vfat &#123;vfat &#123;files &#x3D; &#123; &quot;u-boot-dtb.imx&quot; &#125; &#x2F;&#x2F;路径由 &#123;INPUTPATH&#125; 指定&#125;size &#x3D; 10M&#125;image myrootfs.ext4 &#123;ext4&#123;&#125;name &#x3D; &quot;root&quot;size &#x3D; 32M &#x2F;&#x2F;根据自己的根文件系统大小调整mountpoint &#x3D; &quot;&#x2F;&quot; &#x2F;&#x2F;路径由 &#123;ROOTPATH&#125; 指定&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们现在只是测试，可以先随便创建一个&quot;u-boot-dtb.imx&quot;文件，比方说我创建这个文件，并在里面写入一个“test”字符串。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">genimage <span class="token punctuation">\</span><span class="token parameter variable">--rootpath</span> <span class="token string">"/home/gdm/shared/rootfs_tmp"</span> <span class="token punctuation">\</span><span class="token parameter variable">--inputpath</span> <span class="token string">"/home/gdm/shared/gen_image"</span> <span class="token punctuation">\</span><span class="token parameter variable">--outputpath</span> <span class="token string">"/home/gdm/shared/gen_image/output"</span> <span class="token punctuation">\</span><span class="token parameter variable">--tmppath</span> <span class="token string">"/home/gdm/shared/gen_image/tmp"</span> <span class="token punctuation">\</span><span class="token parameter variable">--config</span> <span class="token string">"genimage.cfg"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="711-issue1"><a class="markdownIt-Anchor" href="#711-issue1"></a> 7.1.1. issue#1</h4><p>执行后报错：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;bin&#x2F;sh: 1: genext2fs: not found<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据提示安装 genext2fs:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> genext2fs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="72-验证"><a class="markdownIt-Anchor" href="#72-验证"></a> 7.2. 验证</h3><p>我们可以使用 <code>fdisk</code> 工具验证一下生成的 emmc.img:</p><p><img src="Snipaste_2025-11-06_17-06-12.png" alt="" /></p><p>与配置文件中的如出一辙。</p><p><strong>另外我们学习一下在Linux下装载镜像文件：</strong></p><p><code>losetup</code> 命令允许用户将文件映射到循环设备（如/dev/loop0），从而使文件能够被视为块设备。这种方式常用于挂载ISO镜像文件或其他磁盘映像文件，使其可以像真实的磁盘一样进行访问和操作。</p><p>查看循环设备：<code>losetup</code> 或 <code>losetup -a</code> 。</p><ol><li>创建循环设备文件并映射镜像文件：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">losetup <span class="token parameter variable">-P</span> /dev/loop3 ./emmc.img<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-P</code> 是指扫描镜像文件分区，创建带有分区的循环设备。</p><ol start="2"><li>查看循环设备信息：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /dev/loop3*输出：/dev/loop3  /dev/loop3p1  /dev/loop3p2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li>挂载分区1：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mount</span> /dev/loop3p1 /mnt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>查看文件：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /mnt输出：u-boot-dtb.imx<span class="token function">ls</span> <span class="token parameter variable">-l</span> /mnt输出：total <span class="token number">2</span>-rwxr-xr-x <span class="token number">1</span> root root <span class="token number">5</span> Nov  <span class="token number">7</span>  <span class="token number">2025</span> u-boot-dtb.imx<span class="token function">cat</span> /mnt/u-boot-dtb.imx输出：<span class="token builtin class-name">test</span><span class="token function">sudo</span> <span class="token function">umount</span> /mnt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>同理查看分区2：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mount</span> /dev/loop3p2 /mnt<span class="token function">ls</span> <span class="token parameter variable">-l</span> /mnt输出：total <span class="token number">27</span>drwxr-xr-x <span class="token number">2</span> gdm  gdm   <span class="token number">3072</span> Nov  <span class="token number">5</span> <span class="token number">18</span>:35 bindrwxr-xr-x <span class="token number">2</span> gdm  gdm   <span class="token number">1024</span> Nov  <span class="token number">5</span> <span class="token number">22</span>:10 bootdrwxr-xr-x <span class="token number">2</span> gdm  gdm   <span class="token number">1024</span> Nov  <span class="token number">6</span> <span class="token number">15</span>:45 devdrwxr-xr-x <span class="token number">2</span> gdm  gdm   <span class="token number">1024</span> Nov  <span class="token number">5</span> <span class="token number">22</span>:01 liblrwxrwxrwx <span class="token number">1</span> gdm  gdm     <span class="token number">11</span> Nov  <span class="token number">5</span> <span class="token number">18</span>:35 linuxrc -<span class="token operator">></span> bin/busyboxdrwx------ <span class="token number">2</span> root root <span class="token number">16384</span> Nov  <span class="token number">6</span> <span class="token number">17</span>:04 lost+founddrwxr-xr-x <span class="token number">2</span> gdm  gdm   <span class="token number">3072</span> Nov  <span class="token number">5</span> <span class="token number">18</span>:35 sbindrwxr-xr-x <span class="token number">4</span> gdm  gdm   <span class="token number">1024</span> Nov  <span class="token number">5</span> <span class="token number">18</span>:35 usr<span class="token function">sudo</span> <span class="token function">umount</span> /mnt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li>卸除循环设备：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> losetup <span class="token parameter variable">-d</span> /dev/loop3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="系统移植" scheme="https://blog.godmao.top/categories/Linux/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="rootfs" scheme="https://blog.godmao.top/Tags/rootfs/"/>
    
    <category term="根文件系统" scheme="https://blog.godmao.top/Tags/%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="busybox" scheme="https://blog.godmao.top/Tags/busybox/"/>
    
  </entry>
  
  <entry>
    <title>mx6ull开发版移植nxp官方linux内核</title>
    <link href="https://blog.godmao.top/posts/44016/"/>
    <id>https://blog.godmao.top/posts/44016/</id>
    <published>2025-10-31T07:53:56.000Z</published>
    <updated>2025-11-24T03:28:26.099Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><blockquote><p>基于野火 I.MX6ULL S1 Pro 开发板。</p></blockquote><h2 id="1-获取内核源码"><a class="markdownIt-Anchor" href="#1-获取内核源码"></a> 1. 获取内核源码</h2><p>访问nxp官网：<br /><a href="https://www.nxp.com/design/design-center/software/embedded-software/i-mx-software/embedded-linux-for-i-mx-applications-processors:IMXLINUX">用于 i.MX 应用处理器的嵌入式 Linux |恩智浦半导体 — Embedded Linux for i.MX Applications Processors | NXP Semiconductors</a></p><p>可以看到，截至目前，官方维护版本是：<code>6.6.52_2.2.1</code> ，因此我们基于此内核构建。</p><p><img src="Snipaste_2025-10-31_15-55-24.png" alt="" /></p><p>在官方github库中获取源码：<br /><a href="https://github.com/nxp-imx/linux-imx/releases/tag/lf-6.6.52-2.2.1">Release lf-6.6.52-2.2.1 · nxp-imx/linux-imx</a></p><h2 id="2-编译内核源码"><a class="markdownIt-Anchor" href="#2-编译内核源码"></a> 2. 编译内核源码</h2><p>我是用的是Arm官方工具链<code>arm-none-linux-gnueabihf</code>：<a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">Arm GNU Toolchain Downloads – Arm Developer</a></p><p>和uboot源码编译类似：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-none-linux-gnueabihf- distclean <span class="token comment"># 清除编译后的文件</span><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-none-linux-gnueabihf- imx_v7_defconfig <span class="token comment"># 配置文件</span><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-none-linux-gnueabihf- <span class="token parameter variable">-j10</span> <span class="token comment"># 10核编译，首次编译时间比较长</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译完成会生成：</p><ul><li><strong>zImage</strong>：压缩的内核镜像，位于 <code>arch/arm/boot/zImage</code></li><li><strong>dtb</strong>：设备树文件，位于 <code>arch/arm/boot/dts/nxp/imx/imx6ull-14x14-evk-emmc.dtb</code></li></ul><h2 id="3-测试在uboot中启动"><a class="markdownIt-Anchor" href="#3-测试在uboot中启动"></a> 3. 测试：在uboot中启动</h2><p>请参见——<a href="obsidian://open?vault=_posts&amp;file=mx6ull%E5%BC%80%E5%8F%91%E7%89%88%E7%A7%BB%E6%A4%8Dnxp%E5%AE%98%E6%96%B9u-boot">mx6ull开发版移植nxp官方u-boot</a> 3.2节。</p><blockquote><p>启动成功后，如果EMMC中是没有rootfs的，或者指定了错误的块设备或分区，会提示panic，挂载不了rootfs，这是正常的。</p></blockquote><p>我们可以看到启动日志的第二行：</p><pre class="line-numbers language-none"><code class="language-none">Linux version 6.6.52 (gdm@mDoG)(arm-none-linux-gnueabihf-gcc (Arm GNU Toolchain 14.3.Rel1 (Build arm-14.174)) 14.3.1 20250623,GNU ld (Arm GNU Toolchain 14.3.Rel1 (Build arm-14.174)) 2.44.0.20250616)#1 SMP PREEMPT Fri Oct 31 16:15:58 CST 2025<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明这确实是我们编译的内核。</p><h2 id="4-创建自己的dts文件和config文件"><a class="markdownIt-Anchor" href="#4-创建自己的dts文件和config文件"></a> 4. 创建自己的dts文件和config文件</h2><h3 id="41-dts"><a class="markdownIt-Anchor" href="#41-dts"></a> 4.1. dts</h3><p>打开 <code>arch/arm/boot/dts/nxp/imx/</code> ，可以看到许多dts文件，我们以<br /><code>imx6ull-14x14-evk.dts</code> 为模板创建，为什么不用 <code>imx6ull-14x14-evk-emmc.dts</code> 呢？查看文件 <code>imx6ull-14x14-evk-emmc.dts</code>：</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;imx6ull-14x14-evk.dts&quot;&amp;usdhc2 &#123;    pinctrl-names &#x3D; &quot;default&quot;, &quot;state_100mhz&quot;, &quot;state_200mhz&quot;;    pinctrl-0 &#x3D; &lt;&amp;pinctrl_usdhc2_8bit&gt;;    pinctrl-1 &#x3D; &lt;&amp;pinctrl_usdhc2_8bit_100mhz&gt;;    pinctrl-2 &#x3D; &lt;&amp;pinctrl_usdhc2_8bit_200mhz&gt;;    bus-width &#x3D; &lt;8&gt;;    non-removable;    status &#x3D; &quot;okay&quot;;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们发现其实它只是在 <code>imx6ull-14x14-evk.dts</code> 的基础上加了 usdhc2 的修改。<br /><strong>所以我们只需要将这个 &amp;usdhc2 里的内容复制到 <code>imx6ull-14x14-evk.dts</code> 后面就可以了。</strong></p><p>我将自己的配置文件命名为：<code>mx6ull-14x14-evk[gdm-main].dts</code>，表示这是以 <code>imx6ull-14x14-evk.dts</code> 为模板创建的，且是主要文件。因为这个 dts 文件还包含了其他的 dtsi 文件——也就是 dts 的头文件，后续我们如果要修改头文件中的内容，也将头文件复制下来改名作修改，并在 dts 文件中包含这个复制后的头文件，这样可以避免直接修改源文件导致其他的 dts 配置错误（因为头文件不只在一个文件中包含）。</p><p><strong>然后打开 <code>arch/arm/boot/dts/nxp/imx/Makefile</code> 添加 <code>mx6ull-14x14-evk[gdm-main].dtb</code> 的make目标。</strong></p><h3 id="42-defconfig"><a class="markdownIt-Anchor" href="#42-defconfig"></a> 4.2. defconfig</h3><p>同理，以 <code>arch/arm/configs/imx_v7_defconfig</code> 为模板创建。</p><h3 id="43-编译下载启动"><a class="markdownIt-Anchor" href="#43-编译下载启动"></a> 4.3. 编译下载启动</h3><p>重复本篇第2节、第3节的内容。如果 EMMC 里有 rootfs 并正确配置，则可正常启动</p><hr /><p style="font-size:30px"> <strong>以下为补充部分</strong></p><hr /><h2 id="5-主频修改"><a class="markdownIt-Anchor" href="#5-主频修改"></a> 5. 主频修改</h2><p>进入到系统后（我的是buildroot）使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /proc/cpuinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看cpu信息输出：</p><pre class="line-numbers language-none"><code class="language-none">processor       : 0model name      : ARMv7 Processor rev 5 (v7l)BogoMIPS        : 24.00Features        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpaeCPU implementer : 0x41CPU architecture: 7CPU variant     : 0x0CPU part        : 0xc07CPU revision    : 5Hardware        : Freescale i.MX6 Ultralite (Device Tree)Revision        : 0000Serial          : 2f39b9d75d68c574<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>BogoMIPS 这一条，此时 BogoMIPS 为 24.00，BogoMIPS 是 Linux 系统中<br />衡量处理器运行速度的一个“尺子”，处理器性能越强，主频越高，BogoMIPS 值就越大。<br />BogoMIPS 只是粗略的计算 CPU 性能，并不十分准确。</p><p>我们再来看看如何查看工作频率及相关信息。</p><p>进入到目录 <code>/sys/bus/cpu/devices/cpu0/cpufreq</code>:</p><pre class="line-numbers language-none"><code class="language-none">affected_cpus                  scaling_cur_freqcpuinfo_cur_freq               scaling_drivercpuinfo_max_freq               scaling_governorcpuinfo_min_freq               scaling_max_freqcpuinfo_transition_latency     scaling_min_freqrelated_cpus                   scaling_setspeedscaling_available_frequencies  statsscaling_available_governors<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此目录中记录了 CPU 频率等信息，这些文件的含义如下：</p><table><thead><tr><th>目录项</th><th>描述</th></tr></thead><tbody><tr><td>cpuinfo_cur_freq</td><td>当前 cpu 工作频率，从 CPU 寄存器读取到的工作频率。</td></tr><tr><td>cpuinfo_max_freq</td><td>处理器所能运行的最高工作频率(单位: KHz）。</td></tr><tr><td>cpuinfo_min_freq</td><td>处理器所能运行的最低工作频率(单位: KHz）。</td></tr><tr><td>cpuinfo_transition_latency</td><td>处理器切换频率所需要的时间(单位:ns)。</td></tr><tr><td>scaling_available_frequencies</td><td>处理器支持的主频率列表(单位: KHz）。</td></tr><tr><td>scaling_available_governors</td><td>当前内核中支持的所有 governor(调频)类型。</td></tr><tr><td>scaling_cur_freq</td><td>保存着 cpufreq 模块缓存的当前 CPU 频率，不会对 CPU 硬件寄存器进行检查。</td></tr><tr><td>scaling_driver</td><td>该文件保存当前 CPU 所使用的调频驱动。</td></tr><tr><td>scaling_max_freq</td><td>governor(调频)可以调节的最高频率。</td></tr><tr><td>cpuinfo_min_freq</td><td>governor(调频)可以调节的最低频率。</td></tr></tbody></table><p>此外还有：</p><ul><li><p><strong>scaling_governor</strong>：governor(调频)策略，Linux 内核一共有 5 中调频策略，</p><ol><li><code>Performance</code>：最高性能，直接用最高频率，不考虑耗电。</li><li><code>Interactive</code>：一开始直接用最高频率，然后根据 CPU 负载慢慢降低。</li><li><code>Powersave</code>：省电模式，通常以最低频率运行，系统性能会受影响，一般不会用这个！</li><li><code>Userspace</code>：可以在用户空间手动调节频率。</li><li><code>Ondemand</code>，：定时检查负载，然后根据负载来调节频率。负载低的时候降低 CPU 频率，这样省电，负载高的时候提高 CPU 频率，增加性能。</li></ol></li><li><p><strong>stats</strong> 目录下给出了 CPU 各种运行频率的统计情况，比如 CPU 在各频率下的运行时间及变频次数。</p></li></ul><p>使用命令查看各参数的值：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token punctuation">[</span>目录项<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会发现当前调度模式是 <code>Ondemand</code>。</p><p>如果我想让我们的板子一直满血运行，怎么做？我们只需图形化配置defconfig文件。</p><p>进入到 kernel 源码目录，使用命令打开图形化配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="Snipaste_2025-10-31_23-08-34.png" alt="" /></p><p>进入 <code>CPU Power Management</code>-&gt; <code>CPU Frequency scaling</code>-&gt; <code>Default CPUFreq governor</code> ，选择performance，再次编译（不用distclean清理），再传进开发板。</p><p>再次查看就可以发现：</p><p><img src="Snipaste_2025-10-31_23-15-11.png" alt="" /></p><p><strong>当然日常使用还是 <code>Ondemand</code> 更好，所以我还是换回 <code>Ondemand</code> 了。</strong></p><p>至此，我们以修改主频为引，介绍了如何调试修改配置文件并应用修改。</p><p>–end–</p><h2 id="6-系统网络测试"><a class="markdownIt-Anchor" href="#6-系统网络测试"></a> 6. 系统网络测试</h2><p>野火的板子PHY芯片使用的和nxp官方的一样，因此直接适配nxp官方linux内核，不用修改设备树文件，所以这里讲一下网络测试。</p><p>进入到系统后，默认是没有启用任何一个网络驱动设备的，使用 <code>ifconfig</code> 命令可能只会显示一个“loc”。所以我们输入命令查看所有的网络驱动设备：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ifconfig</span> <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：</p><p><img src="Snipaste_2025-11-02_18-29-44.png" alt="" /></p><p>我通过MAC地址分辨出我应该启用的是 <code>eth0</code> 它正通过网线连接着我的电脑，输入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ifconfig</span> eth0 up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启用后，我们通过 <code>ifconfig</code> 命令就能查看到这个设备了。但是这个网卡都还没<br />有 IP 地址，所以不能进行 ping 等操作。</p><p>所以我们为其分配 ip 地址：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ifconfig</span> eth0 <span class="token number">192.168</span>.137.145<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在就能 ping 通我的电脑了。<br />我的电脑以太网卡 ip 地址为 192.168.137.1：</p><p><img src="Snipaste_2025-11-02_18-38-02.png" alt="" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="系统移植" scheme="https://blog.godmao.top/categories/Linux/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="内核移植" scheme="https://blog.godmao.top/Tags/%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>mx6ull开发版移植nxp官方u-boot</title>
    <link href="https://blog.godmao.top/posts/26288/"/>
    <id>https://blog.godmao.top/posts/26288/</id>
    <published>2025-10-29T08:25:32.000Z</published>
    <updated>2025-11-06T10:42:21.504Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="1-我写尼玛"><a class="markdownIt-Anchor" href="#1-我写尼玛"></a> 1. 我写尼玛！</h2><p>我他妈直接不想码字。<br />我他妈直接转载。</p><p><strong>移植和烧录部分：</strong><br />作者：觉皇嵌入式 遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议。<br /><a href="https://blog.csdn.net/qq153471503/article/details/126587387">i.MX6ULL - 从零开始移植uboot-imx_v2020.04_5.4.70_2.3.0-CSDN博客</a></p><hr /><blockquote><p><strong>以下为后续补充</strong></p></blockquote><h2 id="2-图形化配置"><a class="markdownIt-Anchor" href="#2-图形化配置"></a> 2. 图形化配置</h2><p>在uboot目录下，使用命令：</p><pre class="line-numbers language-none"><code class="language-none">make menuconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以通过图形化界面配置uboot，更加直观。</p><h2 id="3-u-boot-启动linux测试"><a class="markdownIt-Anchor" href="#3-u-boot-启动linux测试"></a> 3. U-boot 启动Linux测试</h2><h3 id="31-从emmc启动emmc里有原厂自带文件"><a class="markdownIt-Anchor" href="#31-从emmc启动emmc里有原厂自带文件"></a> 3.1. 从EMMC启动（EMMC里有原厂自带文件）</h3><h4 id="311-查看"><a class="markdownIt-Anchor" href="#311-查看"></a> 3.1.1. 查看</h4><p>首先检查EMMC里面是否有——Linux镜像zImage、.dtb文件和根文件系统。</p><p>我们当前的mmc环境是SD卡，切换到EMMC。输入命令：</p><pre class="line-numbers language-none"><code class="language-none">mmc dev 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>具体EMMC的设备号 根据实际情况输入。</p></blockquote><p>该开发板EMMC分区是这样的：</p><ul><li>分区0：是存放boot的，</li><li>分区1：存放linux镜像和设备树，</li><li>分区2：存放root。</li></ul><blockquote><p>可以使用 <code>fstype mmc dev:part</code> 命令查看文件系统格式。<br />其中 dev是EMMC的设备号，part是分区号。运行后：<br />分区0输出 <code>Unrecognized...</code>；<br />分区1输出 <code>fat</code> ；分区2输出 <code>ext4</code>。</p></blockquote><p>分区1使用的文件系统是FAT，因此用 <code>fatls</code> 查看EMMC分区1里面的文件：</p><pre class="line-numbers language-none"><code class="language-none">fatls mmc dev:part<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">7863120   zImage    38733   imx6ull-mmc-npi-lite.dtb2 file(s), 0 dir(s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>说明系统和设备树是存在的。</p><h4 id="312-加载系统相关命令"><a class="markdownIt-Anchor" href="#312-加载系统相关命令"></a> 3.1.2. 加载系统相关命令</h4><ul><li><p><strong>查看指定的镜像加载地址：</strong></p><p><code>printenv loadaddr</code></p><p>输出为 <code>0x80800000</code></p></li><li><p><strong>查看指定的设备树加载地址：</strong></p><p><code>printenv fdt_addr</code></p><p>输出为 <code>0x83000000</code></p></li><li><p><strong>把zImage加载到地址 <code>0x80800000</code>：</strong></p><p><code>fatload mmc 1:1 80800000 zImage</code></p></li><li><p><strong>把设备树加载到地址 <code>0x83000000</code></strong>：</p><p><code>fatload mmc 1:1 83000000 imx6ull-mmc-npi-lite.dtb</code></p></li><li><p><strong>启动内核：</strong><br /><code>bootz 80800000 - 83000000</code></p></li></ul><h4 id="313-设置bootcmd"><a class="markdownIt-Anchor" href="#313-设置bootcmd"></a> 3.1.3. 设置bootcmd</h4><p><code>bootcmd</code> 是一个环境变量，保存着 uboot 默认命令，uboot 倒计时结束以后就会执行 bootcmd 中的命令。这些命令一般都是用来启动 Linux 内核的，比如读取 EMMC 或者 NAND Flash 中的 Linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 Linux 内核。</p><pre class="line-numbers language-none"><code class="language-none">setenv bootcmd &#39;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-mmc-npi-lite.dtb; bootz 80800000 - 83000000;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="314-设置bootargs"><a class="markdownIt-Anchor" href="#314-设置bootargs"></a> 3.1.4. 设置bootargs</h4><details><summary> 关于bootargs的介绍有点长，折叠一下。</summary><p>bootargs 保存着 uboot 传递给 Linux 内核的参数，bootargs 环境变量是由 mmcargs 设置的，mmcargs 环境变量如下：<br /><code>mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; root=$&#123;mmcroot&#125;</code></p><p>其中 console=ttymxc0，baudrate=115200，mmcroot=/dev/mmcblk0p2 rootwait rw，</p><p>因此将mmcargs 展开以后就是：<br /><code>mmcargs=setenv bootargs console= ttymxc0, 115200 root= /dev/mmcblk0p2 rootwait rw</code></p><p>可以看出环境变量 mmcargs 就是设置 bootargs 的值为<code>console= ttymxc0, 115200 root=/dev/mmcblk1p2 rootwait rw</code>，</p><p>bootargs 就是设置了很多的参数的值，这些参数 Linux 内核会使用到，常用的参数有：</p><ul><li><strong>console：</strong><br />console 用来设置 linux 终端(或者叫控制台)，也就是通过什么设备来和 Linux 进行交互，例如串口、 LCD 屏幕。如果是串口的话应该是串口几、波特率等。一般设置串口作为 Linux 终端，这样我们就可以在电脑上通过串口程序来和 linux 交互了。这里设置 console 为 ttymxc0，因为 linux启动以后 I.MX6ULL 的串口 1 在 linux 下的设备文件就是/dev/ttymxc0，”一切皆文件“。</li><li><strong>root：</strong><br />root 用来设置根文件系统的位置，例如，<code>root=/dev/mmcblk1p2</code> 指根文件系统存放在 mmcblk1 设备的分区 2 中。<br /><code>rootwait rw</code>。rootwait 表示等待 mmc 设备初始化完成以后再挂载，否则的话mmc 设备还没初始化完成就挂载根文件系统会出错的。rw 表示根文件系统是可以读写的，不加 rw 的话可能无法在根文件系统中进行写操作，只能进行读操作。</li><li><strong>rootfstype：</strong><br />此选项一般配置 root 一起使用，rootfstype 用于指定根文件系统类型，如果根文件系统为ext 格式的话此选项无所谓。如果根文件系统是 yaffs、jffs 或 ubifs 的话就需要设置此选项，指定根文件系统的类型。</li></ul></details><p>设置：</p><pre class="line-numbers language-none"><code class="language-none">setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;mmcblk1p2 rootwait rw&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="315-启动"><a class="markdownIt-Anchor" href="#315-启动"></a> 3.1.5. 启动</h4><p>使用命令 <code>run bootcmd</code> 或 在切换到EMMC环境后直接输入<code>boot</code>。</p><h3 id="32-从网络启动"><a class="markdownIt-Anchor" href="#32-从网络启动"></a> 3.2. 从网络启动</h3><h4 id="321-安装-tftpd-hpa-和客户端工具"><a class="markdownIt-Anchor" href="#321-安装-tftpd-hpa-和客户端工具"></a> 3.2.1. 安装 tftpd-hpa 和客户端工具</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> tftpd-hpa tftp-hpa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="322-创建共享目录并开放权限"><a class="markdownIt-Anchor" href="#322-创建共享目录并开放权限"></a> 3.2.2. 创建共享目录并开放权限</h4><p>TFTP 的默认根目录是 <code>/srv/tftp</code>，你也可以改成别的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /srv/tftp<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token number">777</span> /srv/tftp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后把要传的文件（比如 <code>uImage</code>）放进去：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> ~/uImage /srv/tftp/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="323-手动启动-tftp-服务因为没有-systemctl"><a class="markdownIt-Anchor" href="#323-手动启动-tftp-服务因为没有-systemctl"></a> 3.2.3. 手动启动 TFTP 服务（因为没有 systemctl）</h4><p>直接运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> /usr/sbin/in.tftpd <span class="token parameter variable">--foreground</span> <span class="token parameter variable">--secure</span> <span class="token parameter variable">--verbose</span> /srv/tftp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>–foreground：在前台运行</li><li>–secure：只允许访问指定目录</li><li>–verbose：打印详细日志</li></ul><blockquote><p>还有一些选项，例如：<br />–address <a href="ip:port">ip:port</a>：指定 TFTP 服务监听的 IP 地址和端口。<br />–blocksize &lt;大小&gt;：指定一个数据包的大小。<br />–create：允许客户端上传。</p></blockquote><p>这会在前台启动服务器（按 <code>Ctrl+C</code> 可停止）。</p><p>如果你想让它<strong>后台运行</strong>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> /usr/sbin/in.tftpd <span class="token parameter variable">--secure</span> /srv/tftp <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="324-确认服务在监听-udp-69-端口"><a class="markdownIt-Anchor" href="#324-确认服务在监听-udp-69-端口"></a> 3.2.4. 确认服务在监听 UDP 69 端口</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">netstat</span> <span class="token parameter variable">-anu</span> <span class="token operator">|</span> <span class="token function">grep</span> :69<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ss <span class="token parameter variable">-anu</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">69</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现类似：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">udp   UNCONN  0      0      0.0.0.0:69    0.0.0.0:*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明启动成功。</p><h4 id="325-让-u-boot-能访问-wsl-的-ip"><a class="markdownIt-Anchor" href="#325-让-u-boot-能访问-wsl-的-ip"></a> 3.2.5. 让 U-Boot 能访问 WSL 的 IP</h4><p>这是关键部分。<br />WSL 和 Windows 的网络是<strong>桥接但不完全共享的</strong>，所以开发板不能直接访问 <code>127.0.0.1</code> 或 <code>localhost</code>。</p><ol><li>在 Windows 里执行：</li></ol><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">ipconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到 <strong>以太网适配器 vEthernet (WSL)</strong> 这一项。<br />它通常是类似 <code>172.25.x.x</code> 或 <code>192.168.137.x</code> 的 IP，比如：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">IPv4 Address. . . . . . . . . . . : 172.27.240.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>在 U-Boot 里设置：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">setenv serverip <span class="token number">192.168</span>.137.1setenv ipaddr <span class="token number">192.168</span>.137.144<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li><p>关闭防火墙：<br />在设置——网络与Internet——高级网络设置——Windows防火墙，将公用网络中的防火墙暂时关闭。</p></li><li><p>测试：</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ping</span> <span class="token number">192.168</span>.137.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果显示 “host is alive”，说明连通。</p><h4 id="326-传文件"><a class="markdownIt-Anchor" href="#326-传文件"></a> 3.2.6. 传文件</h4><p>假设你要下载 <code>/srv/tftp/uImage</code> 到内存地址 <code>0x80800000</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tftp 0x80800000 uImage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看到类似输出：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx"><span class="token directive"><span class="token keyword">Using</span> FEC deviceTFTP from server 172.27.240.1</span><span class="token punctuation">;</span> our IP address is 172.27.240.166Filename 'uImage'.Load address: 0x80800000Loading: <span class="token comment">#########################################</span>doneBytes transferred = 3456789 (34abcd hex)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就成功了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="系统移植" scheme="https://blog.godmao.top/categories/Linux/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="u-boot移植" scheme="https://blog.godmao.top/Tags/u-boot%E7%A7%BB%E6%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>大蟒蛇-typer库</title>
    <link href="https://blog.godmao.top/posts/40650/"/>
    <id>https://blog.godmao.top/posts/40650/</id>
    <published>2025-10-28T13:11:11.000Z</published>
    <updated>2025-10-28T14:28:40.778Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="一-安装"><a class="markdownIt-Anchor" href="#一-安装"></a> 一、安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> typer<span class="token punctuation">[</span>all<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>[all]</code> 会额外安装颜色和补全功能（推荐）。</p><h2 id="二-最简单的例子"><a class="markdownIt-Anchor" href="#二-最简单的例子"></a> 二、最简单的例子</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> typer<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Hello </span><span class="token interpolation"><span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 app.py gdm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-none"><code class="language-none">Hello gdm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Typer 会自动解析命令行参数并生成帮助：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 app.py <span class="token parameter variable">--help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Usage: app.py [OPTIONS] NAMEArguments:  NAME  [required]Options:  --help  Show this message and exit.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三-带类型提示的参数解析"><a class="markdownIt-Anchor" href="#三-带类型提示的参数解析"></a> 三、带类型提示的参数解析</h2><p>Typer 会根据<strong>Python 类型注解</strong>自动转换输入：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> active<span class="token punctuation">:</span> <span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Name: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span></span><span class="token string">, Age: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>age<span class="token punctuation">&#125;</span></span><span class="token string">, Active: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>active<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 app.py gdm <span class="token number">25</span> <span class="token parameter variable">--active</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或关闭 active：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 app.py gdm <span class="token number">25</span> --no-active<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="四-使用选项options"><a class="markdownIt-Anchor" href="#四-使用选项options"></a> 四、使用选项（Options）</h2><p>如果你希望某个参数是可选的、带前缀的选项，可以用 <code>typer.Option</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">str</span> <span class="token operator">=</span> typer<span class="token punctuation">.</span>Option<span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">"名字"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> repeat<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> typer<span class="token punctuation">.</span>Option<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">"重复次数"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>repeat<span class="token punctuation">)</span><span class="token punctuation">:</span>        typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Hello </span><span class="token interpolation"><span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 app.py <span class="token parameter variable">--name</span> gdm <span class="token parameter variable">--repeat</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="五-使用参数arguments"><a class="markdownIt-Anchor" href="#五-使用参数arguments"></a> 五、使用参数（Arguments）</h2><p><code>typer.Argument()</code> 用于定义<strong>位置参数</strong>，即必需参数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>filename<span class="token punctuation">:</span> <span class="token builtin">str</span> <span class="token operator">=</span> typer<span class="token punctuation">.</span>Argument<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">"文件路径"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Processing file: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>filename<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>...</code> 表示必须提供。</p><p>示例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 app.py data.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="六-命令分组多个子命令"><a class="markdownIt-Anchor" href="#六-命令分组多个子命令"></a> 六、命令分组（多个子命令）</h2><p>你可以像写 Git 一样定义多命令结构。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> typerapp <span class="token operator">=</span> typer<span class="token punctuation">.</span>Typer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>command</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>command</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">sub</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    app<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 app.py <span class="token function">add</span> <span class="token number">3</span> <span class="token number">5</span>python3 app.py sub <span class="token number">10</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>帮助信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 app.py <span class="token parameter variable">--help</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Commands:  add  sub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="七-默认命令入口函数"><a class="markdownIt-Anchor" href="#七-默认命令入口函数"></a> 七、默认命令（入口函数）</h2><p>如果只定义一个命令，也可以这样写：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> typerapp <span class="token operator">=</span> typer<span class="token punctuation">.</span>Typer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>command</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">greet</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Hi </span><span class="token interpolation"><span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    app<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="八-提示输入prompt"><a class="markdownIt-Anchor" href="#八-提示输入prompt"></a> 八、提示输入（Prompt）</h2><p>Typer 支持交互式输入：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>password<span class="token punctuation">:</span> <span class="token builtin">str</span> <span class="token operator">=</span> typer<span class="token punctuation">.</span>Option<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> prompt<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> hide_input<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span><span class="token string">"Password received!"</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行后会提示输入密码而不回显。</p><h2 id="九-颜色输出"><a class="markdownIt-Anchor" href="#九-颜色输出"></a> 九、颜色输出</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">typer<span class="token punctuation">.</span>secho<span class="token punctuation">(</span><span class="token string">"成功!"</span><span class="token punctuation">,</span> fg<span class="token operator">=</span>typer<span class="token punctuation">.</span>colors<span class="token punctuation">.</span>GREEN<span class="token punctuation">,</span> bold<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>typer<span class="token punctuation">.</span>secho<span class="token punctuation">(</span><span class="token string">"警告!"</span><span class="token punctuation">,</span> fg<span class="token operator">=</span>typer<span class="token punctuation">.</span>colors<span class="token punctuation">.</span>YELLOW<span class="token punctuation">)</span>typer<span class="token punctuation">.</span>secho<span class="token punctuation">(</span><span class="token string">"错误!"</span><span class="token punctuation">,</span> fg<span class="token operator">=</span>typer<span class="token punctuation">.</span>colors<span class="token punctuation">.</span>RED<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="十-退出与错误"><a class="markdownIt-Anchor" href="#十-退出与错误"></a> 十、退出与错误</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> error<span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span><span class="token string">"Something went wrong."</span><span class="token punctuation">)</span>    <span class="token keyword">raise</span> typer<span class="token punctuation">.</span>Exit<span class="token punctuation">(</span>code<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">typer<span class="token punctuation">.</span>Abort<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 相当于 Ctrl+C</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="十一-自动补全"><a class="markdownIt-Anchor" href="#十一-自动补全"></a> 十一、自动补全</h2><p>为终端安装 Typer 补全脚本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">app --install-completion<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后重启终端。</p><h2 id="十二-复杂结构嵌套命令"><a class="markdownIt-Anchor" href="#十二-复杂结构嵌套命令"></a> 十二、复杂结构（嵌套命令）</h2><p>可以创建多个 <code>Typer</code> 实例，并注册子命令模块：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> typerapp <span class="token operator">=</span> typer<span class="token punctuation">.</span>Typer<span class="token punctuation">(</span><span class="token punctuation">)</span>user_app <span class="token operator">=</span> typer<span class="token punctuation">.</span>Typer<span class="token punctuation">(</span><span class="token punctuation">)</span>app<span class="token punctuation">.</span>add_typer<span class="token punctuation">(</span>user_app<span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@user_app<span class="token punctuation">.</span>command</span><span class="token punctuation">(</span><span class="token string">"create"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">create_user</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Created user: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    app<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python app.py user create gdm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="十三-与click兼容"><a class="markdownIt-Anchor" href="#十三-与click兼容"></a> 十三、与Click兼容</h2><p>Typer 基于 Click，可以混用 Click 的函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> typer<span class="token keyword">import</span> click<span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>command</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@click<span class="token punctuation">.</span>option</span><span class="token punctuation">(</span><span class="token string">"--debug/--no-debug"</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>debug<span class="token punctuation">)</span><span class="token punctuation">:</span>    typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Debug = </span><span class="token interpolation"><span class="token punctuation">&#123;</span>debug<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十四-完整示例"><a class="markdownIt-Anchor" href="#十四-完整示例"></a> 十四、完整示例</h2><p>一个带颜色、帮助信息、命令组、选项的综合例子：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> typerapp <span class="token operator">=</span> typer<span class="token punctuation">.</span>Typer<span class="token punctuation">(</span><span class="token builtin">help</span><span class="token operator">=</span><span class="token string">"一个简单的文件处理工具"</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>command</span><span class="token punctuation">(</span><span class="token builtin">help</span><span class="token operator">=</span><span class="token string">"读取文件内容"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        typer<span class="token punctuation">.</span>echo<span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token decorator annotation punctuation">@app<span class="token punctuation">.</span>command</span><span class="token punctuation">(</span><span class="token builtin">help</span><span class="token operator">=</span><span class="token string">"统计文件行数"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    lines <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token builtin">file</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    typer<span class="token punctuation">.</span>secho<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token builtin">file</span><span class="token punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>lines<span class="token punctuation">&#125;</span></span><span class="token string"> lines"</span></span><span class="token punctuation">,</span> fg<span class="token operator">=</span>typer<span class="token punctuation">.</span>colors<span class="token punctuation">.</span>GREEN<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    app<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大蟒蛇-rich库</title>
    <link href="https://blog.godmao.top/posts/30447/"/>
    <id>https://blog.godmao.top/posts/30447/</id>
    <published>2025-10-28T13:10:46.000Z</published>
    <updated>2025-10-28T14:08:58.528Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="rich-库新手使用指南"><a class="markdownIt-Anchor" href="#rich-库新手使用指南"></a> 🪶 Rich 库新手使用指南</h2><p><code>Rich</code> 是一个超强的 Python 库，用来让终端输出变得<strong>漂亮、有色彩、有格式</strong>。<br />它可以显示<strong>彩色文字、表格、进度条、Markdown、高亮代码、日志信息</strong>等。</p><p>安装非常简单：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip <span class="token function">install</span> rich<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导入方式：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich <span class="token keyword">import</span> <span class="token keyword">print</span><span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Console<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="一-彩色输出基础"><a class="markdownIt-Anchor" href="#一-彩色输出基础"></a> 一、彩色输出基础</h3><p>Rich 自带的 <code>print</code> 可以直接使用类似 BBCode 的标签上色。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich <span class="token keyword">import</span> <span class="token keyword">print</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[bold red]错误：[/bold red] 文件未找到！"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[green]任务完成！[/green]"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[yellow on black]警告：内存不足[/yellow on black]"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>[color]文字[/color]</code><br />支持样式如：<code>bold</code>, <code>italic</code>, <code>underline</code>, <code>red</code>, <code>green</code>, <code>blue</code>, <code>on color</code>, <code>blink</code> 等。</p><h3 id="二-使用-console-对象更灵活"><a class="markdownIt-Anchor" href="#二-使用-console-对象更灵活"></a> 二、使用 Console 对象（更灵活）</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Consoleconsole <span class="token operator">=</span> Console<span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"普通输出"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[bold magenta]高亮输出[/bold magenta]"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token string">"这是带时间戳的日志输出"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三-打印表格"><a class="markdownIt-Anchor" href="#三-打印表格"></a> 三、打印表格</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Console<span class="token keyword">from</span> rich<span class="token punctuation">.</span>table <span class="token keyword">import</span> Tabletable <span class="token operator">=</span> Table<span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token string">"学生成绩"</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>add_column<span class="token punctuation">(</span><span class="token string">"姓名"</span><span class="token punctuation">,</span> style<span class="token operator">=</span><span class="token string">"cyan"</span><span class="token punctuation">,</span> no_wrap<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>add_column<span class="token punctuation">(</span><span class="token string">"科目"</span><span class="token punctuation">,</span> style<span class="token operator">=</span><span class="token string">"magenta"</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>add_column<span class="token punctuation">(</span><span class="token string">"分数"</span><span class="token punctuation">,</span> justify<span class="token operator">=</span><span class="token string">"right"</span><span class="token punctuation">,</span> style<span class="token operator">=</span><span class="token string">"green"</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>add_row<span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"数学"</span><span class="token punctuation">,</span> <span class="token string">"88"</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>add_row<span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token string">"英语"</span><span class="token punctuation">,</span> <span class="token string">"93"</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>add_row<span class="token punctuation">(</span><span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token string">"物理"</span><span class="token punctuation">,</span> <span class="token string">"75"</span><span class="token punctuation">)</span>console <span class="token operator">=</span> Console<span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：彩色、有边框的漂亮表格。</p><h3 id="四-进度条"><a class="markdownIt-Anchor" href="#四-进度条"></a> 四、进度条</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> rich<span class="token punctuation">.</span>progress <span class="token keyword">import</span> track<span class="token keyword">for</span> i <span class="token keyword">in</span> track<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> description<span class="token operator">=</span><span class="token string">"[cyan]正在处理..."</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它会在终端显示一个动态进度条，非常直观。</p><h3 id="五-打印-markdown-文本"><a class="markdownIt-Anchor" href="#五-打印-markdown-文本"></a> 五、打印 Markdown 文本</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Console<span class="token keyword">from</span> rich<span class="token punctuation">.</span>markdown <span class="token keyword">import</span> Markdownmd <span class="token operator">=</span> Markdown<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""# 标题- 支持列表- **加粗**- *斜体*"""</span><span class="token punctuation">)</span>console <span class="token operator">=</span> Console<span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>md<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="六-代码高亮"><a class="markdownIt-Anchor" href="#六-代码高亮"></a> 六、代码高亮</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Console<span class="token keyword">from</span> rich<span class="token punctuation">.</span>syntax <span class="token keyword">import</span> Syntaxcode <span class="token operator">=</span> <span class="token triple-quoted-string string">'''def hello():    print("Hello, world!")'''</span>syntax <span class="token operator">=</span> Syntax<span class="token punctuation">(</span>code<span class="token punctuation">,</span> <span class="token string">"python"</span><span class="token punctuation">,</span> theme<span class="token operator">=</span><span class="token string">"monokai"</span><span class="token punctuation">,</span> line_numbers<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>console <span class="token operator">=</span> Console<span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>syntax<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="七-日志与追踪"><a class="markdownIt-Anchor" href="#七-日志与追踪"></a> 七、日志与追踪</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Console<span class="token keyword">from</span> rich<span class="token punctuation">.</span>traceback <span class="token keyword">import</span> installinstall<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 让报错显示彩色堆栈</span>console <span class="token operator">=</span> Console<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">divide</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> a <span class="token operator">/</span> bdivide<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 会输出带颜色的错误信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="八-组合示例多种元素一起展示"><a class="markdownIt-Anchor" href="#八-组合示例多种元素一起展示"></a> 八、组合示例：多种元素一起展示</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Console<span class="token keyword">from</span> rich<span class="token punctuation">.</span>table <span class="token keyword">import</span> Table<span class="token keyword">from</span> rich<span class="token punctuation">.</span>progress <span class="token keyword">import</span> track<span class="token keyword">from</span> time <span class="token keyword">import</span> sleepconsole <span class="token operator">=</span> Console<span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span>rule<span class="token punctuation">(</span><span class="token string">"[bold green]Rich 示例"</span><span class="token punctuation">)</span>table <span class="token operator">=</span> Table<span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token string">"任务状态"</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>add_column<span class="token punctuation">(</span><span class="token string">"任务名"</span><span class="token punctuation">,</span> style<span class="token operator">=</span><span class="token string">"cyan"</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>add_column<span class="token punctuation">(</span><span class="token string">"状态"</span><span class="token punctuation">,</span> style<span class="token operator">=</span><span class="token string">"magenta"</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> track<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> description<span class="token operator">=</span><span class="token string">"[yellow]执行任务中..."</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    sleep<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span>    table<span class="token punctuation">.</span>add_row<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"任务</span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">,</span> <span class="token string">"完成"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span>console<span class="token punctuation">.</span>rule<span class="token punctuation">(</span><span class="token string">"[bold blue]执行结束"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="九-常见功能速览"><a class="markdownIt-Anchor" href="#九-常见功能速览"></a> 九、常见功能速览</h3><table><thead><tr><th>功能</th><th>模块</th><th>示例</th></tr></thead><tbody><tr><td>彩色文本</td><td>rich.print</td><td>[red]Error[/red]</td></tr><tr><td>表格</td><td>rich.table.Table</td><td>美观的表格输出</td></tr><tr><td>进度条</td><td>rich.progress</td><td>track()</td></tr><tr><td>Markdown</td><td>rich.markdown.Markdown</td><td>渲染 Markdown</td></tr><tr><td>代码高亮</td><td>rich.syntax.Syntax</td><td>高亮 Python 等代码</td></tr><tr><td>日志输出</td><td>console.log()</td><td>彩色时间戳日志</td></tr><tr><td>彩色错误追踪</td><td>rich.traceback.install()</td><td>让异常更清晰</td></tr></tbody></table><h2 id="rich-进阶组件使用指南"><a class="markdownIt-Anchor" href="#rich-进阶组件使用指南"></a> 🌈 Rich 进阶组件使用指南</h2><p>这些功能让你不仅能“美化输出”，还能在终端中<strong>构建交互式信息界面</strong>。<br />主要包括：<code>Panel</code>、<code>Layout</code>、<code>Tree</code>、<code>Live</code>、<code>Columns</code> 等模块。</p><h3 id="一-panel-给内容加上信息卡片边框"><a class="markdownIt-Anchor" href="#一-panel-给内容加上信息卡片边框"></a> 一、Panel —— 给内容加上“信息卡片边框”</h3><p><code>Panel</code> 用来让内容看起来像一块醒目的提示板。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Console<span class="token keyword">from</span> rich<span class="token punctuation">.</span>panel <span class="token keyword">import</span> Panelconsole <span class="token operator">=</span> Console<span class="token punctuation">(</span><span class="token punctuation">)</span>panel <span class="token operator">=</span> Panel<span class="token punctuation">(</span>    <span class="token string">"[bold yellow]操作成功！[/bold yellow]\n数据已保存到数据库。"</span><span class="token punctuation">,</span>    title<span class="token operator">=</span><span class="token string">"通知"</span><span class="token punctuation">,</span>    subtitle<span class="token operator">=</span><span class="token string">"rich.panel 示例"</span><span class="token punctuation">,</span>    border_style<span class="token operator">=</span><span class="token string">"green"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>panel<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以设置：</p><ul><li><code>title</code> / <code>subtitle</code>：上、下标题</li><li><code>border_style</code>：边框颜色</li><li><code>expand=True</code>：让面板占满终端宽度</li></ul><h3 id="二-layout-构建终端界面布局"><a class="markdownIt-Anchor" href="#二-layout-构建终端界面布局"></a> 二、Layout —— 构建终端“界面布局”</h3><p><code>Layout</code> 能让终端像网页一样分区。适合日志面板、状态栏等。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Console<span class="token keyword">from</span> rich<span class="token punctuation">.</span>layout <span class="token keyword">import</span> Layout<span class="token keyword">from</span> rich<span class="token punctuation">.</span>panel <span class="token keyword">import</span> Panelconsole <span class="token operator">=</span> Console<span class="token punctuation">(</span><span class="token punctuation">)</span>layout <span class="token operator">=</span> Layout<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 整体分为上下两部分</span>layout<span class="token punctuation">.</span>split<span class="token punctuation">(</span>    Layout<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"header"</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Layout<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"body"</span><span class="token punctuation">,</span> ratio<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 再把 body 分为左右</span>layout<span class="token punctuation">[</span><span class="token string">"body"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split_row<span class="token punctuation">(</span>    Layout<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"left"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Layout<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"right"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>layout<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span>Panel<span class="token punctuation">(</span><span class="token string">"[bold magenta]Rich Layout 示例"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>layout<span class="token punctuation">[</span><span class="token string">"left"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span>Panel<span class="token punctuation">(</span><span class="token string">"左侧面板内容"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>layout<span class="token punctuation">[</span><span class="token string">"right"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span>Panel<span class="token punctuation">(</span><span class="token string">"右侧面板内容"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>layout<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以使用 <code>split()</code>（上下）或 <code>split_row()</code>（左右）来划分区域。<br />每个区域都能用 <code>.update()</code> 放入 <code>Panel</code>、<code>Table</code>、<code>Markdown</code> 等内容。</p><h3 id="三-tree-生成漂亮的目录结构"><a class="markdownIt-Anchor" href="#三-tree-生成漂亮的目录结构"></a> 三、Tree —— 生成漂亮的目录结构</h3><p><code>Tree</code> 是一个树形结构输出工具，很适合打印文件层级或配置结构。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Console<span class="token keyword">from</span> rich<span class="token punctuation">.</span>tree <span class="token keyword">import</span> Treeconsole <span class="token operator">=</span> Console<span class="token punctuation">(</span><span class="token punctuation">)</span>tree <span class="token operator">=</span> Tree<span class="token punctuation">(</span><span class="token string">"📂 项目结构"</span><span class="token punctuation">)</span>src <span class="token operator">=</span> tree<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"src"</span><span class="token punctuation">)</span>src<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"main.py"</span><span class="token punctuation">)</span>src<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"utils.py"</span><span class="token punctuation">)</span>docs <span class="token operator">=</span> tree<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"docs"</span><span class="token punctuation">)</span>docs<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"readme.md"</span><span class="token punctuation">)</span>tree<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"requirements.txt"</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可搭配 emoji 和颜色使用，让终端目录更直观。</p><h3 id="四-live-实时更新终端内容动态界面"><a class="markdownIt-Anchor" href="#四-live-实时更新终端内容动态界面"></a> 四、Live —— 实时更新终端内容（动态界面）</h3><p><code>Live</code> 能让你持续刷新输出，而不是刷屏。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> rich<span class="token punctuation">.</span>live <span class="token keyword">import</span> Live<span class="token keyword">from</span> rich<span class="token punctuation">.</span>table <span class="token keyword">import</span> Tabletable <span class="token operator">=</span> Table<span class="token punctuation">(</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>add_column<span class="token punctuation">(</span><span class="token string">"任务"</span><span class="token punctuation">)</span>table<span class="token punctuation">.</span>add_column<span class="token punctuation">(</span><span class="token string">"进度"</span><span class="token punctuation">)</span><span class="token keyword">with</span> Live<span class="token punctuation">(</span>table<span class="token punctuation">,</span> refresh_per_second<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        table<span class="token punctuation">.</span>add_row<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"任务 </span><span class="token interpolation"><span class="token punctuation">&#123;</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">,</span> <span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">&#123;</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">20</span><span class="token punctuation">&#125;</span></span><span class="token string">%"</span></span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Live</code> 会在同一块区域动态更新内容，非常适合实时监控或进度显示。</p><h3 id="五-columns-多列并排显示内容"><a class="markdownIt-Anchor" href="#五-columns-多列并排显示内容"></a> 五、Columns —— 多列并排显示内容</h3><p>当你想让一堆内容整齐地排在一行（比如日志或状态栏）时，<code>Columns</code> 是利器。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Console<span class="token keyword">from</span> rich<span class="token punctuation">.</span>columns <span class="token keyword">import</span> Columns<span class="token keyword">from</span> rich<span class="token punctuation">.</span>panel <span class="token keyword">import</span> Panelconsole <span class="token operator">=</span> Console<span class="token punctuation">(</span><span class="token punctuation">)</span>panels <span class="token operator">=</span> <span class="token punctuation">[</span>    Panel<span class="token punctuation">(</span><span class="token string">"CPU: 24%"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"系统状态"</span><span class="token punctuation">,</span> border_style<span class="token operator">=</span><span class="token string">"cyan"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Panel<span class="token punctuation">(</span><span class="token string">"内存: 1.2 GB"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"内存"</span><span class="token punctuation">,</span> border_style<span class="token operator">=</span><span class="token string">"green"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Panel<span class="token punctuation">(</span><span class="token string">"网络: 正常"</span><span class="token punctuation">,</span> title<span class="token operator">=</span><span class="token string">"网络"</span><span class="token punctuation">,</span> border_style<span class="token operator">=</span><span class="token string">"magenta"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>Columns<span class="token punctuation">(</span>panels<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会自动根据终端宽度排版，多列自适应。</p><h3 id="六-progress进阶版-多任务进度条"><a class="markdownIt-Anchor" href="#六-progress进阶版-多任务进度条"></a> 六、Progress（进阶版）—— 多任务进度条</h3><p>之前的 <code>track()</code> 是简化用法。<br />进阶用法可以同时显示多个任务。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> rich<span class="token punctuation">.</span>progress <span class="token keyword">import</span> Progress<span class="token keyword">with</span> Progress<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> progress<span class="token punctuation">:</span>    task1 <span class="token operator">=</span> progress<span class="token punctuation">.</span>add_task<span class="token punctuation">(</span><span class="token string">"[cyan]下载文件A..."</span><span class="token punctuation">,</span> total<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>    task2 <span class="token operator">=</span> progress<span class="token punctuation">.</span>add_task<span class="token punctuation">(</span><span class="token string">"[magenta]下载文件B..."</span><span class="token punctuation">,</span> total<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token keyword">not</span> progress<span class="token punctuation">.</span>finished<span class="token punctuation">:</span>        progress<span class="token punctuation">.</span>update<span class="token punctuation">(</span>task1<span class="token punctuation">,</span> advance<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>        progress<span class="token punctuation">.</span>update<span class="token punctuation">(</span>task2<span class="token punctuation">,</span> advance<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.05</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以随时 <code>update(task_id, advance=x)</code> 来推进进度，非常适合多线程或循环任务。</p><h3 id="七-组合示例一个简易系统监控界面"><a class="markdownIt-Anchor" href="#七-组合示例一个简易系统监控界面"></a> 七、组合示例：一个简易“系统监控界面”</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">from</span> rich<span class="token punctuation">.</span>console <span class="token keyword">import</span> Console<span class="token keyword">from</span> rich<span class="token punctuation">.</span>layout <span class="token keyword">import</span> Layout<span class="token keyword">from</span> rich<span class="token punctuation">.</span>panel <span class="token keyword">import</span> Panel<span class="token keyword">from</span> rich<span class="token punctuation">.</span>live <span class="token keyword">import</span> Liveconsole <span class="token operator">=</span> Console<span class="token punctuation">(</span><span class="token punctuation">)</span>layout <span class="token operator">=</span> Layout<span class="token punctuation">(</span><span class="token punctuation">)</span>layout<span class="token punctuation">.</span>split_column<span class="token punctuation">(</span>    Layout<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"header"</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Layout<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"main"</span><span class="token punctuation">,</span> ratio<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    Layout<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"footer"</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>layout<span class="token punctuation">[</span><span class="token string">"header"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span>Panel<span class="token punctuation">(</span><span class="token string">"[bold green]🖥 系统监控"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>layout<span class="token punctuation">[</span><span class="token string">"footer"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span>Panel<span class="token punctuation">(</span><span class="token string">"按 Ctrl+C 退出"</span><span class="token punctuation">,</span> border_style<span class="token operator">=</span><span class="token string">"red"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">make_main_panel</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> mem<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> Panel<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"CPU 使用率: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>cpu<span class="token punctuation">&#125;</span></span><span class="token string">%\n内存占用: </span><span class="token interpolation"><span class="token punctuation">&#123;</span>mem<span class="token punctuation">&#125;</span></span><span class="token string"> MB"</span></span><span class="token punctuation">,</span> border_style<span class="token operator">=</span><span class="token string">"cyan"</span><span class="token punctuation">)</span><span class="token keyword">with</span> Live<span class="token punctuation">(</span>layout<span class="token punctuation">,</span> refresh_per_second<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        cpu <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span>        mem <span class="token operator">=</span> <span class="token number">500</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>        layout<span class="token punctuation">[</span><span class="token string">"main"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>update<span class="token punctuation">(</span>make_main_panel<span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> mem<span class="token punctuation">)</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行后，你会看到一个实时更新的动态“界面”，像个迷你监控台。</p><h2 id="高级"><a class="markdownIt-Anchor" href="#高级"></a> 高级</h2><p>Rich 的开发者还写了一个基于它的<strong>终端应用框架</strong>：<a href="https://github.com/Textualize/textual"><strong>Textual</strong></a><br />它能让你用 Rich 的基础语法写出带窗口、按钮、滚动区的完整 TUI（终端UI）程序。</p><p>有余力可以学习一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="python" scheme="https://blog.godmao.top/categories/python/"/>
    
    
    <category term="python" scheme="https://blog.godmao.top/Tags/python/"/>
    
    <category term="rich" scheme="https://blog.godmao.top/Tags/rich/"/>
    
  </entry>
  
  <entry>
    <title>大蟒蛇-json库</title>
    <link href="https://blog.godmao.top/posts/50277/"/>
    <id>https://blog.godmao.top/posts/50277/</id>
    <published>2025-10-23T03:25:00.000Z</published>
    <updated>2025-10-27T13:34:29.068Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="jsonload"><a class="markdownIt-Anchor" href="#jsonload"></a> json.load()</h2><p><strong>描述：</strong> 从文件对象读取 JSON 数据并反序列化为 Python 对象<br /><strong>语法：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> cls<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> object_hook<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parse_float<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parse_int<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parse_constant<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> object_pairs_hook<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> json<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'data.json'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    data <span class="token operator">=</span> json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="jsonloads"><a class="markdownIt-Anchor" href="#jsonloads"></a> json.loads()</h2><p><strong>描述：</strong> 从字符串读取 JSON 数据并反序列化为 Python 对象<br /><strong>语法：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> cls<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> object_hook<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parse_float<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parse_int<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parse_constant<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> object_pairs_hook<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span><span class="token string">'&#123;"name": "Alice", "age": 25&#125;'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="jsondump"><a class="markdownIt-Anchor" href="#jsondump"></a> json.dump()</h2><p><strong>描述：</strong> 将 Python 对象序列化为 JSON 并写入文件<br /><strong>语法：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> fp<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> skipkeys<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> ensure_ascii<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> check_circular<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>          allow_nan<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> cls<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> separators<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>          default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> sort_keys<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">&#125;</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'data.json'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>data<span class="token punctuation">,</span> f<span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="jsondumps"><a class="markdownIt-Anchor" href="#jsondumps"></a> json.dumps()</h2><p><strong>描述：</strong> 将 Python 对象序列化为 JSON 字符串<br /><strong>语法：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> skipkeys<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> ensure_ascii<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> check_circular<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>           allow_nan<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> cls<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> separators<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>           default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> sort_keys<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s <span class="token operator">=</span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"x"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"y"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="jsonjsondecoder"><a class="markdownIt-Anchor" href="#jsonjsondecoder"></a> json.JSONDecoder</h2><p><strong>描述：</strong> JSON 反序列化类，可自定义解析逻辑<br /><strong>语法：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">json</span><span class="token punctuation">.</span>JSONDecoder<span class="token punctuation">(</span>object_hook<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> object_pairs_hook<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parse_float<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>                       parse_int<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parse_constant<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">decoder <span class="token operator">=</span> json<span class="token punctuation">.</span>JSONDecoder<span class="token punctuation">(</span><span class="token punctuation">)</span>obj <span class="token operator">=</span> decoder<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'&#123;"a":1,"b":2&#125;'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="jsonjsonencoder"><a class="markdownIt-Anchor" href="#jsonjsonencoder"></a> json.JSONEncoder</h2><p><strong>描述：</strong> JSON 序列化类，可自定义编码行为<br /><strong>语法：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">json</span><span class="token punctuation">.</span>JSONEncoder<span class="token punctuation">(</span>skipkeys<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> ensure_ascii<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> check_circular<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                       allow_nan<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> sort_keys<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> separators<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">encoder <span class="token operator">=</span> json<span class="token punctuation">.</span>JSONEncoder<span class="token punctuation">(</span>indent<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>s <span class="token operator">=</span> encoder<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"test"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="jsonjsondecodeerror"><a class="markdownIt-Anchor" href="#jsonjsondecodeerror"></a> json.JSONDecodeError</h2><p><strong>描述：</strong> 解码 JSON 时的异常类型（继承自 <code>ValueError</code>）<br /><strong>语法：</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span><span class="token string">'invalid json'</span><span class="token punctuation">)</span><span class="token keyword">except</span> json<span class="token punctuation">.</span>JSONDecodeError <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="jsontool命令行模块"><a class="markdownIt-Anchor" href="#jsontool命令行模块"></a> json.tool（命令行模块）</h2><p><strong>描述：</strong> 命令行工具，用于格式化 JSON 输出<br /><strong>语法：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python <span class="token parameter variable">-m</span> json.tool input.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'&#123;"a":1,"b":2&#125;'</span> <span class="token operator">|</span> python <span class="token parameter variable">-m</span> json.tool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参数说明适用于-dumpdumpsloadloads"><a class="markdownIt-Anchor" href="#参数说明适用于-dumpdumpsloadloads"></a> 参数说明（适用于 dump/dumps/load/loads）</h2><h3 id="indent"><a class="markdownIt-Anchor" href="#indent"></a> indent</h3><p>控制缩进格式（整数或字符串）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="separators"><a class="markdownIt-Anchor" href="#separators"></a> separators</h3><p>自定义分隔符（默认 <code>(', ', ': ')</code>）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">,</span> separators<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span> <span class="token string">':'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="sort_keys"><a class="markdownIt-Anchor" href="#sort_keys"></a> sort_keys</h3><p>按键名排序输出</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>data<span class="token punctuation">,</span> sort_keys<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ensure_ascii"><a class="markdownIt-Anchor" href="#ensure_ascii"></a> ensure_ascii</h3><p>是否转义非 ASCII 字符</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"中文"</span><span class="token punctuation">:</span> <span class="token string">"测试"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> ensure_ascii<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="default"><a class="markdownIt-Anchor" href="#default"></a> default</h3><p>定义无法序列化对象的处理函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">encode_complex</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token builtin">complex</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token string">"real"</span><span class="token punctuation">:</span> obj<span class="token punctuation">.</span>real<span class="token punctuation">,</span> <span class="token string">"imag"</span><span class="token punctuation">:</span> obj<span class="token punctuation">.</span>imag<span class="token punctuation">&#125;</span>    <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token punctuation">)</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2j</span><span class="token punctuation">,</span> default<span class="token operator">=</span>encode_complex<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="object_hook"><a class="markdownIt-Anchor" href="#object_hook"></a> object_hook</h3><p>自定义反序列化处理函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">as_person</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> Person<span class="token punctuation">(</span>d<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token string">'name'</span> <span class="token keyword">in</span> d <span class="token keyword">else</span> djson<span class="token punctuation">.</span>loads<span class="token punctuation">(</span><span class="token string">'&#123;"name":"Alice"&#125;'</span><span class="token punctuation">,</span> object_hook<span class="token operator">=</span>as_person<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="parse_float-parse_int-parse_constant"><a class="markdownIt-Anchor" href="#parse_float-parse_int-parse_constant"></a> parse_float, parse_int, parse_constant</h3><p>用于自定义解析数字/常量的函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span><span class="token string">'&#123;"num": 1.23&#125;'</span><span class="token punctuation">,</span> parse_float<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token builtin">round</span><span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="常见用法对比"><a class="markdownIt-Anchor" href="#常见用法对比"></a> 常见用法对比</h2><table><thead><tr><th>操作</th><th>从字符串</th><th>从文件</th><th>输出为字符串</th><th>输出为文件</th></tr></thead><tbody><tr><td>反序列化</td><td>json.loads()</td><td>json.load()</td><td>—</td><td>—</td></tr><tr><td>序列化</td><td>—</td><td>—</td><td>json.dumps()</td><td>json.dump()</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="python" scheme="https://blog.godmao.top/categories/python/"/>
    
    
    <category term="python" scheme="https://blog.godmao.top/Tags/python/"/>
    
    <category term="json" scheme="https://blog.godmao.top/Tags/json/"/>
    
  </entry>
  
  <entry>
    <title>u-boot常见命令</title>
    <link href="https://blog.godmao.top/posts/13859/"/>
    <id>https://blog.godmao.top/posts/13859/</id>
    <published>2025-10-22T09:59:21.000Z</published>
    <updated>2025-10-31T09:56:45.785Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><p>U-Boot（Universal Boot Loader）是嵌入式系统开发中一个非常重要的组件，它负责在操作系统启动之前，进行基本的硬件初始化，并提供一个交互式的命令行接口，以便用户进行系统配置、内核加载等操作。掌握 U-Boot 的常见命令是嵌入式工程师的基本功。</p><p>本文将为您介绍一些 U-Boot 中最常用和最关键的命令及其用途。</p><h2 id="一-环境与信息查看命令"><a class="markdownIt-Anchor" href="#一-环境与信息查看命令"></a> 一、 环境与信息查看命令</h2><p>这些命令用于查看和管理 U-Boot 的运行环境和系统信息。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>用途</strong></th><th><strong>示例</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><code>help</code> 或 <code>?</code></td><td>显示所有可用命令的列表或特定命令的帮助信息。</td><td><code>help</code> / <code>help setenv</code></td><td><code>?</code> 是 <code>help</code> 的别名。</td></tr><tr><td><code>printenv</code></td><td>显示所有的环境变量及其值。</td><td><code>printenv</code></td><td>环境变量通常保存在非易失性存储介质中。</td></tr><tr><td><code>bdinfo</code></td><td>显示板级信息（Board Info Structure），如内存地址、大小等。</td><td><code>bdinfo</code></td><td></td></tr><tr><td><code>version</code></td><td>显示 U-Boot 的版本信息。</td><td><code>version</code></td><td></td></tr></tbody></table><h2 id="二-环境变量操作命令"><a class="markdownIt-Anchor" href="#二-环境变量操作命令"></a> 二、 环境变量操作命令</h2><p>环境变量是 U-Boot 配置系统行为的关键，例如定义启动参数、网络设置等。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>用途</strong></th><th><strong>示例</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><code>setenv</code></td><td>设置或修改一个环境变量的值。</td><td><code>setenv ipaddr 192.168.1.100</code></td><td>更改是临时的，只在当前 U-Boot 会话中生效。</td></tr><tr><td><code>saveenv</code></td><td>将当前内存中的环境变量保存到非易失性存储（如 Flash 或 eMMC）中。</td><td><code>saveenv</code></td><td>使环境变量永久生效。</td></tr><tr><td><code>run</code></td><td>执行存储在一个环境变量中的命令序列。</td><td><code>run bootcmd</code></td><td><code>bootcmd</code> 是一个重要的环境变量，定义了自动启动时执行的命令。</td></tr><tr><td><code>bootargs</code></td><td><strong>（特殊变量）</strong> 设置传递给 Linux 内核的启动参数。</td><td><code>setenv bootargs 'root=/dev/mmcblk0p2 console=ttyS0,115200'</code></td><td>通常在启动前设置。</td></tr><tr><td><code>bootcmd</code></td><td><strong>（特殊变量）</strong> 设定 U-Boot 自动启动时执行的命令。</td><td><code>setenv bootcmd 'tftp 0x42000000 zImage; bootm 0x42000000'</code></td><td>启动时若不打断，则执行此变量中的命令。</td></tr></tbody></table><h2 id="三-内存与存储操作命令"><a class="markdownIt-Anchor" href="#三-内存与存储操作命令"></a> 三、 内存与存储操作命令</h2><p>这些命令用于读写内存、从外部存储加载数据、以及操作 Flash 等。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>用途</strong></th><th><strong>示例</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><code>mw</code></td><td>内存写入（Memory Write），向内存地址写入指定值。</td><td><code>mw.l 0x40000000 0xDEADBEEF 10</code></td><td><code>.b</code> (字节), <code>.w</code> (字), <code>.l</code> (长字) 指定写入单位。<strong>10是一个十六进制数</strong>。</td></tr><tr><td><code>md</code></td><td>内存显示（Memory Display），查看指定内存地址的内容。</td><td><code>md.l 0x40000000 10</code></td><td><strong>10是一个十六进制数</strong>，表示显示 10 个单位。</td></tr><tr><td><code>cp</code></td><td>内存拷贝（Memory Copy），在内存或存储之间复制数据。</td><td><code>cp.b 0x40000000 0x40100000 0x100</code></td><td>可用于从 NAND/SD/eMMC 等到 RAM 的复制。</td></tr><tr><td><code>erase</code></td><td>擦除 Flash 或其他存储区域。</td><td><code>erase 0x50000000 +0x100000</code></td><td>慎用！会清除数据。</td></tr><tr><td><code>nand</code> / <code>mmc</code> / <code>spi</code> / <code>sata</code> 等</td><td>针对不同存储介质的操作命令。</td><td><code>mmc rescan</code> / <code>nand read 0x40000000 kernel 0x800000</code></td><td>具体命令取决于 U-Boot 配置和硬件支持。</td></tr><tr><td><code>cmp</code></td><td>比较两段内存地址的指定单位长度数据是否相等</td><td><code>cmp.l 80000000 80000100 10</code></td><td><code>.b</code> (字节), <code>.w</code> (字), <code>.l</code> (长字) 指定写入单位。<strong>10是一个十六进制数</strong>。</td></tr></tbody></table><h2 id="四-网络与文件传输命令"><a class="markdownIt-Anchor" href="#四-网络与文件传输命令"></a> 四、 网络与文件传输命令</h2><p>在嵌入式开发中，通常通过网络（如 TFTP）从主机下载内核或文件系统镜像。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>用途</strong></th><th><strong>示例</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><code>ping</code></td><td>测试网络连接。</td><td><code>ping 192.168.1.1</code></td><td>需要设置 <code>ipaddr</code> 和 <code>serverip</code> 环境变量。</td></tr><tr><td><code>tftp</code></td><td>使用 TFTP 协议从服务器下载文件到内存。</td><td><code>tftp 0x42000000 zImage</code></td><td>0x42000000 是内存地址，zImage 是服务器上的文件名。</td></tr><tr><td><code>dhcp</code></td><td>通过 DHCP 获取板子的 IP 地址等网络参数。</td><td><code>dhcp</code></td><td></td></tr><tr><td><code>setenv</code></td><td><strong>（网络相关变量）</strong> 设置网络参数。</td><td><code>setenv ipaddr 192.168.1.10</code> / <code>setenv serverip 192.168.1.1</code></td><td></td></tr></tbody></table><h3 id="issue1无法ping通"><a class="markdownIt-Anchor" href="#issue1无法ping通"></a> issue#1:无法ping通</h3><p>第一，检查环境变量，配置好ipaddr、ethaddr、netmask，确保与主机处于同一网段。</p><table><thead><tr><th><strong>环境变量</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>ipaddr</td><td>开发板ip地址</td></tr><tr><td>ethaddr</td><td>开发板MAC地址</td></tr><tr><td>netmask</td><td>子网掩码</td></tr><tr><td>gatewayip</td><td>网关地址</td></tr><tr><td>serveip</td><td>服务器 IP 地址，也就是主机 IP 地址，用于调试代码。</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">setenv ipaddr 192.168.137.144setenv ethaddr yourethaddrsetenv netmask 255.255.255.0setenv serverip 192.168.137.1saveenv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二，检查无误后，使用网线连接主机（电脑），发现无法ping通。</p><ul><li><p><strong>原因</strong>：windows系统无法识别连接到以太网接口的设备，显示为“未识别的网络”，使用的是公用网络的网络配置文件，而windows公用网络配置文件默认是不允许回应ping的，因此无法ping通。</p></li><li><p><strong>解决方法</strong>：在设置——网络与Internet——高级网络设置——Windows防火墙，将公用网络中的防火墙暂时关闭，即可ping通。</p></li></ul><h2 id="五-系统启动命令"><a class="markdownIt-Anchor" href="#五-系统启动命令"></a> 五、 系统启动命令</h2><p>这些命令用于加载并启动操作系统内核。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>用途</strong></th><th><strong>示例</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><code>bootm</code></td><td>启动一个由 <code>mkimage</code> 工具制作的、带有 U-Boot 映像头信息的内核或操作系统映像。</td><td><code>bootm 0x42000000</code></td><td>地址是内核在 RAM 中的加载地址。</td></tr><tr><td><code>bootz</code></td><td>启动一个 Linux zImage 格式的内核。</td><td><code>bootz 0x42000000</code></td><td>通常用于启动未被 <code>mkimage</code> 打包的 zImage。</td></tr><tr><td><code>boot</code> 或 <code>bootd</code></td><td>执行 <code>bootcmd</code> 环境变量中定义的命令，实现默认启动。</td><td><code>boot</code></td><td><code>bootd</code> 是 <code>boot</code> 的别名。</td></tr></tbody></table><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>U-Boot 的命令众多，但上述这些是日常开发和调试中最常用的。通过这些命令，您可以实现：</p><ol><li><p><strong>查看和修改配置：</strong> 使用 <code>printenv</code>、<code>setenv</code> 和 <code>saveenv</code> 管理启动参数和网络设置。</p></li><li><p><strong>加载映像文件：</strong> 使用 <code>tftp</code>、<code>mmc read</code> 等将内核、设备树（DTB）和文件系统加载到 RAM 中。</p></li><li><p><strong>启动系统：</strong> 使用 <code>bootm</code> 或 <code>bootz</code> 引导操作系统。</p></li><li><p><strong>调试和诊断：</strong> 使用 <code>md</code>、<code>mw</code> 和 <code>ping</code> 等进行内存和网络测试。</p></li></ol><p>在实际操作中，您可以通过输入 <code>help</code> 命令来获取当前 U-Boot 版本所支持的完整命令列表。希望这篇文章能帮助您更好地理解和使用 U-Boot！</p><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="系统移植" scheme="https://blog.godmao.top/categories/Linux/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
    
    
    <category term="u-boot" scheme="https://blog.godmao.top/Tags/u-boot/"/>
    
  </entry>
  
  <entry>
    <title>记录搭建一台云服务器环境的过程</title>
    <link href="https://blog.godmao.top/posts/2446/"/>
    <id>https://blog.godmao.top/posts/2446/</id>
    <published>2025-10-14T06:07:43.000Z</published>
    <updated>2025-10-14T12:13:45.233Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><ul><li><a href="#1-%E5%89%8D%E8%A8%80">1. 前言</a></li><li><a href="#2-%E6%93%8D%E4%BD%9C%E4%B9%A0%E6%83%AF%E9%83%A8%E5%88%86">2. 操作习惯部分</a><ul><li><a href="#21-%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D">2.1. 修改主机名</a></li><li><a href="#22-%E9%85%8D%E7%BD%AE%E6%97%B6%E5%8C%BA">2.2. 配置时区</a></li></ul></li><li><a href="#3-%E5%AE%89%E5%85%A8%E9%83%A8%E5%88%86">3. 🔐安全部分</a><ul><li><a href="#31-%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81%E4%B8%BA%E5%BC%BA%E5%AF%86%E7%A0%81">3.1. 重新设置root密码为强密码</a></li><li><a href="#32-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%BA%E5%AF%86%E7%A0%81">3.2. 添加用户并设置强密码</a></li><li><a href="#33-%E7%B3%BB%E7%BB%9F%E5%8D%87%E7%BA%A7">3.3. 系统升级</a></li><li><a href="#34-%E4%BD%BF%E7%94%A8ssh-key%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E8%80%8C%E4%B8%8D%E6%98%AF%E5%AF%86%E7%A0%81">3.4. 使用SSH Key远程登录而不是密码</a><ul><li><a href="#341-%E5%9C%A8%E6%9C%AC%E5%9C%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%94%9F%E6%88%90%E5%AF%86%E5%8C%99%E5%AF%B9">3.4.1. 在本地电脑上生成密匙对：</a></li><li><a href="#342-%E5%88%9B%E5%BB%BAconfig%E6%96%87%E4%BB%B6">3.4.2. 创建config文件</a></li><li><a href="#343-%E5%A4%8D%E5%88%B6%E5%85%AC%E5%8C%99%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8">3.4.3. 复制公匙到服务器</a></li><li><a href="#344-%E7%99%BB%E5%BD%95">3.4.4. 登录</a></li></ul></li><li><a href="#35-%E6%94%B9ssh%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99">3.5. 改ssh端口&amp;配置防火墙</a><ul><li><a href="#351-%E5%88%9D%E6%AD%A5%E9%85%8D%E7%BD%AE">3.5.1. 初步配置</a></li><li><a href="#352-%E6%94%B9ssh%E7%AB%AF%E5%8F%A3">3.5.2. 改SSH端口</a></li><li><a href="#353-%E5%85%B3%E9%97%AD22%E7%AB%AF%E5%8F%A3">3.5.3. 关闭22端口</a></li></ul></li><li><a href="#36-ssh%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">3.6. ssh配置文件</a><ul><li><a href="#361-%E7%A6%81%E7%94%A8-root%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95">3.6.1. 禁用 root远程登录&amp;密码登录</a></li><li><a href="#362-%E4%BD%BF%E7%94%A8ssh2">3.6.2. 使用SSH2</a></li><li><a href="#363-%E9%87%8D%E5%90%AFssh">3.6.3. 重启ssh</a></li></ul></li><li><a href="#37-fail2ban%E5%B7%A5%E5%85%B7%E9%98%B2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3">3.7. Fail2ban工具防暴力破解</a><ul><li><a href="#371-%E9%85%8D%E7%BD%AEfail2ban">3.7.1. 配置fail2ban</a></li><li><a href="#372-%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81">3.7.2. 查看状态</a></li><li><a href="#373-%E8%A7%A3%E5%B0%81ip">3.7.3. 解封ip</a></li><li><a href="#374-%E5%90%AF%E7%94%A8fail2ban">3.7.4. 启用fail2ban</a></li><li><a href="#375-%E5%B0%8F%E8%B4%B4%E5%A3%AB">3.7.5. 小贴士</a></li></ul></li></ul></li><li><a href="#4-%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4%E9%83%A8%E5%88%86">4. 系统维护部分</a><ul><li><a href="#41-%E4%BD%BF%E7%94%A8expkg">4.1. <s>使用expkg</s></a></li></ul></li><li><a href="#5-%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E9%83%A8%E5%88%86">5. 系统运行部分</a></li></ul><h2 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1. 前言</h2><p>前几天在七牛云租了一台轻量应用级服务器，2c4gb，足够满足玩具的需求了。第一次玩服务器，现在把自己的搭建环境的过程记录一下，方便日后操作。</p><p>云服务器系统：Ubuntu 24.04 LTS<br />云服务器厂商：七牛云<br />云服务器规格：轻量型 T1 2C4GB CPU型</p><h2 id="2-操作习惯部分"><a class="markdownIt-Anchor" href="#2-操作习惯部分"></a> 2. 操作习惯部分</h2><h3 id="21-修改主机名"><a class="markdownIt-Anchor" href="#21-修改主机名"></a> 2.1. 修改主机名</h3><p>ssh登录到服务器后，发现主机名是一坨乱码，看着太难受了，必须改了。<br /><img src="Snipaste_2025-10-14_14-17-13.png" alt="" /></p><p>永久修改主机名命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> hostnamectl set-hostname myserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启生效。</p><h3 id="22-配置时区"><a class="markdownIt-Anchor" href="#22-配置时区"></a> 2.2. 配置时区</h3><p>输入 <code>date</code> 命令，发现服务器使用的世界协调时（UTC），改为中国标准时（UTC+8），符合习惯。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> timedatectl set-timezone Asia/Shanghai<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行后，使用  <code>timedatectl</code> 命令确认是否修改成功，并查看 <code>NTP service</code> 是否启用，这是自动同步网络时间，可保持时间精准。若未启用则需查询相关教程启用。</p><h2 id="3-安全部分"><a class="markdownIt-Anchor" href="#3-安全部分"></a> 3. 🔐安全部分</h2><p>此部分需格外重视！</p><h3 id="31-重新设置root密码为强密码"><a class="markdownIt-Anchor" href="#31-重新设置root密码为强密码"></a> 3.1. 重新设置root密码为强密码</h3><p>不用多说，<code>passwd</code> 命令即可。</p><h3 id="32-添加用户并设置强密码"><a class="markdownIt-Anchor" href="#32-添加用户并设置强密码"></a> 3.2. 添加用户并设置强密码</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">adduser yourname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加到sudo组：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">usermod</span> <span class="token parameter variable">-aG</span> <span class="token function">sudo</span> yourname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看用户组：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etc/group<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看当前用户所属组：<code>groups</code>命令。</p><blockquote><p>设置完成后，退出root用户登录，用SSH以普通用户重新登录到服务器。</p></blockquote><h3 id="33-系统升级"><a class="markdownIt-Anchor" href="#33-系统升级"></a> 3.3. 系统升级</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> update<span class="token function">sudo</span> <span class="token function">apt</span> upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="34-使用ssh-key远程登录而不是密码"><a class="markdownIt-Anchor" href="#34-使用ssh-key远程登录而不是密码"></a> 3.4. 使用SSH Key远程登录而不是密码</h3><p>SSH Key 登录比密码安全很多，几乎无法破解。本质就是让服务器识别你的电脑，只有你的电脑才能登录到服务器。</p><h4 id="341-在本地电脑上生成密匙对"><a class="markdownIt-Anchor" href="#341-在本地电脑上生成密匙对"></a> 3.4.1. 在本地电脑上生成密匙对：</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-b</span> <span class="token number">4096</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-t</code>：指定密匙类型，rsa是经典算法，兼容性好。</li><li><code>-b</code>：指定密匙长度为4096位。</li></ul><p>它会提示你几个问题：</p><pre class="line-numbers language-none"><code class="language-none">Generating public&#x2F;private rsa key pair. Enter file in which to save the key (&#x2F;home&#x2F;yourname&#x2F;.ssh&#x2F;id_rsa):<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时候：</p><ul><li><strong>直接回车</strong> 就会把密钥生成在默认位置：<ul><li>私钥：<code>~/.ssh/id_rsa</code> ，<strong>绝对不能泄露！</strong></li><li>公钥：`~/.ssh/id_rsa.pub</li></ul></li><li><strong>或者</strong>指定位置及文件名。<br />接着会提示：</li></ul><pre class="line-numbers language-none"><code class="language-none">Enter passphrase (empty for no passphrase):<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里你可以选择：</p><ul><li><strong>直接回车</strong>：不设置密码，登录更方便；</li><li><strong>输入密码短语</strong>：多一层保护（每次用私钥登录都要输入这串密码）。</li></ul><h4 id="342-创建config文件"><a class="markdownIt-Anchor" href="#342-创建config文件"></a> 3.4.2. 创建config文件</h4><p>有时，我们不只有一个ssh密匙对，比如我为github生成了一个密匙对，也给服务器生成了一个。如果使用了非默认名称的密钥文件，需要在 <em>~/.ssh/config</em> 文件中进行配置。</p><p>在本地保存ssh密匙对文件的文件夹里，打开或创建名为 <code>config</code> 的文件，无需后缀名。编辑该文件，示例：</p><pre class="line-numbers language-none"><code class="language-none"># GitHub（常见）Host github.com  HostName github.com  User git  IdentityFile ~&#x2F;.ssh&#x2F;id_ed25519_github  IdentitiesOnly yes# 我的服务器Host myserver #你的主机名  HostName 1.2.3.4 #主机ip地址&#x2F;域名  User someone #你要登录的用户  Port 22        # 如果你改过SSH端口就写上，默认22  IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_server  IdentitiesOnly yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>Host</code></td><td>自定义的别名（可以随意起名）</td></tr><tr><td><code>HostName</code></td><td>实际的服务器域名或 IP 地址</td></tr><tr><td><code>User</code></td><td>登录用户名</td></tr><tr><td><code>Port</code></td><td>SSH 端口（没改的话默认 22）</td></tr><tr><td><code>IdentityFile</code></td><td>私钥文件路径</td></tr><tr><td><code>IdentitiesOnly yes</code></td><td>只使用指定的私钥，避免自动尝试其他 key 导致拒绝</td></tr></tbody></table><h4 id="343-复制公匙到服务器"><a class="markdownIt-Anchor" href="#343-复制公匙到服务器"></a> 3.4.3. 复制公匙到服务器</h4><p>方式1</p><hr /><p>在服务器创建一个文件夹保存ssh公匙，服务器用它来识别远程登录到它的电脑。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/.ssh<span class="token function">touch</span> ~/.ssh/authorized_keys<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token number">700</span> ~/.ssh<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token number">600</span> ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之后使用nano编辑器，将本地的.pub文件里的内容复制到authorized_keys即可。</p><blockquote><ul><li><strong>千万别上传私钥</strong>（例如 <code>id_rsa</code>、<code>id_ed25519</code>）。只传 <code>*.pub</code>。</li><li><strong>权限必须正确</strong>：- 确保服务器 <code>~/.ssh</code> 权限是 <code>700</code>，<code>~/.ssh/authorized_keys</code> 权限是 <code>600</code>，否则 SSH 会拒绝使用密钥。</li><li><strong>每个公钥一行</strong>，不要插入换行或空格。<code>authorized_keys</code> 可包含多把公钥（多台电脑可共用）。</li></ul></blockquote><p>方式2</p><hr /><p>window可使用gitbash。linux直接输入：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-copy-id <span class="token parameter variable">-i</span> ~/.ssh/id_rsa_server.pub root@SERVER_IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-i</code> 后面是你本地的公钥文件（比如 <code>~/.ssh/id_rsa_server.pub</code>）。</li><li>运行会提示输入服务器密码，然后把公钥追加到服务器 <code>~/.ssh/authorized_keys</code>。<br /><strong>注意不要错传成私匙！</strong></li></ul><hr /><h4 id="344-登录"><a class="markdownIt-Anchor" href="#344-登录"></a> 3.4.4. 登录</h4><p>尝试在本地ssh登录。正常的话不用输密码就可以直接登陆上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ssh</span> Host<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="35-改ssh端口配置防火墙"><a class="markdownIt-Anchor" href="#35-改ssh端口配置防火墙"></a> 3.5. 改ssh端口&amp;配置防火墙</h3><blockquote><p>警告：此步操作需要谨慎，至少保留一个已登录的ssh终端，否则如果操作不当会导致被锁（无法登录到服务器），正确配置之前先不要启用防火墙。</p></blockquote><h4 id="351-初步配置"><a class="markdownIt-Anchor" href="#351-初步配置"></a> 3.5.1. 初步配置</h4><p>Ubuntu 内置了UFW防火墙。通过防火墙，尽可能少的暴露端口，提升安全性。</p><p>我们首先允许以下端口：</p><ul><li>22端口：SSH默认端口</li><li>80端口：HTTP服务，如果你在服务器上架网站，这个端口必须开放。</li><li>443端口：HTTPS服务</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ufw default deny incoming<span class="token function">sudo</span> ufw default allow outgoing<span class="token function">sudo</span> ufw allow <span class="token number">22</span>/tcp    <span class="token comment"># SSH端口</span><span class="token function">sudo</span> ufw allow <span class="token number">80</span>/tcp      <span class="token comment"># HTTP</span><span class="token function">sudo</span> ufw allow <span class="token number">443</span>/tcp     <span class="token comment"># HTTPS</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sudo ufw default deny incoming</code>：默认拒绝所有进入服务器的流量（incoming traffic）。除非你明确允许某个端口，否则外部无法连接到你的服务器。<br /><code>sudo ufw default allow outgoing</code>：默认允许服务器发出的所有流量（outgoing traffic）。服务器可以自由访问外部网络（比如下载更新、访问 API 等）。</p><h4 id="352-改ssh端口"><a class="markdownIt-Anchor" href="#352-改ssh端口"></a> 3.5.2. 改SSH端口</h4><blockquote><p><strong>注意</strong>：保留一个已经登录的 SSH 窗口，先测试新端口可用再关闭旧窗口，避免自己被锁。</p></blockquote><p>不使用默认SSH端口登录，提高安全性。</p><ol><li>编辑 SSH 配置：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">nano</span> /etc/ssh/sshd_config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到：<code>#Port 22</code><br />修改为：<code>Port your_ssh_port</code></p><blockquote><p>建议 SSH 改到 <strong>1024 以上，最好 2000~65000 的范围</strong>，例如 2222、22022、55222。</p></blockquote><ol start="2"><li>防火墙允许该端口并启用防火墙</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ufw allow your_ssh_port/tcp<span class="token function">sudo</span> ufw <span class="token builtin class-name">enable</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行 <code>sudo ufw status</code> 命令检查防火墙规则。<br />应该显示：</p><pre class="line-numbers language-none"><code class="language-none">To                         Action      From--                         ------      ----22&#x2F;tcp                     ALLOW       Anywhere80&#x2F;tcp                     ALLOW       Anywhere443&#x2F;tcp                    ALLOW       Anywhereyour_ssh_port&#x2F;tcp          ALLOW       Anywhere22&#x2F;tcp (v6)                ALLOW       Anywhere (v6)80&#x2F;tcp (v6)                ALLOW       Anywhere (v6)443&#x2F;tcp (v6)               ALLOW       Anywhere (v6)your_ssh_port&#x2F;tcp (v6)     ALLOW       Anywhere (v6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><p>重启 SSH：<br /><code>sudo systemctl restart ssh</code></p></li><li><p>测试新端口：<br /><code>ssh -p your_ssh_port root@SERVER_IP</code></p></li></ol><p>如果第四步访问被拒绝，别慌，使用命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> sshd <span class="token parameter variable">-T</span> <span class="token operator">|</span> <span class="token function">grep</span> port<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果输出的是你设定的端口号，<strong>且ufw中允许了设定端口</strong>，那么可以忽略保留ssh窗口的note，直接重启云服务器，重新以新端口号登录，应该可以成功。</p><h4 id="353-关闭22端口"><a class="markdownIt-Anchor" href="#353-关闭22端口"></a> 3.5.3. 关闭22端口</h4><p>成功登录后，可以关闭22端口了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ufw delete allow <span class="token number">22</span>/tcp<span class="token function">sudo</span> ufw reload<span class="token function">sudo</span> ufw status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="36-ssh配置文件"><a class="markdownIt-Anchor" href="#36-ssh配置文件"></a> 3.6. ssh配置文件</h3><p>依旧：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">nano</span> /etc/ssh/sshd_config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="361-禁用-root远程登录密码登录"><a class="markdownIt-Anchor" href="#361-禁用-root远程登录密码登录"></a> 3.6.1. 禁用 root远程登录&amp;密码登录</h4><p>配置文件中设置：</p><pre class="line-numbers language-none"><code class="language-none">PermitRootLogin no # 禁用root登录PasswordAuthentication no # 禁用密码登录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于第二个选项，请自行决定。至于暴力破解，用Fail2ban工具可以防暴力破解。</p><table><thead><tr><th>配置</th><th>优势</th><th>风险</th></tr></thead><tbody><tr><td>PasswordAuthentication yes</td><td>可以用密码登录（灵活）</td><td>容易被暴力破解，安全性低</td></tr><tr><td>PasswordAuthentication no</td><td>安全性高，防止暴力攻击</td><td>如果 SSH Key 配置有问题，可能登录不上</td></tr></tbody></table><h4 id="362-使用ssh2"><a class="markdownIt-Anchor" href="#362-使用ssh2"></a> 3.6.2. 使用SSH2</h4><ul><li><code>Protocol</code> 指定 SSH 使用的协议版本：<ul><li><strong>Protocol 1</strong>：SSH-1，存在严重安全漏洞，不再推荐</li><li><strong>Protocol 2</strong>：SSH-2，更安全，更稳定</li></ul></li><li>现代 Linux 发行版默认使用 <strong>Protocol 2</strong>，但最好确认配置文件里明确指定。</li></ul><p>在配置文件中修改或在适当位置添加：</p><pre class="line-numbers language-none"><code class="language-none">Protocol 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="363-重启ssh"><a class="markdownIt-Anchor" href="#363-重启ssh"></a> 3.6.3. 重启ssh</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl restart <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="37-fail2ban工具防暴力破解"><a class="markdownIt-Anchor" href="#37-fail2ban工具防暴力破解"></a> 3.7. Fail2ban工具防暴力破解</h3><p>该工具可以自动封禁暴力破解 IP。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> fail2ban<span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> fail2ban<span class="token function">sudo</span> systemctl start fail2ban<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="371-配置fail2ban"><a class="markdownIt-Anchor" href="#371-配置fail2ban"></a> 3.7.1. 配置fail2ban</h4><pre class="line-numbers language-none"><code class="language-none">sudo nano &#x2F;etc&#x2F;fail2ban&#x2F;jail.local# 添加：[sshd]enabled &#x3D; truemaxretry &#x3D; 5findtime &#x3D; 86400bantime &#x3D; 86400<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>enabled</strong> → 是否启用该 jail</li><li><strong>port</strong> → SSH 服务端口（可用逗号指定多个端口，如 22,2222）</li><li><strong>maxretry</strong> → 超过多少次失败被 ban</li><li><strong>bantime</strong> → 封禁持续时间，可改为 <code>-1</code> 永久封禁</li><li><strong>findtime</strong> → 在findtime时间内输入maxretry次错误密码即被封禁。</li></ul><h4 id="372-查看状态"><a class="markdownIt-Anchor" href="#372-查看状态"></a> 3.7.2. 查看状态</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> fail2ban-client status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Status for the jail: sshd|- Filter|  |- Currently failed: 3|  |- Total failed: 15|  &#96;- File list: &#x2F;var&#x2F;log&#x2F;auth.log&#96;- Actions   |- Currently banned: 1   |- Total banned: 5   &#96;- Banned IP list: 123.45.67.89<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Banned IP list</code> → 被封禁的 IP</li><li><code>Currently banned</code> → 当前封禁数量</li></ul><h4 id="373-解封ip"><a class="markdownIt-Anchor" href="#373-解封ip"></a> 3.7.3. 解封ip</h4><p>如果自己被 ban，可以在服务器端解封（假设你的 IP 是 <code>1.2.3.4</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> fail2ban-client <span class="token builtin class-name">set</span> sshd unbanip <span class="token number">1.2</span>.3.4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解封后你可以正常 SSH 登录。</p><h4 id="374-启用fail2ban"><a class="markdownIt-Anchor" href="#374-启用fail2ban"></a> 3.7.4. 启用fail2ban</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> fail2ban<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="375-小贴士"><a class="markdownIt-Anchor" href="#375-小贴士"></a> 3.7.5. 小贴士</h4><ol><li><strong>改规则前保持一个活动 SSH 会话</strong>，测试新规则生效再退出</li><li><strong>先小范围测试</strong>：例如 <code>maxretry = 3, bantime = 60</code>，确认不会误锁自己</li><li><strong>定期检查</strong>：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> fail2ban-client status sshd<span class="token function">sudo</span> fail2ban-client status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>做完上面部分后，在云服务器后台创建一个自定义镜像，备份一下，方便日后快速恢复。</p></blockquote><h2 id="4-系统维护部分"><a class="markdownIt-Anchor" href="#4-系统维护部分"></a> 4. 系统维护部分</h2><h3 id="41-使用expkg"><a class="markdownIt-Anchor" href="#41-使用expkg"></a> 4.1. <s>使用expkg</s></h3><h2 id="5-系统运行部分"><a class="markdownIt-Anchor" href="#5-系统运行部分"></a> 5. 系统运行部分</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="VPS" scheme="https://blog.godmao.top/categories/VPS/"/>
    
    
    <category term="VPS" scheme="https://blog.godmao.top/Tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>哈希表与设备号</title>
    <link href="https://blog.godmao.top/posts/7167/"/>
    <id>https://blog.godmao.top/posts/7167/</id>
    <published>2025-10-10T08:31:46.000Z</published>
    <updated>2025-10-10T09:46:29.493Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h2 id="1-哈希表的通俗理解"><a class="markdownIt-Anchor" href="#1-哈希表的通俗理解"></a> 1. 哈希表的通俗理解</h2><p>我们知道，线性链表灵活性高，扩展性强，但是查找效率低；而数组虽然查找效率高，但是扩展性，灵活性都不高。哈希表则巧妙的结合了这两种数据结构的优点，不仅插入、删除数据高效，同时查找效率也高，但是内存占用也高，相当于用空间换时间。</p><h3 id="11-类比快递仓库"><a class="markdownIt-Anchor" href="#11-类比快递仓库"></a> 1.1. 类比：快递仓库</h3><p>想象你在一个快递仓库工作，</p><ul><li>这个仓库有100个货架（0~99）。</li><li>每个快递都有一个快递名。</li><li>有一个hash牌的编码器，专门把这些快递名编码成0~99的数字，你根据这些数字把快递放在相应的货架。</li></ul><p>Like this：</p><table><thead><tr><th>快递名</th><th>编码结果（货架号）</th><th>放到哪个架子</th></tr></thead><tbody><tr><td>Alice</td><td>hash(“Alice”) % 100 = 37</td><td>37号架</td></tr><tr><td>Bob</td><td>hash(“Bob”) % 100 = 12</td><td>12号架</td></tr><tr><td>Carol</td><td>hash(“Carol”) % 100 = 37</td><td>37号架</td></tr></tbody></table><p>WTF？Alice 和 Carol 都被分到了37号架，怎么办？</p><p>聪明的你在37号架上放一个“小篮子”，把所有撞到这里的快递都放一起。<br />查找时，只需要在篮子里翻几下。</p><h3 id="12-理解哈希表的原理"><a class="markdownIt-Anchor" href="#12-理解哈希表的原理"></a> 1.2. 理解：哈希表的原理</h3><ul><li>hash表就是这个货架，可以理解为“链表数组”。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TABLE_SIZE</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token keyword">struct</span> <span class="token class-name">hash_node</span> <span class="token operator">*</span>table<span class="token punctuation">[</span>TABLE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 数组，每个槽位一个指针，初始全为NULL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>整个快递包裹，我们可以看作一个结构体。结构体成员“快递名”即为“键”，它们用来索引对应的快递；当然，结构体成员”快递里装的物品“就是“值”。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">hash_node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>                <span class="token comment">// 键</span>    <span class="token keyword">char</span> <span class="token operator">*</span>value<span class="token punctuation">;</span>              <span class="token comment">// 值</span>    <span class="token keyword">struct</span> <span class="token class-name">hash_node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>   <span class="token comment">// 指向下一个节点的指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>编码器呢，就是所谓的哈希函数，它会计算出一个整数，用于将“键” 映射到数组（哈希表）的某一个槽位中，也就是某个内存块啦。</p></li><li><p>一槽不容两键？nonono！被伟大的hash神分配在同一槽的键值会形成链表啦~</p></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> TABLE_SIZE<span class="token punctuation">;</span>  <span class="token comment">// 计算槽位</span>    <span class="token keyword">struct</span> <span class="token class-name">hash_node</span> <span class="token operator">*</span>new_node <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">hash_node</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    new_node<span class="token operator">-></span>key <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    new_node<span class="token operator">-></span>value <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将新节点插入到链表头部</span>    new_node<span class="token operator">-></span>next <span class="token operator">=</span> table<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 指向原来的第一个节点</span>    table<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> new_node<span class="token punctuation">;</span>         <span class="token comment">// 数组该槽位现在指向新节点</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更直观一点</p><pre class="line-numbers language-none"><code class="language-none">[槽位2：链表首地址]---------[槽位3：链表首地址]---------[槽位4：空]---------| -&gt; 最新添加的节点         | -&gt; 节点| -&gt; 后续添加的| -&gt; 首次插入的节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上文提供的链表插入方法是首插法，链表首地址由最新添加的节点地址呈现。</p><h2 id="2-哈希表在linux中的应用"><a class="markdownIt-Anchor" href="#2-哈希表在linux中的应用"></a> 2. 哈希表在linux中的应用</h2><p>在 Linux 里，每个设备（比如 <code>/dev/sda</code>, <code>/dev/ttyS0</code>）都有一个编号：<br /><strong>设备号 = 主号 + 次号</strong>。<br />你可以理解为：</p><ul><li>主号：设备类别（比如“硬盘类”、“串口类”）</li><li>次号：同类中的编号（第1个、第2个）</li></ul><p>设备号类型定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token class-name">dev_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主次设备号可以通过以下宏操作：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">MAJOR</span><span class="token punctuation">(</span><span class="token class-name">dev_t</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取主设备号</span><span class="token function">MINOR</span><span class="token punctuation">(</span><span class="token class-name">dev_t</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取次设备号</span><span class="token function">MKDEV</span><span class="token punctuation">(</span><span class="token keyword">int</span> major<span class="token punctuation">,</span> <span class="token keyword">int</span> minor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 组合成一个dev_t</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>已注册的设备号可以使用<code>cat /proc/devices</code>查看</li><li>内核是希望一个设备驱动(file_operation)可以独自占有一个主设备号和多个次设备号，而通常一个设备文件绑定一个主设备号和一个次设备号，所以设备驱动与设备文件是一对一或者一对多的关系。</li></ul><p>内核就像一个大仓库，存着成千上万个设备。<br />系统要根据设备号，<strong>快速找到对应的设备结构体</strong>（里面保存操作函数、状态等信息）。</p><p>于是它用哈希表来实现：<br />把设备号算一算 → 得出“货架号” → 直接找到设备对应的信息结构。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="哈希表" scheme="https://blog.godmao.top/Tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="设备号" scheme="https://blog.godmao.top/Tags/%E8%AE%BE%E5%A4%87%E5%8F%B7/"/>
    
    <category term="数据结构" scheme="https://blog.godmao.top/Tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件操作调用链探究</title>
    <link href="https://blog.godmao.top/posts/31088/"/>
    <id>https://blog.godmao.top/posts/31088/</id>
    <published>2025-10-09T12:57:35.000Z</published>
    <updated>2025-11-26T13:45:40.288Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说，底层的核心逻辑是<strong>基于C语言的“多态”实现，通过函数指针表 (Function Pointer Table) 进行的“间接调用”</strong>。</p><p>内核本身（VFS层）并<strong>不“认识”</strong> 你的 <code>my_led_write</code> 函数。它只知道一个通用的“合同”或“接口”（即 <code>struct file_operations</code>），你的驱动在注册时，把自己的函数地址“登记”在了这份合同上。</p><p>当用户调用 <code>write()</code> 时，内核会通过一系列的查找，最终找到你登记的那个函数地址，然后调用它。</p><hr /><h2 id="️-底层逻辑的三大组件"><a class="markdownIt-Anchor" href="#️-底层逻辑的三大组件"></a> 🏛️ 底层逻辑的三大组件</h2><p>内核的这种设计，依赖于三个关键的结构体，它们共同构成了这个调用框架：</p><h3 id="1-struct-file_operations-fops"><a class="markdownIt-Anchor" href="#1-struct-file_operations-fops"></a> 1. <code>struct file_operations</code> (fops)</h3><p>这是**“合同” (Interface)**。</p><ul><li><p><strong>它是什么？</strong> 这是一个包含<strong>大量函数指针</strong>的结构体（如 <code>.open</code>, <code>.read</code>, <code>.write</code>, <code>.ioctl</code> 等）。</p></li><li><p><strong>它的作用？</strong> 它定义了一个字符设备<strong>可以被如何操作</strong>的所有标准方法。内核只关心这个“合同”，不关心是谁（哪个驱动）来实现它。</p></li><li><p><strong>你的角色：</strong> 在你的 LED 驱动中，你定义了一个 <code>led_fops</code> 变量，并<strong>填充</strong>了你实现的函数（如 <code>.write = my_led_write</code>）。</p></li></ul><h3 id="2-struct-cdev-字符设备"><a class="markdownIt-Anchor" href="#2-struct-cdev-字符设备"></a> 2. <code>struct cdev</code> (字符设备)</h3><p>这是**“登记处” (Registry)**。</p><ul><li><p><strong>它是什么？</strong> 代表一个“字符设备”的内核抽象。</p></li><li><p><strong>它的作用？</strong> 它的核心作用是将一个<strong>设备号 (dev_t)</strong> 与一份**“合同” (<code>file_operations</code>)** 绑定在一起。</p></li><li><p><strong>你的角色：</strong> 你在 <code>init</code> 函数中调用 <code>cdev_init(&amp;led_cdev, &amp;led_fops)</code>，这一步就是**“绑定”<strong>；然后调用 <code>cdev_add()</code>，这一步就是</strong>“向内核注册”**，告诉内核：“嘿，设备号 240:0 的操作方法，请参考 <code>led_fops</code>！”</p></li></ul><h3 id="3-struct-file-和-struct-inode"><a class="markdownIt-Anchor" href="#3-struct-file-和-struct-inode"></a> 3. <code>struct file</code> 和 <code>struct inode</code></h3><p>这是**“上下文” (Context)**。</p><ul><li><p><strong><code>inode</code> (索引节点)：</strong> 代表一个<strong>文件系统中的文件</strong>（如 <code>/dev/my_led</code>）。它在内核中是唯一的。它包含了这个文件的元数据，最重要的是，它包含了<strong>设备号 (dev_t)</strong>。</p></li><li><p><strong><code>file</code> (打开的文件)：</strong> 代表一个<strong>进程打开的文件实例</strong>。当用户 <code>open()</code> 一个文件时，内核会创建一个 <code>struct file</code>。</p><ul><li><strong>最关键的一点：</strong> 在 <code>open</code> 的过程中，内核会根据 <code>inode</code> 里的设备号，通过 <code>cdev</code> 登记处，找到你驱动的 <code>file_operations</code> (即 <code>led_fops</code>)，然后<strong>将这个 <code>led_fops</code> 的地址存储到新创建的 <code>struct file</code> 对象的 <code>f_op</code> 字段中</strong>。</li></ul></li></ul><hr /><h2 id="️-完整调用链-以-write-为例"><a class="markdownIt-Anchor" href="#️-完整调用链-以-write-为例"></a> ⛓️ 完整调用链 (以 <code>write()</code> 为例)</h2><p>现在，我们把一个用户空间的 <code>write()</code> 调用串联起来，看看内核是如何一步步找到你的 <code>my_led_write</code> 函数的。</p><p><strong>前提：</strong> 你的驱动已加载 (<code>my_led_init</code> 已执行)。<code>alloc_chrdev_region</code> 分配了设备号 (假设 240:0)，<code>cdev_add</code> 已将 <code>led_cdev</code> (绑定了 <code>led_fops</code>) 注册到内核。</p><h3 id="阶段一用户空间-open-准备工作"><a class="markdownIt-Anchor" href="#阶段一用户空间-open-准备工作"></a> 阶段一：用户空间 <code>open()</code> (准备工作)</h3><ol><li><p><strong>用户空间：</strong> 应用程序调用 <code>fd = open(&quot;/dev/my_led&quot;, O_RDWR);</code></p></li><li><p><strong>系统调用：</strong> 触发 <code>sys_open()</code> 系统调用，进入内核空间。</p></li><li><p><strong>VFS (内核)：</strong> 内核的 VFS (虚拟文件系统) 层开始工作。</p><ul><li><p>它沿着路径名找到 <code>/dev/my_led</code> 对应的 <code>inode</code>。</p></li><li><p>VFS 发现这个 <code>inode</code> 是一个<strong>字符设备文件</strong> (S_IFCHR)。</p></li><li><p>VFS 从 <code>inode</code> 中读取<strong>设备号 (dev_t)</strong>，即 240:0。</p></li></ul></li><li><p><strong><code>cdev</code> 查找：</strong> VFS 使用这个设备号 240:0，去 <code>cdev</code> 登记处（一个哈希表）查找。</p></li><li><p><strong>找到驱动：</strong> VFS 找到了你注册的 <code>led_cdev</code>！</p></li><li><p><strong>创建 <code>file</code> 对象：</strong> 内核创建一个新的 <code>struct file</code> 对象来代表这个打开的实例。</p></li><li><p><strong>核心步骤 (绑定)：</strong> 内核从 <code>led_cdev</code> 中取出 <code>file_operations</code> 指针 (即 <code>led_fops</code>)，并将其<strong>赋值给 <code>file-&gt;f_op</code></strong>。</p></li></ol>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// VFS 内部的伪代码</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>new_file <span class="token operator">=</span> <span class="token function">create_file_struct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>new_file<span class="token operator">-></span>f_op <span class="token operator">=</span> led_cdev<span class="token operator">-></span>ops<span class="token punctuation">;</span> <span class="token comment">// led_cdev->ops 就是你的 led_fops</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="8"><li><p><strong>调用驱动的 <code>open</code>：</strong> VFS 检查 <code>file-&gt;f_op-&gt;open</code> 是否存在。如果存在（即你的 <code>led_fops.open</code>），就调用它。</p></li><li><p><strong>返回 <code>fd</code>：</strong> <code>open</code> 完成，<code>sys_open</code> 返回文件描述符 <code>fd</code> 给用户空间。这个 <code>fd</code> 在进程中唯一标识了第 6 步创建的 <code>struct file</code> 对象。</p></li></ol><h3 id="阶段二用户空间-write-执行调用"><a class="markdownIt-Anchor" href="#阶段二用户空间-write-执行调用"></a> 阶段二：用户空间 <code>write()</code> (执行调用)</h3><ol><li><p><strong>用户空间：</strong> 应用程序调用 <code>write(fd, &quot;1&quot;, 1);</code></p></li><li><p><strong>系统调用：</strong> 触发 <code>sys_write()</code> 系统调用，进入内核空间。</p></li><li><p><strong>VFS (内核)：</strong></p><ul><li><p>VFS 使用 <code>fd</code> 找到对应的 <code>struct file</code> 对象 (就是阶段一第 6 步创建的那个)。</p></li><li><p>VFS 检查这个 <code>struct file</code> 对象，确保它可写。</p></li></ul></li><li><p><strong>核心分发 (Dispatch)：</strong> VFS 执行类似如下的逻辑（这是<strong>关键</strong>！）：</p></li></ol>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// VFS 内部的伪代码 (sys_write -> vfs_write)</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>filp <span class="token operator">=</span> <span class="token function">find_file_by_fd</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 检查 "合同" 上有没有 write 方法</span><span class="token keyword">if</span> <span class="token punctuation">(</span>filp<span class="token operator">-></span>f_op <span class="token operator">&amp;&amp;</span> filp<span class="token operator">-></span>f_op<span class="token operator">-></span>write<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果有，就调用它！</span>    ret <span class="token operator">=</span> filp<span class="token operator">-></span>f_op<span class="token operator">-></span><span class="token function">write</span><span class="token punctuation">(</span>filp<span class="token punctuation">,</span> user_buf<span class="token punctuation">,</span> count<span class="token punctuation">,</span> <span class="token operator">&amp;</span>filp<span class="token operator">-></span>f_pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><p><strong>执行驱动代码：</strong></p><ul><li><p>因为 <code>filp-&gt;f_op</code> 指向的就是你的 <code>led_fops</code>。</p></li><li><p>所以 <code>filp-&gt;f_op-&gt;write</code> 指向的就是你的 <code>my_led_write</code> 函数。</p></li><li><p>内核<strong>间接调用</strong>了你的 <code>my_led_write</code> 函数，CPU 控制权转移到你的驱动代码。</p></li></ul></li><li><p><strong>驱动工作：</strong> 你的 <code>my_led_write</code> 函数被执行。它使用 <code>copy_from_user</code> 拷贝数据，然后（虚拟地）点亮 LED。</p></li><li><p><strong>返回：</strong> 你的 <code>my_led_write</code> 返回 <code>1</code> (写入的字节数)。</p></li><li><p><strong>VFS (内核)：</strong> VFS 拿到返回值，<code>sys_write</code> 随之返回。</p></li><li><p><strong>用户空间：</strong> 应用程序的 <code>write()</code> 调用返回 <code>1</code>。</p></li></ol><hr /><h2 id="调用链图示"><a class="markdownIt-Anchor" href="#调用链图示"></a> 📈 调用链图示</h2><p>这个流程可以简化为：</p><p><code>User Space</code> -&gt; <code>System Call</code> -&gt; <code>VFS (Generic Layer)</code> -&gt; <code>Function Pointer Call</code> -&gt; <code>Device Driver (Specific Code)</code></p><pre class="line-numbers language-none"><code class="language-none">[用户空间]   write(fd, ...);       |       v[内核空间 - 系统调用]   sys_write(fd, ...);       |       v[内核空间 - VFS]   vfs_write(...) &#123;     &#x2F;&#x2F; 1. 根据 fd 找到 struct file *filp     struct file *filp &#x3D; fget(fd);          &#x2F;&#x2F; 2. 找到 filp-&gt;f_op (这个在 open 时已被设为 led_fops)     &#x2F;&#x2F; 3. 执行函数指针     filp-&gt;f_op-&gt;write(filp, ...);  &lt;---- 核心跳转！   &#125;                                    |                                        |       +--------------------------------+       |       v[内核空间 - 你的驱动]   my_led_write(struct file *filp, ...) &#123;     &#x2F;&#x2F; ...     &#x2F;&#x2F; copy_from_user(...)     &#x2F;&#x2F; 控制硬件     &#x2F;&#x2F; ...     return count;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="核心总结"><a class="markdownIt-Anchor" href="#核心总结"></a> 核心总结</h2><p>内核调用驱动的逻辑，就是**“注册与回调”**：</p><ol><li><p><strong>注册 (Registration)：</strong> 你的驱动 <code>init</code> 时，通过 <code>cdev_add</code> 把一个包含函数指针的 “合同” (<code>file_operations</code>) 注册到内核的 <code>cdev</code> 系统中。</p></li><li><p><strong>回调 (Callback)：</strong> 当 VFS 需要对你的设备进行操作时，它不关心你的驱动叫什么，它只通过 <code>file</code> 对象找到那份 “合同”，然后调用 “合同” 上约定的函数指针。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单来说，底层的核心逻辑是&lt;strong&gt;基于C语言的“多态”实现，通过函数指针表 (Function Pointer Table) 进行的“间接调用”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;内核本身（VFS层）并&lt;strong&gt;不“认识”&lt;/strong&gt; 你的 &lt;code&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="内核编程" scheme="https://blog.godmao.top/categories/Linux/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="调用链" scheme="https://blog.godmao.top/Tags/%E8%B0%83%E7%94%A8%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>大蟒蛇-sys/argparse库</title>
    <link href="https://blog.godmao.top/posts/22025/"/>
    <id>https://blog.godmao.top/posts/22025/</id>
    <published>2025-09-29T12:53:30.000Z</published>
    <updated>2025-09-29T14:34:58.586Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><div class="admonition warning"><p class="admonition-title">warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p></div></details><hr /><h1 id="sys库"><a class="markdownIt-Anchor" href="#sys库"></a> sys库</h1><p><code>sys</code> 是 Python 标准库中的一个模块，提供了与 Python 解释器及其环境交互的功能。<br />通过 <code>sys</code> 库，你可以访问与 Python 解释器相关的变量和函数，例如命令行参数、标准输入输出、程序退出等。命令行参数部分可用<code>argparse</code>库替代。</p><h2 id="sysargv"><a class="markdownIt-Anchor" href="#sysargv"></a> sys.argv</h2><p>描述：命令行参数的列表。<code>sys.argv[0]</code> 是脚本的名称，后续元素是传递给脚本的参数。<br />语法：<code>sys.argv[]</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"脚本名称:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"参数列表:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sysexit"><a class="markdownIt-Anchor" href="#sysexit"></a> sys.exit</h2><p>描述：用于退出程序。你可以传递一个整数作为退出状态码，通常 <code>0</code> 表示成功，非零值表示错误。<br />语法：<code>sys.exit(num）</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"程序开始"</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这行代码不会执行"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sysstdinstdoutstderr"><a class="markdownIt-Anchor" href="#sysstdinstdoutstderr"></a> sys.stdin/stdout/stderr</h2><p>描述：<code>sys.stdin</code>、<code>sys.stdout</code> 和 <code>sys.stderr</code> 分别代表标准输入、标准输出和标准错误流。你可以重定向这些流以实现自定义的输入输出行为。<br />语法：<code>sys.stderr.write(&quot;err&quot;)</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token comment"># 重定向标准输出到文件</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'output.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    sys<span class="token punctuation">.</span>stdout <span class="token operator">=</span> f    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这行内容将写入 output.txt"</span><span class="token punctuation">)</span><span class="token comment"># 恢复标准输出</span>sys<span class="token punctuation">.</span>stdout <span class="token operator">=</span> sys<span class="token punctuation">.</span>__stdout__<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"这行内容将显示在控制台"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="sysversionversion_info"><a class="markdownIt-Anchor" href="#sysversionversion_info"></a> sys.version/version_info</h2><p>描述：提供了当前 Python 解释器的版本信息。<br />语法：<code>sys.version</code><br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Python 版本:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>version<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"版本信息:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>version_info<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="syspath"><a class="markdownIt-Anchor" href="#syspath"></a> sys.path</h2><p>描述：列表，包含了 Python 解释器在导入模块时搜索的路径。可以修改这个列表来添加自定义的模块搜索路径。<br />示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"模块搜索路径:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>path<span class="token punctuation">)</span>sys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'/custom/path'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"更新后的模块搜索路径:"</span><span class="token punctuation">,</span> sys<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>sys.modules</code></td><td>已加载模块的字典</td></tr><tr><td><code>sys.platform</code></td><td>操作系统平台标识（如 <code>'win32'</code>, <code>'linux'</code>, <code>'darwin'</code>）</td></tr><tr><td><code>sys.executable</code></td><td>Python 解释器的绝对路径</td></tr><tr><td><code>sys.byteorder</code></td><td>字节序（<code>'little'</code> 或 <code>'big'</code>）</td></tr><tr><td><code>sys.maxsize</code></td><td>最大整数值（<code>2**31-1</code> 或 <code>2**63-1</code>）</td></tr></tbody></table><h1 id="argparser库"><a class="markdownIt-Anchor" href="#argparser库"></a> argparser库</h1><h2 id="argumentparser"><a class="markdownIt-Anchor" href="#argumentparser"></a> ArgumentParser</h2><p>描述：用于创建解析命令行参数的对象。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>prog<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> usage<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> description<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> epilog<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parents<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> formatter_class<span class="token operator">=</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'argparse.HelpFormatter'</span><span class="token operator">></span><span class="token punctuation">,</span> prefix_chars<span class="token operator">=</span><span class="token string">'-'</span><span class="token punctuation">,</span> fromfile_prefix_chars<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> argument_default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> conflict_handler<span class="token operator">=</span><span class="token string">'error'</span><span class="token punctuation">,</span> add_help<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> argparseparser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">"Example parser"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="add_argument重点"><a class="markdownIt-Anchor" href="#add_argument重点"></a> add_argument——重点</h2><p>描述：向ArgumentParser对象添加命令行参数。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span>name <span class="token keyword">or</span> flags<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store'</span><span class="token punctuation">,</span> nargs<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> const<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> choices<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> required<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> metavar<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--verbose'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'Increase output verbosity'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>补充：</p><table><thead><tr><th>键</th><th>接受的值</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td>name</td><td>字符串</td><td>变量的名字</td><td>‘radius’</td></tr><tr><td>nargs</td><td>数字或’?‘或’‘或’+’</td><td>用来说明传入的参数个数（符号意义和正则表达式里的一致)</td><td>nargs=’?’ nargs=2</td></tr><tr><td>type</td><td>list, str, tuple, set, dict等</td><td>设置读取参数的类型</td><td>type=int</td></tr><tr><td>default</td><td>类型跟type统一</td><td>设置默认值</td><td>default=1</td></tr><tr><td>choices</td><td>装选项的list</td><td>参数值只能从几个选项里面选择</td><td>choices=[1,2,3,4]</td></tr><tr><td>required</td><td>True或False</td><td>这个可选参数是否必须有（只能用于可选参数！否则报错）</td><td>required=True</td></tr><tr><td>help</td><td>字符串</td><td>说明一下这个参数是干嘛的</td><td>help=“I don’t know”</td></tr><tr><td>action</td><td>六种内置动作</td><td>一旦这个有参数，就会触发相应的动作</td><td>action=‘store_true’</td></tr></tbody></table><h2 id="parse_args"><a class="markdownIt-Anchor" href="#parse_args"></a> parse_args</h2><p>描述：解析命令行参数。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span>args<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> namespace<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">[</span>arg name<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="set_defaults"><a class="markdownIt-Anchor" href="#set_defaults"></a> set_defaults</h2><p>描述：为指定的参数设置默认值。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>set_defaults<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>set_defaults<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"John Doe"</span><span class="token punctuation">,</span> age<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="print_help"><a class="markdownIt-Anchor" href="#print_help"></a> print_help</h2><p>描述：打印帮助信息。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>print_help<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>print_help<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="add_subparsers"><a class="markdownIt-Anchor" href="#add_subparsers"></a> add_subparsers</h2><p>描述：为ArgumentParser对象添加子命令解析器。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>add_subparsers<span class="token punctuation">(</span>dest<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> parser_class<span class="token operator">=</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'argparse.ArgumentParser'</span><span class="token operator">></span><span class="token punctuation">,</span> required<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">subparsers <span class="token operator">=</span> parser<span class="token punctuation">.</span>add_subparsers<span class="token punctuation">(</span>dest<span class="token operator">=</span><span class="token string">'command'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这上面几个是最常用的。</p></blockquote><hr /><h2 id="add_mutually_exclusive_group"><a class="markdownIt-Anchor" href="#add_mutually_exclusive_group"></a> add_mutually_exclusive_group</h2><p>描述：创建一个互斥的参数组，同一时间只能使用组内一个参数。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>add_mutually_exclusive_group<span class="token punctuation">(</span>required<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">group <span class="token operator">=</span> parser<span class="token punctuation">.</span>add_mutually_exclusive_group<span class="token punctuation">(</span><span class="token punctuation">)</span>group<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--foo'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">)</span>group<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--bar'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="parse_known_args"><a class="markdownIt-Anchor" href="#parse_known_args"></a> parse_known_args</h2><p>描述：解析命令行参数，但返回一个包含已知参数和未知参数的元组。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>parse_known_args<span class="token punctuation">(</span>args<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> namespace<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">args<span class="token punctuation">,</span> unknown <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_known_args<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="convert_arg_line_to_args"><a class="markdownIt-Anchor" href="#convert_arg_line_to_args"></a> convert_arg_line_to_args</h2><p>描述：将从文件读取的一行转换为参数列表。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>convert_arg_line_to_args<span class="token punctuation">(</span>arg_line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">args <span class="token operator">=</span> parser<span class="token punctuation">.</span>convert_arg_line_to_args<span class="token punctuation">(</span><span class="token string">"foo --bar=3"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="error"><a class="markdownIt-Anchor" href="#error"></a> error</h2><p>描述：在命令行参数解析过程中发生错误时，抛出异常并输出错误信息。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>error<span class="token punctuation">(</span>message<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>error<span class="token punctuation">(</span><span class="token string">"Invalid argument"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="exit"><a class="markdownIt-Anchor" href="#exit"></a> exit</h2><p>描述：在解析命令行参数时遇到错误时，退出程序。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>exit<span class="token punctuation">(</span>status<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> message<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>exit<span class="token punctuation">(</span>message<span class="token operator">=</span><span class="token string">"Exiting due to error"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="parse_args_from_file"><a class="markdownIt-Anchor" href="#parse_args_from_file"></a> parse_args_from_file</h2><p>描述：从文件中读取参数并解析。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>parse_args_from_file<span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">parser<span class="token punctuation">.</span>parse_args_from_file<span class="token punctuation">(</span><span class="token string">'args.txt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="add_argument_group"><a class="markdownIt-Anchor" href="#add_argument_group"></a> add_argument_group</h2><p>描述：创建一个参数组，用于组织和描述相关参数。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>add_argument_group<span class="token punctuation">(</span>title<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> description<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">group <span class="token operator">=</span> parser<span class="token punctuation">.</span>add_argument_group<span class="token punctuation">(</span><span class="token string">'Optional arguments'</span><span class="token punctuation">)</span>group<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'--output'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'Output file'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="format_help"><a class="markdownIt-Anchor" href="#format_help"></a> format_help</h2><p>描述：返回当前帮助信息的格式化字符串。<br />语法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ArgumentParser<span class="token punctuation">.</span>format_help<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">help_text <span class="token operator">=</span> parser<span class="token punctuation">.</span>format_help<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;div class=&quot;admonition warning&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;warning&lt;/p&gt;&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://c</summary>
      
    
    
    
    <category term="python" scheme="https://blog.godmao.top/categories/python/"/>
    
    
    <category term="python" scheme="https://blog.godmao.top/Tags/python/"/>
    
    <category term="sys" scheme="https://blog.godmao.top/Tags/sys/"/>
    
    <category term="argparse" scheme="https://blog.godmao.top/Tags/argparse/"/>
    
  </entry>
  
</feed>

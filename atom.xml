<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GoDm@&#39;s Blog</title>
  
  <subtitle>记录自己所爱。</subtitle>
  <link href="https://blog.godmao.top/atom.xml" rel="self"/>
  
  <link href="https://blog.godmao.top/"/>
  <updated>2025-06-18T10:54:34.197Z</updated>
  <id>https://blog.godmao.top/</id>
  
  <author>
    <name>GoDm@</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell脚本流程控制简明指南</title>
    <link href="https://blog.godmao.top/posts/21870/"/>
    <id>https://blog.godmao.top/posts/21870/</id>
    <published>2025-06-18T10:38:30.000Z</published>
    <updated>2025-06-18T10:54:34.197Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><ul><li><a href="#1-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5-ifelse">1. 条件判断语句 if/else</a><ul><li><a href="#11-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">1.1. 基本语法：</a></li><li><a href="#12-%E7%A4%BA%E4%BE%8B">1.2. 示例：</a></li></ul></li><li><a href="#2-%E5%88%A4%E6%96%AD%E7%AC%A6%E5%8F%B7%E8%AF%B4%E6%98%8E">2. 判断符号说明</a></li><li><a href="#3-case-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">3. case 分支结构</a><ul><li><a href="#31-%E8%AF%AD%E6%B3%95">3.1. 语法：</a></li><li><a href="#32-%E7%A4%BA%E4%BE%8B">3.2. 示例：</a></li></ul></li><li><a href="#4-for-%E5%BE%AA%E7%8E%AF">4. for 循环</a><ul><li><a href="#41-%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8">4.1. 遍历列表：</a></li><li><a href="#42-%E4%BD%BF%E7%94%A8-c-%E9%A3%8E%E6%A0%BC%E8%AF%AD%E6%B3%95">4.2. 使用 C 风格语法：</a></li></ul></li><li><a href="#5-while-%E5%BE%AA%E7%8E%AF">5. while 循环</a><ul><li><a href="#51-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">5.1. 基本语法：</a></li><li><a href="#52-%E7%A4%BA%E4%BE%8B">5.2. 示例：</a></li></ul></li><li><a href="#6-until-%E5%BE%AA%E7%8E%AF">6. until 循环</a></li><li><a href="#7-%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AFbreak-%E5%92%8C-continue">7. 跳出循环：break 和 continue</a></li></ul><p>Shell 脚本不仅可以批量处理命令任务，还拥有完整的流程控制语法结构，包括条件判断、循环与分支等逻辑控制结构。本文将简明介绍 Shell 的基本流程控制语法，适用于 bash 环境。</p><h2 id="1-条件判断语句-ifelse"><a class="markdownIt-Anchor" href="#1-条件判断语句-ifelse"></a> 1. 条件判断语句 if/else</h2><h3 id="11-基本语法"><a class="markdownIt-Anchor" href="#11-基本语法"></a> 1.1. 基本语法：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件 ]; then</span><br><span class="line">    命令1</span><br><span class="line">elif [ 条件 ]; then</span><br><span class="line">    命令2</span><br><span class="line">else</span><br><span class="line">    命令3</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>写成一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ ]; then ; fi</span><br></pre></td></tr></table></figure><h3 id="12-示例"><a class="markdownIt-Anchor" href="#12-示例"></a> 1.2. 示例：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;请输入一个数字: &quot; num</span><br><span class="line">if [ &quot;$num&quot; -gt 0 ]; then</span><br><span class="line">    echo &quot;正数&quot;</span><br><span class="line">elif [ &quot;$num&quot; -lt 0 ]; then</span><br><span class="line">    echo &quot;负数&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;零&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><hr /><h2 id="2-判断符号说明"><a class="markdownIt-Anchor" href="#2-判断符号说明"></a> 2. 判断符号说明</h2><table><thead><tr><th>条件表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>等于（整数）</td></tr><tr><td><code>-ne</code></td><td>不等于</td></tr><tr><td><code>-gt</code></td><td>大于</td></tr><tr><td><code>-lt</code></td><td>小于</td></tr><tr><td><code>-ge</code></td><td>大于等于</td></tr><tr><td><code>-le</code></td><td>小于等于</td></tr><tr><td><code>-z str</code></td><td>字符串是否为空</td></tr><tr><td><code>-n str</code></td><td>字符串是否非空</td></tr><tr><td><code>str1 = str2</code></td><td>字符串相等</td></tr><tr><td><code>-f file</code></td><td>是否为普通文件</td></tr><tr><td><code>-d dir</code></td><td>是否为目录</td></tr></tbody></table><blockquote><p>注意：<code>[</code> 和 <code>]</code> 要有空格；变量最好加引号防止空值。</p></blockquote><h2 id="3-case-分支结构"><a class="markdownIt-Anchor" href="#3-case-分支结构"></a> 3. case 分支结构</h2><p>用于多个条件的匹配处理。</p><h3 id="31-语法"><a class="markdownIt-Anchor" href="#31-语法"></a> 3.1. 语法：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case $变量 in</span><br><span class="line">    模式1)</span><br><span class="line">        命令 ;;</span><br><span class="line">    模式2)</span><br><span class="line">        命令 ;;</span><br><span class="line">    *)</span><br><span class="line">        默认命令 ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h3 id="32-示例"><a class="markdownIt-Anchor" href="#32-示例"></a> 3.2. 示例：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;请输入选项[a/b/c]: &quot; choice</span><br><span class="line">case $choice in</span><br><span class="line">    a) echo &quot;你选择了A&quot; ;;</span><br><span class="line">    b) echo &quot;你选择了B&quot; ;;</span><br><span class="line">    c) echo &quot;你选择了C&quot; ;;</span><br><span class="line">    *) echo &quot;无效选项&quot; ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h2 id="4-for-循环"><a class="markdownIt-Anchor" href="#4-for-循环"></a> 4. for 循环</h2><h3 id="41-遍历列表"><a class="markdownIt-Anchor" href="#41-遍历列表"></a> 4.1. 遍历列表：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for var in 值1 值2 值3; do</span><br><span class="line">    命令</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for name in Alice Bob Charlie; do</span><br><span class="line">    echo &quot;Hello, $name&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="42-使用-c-风格语法"><a class="markdownIt-Anchor" href="#42-使用-c-风格语法"></a> 4.2. 使用 C 风格语法：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++)); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;第 <span class="variable">$i</span> 次&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="5-while-循环"><a class="markdownIt-Anchor" href="#5-while-循环"></a> 5. while 循环</h2><h3 id="51-基本语法"><a class="markdownIt-Anchor" href="#51-基本语法"></a> 5.1. 基本语法：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件 ]; do</span><br><span class="line">    命令</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="52-示例"><a class="markdownIt-Anchor" href="#52-示例"></a> 5.2. 示例：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">while [ $i -le 5 ]; do</span><br><span class="line">    echo &quot;循环第 $i 次&quot;</span><br><span class="line">    ((i++))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="6-until-循环"><a class="markdownIt-Anchor" href="#6-until-循环"></a> 6. until 循环</h2><p>与 <code>while</code> 相反：<strong>条件为假时执行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=1</span><br><span class="line">until [ $i -gt 5 ]; do</span><br><span class="line">    echo &quot;第 $i 次&quot;</span><br><span class="line">    ((i++))</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="7-跳出循环break-和-continue"><a class="markdownIt-Anchor" href="#7-跳出循环break-和-continue"></a> 7. 跳出循环：break 和 continue</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for ((i=1;i&lt;=10;i++)); do</span><br><span class="line">    if [ $i -eq 5 ]; then</span><br><span class="line">        break   # 提前结束循环</span><br><span class="line">    fi</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for ((i=1;i&lt;=5;i++)); do</span><br><span class="line">    if [ $i -eq 3 ]; then</span><br><span class="line">        continue   # 跳过当前循环</span><br><span class="line">    fi</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="Shell" scheme="https://blog.godmao.top/categories/Linux/Shell/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="shell" scheme="https://blog.godmao.top/Tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本入门</title>
    <link href="https://blog.godmao.top/posts/27290/"/>
    <id>https://blog.godmao.top/posts/27290/</id>
    <published>2025-06-18T08:22:15.000Z</published>
    <updated>2025-06-18T10:34:11.431Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>作为linux嵌入式开发，掌握一些shell脚本的基础是必要的。</p><ul><li><a href="#1-shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%86%99%E6%B3%95">1. shell脚本的写法</a></li><li><a href="#2-shell%E8%84%9A%E6%9C%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">2. shell脚本的一些基本用法</a><ul><li><a href="#21-%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0">2.1. 输入参数</a></li><li><a href="#22-%E6%95%B4%E5%BD%A2%E8%BF%90%E7%AE%97">2.2. 整形运算</a></li><li><a href="#23-test%E5%91%BD%E4%BB%A4">2.3. test命令</a><ul><li><a href="#231-%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95">2.3.1. 文件测试</a></li><li><a href="#232-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83">2.3.2. 字符串比较</a></li><li><a href="#233-%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83">2.3.3. 数值比较</a></li><li><a href="#234-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6">2.3.4. 逻辑操作符</a></li></ul></li><li><a href="#24-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD">2.4. 条件判断</a></li></ul></li><li><a href="#3-%E6%8B%93%E5%B1%95shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">3. 拓展：shell脚本中<code>$</code>的作用</a><ul><li><a href="#31-%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8">3.1. 变量引用</a></li><li><a href="#32-%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2">3.2. 命令替换</a></li><li><a href="#33-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%92%8C%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F">3.3. 位置参数和特殊变量</a></li><li><a href="#34-%E7%AE%97%E6%9C%AF%E6%89%A9%E5%B1%95">3.4. 算术扩展</a></li><li><a href="#35-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC%E5%A4%84%E7%90%86">3.5. 字符串操作和默认值处理</a></li></ul></li></ul><h2 id="1-shell脚本的写法"><a class="markdownIt-Anchor" href="#1-shell脚本的写法"></a> 1. shell脚本的写法</h2><p>shell是个纯文本文件，命令从上而下，一行一行开始执行，<a href="http://xn--shell-iq1h016atuqd2mjsls84bdt0a.sh">shell脚本的扩展名为.sh</a><br />第一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">！/bin/bash</span></span><br></pre></td></tr></table></figure><p>表示使用bash</p><h2 id="2-shell脚本的一些基本用法"><a class="markdownIt-Anchor" href="#2-shell脚本的一些基本用法"></a> 2. shell脚本的一些基本用法</h2><h3 id="21-输入参数"><a class="markdownIt-Anchor" href="#21-输入参数"></a> 2.1. 输入参数</h3><p><code>read</code>常用选项：</p><ul><li>-a array 将输入的值作为数组赋值</li><li>-d delim 指定输入结束的标识符</li><li>-p prompt 在输入前打印提示信息</li><li>-t timeout 设置超时时间</li><li>-e 在输入的时候可以使用命令补全</li><li>-s silent 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。</li></ul><hr /><h3 id="22-整形运算"><a class="markdownIt-Anchor" href="#22-整形运算"></a> 2.2. 整形运算</h3><p>使用<code>$[]</code>进行算数扩展</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;two num: &quot; num1 num2</span><br><span class="line">echo &quot;$num1 + $num2 = $[num1 + num2]&quot;</span><br></pre></td></tr></table></figure><hr /><h3 id="23-test命令"><a class="markdownIt-Anchor" href="#23-test命令"></a> 2.3. test命令</h3><p>用于查看文件是否存在、权限等信息。可以对数值、字符、文件三方面测试，<strong>返回布尔值</strong><br />格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test EXPRESSION</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">[ EXPRESSION ]  # 注意方括号内必须有空格</span><br></pre></td></tr></table></figure><h4 id="231-文件测试"><a class="markdownIt-Anchor" href="#231-文件测试"></a> 2.3.1. 文件测试</h4><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>-e</td><td>文件是否存在</td><td><code>[ -e file.txt ]</code></td></tr><tr><td>-f</td><td>是普通文件</td><td><code>[ -f /path/to/file ]</code></td></tr><tr><td>-d</td><td>是目录</td><td><code>[ -d /path/to/dir ]</code></td></tr><tr><td>-r</td><td>可读</td><td><code>[ -r file.txt ]</code></td></tr><tr><td>-w</td><td>可写</td><td><code>[ -w file.txt ]</code></td></tr><tr><td>-x</td><td>可执行</td><td><code>[ -x script.sh ]</code></td></tr><tr><td>-s</td><td>文件大小 &gt;0</td><td><code>[ -s logfile ]</code></td></tr><tr><td>-L</td><td>是符号链接</td><td><code>[ -L symlink ]</code></td></tr></tbody></table><h4 id="232-字符串比较"><a class="markdownIt-Anchor" href="#232-字符串比较"></a> 2.3.2. 字符串比较</h4><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>-z STRING</td><td>字符串为空</td><td><code>[ -z &quot;$var&quot; ]</code></td></tr><tr><td>-n STRING</td><td>字符串非空</td><td><code>[ -n &quot;$var&quot; ]</code></td></tr><tr><td>STRING1 = STRING2</td><td>字符串相等</td><td><code>[ &quot;$var1&quot; = &quot;$var2&quot; ]</code></td></tr><tr><td>STRING1 != STRING2</td><td>字符串不等</td><td><code>[ &quot;$var1&quot; != &quot;$var2&quot; ]</code></td></tr></tbody></table><h4 id="233-数值比较"><a class="markdownIt-Anchor" href="#233-数值比较"></a> 2.3.3. 数值比较</h4><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>-eq</td><td>等于</td><td><code>[ &quot;$a&quot; -eq &quot;$b&quot; ]</code></td></tr><tr><td>-ne</td><td>不等于</td><td><code>[ &quot;$a&quot; -ne &quot;$b&quot; ]</code></td></tr><tr><td>-gt</td><td>大于</td><td><code>[ &quot;$a&quot; -gt &quot;$b&quot; ]</code></td></tr><tr><td>-ge</td><td>大于或等于</td><td><code>[ &quot;$a&quot; -ge &quot;$b&quot; ]</code></td></tr><tr><td>-lt</td><td>小于</td><td><code>[ &quot;$a&quot; -lt &quot;$b&quot; ]</code></td></tr><tr><td>-le</td><td>小于或等于</td><td><code>[ &quot;$a&quot; -le &quot;$b&quot; ]</code></td></tr></tbody></table><h4 id="234-逻辑操作符"><a class="markdownIt-Anchor" href="#234-逻辑操作符"></a> 2.3.4. 逻辑操作符</h4><p><code>test</code> 支持逻辑组合：</p><table><thead><tr><th>操作符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>!</td><td>逻辑非</td><td><code>[ ! -f &quot;$file&quot; ]</code></td></tr><tr><td>-a</td><td>逻辑与</td><td><code>[ &quot;$a&quot; -eq 1 -a &quot;$b&quot; -eq 2 ]</code></td></tr><tr><td>-o</td><td>逻辑或</td><td><code>[ &quot;$a&quot; -eq 1 -o &quot;$b&quot; -eq 2 ]</code></td></tr></tbody></table><p><strong>现代推荐写法</strong>：使用 <code>&amp;&amp;</code> 和 <code>||</code> 替代 <code>-a</code> 和 <code>-o</code>，更符合 POSIX 标准</p><hr /><h3 id="24-条件判断"><a class="markdownIt-Anchor" href="#24-条件判断"></a> 2.4. 条件判断</h3><p>:::warning<br />和 Java、PHP 等语言不一样，sh 的流程控制不可为空<br />:::</p><p><strong>这个我单独开一篇算了…</strong></p><h2 id="3-拓展shell脚本中的作用"><a class="markdownIt-Anchor" href="#3-拓展shell脚本中的作用"></a> 3. 拓展：shell脚本中<code>$</code>的作用</h2><p>在 Shell 中，<code>$</code> 是一个非常核心的符号，主要用于<strong>变量引用</strong>、<strong>命令替换</strong>、<strong>参数访问</strong>、<strong>字符串操作</strong>等。下面按不同用途分类说明：</p><h3 id="31-变量引用"><a class="markdownIt-Anchor" href="#31-变量引用"></a> 3.1. 变量引用</h3><p><code>$变量名</code> 用于获取变量的值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;lemon&quot;</span><br><span class="line">echo $name     # 输出: lemon</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;name&#125;world   # 输出: lemonworld</span><br></pre></td></tr></table></figure><h3 id="32-命令替换"><a class="markdownIt-Anchor" href="#32-命令替换"></a> 3.2. 命令替换</h3><p><code>$(command)</code> 会执行 <code>command</code> 命令，并将其标准输出结果替换为字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Today is $(date)&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出: Today is Wed Jun 18 17:00:00 CST 2025</span></span><br></pre></td></tr></table></figure><p>等价于旧式：<code>`command`</code></p><h3 id="33-位置参数和特殊变量"><a class="markdownIt-Anchor" href="#33-位置参数和特殊变量"></a> 3.3. 位置参数和特殊变量</h3><p>Shell 脚本中 <code>$</code> 也用于获取传入脚本的参数或特殊含义变量：</p><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>$0</code></td><td>脚本名</td></tr><tr><td><code>$1</code> ~ <code>$9</code></td><td>脚本参数（第1~9个）</td></tr><tr><td><code>$@</code></td><td>所有参数（独立）</td></tr><tr><td><code>$*</code></td><td>所有参数（整体）</td></tr><tr><td><code>$#</code></td><td>参数个数</td></tr><tr><td><code>$$</code></td><td>当前脚本/进程的 PID</td></tr><tr><td><code>$?</code></td><td>上一个命令的返回值</td></tr><tr><td><code>$!</code></td><td>最近一个后台进程的 PID</td></tr></tbody></table><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;【\$0】：脚本名称：$0&quot;</span><br><span class="line">echo &quot;【\$1】：第一个参数：$1&quot;</span><br><span class="line">echo &quot;【\$2】：第二个参数：$2&quot;</span><br><span class="line">echo &quot;【\$#】：参数总数：$#&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;【\$@】：所有参数（逐个显示）&quot;</span><br><span class="line">for arg in &quot;$@&quot;; do</span><br><span class="line">    echo &quot;  - $arg&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 或<span class="built_in">echo</span> <span class="string">&quot;【\$@】：所有参数:&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span></span><br><span class="line">echo &quot;【\$*】：所有参数（整体显示）&quot;</span><br><span class="line">for arg in &quot;$*&quot;; do</span><br><span class="line">    echo &quot;  - $arg&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;【\$$】：当前脚本的 PID 是：$$&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模拟一个命令并查看返回值</span></span><br><span class="line">echo &quot;执行 ls 命令：&quot;</span><br><span class="line">ls &gt; /dev/null</span><br><span class="line">echo &quot;【\$?】：上一个命令的退出状态码：$?&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模拟后台命令并查看其 PID</span></span><br><span class="line">sleep 5 &amp;</span><br><span class="line">echo &quot;【\$!】：最近一个后台任务的 PID 是：$!&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常见问题：<code>$&#123;@&#125;</code>与 <code>$&#123;*&#125;</code>的区别</p><table><thead><tr><th>表达式</th><th>解释</th></tr></thead><tbody><tr><td><code>&quot;$&#123;@&#125;&quot;</code></td><td>把每个参数<strong>作为独立字符串</strong>处理，适合 for 循环</td></tr><tr><td><code>&quot;$&#123;*&#125;&quot;</code></td><td>把所有参数当作<strong>一个整体字符串</strong>处理，若带引号会合并成一个参数</td></tr></tbody></table><h3 id="34-算术扩展"><a class="markdownIt-Anchor" href="#34-算术扩展"></a> 3.4. 算术扩展</h3><p>用 <code>$(())</code> 或 <code>$[]</code> 进行算术运算：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=5</span><br><span class="line">b=3</span><br><span class="line"><span class="built_in">echo</span> $[a + b]  <span class="comment"># 输出: 8</span></span><br></pre></td></tr></table></figure><h3 id="35-字符串操作和默认值处理"><a class="markdownIt-Anchor" href="#35-字符串操作和默认值处理"></a> 3.5. 字符串操作和默认值处理</h3><p>支持 <code>:-</code>, <code>:=</code>, <code>:+</code>, <code>:?</code> 等操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var:-default&#125;   # var未定义则使用&quot;default&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="Shell" scheme="https://blog.godmao.top/categories/Linux/Shell/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="shell" scheme="https://blog.godmao.top/Tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下连接文件</title>
    <link href="https://blog.godmao.top/posts/36626/"/>
    <id>https://blog.godmao.top/posts/36626/</id>
    <published>2025-06-14T13:09:49.000Z</published>
    <updated>2025-06-14T14:04:11.213Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>在 Linux 系统中，我们常常需要在不同位置引用同一个文件，或者希望通过某种方式为某个文件设置别名。这时候，文件“连接（Link）”机制就派上用场了。本文将详细介绍 Linux 下的硬链接（Hard Link）与符号链接（Symbolic Link，又称软链接）的概念、区别以及实际用法。</p><hr /><h2 id="一-什么是文件连接"><a class="markdownIt-Anchor" href="#一-什么是文件连接"></a> 📌 一、什么是文件连接？</h2><p>Linux 中的“连接”指的是为某个文件创建一个别名或指针，使你可以通过多个路径访问同一个文件内容。</p><p>连接分为两种类型：</p><ul><li><strong>硬链接（Hard Link）</strong></li><li><strong>符号链接（Symbolic Link 或 Soft Link）</strong></li></ul><hr /><h2 id="二-硬链接hard-link"><a class="markdownIt-Anchor" href="#二-硬链接hard-link"></a> 🔗 二、硬链接（Hard Link）</h2><h3 id="1-概念"><a class="markdownIt-Anchor" href="#1-概念"></a> 1. 概念</h3><p>硬链接是文件系统中的一种机制，它为<strong>同一个 inode（索引节点）</strong> 创建多个目录项。多个硬链接本质上是“平等的”，互为镜像。</p><h3 id="2-特点"><a class="markdownIt-Anchor" href="#2-特点"></a> 2. 特点</h3><ul><li>同一个 inode 号，表示指向同一个文件内容。</li><li>删除其中一个链接不会影响其他链接。</li><li>不支持对目录创建硬链接（为避免环形结构）。</li><li>只能对同一文件系统内的文件创建。</li></ul><h3 id="3-创建命令"><a class="markdownIt-Anchor" href="#3-创建命令"></a> 3. 创建命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> 源文件 目标文件</span><br></pre></td></tr></table></figure><h3 id="4实验"><a class="markdownIt-Anchor" href="#4实验"></a> 4.实验</h3><p>查看链接数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><p>第二列显示的数字表示链接数（包括自己）。</p><p><img src="Snipaste_2025-06-14_21-30-04.png" alt="" /><br />可见其所占用的存储空间是相同的，说明它们本质是相同的，指向同一incode，删除链接源文件，其他文件依然可以运行。<br />例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> hello</span><br><span class="line">./ hello2</span><br></pre></td></tr></table></figure><p>依然正常输出</p><hr /><h2 id="三-符号链接symbolic-link-soft-link"><a class="markdownIt-Anchor" href="#三-符号链接symbolic-link-soft-link"></a> 三、符号链接（Symbolic Link / Soft Link）</h2><h3 id="1-概念-2"><a class="markdownIt-Anchor" href="#1-概念-2"></a> 1. 概念</h3><p>符号链接类似 Windows 的快捷方式，它是一个<strong>特殊类型的文件</strong>，包含了另一个文件的路径。</p><h3 id="2-特点-2"><a class="markdownIt-Anchor" href="#2-特点-2"></a> 2. 特点</h3><ul><li>是一个独立的文件，有自己的 inode。</li><li>链接路径，而非直接指向数据块。</li><li>删除源文件会导致符号链接失效（变成“悬挂链接”或“死链接”）。</li><li>可跨文件系统，也可指向目录。</li></ul><p>:::bug<br /><strong>请使用绝对路径，否则拷贝文件到另一目录时会失去软连接</strong><br />:::</p><h3 id="3-创建命令-2"><a class="markdownIt-Anchor" href="#3-创建命令-2"></a> 3. 创建命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s 源文件 目标链接名</span><br></pre></td></tr></table></figure><h3 id="4-实验"><a class="markdownIt-Anchor" href="#4-实验"></a> 4. 实验</h3><p>拷贝文件保留软链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -d [源] [目的]</span><br></pre></td></tr></table></figure><p>当使用相对路径时：<br /><img src="Snipaste_2025-06-14_21-42-53.png" alt="" /><br /><img src="Snipaste_2025-06-14_21-48-24.png" alt="" /><br />使用绝对路径：<br /><img src="Snipaste_2025-06-14_21-54-29.png" alt="" /></p><hr /><h2 id="四-硬链接-vs-符号链接"><a class="markdownIt-Anchor" href="#四-硬链接-vs-符号链接"></a> 🆚 四、硬链接 vs 符号链接</h2><table><thead><tr><th>特性</th><th>硬链接（Hard Link）</th><th>符号链接（Symbolic Link）</th></tr></thead><tbody><tr><td>是否有独立 inode</td><td>否</td><td>是</td></tr><tr><td>是否可跨文件系统</td><td>否</td><td>是</td></tr><tr><td>是否可链接目录</td><td>否</td><td>是（需管理员权限）</td></tr><tr><td>删除原文件后</td><td>内容仍保留</td><td>链接失效（悬挂链接）</td></tr><tr><td>作用</td><td>多个文件名共享内容</td><td>文件快捷方式</td></tr></tbody></table><hr /><h2 id="五-补充"><a class="markdownIt-Anchor" href="#五-补充"></a> 🧪 五、补充</h2><h3 id="查找所有指向同一-inode-的文件"><a class="markdownIt-Anchor" href="#查找所有指向同一-inode-的文件"></a> 查找所有指向同一 inode 的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -inum &lt;inode号&gt;</span><br></pre></td></tr></table></figure><h3 id="查找所有死链接"><a class="markdownIt-Anchor" href="#查找所有死链接"></a> 查找所有死链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -xtype l</span><br></pre></td></tr></table></figure><hr /><h2 id="六-总结"><a class="markdownIt-Anchor" href="#六-总结"></a> ✅ 六、总结</h2><table><thead><tr><th>关键点</th><th>硬链接</th><th>符号链接</th></tr></thead><tbody><tr><td>安全性</td><td>内容冗余，较安全</td><td>容易产生死链接</td></tr><tr><td>灵活性</td><td>不支持跨系统和目录</td><td>灵活，可指向任意路径</td></tr><tr><td>适用场景</td><td>本地备份，核心文件</td><td>快捷方式，快捷访问</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/categories/Linux/Ubuntu/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="链接文件" scheme="https://blog.godmao.top/Tags/%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>踩坑记录：WSL下对u盘格式化修改后在win下连接u盘发现盘内内容未改变</title>
    <link href="https://blog.godmao.top/posts/20676/"/>
    <id>https://blog.godmao.top/posts/20676/</id>
    <published>2025-06-14T10:15:30.000Z</published>
    <updated>2025-06-14T10:37:16.303Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>我将USB读卡器插入microSD卡（该SD卡此前刷入过micropython固件包），并将其连接至电脑，接着我在win系统下，在SD卡目录下创建了一个文件wtf.txt，然后打开WSL，使用usbip将该u盘共享，在WSL下，u盘能正确读取、挂载，我在WSL重新对这个u盘使用fdisk重新分区，mkfs重新格式化为FAT32文件系统，并且在WSL下touch了一个新文件hi.txt，使用sync同步，然后使用usbipd的命令断开连接，接入win系统后，wtf.txt居然还在，再次将u盘接入WSL，发现hi.txt也在，也就是说，同样的SD卡，两个系统读到的东西却不一样，这是怎么回事？<br />按照网上的主流方法，尝试过编译内核添加usb驱动支持，手动安装usbip工具都不管用。</p><h2 id="问题解决"><a class="markdownIt-Anchor" href="#问题解决"></a> 问题解决</h2><p>在使用fdisk分区时，我发现如下警告：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The device contains hybrid MBR -- writing GPT only.</span><br></pre></td></tr></table></figure><p>在询问chatgpt后，弄清了这条警告的含义：</p><ol><li><strong>磁盘中检测到 Hybrid MBR</strong>：即使之前格式化或重分区过，它仍可能保留有旧的混合结构。</li><li><strong>当前正尝试用 GPT 格式重写该磁盘</strong>：工具会忽略 MBR 部分，只写入纯 GPT。</li></ol><p><strong>Hybrid MBR（混合主引导记录）</strong> 是一种兼容机制，它允许一个磁盘同时拥有：</p><ul><li>一部分 <strong>MBR（传统 BIOS 启动支持）</strong></li><li>一部分 <strong>GPT（用于现代系统的分区方案）</strong></li></ul><p>这种结构通常用于让 <strong>使用 GPT 分区的磁盘</strong>仍然可以在一些只识别 MBR 的系统中启动，比如旧版 BIOS 系统。</p><p>我突然想起来这个SD卡不就是之前用于引导启动micropython固件的吗，所以存在混合结构，而正是这样的混合结构，是使得在win下，系统读到的是MBR分区表，Linux下读到的是GPT分区表，这就像 SD 卡前面贴着两张标签纸（MBR 和 GPT）：</p><ul><li>Windows 看标签 A，就看到旧文件</li><li>Linux 看标签 B，就看到新文件</li><li>它们根本没在“同一张纸”上操作</li></ul><p>于是我按照GPT提供的方法，使用命令彻底清除磁盘前部（包括 MBR &amp; GPT）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/dev/sdd bs=1M count=10</span><br><span class="line"><span class="built_in">sync</span></span><br></pre></td></tr></table></figure><p>完全抹除了旧的结构信息，再次重复分区、格式化、挂载、创建文件等操作，这下两个系统读取到的文件就同步了😍！</p><h2 id="特别感谢"><a class="markdownIt-Anchor" href="#特别感谢"></a> 特别感谢</h2><ul><li><a href="https://chatgpt.com/">ChatGPT</a>!，AI改变世界啊~</li><li>我自己！</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="记录" scheme="https://blog.godmao.top/categories/Linux/%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="踩坑记录" scheme="https://blog.godmao.top/Tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下文件权限管理</title>
    <link href="https://blog.godmao.top/posts/10180/"/>
    <id>https://blog.godmao.top/posts/10180/</id>
    <published>2025-06-14T09:31:19.000Z</published>
    <updated>2025-06-14T10:37:16.300Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>在命令行界面下，输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /dev</span><br><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><p>得到输出如下：</p><p><img src="Snipaste_2025-06-14_17-39-42.png" alt="" /></p><p>每列释义如下：</p><table><thead><tr><th>列</th><th>示例值</th><th>含义说明</th></tr></thead><tbody><tr><td>1</td><td><code>crw-rw----</code></td><td>文件类型与权限（c 表示字符设备；接下来是用户/组/其他的读写执行权限）</td></tr><tr><td>2</td><td><code>1</code></td><td>硬链接数量（对于设备文件通常是1）</td></tr><tr><td>3</td><td><code>root</code></td><td>文件（或设备）的所有者</td></tr><tr><td>4</td><td><code>root</code></td><td>所属用户组</td></tr><tr><td>5</td><td><code>188, 0</code></td><td>主设备号和次设备号（<strong>仅对设备文件存在</strong>，表示对应驱动和设备）</td></tr><tr><td>6</td><td><code>Jun 14 16:45</code></td><td>最后修改时间</td></tr><tr><td>7</td><td><code>ttyUSB0</code></td><td>文件名（这里是设备名）</td></tr></tbody></table><h2 id="主次设备号"><a class="markdownIt-Anchor" href="#主次设备号"></a> 主次设备号</h2><p>主设备号（Major Number）</p><ul><li>决定了这个文件对应哪个<strong>驱动程序</strong>。</li><li>比如所有的 <code>ttyUSBx</code> 设备可能都由主设备号 188 对应的驱动处理。</li></ul><p>次设备号（Minor Number）</p><ul><li>由主设备号指定的驱动程序使用，用于区分同一驱动管理下的不同设备。</li><li>比如 <code>ttyUSB0</code> 是第一个设备，<code>ttyUSB1</code> 是第二个，以此类推。</li></ul><h2 id="文件权限位详解"><a class="markdownIt-Anchor" href="#文件权限位详解"></a> 文件权限位详解</h2><p>第一列是文件权限位，每位释义如下：</p><table><thead><tr><th>位次</th><th>含义</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>文件类型</td><td><code>-</code></td><td><code>-</code> 普通文件、<code>d</code> 目录、<code>l</code> 软链接、<code>c</code> 字符设备等</td></tr><tr><td>2-4</td><td>所有者权限（user）</td><td><code>rwx</code></td><td>读（r）、写（w）、执行（x）</td></tr><tr><td>5-7</td><td>用户组权限（group）</td><td><code>r-x</code></td><td></td></tr><tr><td>8-10</td><td>其他人权限（other）</td><td><code>r--</code></td><td></td></tr><tr><td>权限字符：</td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>r</code></td><td>可读（read）：可以读取文件内容或列出目录内容</td></tr><tr><td><code>w</code></td><td>可写（write）：可以修改文件内容或添加/删除目录项</td></tr><tr><td><code>x</code></td><td>可执行（execute）：可执行程序或进入目录</td></tr><tr><td><code>-</code></td><td>没有该权限</td></tr></tbody></table><h2 id="文件权限修改"><a class="markdownIt-Anchor" href="#文件权限修改"></a> 文件权限修改</h2><h3 id="一-chmod-命令概述"><a class="markdownIt-Anchor" href="#一-chmod-命令概述"></a> 一、<code>chmod</code> 命令概述</h3><p>用于更改文件或目录的权限，支持 <strong>符号法</strong> 和 <strong>数字法</strong>。</p><hr /><h3 id="二-权限基础"><a class="markdownIt-Anchor" href="#二-权限基础"></a> 二、权限基础</h3><table><thead><tr><th>权限字符</th><th>权限含义</th><th>对文件作用</th><th>对目录作用</th></tr></thead><tbody><tr><td><code>r</code></td><td>读权限</td><td>可读取内容</td><td>可列出目录文件</td></tr><tr><td><code>w</code></td><td>写权限</td><td>可修改内容</td><td>可创建/删除文件</td></tr><tr><td><code>x</code></td><td>执行权限</td><td>可执行</td><td>可进入目录</td></tr></tbody></table><hr /><h3 id="三-符号法symbolic-mode"><a class="markdownIt-Anchor" href="#三-符号法symbolic-mode"></a> 三、符号法（Symbolic Mode）</h3><h4 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [对象][操作][权限] 文件名</span><br></pre></td></tr></table></figure><h4 id="对象权限归属"><a class="markdownIt-Anchor" href="#对象权限归属"></a> 对象（权限归属）</h4><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>u</code></td><td>所有者</td></tr><tr><td><code>g</code></td><td>所属组</td></tr><tr><td><code>o</code></td><td>其他用户</td></tr><tr><td><code>a</code></td><td>所有人（ugo）</td></tr></tbody></table><h4 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> 操作符</h4><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><code>+</code></td><td>添加权限</td></tr><tr><td><code>-</code></td><td>删除权限</td></tr><tr><td><code>=</code></td><td>赋予权限（替换）</td></tr></tbody></table><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x file.sh     <span class="comment"># 给所有者添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> g-w file.txt    <span class="comment"># 移除组的写权限</span></span><br><span class="line"><span class="built_in">chmod</span> o=r file.txt    <span class="comment"># 其他人只读</span></span><br><span class="line"><span class="built_in">chmod</span> a+x run.sh      <span class="comment"># 所有人添加执行权限</span></span><br></pre></td></tr></table></figure><hr /><h3 id="四-数字法octal-mode"><a class="markdownIt-Anchor" href="#四-数字法octal-mode"></a> 四、数字法（Octal Mode）</h3><h4 id="权限与数字映射"><a class="markdownIt-Anchor" href="#权限与数字映射"></a> 权限与数字映射</h4><table><thead><tr><th>权限</th><th>数值</th><th>含义</th></tr></thead><tbody><tr><td><code>---</code></td><td>0</td><td>无权限</td></tr><tr><td><code>--x</code></td><td>1</td><td>执行</td></tr><tr><td><code>-w-</code></td><td>2</td><td>写</td></tr><tr><td><code>-wx</code></td><td>3</td><td>写 + 执行</td></tr><tr><td><code>r--</code></td><td>4</td><td>读</td></tr><tr><td><code>r-x</code></td><td>5</td><td>读 + 执行</td></tr><tr><td><code>rw-</code></td><td>6</td><td>读 + 写</td></tr><tr><td><code>rwx</code></td><td>7</td><td>全部权限</td></tr><tr><td>相当于以二进制对应的十进制来表示，这点应该不陌生。</td><td></td><td></td></tr></tbody></table><h4 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 script.sh    <span class="comment"># 所有者全部权限，其他用户读+执行</span></span><br><span class="line"><span class="built_in">chmod</span> 644 note.txt     <span class="comment"># 所有者读写，其他人只读</span></span><br><span class="line"><span class="built_in">chmod</span> 700 secret.txt   <span class="comment"># 只有所有者有权限</span></span><br></pre></td></tr></table></figure><hr /><h3 id="五-递归权限修改"><a class="markdownIt-Anchor" href="#五-递归权限修改"></a> 五、递归权限修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R 755 myfolder     <span class="comment"># 递归修改目录及其下所有文件/子目录权限</span></span><br></pre></td></tr></table></figure><hr /><h3 id="六-使用-find-批量设置权限"><a class="markdownIt-Anchor" href="#六-使用-find-批量设置权限"></a> 六、使用 find 批量设置权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">chmod</span> 644 &#123;&#125; \;   <span class="comment"># 设置所有文件权限</span></span><br><span class="line">find . -<span class="built_in">type</span> d -<span class="built_in">exec</span> <span class="built_in">chmod</span> 755 &#123;&#125; \;   <span class="comment"># 设置所有目录权限</span></span><br></pre></td></tr></table></figure><hr /><h3 id="七-常见目录权限推荐"><a class="markdownIt-Anchor" href="#七-常见目录权限推荐"></a> 七、常见目录权限推荐</h3><table><thead><tr><th>目录</th><th>推荐权限</th><th>含义说明</th></tr></thead><tbody><tr><td><code>/home/用户名</code></td><td><code>700</code></td><td>仅用户本人访问</td></tr><tr><td><code>/tmp</code></td><td><code>1777</code></td><td>所有人可写，Sticky 位保护</td></tr><tr><td>网站目录</td><td><code>755</code></td><td>其他人可访问但不可修改</td></tr></tbody></table><hr /><h3 id="八-特殊权限简述可选"><a class="markdownIt-Anchor" href="#八-特殊权限简述可选"></a> 八、特殊权限简述（可选）</h3><table><thead><tr><th>权限</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>SUID</td><td>执行程序时使用文件所有者权限</td><td><code>chmod u+s</code></td></tr><tr><td>SGID</td><td>同上，应用于组</td><td><code>chmod g+s</code></td></tr><tr><td>Sticky</td><td>只能删除自己文件（多用于/tmp）</td><td><code>chmod +t</code></td></tr></tbody></table><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/categories/Linux/Ubuntu/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/Tags/Ubuntu/"/>
    
    <category term="文件系统" scheme="https://blog.godmao.top/Tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下磁盘管理</title>
    <link href="https://blog.godmao.top/posts/30265/"/>
    <id>https://blog.godmao.top/posts/30265/</id>
    <published>2025-06-12T08:00:30.000Z</published>
    <updated>2025-06-14T10:37:16.302Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>前面我们成功让WSL读取到Win系统的USB设备，下面来学习WSL下磁盘的管理。</p><h2 id="磁盘和目录的容量查询命令"><a class="markdownIt-Anchor" href="#磁盘和目录的容量查询命令"></a> 磁盘和目录的容量查询命令</h2><p><code>df</code> ：查看文件系统使用量，主要查看文件系统的使用量。<br /><code>du</code> ：评估文件系统的磁盘使用量，主要查看单个文件大小。<br /><code>lsblk</code> ：<em>List Block Devices</em> 列出系统中SSD、U盘等存储设备的信息</p><h2 id="磁盘的挂载卸载"><a class="markdownIt-Anchor" href="#磁盘的挂载卸载"></a> 磁盘的挂载卸载</h2><p>还记得前面提到的<a href="https://blog.godmao.top/posts/7417/">Ubuntu文件系统结构</a>吗？想要读取u盘里的文件，需要把u盘挂载在某个目录下才能访问。</p><h3 id="什么是挂载"><a class="markdownIt-Anchor" href="#什么是挂载"></a> 什么是挂载？</h3><p>挂载就是“<strong>把设备上的文件系统接入Linux的目录结构中</strong>”。</p><ul><li>Linux 的目录结构是一个<strong>统一的树形结构</strong>（根目录 <code>/</code> 是起点）。</li><li>所有的文件、文件夹、设备访问，都要通过这个统一的目录树。</li><li>当你插入一个U盘时，它本身是一个独立的文件系统（如FAT32），Linux不会自动将其连接进目录树，除非你明确地<strong>挂载</strong>它。</li></ul><h3 id="为什么linux要挂载windows为什么不需要"><a class="markdownIt-Anchor" href="#为什么linux要挂载windows为什么不需要"></a> 为什么Linux要挂载？Windows为什么不需要？</h3><p><strong>Linux设计哲学：</strong></p><ul><li>Linux源于Unix，追求“一切皆文件”，统一的目录结构。</li><li>所有设备都必须通过<code>/dev/xxx</code>表示为一个文件，然后挂载到某个目录（如<code>/mnt/usb</code>）才可以访问。<br /><strong>Windows的方式：</strong></li><li>Windows是“盘符式”的，每个设备有独立的盘符（如<code>E:\</code>, <code>F:\</code>），操作系统会<strong>自动识别并挂载</strong>。</li><li>挂载过程对用户是透明的，但其实系统内部也在完成挂载，只是隐藏了细节。<br />所以：<strong>Windows系统也挂载，只是自动化并且用盘符表示；Linux则更显式且灵活</strong>。</li></ul><h3 id="linux下如何手动挂载u盘"><a class="markdownIt-Anchor" href="#linux下如何手动挂载u盘"></a> Linux下如何手动挂载u盘？</h3><p>如果是U盘可以挂载在<code>/dev/media/</code>目录或<code>/dev/mnt/</code>目录</p><h4 id="1查看u盘设备名"><a class="markdownIt-Anchor" href="#1查看u盘设备名"></a> 1.查看u盘设备名</h4><p>在使用usbipd使WSL读取到u盘后，运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><p>会看到类似这样的输出：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sdb      8:16  <span class="number"> 1 </span> 29.8G <span class="number"> 0 </span>disk</span><br><span class="line">├─sdb1   8:17  <span class="number"> 1 </span> 10.0G <span class="number"> 0 </span>part</span><br><span class="line">├─sdb2   8:18  <span class="number"> 1 </span>  9.8G <span class="number"> 0 </span>part</span><br><span class="line">└─sdb3   8:19  <span class="number"> 1 </span> 10.0G <span class="number"> 0 </span>part</span><br></pre></td></tr></table></figure><p>这里 <code>sdb1</code> 是U盘的分区名。磁盘可能有很多分区嘛。</p><h4 id="2为每个分区创建挂载点目录"><a class="markdownIt-Anchor" href="#2为每个分区创建挂载点目录"></a> 2.为每个分区创建挂载点目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /mnt/usb1 /mnt/usb2 /mnt/usb3</span><br></pre></td></tr></table></figure><h4 id="3逐个挂载"><a class="markdownIt-Anchor" href="#3逐个挂载"></a> 3.逐个挂载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount /dev/sdb1 /mnt/usb1</span><br><span class="line"><span class="built_in">sudo</span> mount /dev/sdb2 /mnt/usb2</span><br><span class="line"><span class="built_in">sudo</span> mount /dev/sdb3 /mnt/usb3</span><br></pre></td></tr></table></figure><p>如果某个分区的文件系统不是自动识别的（报错），你可以指定类型挂载，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount -t vfat /dev/sdb1 /mnt/usb1</span><br><span class="line"><span class="built_in">sudo</span> mount -t ext4 /dev/sdb2 /mnt/usb2</span><br><span class="line"><span class="built_in">sudo</span> mount -t ntfs /dev/sdb3 /mnt/usb3</span><br></pre></td></tr></table></figure><p>如果不清楚类型运行如下命令可以查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> blkid /dev/sdb1 /dev/sdb2 /dev/sdb3</span><br></pre></td></tr></table></figure><h3 id="卸载"><a class="markdownIt-Anchor" href="#卸载"></a> 卸载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> umount /mnt/usb1</span><br><span class="line"><span class="built_in">sudo</span> umount /mnt/usb2</span><br><span class="line"><span class="built_in">sudo</span> umount /mnt/usb3</span><br></pre></td></tr></table></figure><h2 id="磁盘分区"><a class="markdownIt-Anchor" href="#磁盘分区"></a> 磁盘分区</h2><h3 id="fdisk命令常用选项"><a class="markdownIt-Anchor" href="#fdisk命令常用选项"></a> fdisk命令常用选项</h3><table><thead><tr><th>命令</th><th>含义</th><th>功能说明</th></tr></thead><tbody><tr><td><code>m</code></td><td>help</td><td>显示所有可用命令</td></tr><tr><td><code>p</code></td><td>print</td><td>显示当前分区表</td></tr><tr><td><code>n</code></td><td>new</td><td>创建一个新分区（主分区或逻辑分区）</td></tr><tr><td><code>d</code></td><td>delete</td><td>删除一个已有分区</td></tr><tr><td><code>t</code></td><td>type</td><td>修改分区的类型 ID</td></tr><tr><td><code>l</code></td><td>list</td><td>列出所有分区类型 ID</td></tr><tr><td><code>a</code></td><td>toggle bootable</td><td>切换分区的启动标志（设置/取消可引导分区）</td></tr><tr><td><code>w</code></td><td>write</td><td>写入分区表并退出</td></tr><tr><td><code>q</code></td><td>quit</td><td>不保存更改，直接退出</td></tr><tr><td><code>g</code></td><td>gpt</td><td>创建新的 GPT 分区表</td></tr><tr><td><code>o</code></td><td>dos</td><td>创建新的空白 DOS (MBR) 分区表</td></tr><tr><td><code>v</code></td><td>verify</td><td>验证分区表的完整性</td></tr><tr><td><code>x</code></td><td>expert</td><td>进入专家模式（用于高级操作）</td></tr></tbody></table><h3 id="用fdisk打开要分区的磁盘"><a class="markdownIt-Anchor" href="#用fdisk打开要分区的磁盘"></a> 用fdisk打开要分区的磁盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> fdisk /dev/sde</span><br></pre></td></tr></table></figure><p>:::warning<br />千万不要误选，否则可能破坏你的数据。<br />:::</p><h3 id="删除分区"><a class="markdownIt-Anchor" href="#删除分区"></a> 删除分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p        ← 查看当前分区情况（确认要删哪个）</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): d        ← 删除分区</span><br><span class="line">Partition number (1,2,...): 2  ← 选择你要删除的分区编号（比如 2 表示 /dev/sdb2）</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w        ← 保存更改并退出</span><br></pre></td></tr></table></figure><h3 id="创建分区"><a class="markdownIt-Anchor" href="#创建分区"></a> 创建分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br></pre></td></tr></table></figure><p><img src="Snipaste_2025-06-12_17-21-39.png" alt="" /></p><p>1：分区编号，直接回车接受默认编号。<br />2：起始扇区，默认值通常合适，直接回车即可。<br />3：结束扇区 or 分区大小，可以输入：扇区编号（直接回车使用剩余空间）或者手动输入大小（例如：<code>+1G</code>、<code>+512M</code>）</p><h3 id="写出"><a class="markdownIt-Anchor" href="#写出"></a> 写出</h3><p>保存并退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br></pre></td></tr></table></figure><h2 id="格式化分区"><a class="markdownIt-Anchor" href="#格式化分区"></a> 格式化分区</h2><p>当用 <code>fdisk</code> 创建完一个分区后，这个分区只是“逻辑划分好了”，但<strong>还不能使用</strong>，必须要**格式化（创建文件系统）**才能真正读写数据。</p><h3 id="为什么要格式化"><a class="markdownIt-Anchor" href="#为什么要格式化"></a> 为什么要格式化？</h3><p>格式化的本质是：</p><blockquote><p><strong>在分区上写入特定的文件系统结构</strong>（如 ext4、FAT32、NTFS 等）。</p></blockquote><p>只有这样，操作系统才知道如何在这块区域内组织、存储和查找文件。</p><h3 id="1选择格式化类型"><a class="markdownIt-Anchor" href="#1选择格式化类型"></a> 1.选择格式化类型</h3><table><thead><tr><th>文件系统</th><th>说明</th></tr></thead><tbody><tr><td>ext4</td><td>Linux常用，性能稳定，支持大文件</td></tr><tr><td>vfat</td><td>FAT32，兼容Windows/Mac/Linux，不支持大文件</td></tr><tr><td>ntfs</td><td>Windows常用，Linux可读写（需驱动）</td></tr><tr><td>exfat</td><td>新型通用格式，支持大文件，跨平台兼容性好</td></tr></tbody></table><h3 id="2执行格式化命令"><a class="markdownIt-Anchor" href="#2执行格式化命令"></a> 2.执行格式化命令</h3><p><em>make file system</em> -type</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkfs.vfat -f 32 /dev/sde2</span><br></pre></td></tr></table></figure><p>没有mkfs的先安装，不然报错：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to<span class="built_in"> execute </span>mkfs.vfat: No such file<span class="built_in"> or </span>directory</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install dosfstools</span><br></pre></td></tr></table></figure><h3 id="检查"><a class="markdownIt-Anchor" href="#检查"></a> 检查</h3><p>可以输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> blkid /dev/sde1 /dev/sde2</span><br></pre></td></tr></table></figure><p>检查type<br />输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sde1: <span class="attribute">UUID</span>=<span class="string">&quot;FBD5-E06C&quot;</span> <span class="attribute">BLOCK_SIZE</span>=<span class="string">&quot;512&quot;</span> <span class="attribute">TYPE</span>=<span class="string">&quot;vfat&quot;</span> <span class="attribute">PARTUUID</span>=<span class="string">&quot;3b15f93b-f163-491d-9f0f-94be96692beb&quot;</span></span><br><span class="line">sde2: <span class="attribute">UUID</span>=<span class="string">&quot;FC22-7890&quot;</span> <span class="attribute">BLOCK_SIZE</span>=<span class="string">&quot;512&quot;</span> <span class="attribute">TYPE</span>=<span class="string">&quot;vfat&quot;</span> <span class="attribute">PARTUUID</span>=<span class="string">&quot;248a2fdb-2255-4a7a-802e-e5a11bb87c53&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/categories/Linux/Ubuntu/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/Tags/Ubuntu/"/>
    
    <category term="磁盘管理" scheme="https://blog.godmao.top/Tags/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>WSL下连接USB设备</title>
    <link href="https://blog.godmao.top/posts/13715/"/>
    <id>https://blog.godmao.top/posts/13715/</id>
    <published>2025-06-11T15:49:53.000Z</published>
    <updated>2025-06-14T09:32:43.934Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>⭐⭐⭐本文参考自微软官方WSL文档——<a href="https://learn.microsoft.com/zh-cn/windows/wsl/connect-usb">连接 USB 设备 | Microsoft Learn</a></p><p>由于WSL不提供本机连接USB设备的支持，因此需要安装开源项目usbipd-win来支持USB的共享连接。</p><h2 id="什么是usbpid"><a class="markdownIt-Anchor" href="#什么是usbpid"></a> 什么是usbpid？</h2><p>usbipd 是一个<strong>用于管理 USB/IP（USB over IP）服务的命令行工具</strong>，可以在 Windows 下使用。 USB/IP 是一种协议，允许<strong>通过网络共享USB 设备</strong>。 usbipd工具允许用户在 Windows 上共享 USB 设备，使其他计算机能够通过网络访问这些设备。</p><h2 id="安装-usbipd-win-项目"><a class="markdownIt-Anchor" href="#安装-usbipd-win-项目"></a> 安装 USBIPD-WIN 项目</h2><ol><li>转到 <a href="https://github.com/dorssel/usbipd-win/releases">usbipd-win 项目的最新发布页面</a>。</li><li>选择 .msi 文件，该文件将下载安装程序。 （你可能会收到一条警告，要求你确认你信任此下载）。</li><li>运行下载 usbipd-win_x.msi 安装程序文件。</li></ol><p>这将安装：</p><ul><li>名为 <code>usbipd</code> 的服务，（显示名称：USBIP 设备主机）。 可以使用 Windows 中的服务应用检查此服务的状态。</li><li>命令行工具 <code>usbipd</code>。 此工具的位置将添加到 PATH 环境变量。</li><li>名为 <code>usbipd</code> 的防火墙规则，用于允许所有本地子网连接到服务。 可修改此防火墙规则以微调访问控制。</li></ul><ol start="4"><li>若要附加 USB 设备，请运行以下命令。 （不再需要使用提升的管理员提示。确保 WSL 命令提示符处于打开状态，以使 WSL 2 轻型 VM 保持活动状态。 <strong>请注意，只要 USB 设备连接到 WSL，Windows 将无法使用它。</strong> 一旦连接到 WSL，任何在 WSL 2 上运行的发行版都可以使用该 USB 设备。 请确认设备是否已连接 <code>usbipd list</code>。 在 WSL 提示符下，运行 <code>lsusb</code> 以验证 USB 设备是否已列出，并且可以使用 Linux 工具与之交互。</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usbipd attach <span class="literal">--wsl</span> <span class="literal">--busid</span> &lt;busid&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>打开 Ubuntu（或首选 WSL 命令行），并使用以下命令列出附加的 USB 设备：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br><span class="line">或者</span><br><span class="line">lsblk -f</span><br></pre></td></tr></table></figure><p>若没有找到命令，则先下载<code>usbutils</code><br /><img src="Snipaste_2025-06-12_00-11-23.png" alt="" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install usbutils</span><br></pre></td></tr></table></figure><p>可以看到已经成功读取到u盘，并且能够使用普通 Linux 工具与之交互。 根据应用程序，可能需要配置 udev 规则，以允许非根用户访问设备。<br /><img src="Snipaste_2025-06-12_00-18-59.png" alt="" /><br />6. 在 WSL 中使用设备后，可以物理断开 USB 设备的连接，或者从 PowerShell 运行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usbipd detach <span class="literal">--busid</span> &lt;busid&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="WSL2" scheme="https://blog.godmao.top/categories/Linux/WSL2/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="USB" scheme="https://blog.godmao.top/Tags/USB/"/>
    
    <category term="WSL2" scheme="https://blog.godmao.top/Tags/WSL2/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu文件系统结构</title>
    <link href="https://blog.godmao.top/posts/7417/"/>
    <id>https://blog.godmao.top/posts/7417/</id>
    <published>2025-06-11T09:02:41.000Z</published>
    <updated>2025-06-14T09:32:23.332Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>Ubuntu文件系统结构清单。</p><span id="more"></span><blockquote><p>万物皆文件</p></blockquote><p><strong>仅作学习记录。</strong></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td><code>/</code></td><td>根目录，是所有文件和目录的起点。</td></tr><tr><td><code>/bin</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></td><td>存放系统启动和运行所需的基本命令（如 <code>ls</code>, <code>cp</code>, <code>mv</code>）。</td></tr><tr><td><code>/boot</code></td><td>启动相关文件，如内核 (<code>vmlinuz</code>)、引导加载器配置等。</td></tr><tr><td><code>/dev</code></td><td>包含所有设备（驱动）文件（如硬盘、终端、USB 设备）。</td></tr><tr><td><code>/etc</code></td><td>系统配置文件目录（如网络、用户、服务配置）。</td></tr><tr><td><code>/home</code></td><td>每个普通用户的主目录（如 <code>/home/alice</code>）。</td></tr><tr><td><code>/lib</code></td><td>存放系统程序所需的共享库文件。</td></tr><tr><td><code>/lib64</code></td><td>存放64位系统的共享库（与 <code>/lib</code> 类似）。</td></tr><tr><td><code>/media</code></td><td>可移动设备挂载点（如U盘、CD-ROM）。</td></tr><tr><td><code>/mnt</code></td><td>临时挂载文件系统的目录，供管理员使用。</td></tr><tr><td><code>/opt</code></td><td>为第三方软件提供安装位置。</td></tr><tr><td><code>/proc</code></td><td>虚拟文件系统，内核和进程信息以文件形式展现（如 <code>/proc/cpuinfo</code>）。存放系统运行的信息？</td></tr><tr><td><code>/root</code></td><td><code>root</code> 用户的主目录（注意：不是 <code>/</code>）。</td></tr><tr><td><code>/run</code></td><td>存放运行时数据，如系统启动后生成的PID文件或Socket文件。</td></tr><tr><td><code>/sbin</code></td><td>存放系统管理类命令，仅供 <code>root</code> 用户使用（如 <code>reboot</code>, <code>fsck</code>）。</td></tr><tr><td><code>/srv</code></td><td>存放提供服务的数据（如网站、FTP 服务器数据）。</td></tr><tr><td><code>/sys</code></td><td>虚拟文件系统，表示内核设备结构，供 <code>udev</code> 和其他工具使用。</td></tr><tr><td><code>/tmp</code></td><td>存放临时文件（系统重启后清空）。</td></tr><tr><td><code>/usr</code></td><td>多数用户空间程序和库的安装目录。</td></tr><tr><td><code>/usr/bin</code></td><td>非必要基本命令（大部分用户程序）的位置。</td></tr><tr><td><code>/usr/sbin</code></td><td>系统管理命令的位置，供管理员使用。</td></tr><tr><td><code>/usr/lib</code></td><td><code>/usr/bin</code> 和 <code>/usr/sbin</code> 程序所用库文件。</td></tr><tr><td><code>/var</code></td><td>可变数据文件（如日志、缓存、邮件、数据库文件等）。</td></tr></tbody></table><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Faker VS Bin 你蹲我的意思吗 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;CC 4.0 BY-SA&lt;/a&gt; 版权协议，转载请附上原文出处链接和本声明。&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;Ubuntu文件系统结构清单。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/categories/Linux/Ubuntu/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.godmao.top/Tags/Ubuntu/"/>
    
    <category term="文件系统" scheme="https://blog.godmao.top/Tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用的命令总结</title>
    <link href="https://blog.godmao.top/posts/37616/"/>
    <id>https://blog.godmao.top/posts/37616/</id>
    <published>2025-06-11T07:35:35.000Z</published>
    <updated>2025-06-18T10:17:26.540Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>Linux下常用的命令清单及补充。</p><span id="more"></span><p><strong>仅作学习记录。</strong></p><table><thead><tr><th>命令</th><th>说明</th><th>使用格式</th></tr></thead><tbody><tr><td><code>ls</code></td><td>列出目录内容</td><td><code>ls [选项] [目录]</code></td></tr><tr><td><code>cd</code></td><td>改变当前目录</td><td><code>cd [目录]</code></td></tr><tr><td><code>pwd</code></td><td>显示当前工作目录</td><td><code>pwd</code></td></tr><tr><td><code>cp</code></td><td>复制文件或目录</td><td><code>cp [选项] 源文件 目标文件</code></td></tr><tr><td><code>mv</code></td><td>移动文件或目录，重命名文件</td><td><code>mv [选项] 源文件 目标文件</code></td></tr><tr><td><code>rm</code></td><td>删除文件或目录</td><td><code>rm [选项] 文件</code></td></tr><tr><td><code>touch</code></td><td>创建空文件</td><td><code>touch 文件名</code></td></tr><tr><td><code>mkdir</code></td><td>创建目录</td><td><code>mkdir [选项] 目录名</code></td></tr><tr><td><code>rmdir</code></td><td>删除空目录</td><td><code>rmdir 目录名</code></td></tr><tr><td><code>chmod</code></td><td>更改文件或目录权限</td><td><code>chmod [选项] 权限 文件</code></td></tr><tr><td><code>chown</code></td><td>更改文件或目录的所有者</td><td><code>chown 用户:组 文件</code></td></tr><tr><td><code>chgrp</code></td><td>更改文件或目录的所属组</td><td><code>chgrp 组 文件</code></td></tr><tr><td><code>cat</code></td><td>查看文件内容</td><td><code>cat 文件名</code></td></tr><tr><td><code>more</code></td><td>分页显示文件内容</td><td><code>more 文件名</code></td></tr><tr><td><code>less</code></td><td>分页显示文件内容（支持上下翻页）</td><td><code>less 文件名</code></td></tr><tr><td><code>head</code></td><td>查看文件开头部分</td><td><code>head [选项] 文件</code></td></tr><tr><td><code>tail</code></td><td>查看文件尾部部分</td><td><code>tail [选项] 文件</code></td></tr><tr><td><code>find</code></td><td>查找文件或目录</td><td><code>find [路径] [选项] [表达式]</code></td></tr><tr><td><code>grep</code></td><td>文本搜索</td><td><code>grep [选项] &quot;模式&quot; 文件</code></td></tr><tr><td><code>tar</code></td><td>压缩或解压文件</td><td><code>tar [选项] [文件]</code></td></tr><tr><td><code>gzip</code></td><td>压缩文件</td><td><code>gzip 文件名</code></td></tr><tr><td><code>gunzip</code></td><td>解压.gz文件</td><td><code>gunzip 文件名.gz</code></td></tr><tr><td><code>zip</code></td><td>压缩文件</td><td><code>zip [选项] 压缩包 文件</code></td></tr><tr><td><code>unzip</code></td><td>解压.zip文件</td><td><code>unzip 压缩包</code></td></tr><tr><td><code>df</code></td><td>查看文件系统磁盘空间使用情况</td><td><code>df [选项]</code></td></tr><tr><td><code>du</code></td><td>查看目录或文件的磁盘使用情况</td><td><code>du [选项] 文件/目录</code></td></tr><tr><td><code>top</code></td><td>查看系统进程状态</td><td><code>top</code></td></tr><tr><td><code>ps</code></td><td>查看进程状态</td><td><code>ps [选项]</code></td></tr><tr><td><code>kill</code></td><td>终止进程</td><td><code>kill [选项] 进程号</code></td></tr><tr><td><code>pstree</code></td><td>以树形结构显示进程</td><td><code>pstree</code></td></tr><tr><td><code>free</code></td><td>查看内存使用情况</td><td><code>free [选项]</code></td></tr><tr><td><code>uname</code></td><td>查看系统信息</td><td><code>uname [选项]</code></td></tr><tr><td><code>ifconfig</code></td><td>配置网络接口</td><td><code>ifconfig [网络接口]</code></td></tr><tr><td><code>ip</code></td><td>查看或配置网络</td><td><code>ip [选项]</code></td></tr><tr><td><code>ping</code></td><td>测试网络连接</td><td><code>ping [选项] 地址</code></td></tr><tr><td><code>scp</code></td><td>安全复制文件</td><td><code>scp 源文件 用户@主机:目标</code></td></tr><tr><td><code>rsync</code></td><td>同步文件和目录</td><td><code>rsync [选项] 源 目标</code></td></tr><tr><td><code>wget</code></td><td>从网络下载文件</td><td><code>wget [选项] URL</code></td></tr><tr><td><code>curl</code></td><td>与网络交互（下载、上传文件等）</td><td><code>curl [选项] URL</code></td></tr><tr><td><code>alias</code></td><td>创建命令别名</td><td><code>alias 别名='命令'</code></td></tr><tr><td><code>history</code></td><td>查看命令历史</td><td><code>history</code></td></tr><tr><td><code>man</code></td><td>查看命令手册</td><td><code>man 命令名</code></td></tr><tr><td><code>echo</code></td><td>输出字符串到终端</td><td><code>echo &quot;文本&quot;</code></td></tr><tr><td><code>tee</code></td><td>从标准输入读取，并将其内容输出到文件</td><td><code>命令 | tee 文件</code></td></tr><tr><td><code>cut</code></td><td>按列切割文件内容</td><td><code>cut -d 分隔符 -f 列 文件</code></td></tr><tr><td><code>awk</code></td><td>强大的文本处理工具</td><td><code>awk '条件 &#123;动作&#125;' 文件</code></td></tr><tr><td><code>sed</code></td><td>流编辑器，处理文本数据</td><td><code>sed 's/模式/替换文本/' 文件</code></td></tr><tr><td><code>tr</code></td><td>转换字符</td><td><code>tr '旧字符' '新字符' &lt; 文件</code></td></tr><tr><td><code>wc</code></td><td>统计文件字数、行数、字节数等</td><td><code>wc [选项] 文件</code></td></tr><tr><td><code>whoami</code></td><td>查看当前用户</td><td><code>whoami</code></td></tr><tr><td><code>sudo</code></td><td>以超级用户身份执行命令</td><td><code>sudo 命令</code></td></tr><tr><td><code>exit</code></td><td>退出终端或当前Shell会话</td><td><code>exit</code></td></tr><tr><td><code>file</code></td><td>文件类型查看命令</td><td><code>file 文件路径</code></td></tr></tbody></table><h2 id="ls"><a class="markdownIt-Anchor" href="#ls"></a> ls</h2><p>-a 列出全部<br />-l 以列展示</p><h2 id="ranger"><a class="markdownIt-Anchor" href="#ranger"></a> ranger</h2><p>一个终端文件管理器（Vim风格）</p><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>向上/向下</td><td>方向键</td></tr><tr><td>进入目录或打开文件</td><td><code>l / Enter</code></td></tr><tr><td>返回上一级目录</td><td>方向键</td></tr><tr><td>创建新文件</td><td><code>:touch filename</code></td></tr><tr><td>创建新目录</td><td><code>:mkdir dirname</code></td></tr><tr><td>删除文件/目录</td><td><code>D</code> 然后确认</td></tr><tr><td>重命名</td><td><code>cw</code></td></tr><tr><td>复制</td><td><code>yy</code>（复制）+ <code>pp</code>（粘贴）</td></tr><tr><td>剪切</td><td><code>dd</code>（剪切）+ <code>pp</code>（粘贴）</td></tr><tr><td>预览文件内容</td><td>自动或按 <code>i</code></td></tr><tr><td>搜索文件名</td><td><code>/关键词</code></td></tr><tr><td>退出</td><td><code>q</code> 或 <code>:q</code></td></tr></tbody></table><h2 id="grep"><a class="markdownIt-Anchor" href="#grep"></a> grep</h2><p>-r  递归子目录<br />-l  列出文件内容符合指定的样式的文件名称。<br />-i  不区分大小写<br />-n 字符串在哪一行</p><h2 id="du"><a class="markdownIt-Anchor" href="#du"></a> du</h2><p>-s 只显示指定目录总大小<br />-h 以单位k、m、g显示</p><h2 id="tar"><a class="markdownIt-Anchor" href="#tar"></a> tar</h2><p>-c 创建新归档，压缩<br />-x 从归档中解出文件，解压缩<br />-j 使用bzip2压缩格式<br />-z 使用gzip压缩格式<br />-v 打印命令执行过程<br />-f 以什么名字归档</p>]]></content>
    
    
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;CC 4.0 BY-SA&lt;/a&gt; 版权协议，转载请附上原文出处链接和本声明。&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;/details&gt;
&lt;hr /&gt;
&lt;p&gt;Linux下常用的命令清单及补充。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="命令" scheme="https://blog.godmao.top/Tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的在win上运行Linux</title>
    <link href="https://blog.godmao.top/posts/26155/"/>
    <id>https://blog.godmao.top/posts/26155/</id>
    <published>2025-06-07T15:16:17.000Z</published>
    <updated>2025-06-14T09:32:51.535Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>在 Windows 和 Linux 之间切换开发环境是一件让人头疼的事。幸运的是，WSL（Windows Subsystem for Linux）为我们提供了一种优雅的解决方案：<strong>在 Windows 上原生运行 Linux</strong>，无需虚拟机或双系统。本文将带你优雅地入门 WSL，从安装到使用，让你轻松拥有双系统的快乐而不牺牲效率。</p><h2 id="一-wsl-是什么"><a class="markdownIt-Anchor" href="#一-wsl-是什么"></a> 一、WSL 是什么？</h2><p>WSL（Windows Subsystem for Linux）是微软提供的一种兼容层，使你可以直接在 Windows 上运行 Linux 用户空间环境。当前主流版本是 <strong>WSL 2</strong>，它使用轻量虚拟化技术，提供完整的 Linux 内核和更好的性能。那么它有什么好处呢？</p><ul><li>Linux 、Windows文件共享。你可以在Windows的文件资源管理器上处理Linux子系统的文件</li><li>命令混用，在Windows里可以运行Liunx命令，在Linux里可以运行Windows程序</li><li>显卡直通，在AI训练方面非常方便<br />等等…</li></ul><h2 id="二-准备工作"><a class="markdownIt-Anchor" href="#二-准备工作"></a> 二、准备工作</h2><p>:::success</p><ul><li>Windows 10（版本 2004 及以上，推荐 21H2 或更高）</li><li>或 Windows 11（原生支持 WSL 2）<br />:::<br />本文以win11为例。</li></ul><h3 id="开启必要功能"><a class="markdownIt-Anchor" href="#开启必要功能"></a> 开启必要功能</h3><p>在搜索栏搜索 <code>启动或关闭window功能</code><br /><img src="Snipaste_2025-06-07_23-29-33%201.png" alt="" /><br />开启如下两项：</p><ul><li>适用于Linux的Windows子系统</li><li>虚拟机平台<br /><img src="Snipaste_2025-06-07_23-32-13.png" alt="" /><br />然后<strong>重启以使更改生效</strong>。<br />如果是win11的话重启后可以看到文件资源管理器中有个Linux<br /><img src="Snipaste_2025-06-07_23-36-31.png" alt="" /></li></ul><h2 id="安装linux子系统"><a class="markdownIt-Anchor" href="#安装linux子系统"></a> 安装Linux子系统</h2><p>:::warning<br />win11原生支持WSL2，如果没有安装WSL，可以点击这个链接安装<br /><a href="https://apps.microsoft.com/detail/9p9tqf7mrm4r?ocid=pdpshare&amp;hl=en-us&amp;gl=US">Windows Subsystem for Linux - Microsoft Apps</a><br />:::</p><p>这里提供两种方法安装WSL2：</p><h3 id="直接安装发行版"><a class="markdownIt-Anchor" href="#直接安装发行版"></a> 直接安装发行版</h3><p>打开下面的链接：<br /><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-1---enable-the-windows-subsystem-for-linux">旧版 WSL 的手动安装步骤 | Microsoft Learn</a><br />直接下载想要的系统的发行版：<br /><img src="Snipaste_2025-06-08_00-08-42.png" alt="" /></p><p>下载下来后将文件后缀改为<code>.zip</code>,解压缩<br /><img src="Snipaste_2025-06-08_00-11-46.png" alt="" /></p><p>解压后，选择x64版本，同样的方法，继续解压<br /><img src="Snipaste_2025-06-08_00-14-29.png" alt="" /></p><p>解压后，复制如下两个文件到你想要安装的指定目录<br /><img src="Snipaste_2025-06-08_00-14-53.png" alt="" /></p><p>例如我的是<code>E:\Linux\Ubuntu-24.04LTS</code></p><p>在目录下双击运行exe文件，自此安装完成。<br /><img src="Snipaste_2025-06-08_00-18-01.png" alt="" /></p><h3 id="命令行安装不推荐"><a class="markdownIt-Anchor" href="#命令行安装不推荐"></a> 命令行安装（不推荐）</h3><p>不推荐原因如下：</p><ul><li>此方法下安装的Linux子系统默认安装在c盘，无法更改安装路径，想要迁移比较麻烦。</li><li>由于服务器原因，下载很慢，需要一些上网技巧才能流畅下载。</li></ul><p>打开cmd命令提示符窗口，输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl --update</span><br><span class="line">wsl --install</span><br></pre></td></tr></table></figure><p>等待安装成功。默认安装Ubuntu系统。<br />也可以指定版本<br />输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --list --online</span><br></pre></td></tr></table></figure><p>可以查看当前可安装的发行版。<br /><img src="Snipaste_2025-06-08_00-01-29%201.png" alt="" /><br />比如安装Debian，直接输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install Debian</span><br></pre></td></tr></table></figure><p>等待安装完成即可。</p><p><strong>安装完成后提示输入用户名和密码，注意密码输入是不显示的。</strong></p><h3 id="开始使用"><a class="markdownIt-Anchor" href="#开始使用"></a> 开始使用</h3><p>💡如果你的电脑只有那种丑丑的简陋的命令行工具，可以在微软商店下载一个<code>Windows Terminal Preview</code>获得更好的体验<br /><img src="Snipaste_2025-06-08_00-21-38.png" alt="" /></p><h3 id="常用命令速查"><a class="markdownIt-Anchor" href="#常用命令速查"></a> 常用命令速查</h3><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td><code>wsl</code></td><td>启动默认 Linux 发行版</td></tr><tr><td><code>wsl -l -v</code></td><td>查看已安装的发行版和 WSL 版本</td></tr><tr><td><code>wsl --set-version &lt;发行版&gt; 2</code></td><td>将指定发行版升级到 WSL 2</td></tr><tr><td><code>wsl --set-default-version 2</code></td><td>设置默认启动Linux版本</td></tr><tr><td><code>wsl -d &lt;发行版&gt;</code></td><td>启动指定发行版</td></tr><tr><td><code>wsl --shutdown</code></td><td>关闭所有正在运行的 WSL 实例</td></tr><tr><td><code>wsl --unregister &lt;发行版&gt;</code></td><td>卸载发行版</td></tr><tr><td><code>wsl --export Ubuntu ubuntu.tar</code></td><td>对子系统进行备份与恢复 【导出】</td></tr><tr><td><code>wsl --import &lt;自定义名&gt; &lt;目标路径&gt; &lt;.tar源路径&gt;</code></td><td>对子系统进行读取/恢复  【导入】</td></tr></tbody></table><h2 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h2><p>可以使用命令行启动（见上表）也可在<code>Windows Terminal Preview</code>下直接点击<br /><img src="Snipaste_2025-06-08_00-26-24.png" alt="" /><br />即可打开~</p><h2 id="换源"><a class="markdownIt-Anchor" href="#换源"></a> 换源</h2><p>这里使用清华源<br /><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a><br />有详细的使用介绍，根据自己的版本选择文件路径以及格式复制粘贴即可，以Ubuntu24.04为例：<br />使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list.d/ubuntu.sources</span><br></pre></td></tr></table></figure><p>进入编辑页面后，先把原来的配置源删除，再粘贴。<br /><img src="Snipaste_2025-06-08_13-50-00.png" alt="" /><br />然后按<code>Ctrl+O</code> <code>Enter</code> <code>Ctrl+x</code>退出 （&quot;^&quot;指Ctrl &quot;M&quot;指Alt）<br />退出后使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>更新软件包数据库。<br />最后使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>升级软件包。</p><h2 id="退出系统"><a class="markdownIt-Anchor" href="#退出系统"></a> 退出系统</h2><p><code>Windows Terminal Preview</code>下，直接叉掉Linux命令行窗口即可退出<br />或在Linux命令行窗口直接使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p>推出后等待几秒可以输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure><p>查看Liunx状态：是停止<br /><img src="Snipaste_2025-06-08_14-16-16.png" alt="" /><br />还可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><p>一次性关闭所有运行的实例。</p><h2 id="卸载系统"><a class="markdownIt-Anchor" href="#卸载系统"></a> 卸载系统</h2><p>使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister &lt;发行版名&gt;</span><br></pre></td></tr></table></figure><p>即可卸载</p><h2 id="cc-环境搭建"><a class="markdownIt-Anchor" href="#cc-环境搭建"></a> C/C++ 环境搭建</h2><p>比较简单，默认的 Ubuntu 软件源包含了一个软件包组，名称为 “build-essential”,它包含了 GNU 编辑器集合，GNU 调试器，和其他编译软件所必需的开发库和工具。<br />想要安装开发工具软件包，直接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -v</span><br><span class="line">g++ -v</span><br><span class="line">gdb -v</span><br></pre></td></tr></table></figure><p>有一个没有的话 单独安装一下即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gdb</span><br></pre></td></tr></table></figure><h2 id="推荐玩法"><a class="markdownIt-Anchor" href="#推荐玩法"></a> 推荐玩法</h2><h3 id="vscode插件"><a class="markdownIt-Anchor" href="#vscode插件"></a> VScode插件</h3><p>使用 WSL 作为开发环境，结合 VS Code 的 <strong>Remote - WSL 插件</strong>，在 Windows 中编辑、WSL 中运行。<br />直接下载插件<br /><img src="Snipaste_2025-06-08_14-28-45.png" alt="" /><br />在Linux终端打开某个文件夹 然后使用命令即可在Linux环境下运行VScode</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure><p><img src="Snipaste_2025-06-08_14-31-11.png" alt="" /><br />还可以直接使用VScode终端输入Linux命令。<br /><img src="Snipaste_2025-06-08_14-43-03.png" alt="" /></p><h2 id="推荐安装"><a class="markdownIt-Anchor" href="#推荐安装"></a> 推荐安装</h2><p><code>ranger</code>：文件管理器<br /><code>usbipd</code>：共享usb</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.godmao.top/categories/Linux/"/>
    
    <category term="WSL2" scheme="https://blog.godmao.top/categories/Linux/WSL2/"/>
    
    
    <category term="Linux" scheme="https://blog.godmao.top/Tags/Linux/"/>
    
    <category term="WSL2" scheme="https://blog.godmao.top/Tags/WSL2/"/>
    
  </entry>
  
  <entry>
    <title>[自用]16届烂桥杯嵌入式赛道模块代码整理</title>
    <link href="https://blog.godmao.top/posts/44982/"/>
    <id>https://blog.godmao.top/posts/44982/</id>
    <published>2025-04-10T07:19:22.000Z</published>
    <updated>2025-06-08T08:26:04.144Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="时间片轮询调度"><a class="markdownIt-Anchor" href="#时间片轮询调度"></a> 时间片轮询调度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> TaskCount = <span class="number">0</span>;<span class="comment">//用于记录任务数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">run,wait,stop</span><br><span class="line">&#125;TaskStatus;<span class="comment">//任务状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">uint8_t</span> TaskRunTime;</span><br><span class="line"><span class="type">uint8_t</span> TaskTimer;</span><br><span class="line">TaskStatus Status;</span><br><span class="line"><span class="type">void</span> (*FC)();</span><br><span class="line">&#125;TaskStrust;<span class="comment">//任务信息块：注意两点1.注意Timer和runtime的数据类型为uchar，最大为255 2.时间片为2ms</span></span><br><span class="line">TaskStrust TaskList[]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OS_Init</span><span class="params">(TIM_HandleTypeDef* htim)</span>&#123;</span><br><span class="line">HAL_TIM_Base_Start_IT(htim);</span><br><span class="line">TaskCount = <span class="keyword">sizeof</span>(TaskList)/<span class="keyword">sizeof</span>(TaskList[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(TaskCount &gt; MAX_TASK) <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OS_IT_Run</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; TaskCount;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(TaskList[i].Status == wait)&#123;</span><br><span class="line"><span class="keyword">if</span>(++TaskList[i].TaskTimer &gt;= TaskList[i].TaskRunTime)&#123;</span><br><span class="line">TaskList[i].TaskTimer = <span class="number">0</span>;</span><br><span class="line">TaskList[i].Status = run;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自带死循环，主函数里运行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OS_Run</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">uint8_t</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(TaskList[j].Status == run)&#123;</span><br><span class="line">TaskList[j].FC();</span><br><span class="line">TaskList[j].Status = wait;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(++j &gt;= TaskCount) j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="频率测量"><a class="markdownIt-Anchor" href="#频率测量"></a> 频率测量</h2><p>核心思路：</p><p>1/（（这一次的计数值-上一次记录的计数值）x （1/时钟频率））= 时钟频率/（记录差值）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> i;<span class="comment">//记录当前是第几次。</span></span><br><span class="line">    <span class="type">int</span> former;<span class="comment">//前一次记录的计数值</span></span><br><span class="line">    <span class="type">int</span> now;<span class="comment">//现在记录的计数值</span></span><br><span class="line">    <span class="type">int</span> result;<span class="comment">//频率结果</span></span><br><span class="line">    <span class="type">uint8_t</span> ElapsedTime;<span class="comment">//定时器溢出次数</span></span><br><span class="line">&#125;FreqInfo;</span><br><span class="line"></span><br><span class="line">reqInfo F1 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">FreqInfo F2 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动频率测量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Freq_Start</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim3);<span class="comment">//对应F1</span></span><br><span class="line">    HAL_TIM_IC_Start_IT(&amp;htim3,TIM_CHANNEL_1);</span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim8);<span class="comment">//对应F2</span></span><br><span class="line">    HAL_TIM_IC_Start_IT(&amp;htim8,TIM_CHANNEL_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Freq_Measure</span><span class="params">(FreqInfo* Fx,TIM_HandleTypeDef *htim)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Fx-&gt;i == <span class="number">0</span>)&#123;</span><br><span class="line">        Fx-&gt;result = <span class="number">1000000</span>/(Fx-&gt;now - Fx-&gt;former);</span><br><span class="line">        __HAL_TIM_ENABLE(htim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Freq_Fuc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    Freq_Measure(&amp;F1,&amp;htim3);</span><br><span class="line">Freq_Measure(&amp;F2,&amp;htim8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(htim-&gt;Instance == TIM3)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(F1.i)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">                F1.former = HAL_TIM_ReadCapturedValue(&amp;htim3,TIM_CHANNEL_1) + <span class="number">65535</span> * F1.ElapsedTime;</span><br><span class="line">                F1.i = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                F1.now = HAL_TIM_ReadCapturedValue(&amp;htim3,TIM_CHANNEL_1) + <span class="number">65535</span> * F1.ElapsedTime;</span><br><span class="line">                __HAL_TIM_DISABLE(&amp;htim3);</span><br><span class="line">                F1.ElapsedTime = <span class="number">0</span>;</span><br><span class="line">                F1.i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(htim-&gt;Instance == TIM8)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(F2.i)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                F2.former = HAL_TIM_ReadCapturedValue(&amp;htim8,TIM_CHANNEL_1) + <span class="number">65535</span> * F2.ElapsedTime;</span><br><span class="line">                F2.i = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                F2.now = HAL_TIM_ReadCapturedValue(&amp;htim8,TIM_CHANNEL_1) + <span class="number">65535</span> * F2.ElapsedTime;</span><br><span class="line">                __HAL_TIM_DISABLE(&amp;htim8);</span><br><span class="line">                F2.ElapsedTime = <span class="number">0</span>;</span><br><span class="line">                F2.i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在溢出中断中记录溢出次数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="共享变量"><a class="markdownIt-Anchor" href="#共享变量"></a> 共享变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SharedData.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">static</span> Data1 shareddata1 = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Data1指针的接口</span></span><br><span class="line">Data1* <span class="title function_">get_shared_data</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;shareddata1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="按键"><a class="markdownIt-Anchor" href="#按键"></a> 按键</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">KeyBit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> keybit = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">//读取B1的电平状态并把他左移到bit0位</span></span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B1_GPIO_Port,B1_Pin) &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B2_GPIO_Port,B2_Pin) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B3_GPIO_Port,B3_Pin) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B4_GPIO_Port,B4_Pin) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> keybit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_Key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> Trg,Cont;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ReadData = KeyBit() ^ <span class="number">0x0f</span>;   <span class="comment">// 取反：在没有按键按下的情况下，其始终为0x00</span></span><br><span class="line">    Trg = ReadData &amp; (ReadData ^ Cont);             <span class="comment">// 2</span></span><br><span class="line">    Cont = ReadData; </span><br><span class="line">    <span class="keyword">if</span>(Trg &amp;&amp; Cont)&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(Trg &amp;&amp; Cont == <span class="number">0</span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lcd"><a class="markdownIt-Anchor" href="#lcd"></a> LCD</h2><p>引脚初始化为全低就行</p><h2 id="led"><a class="markdownIt-Anchor" href="#led"></a> LED</h2><p>LD口 为 PD2 低电平不允许写入，高电平允许写入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SharedData.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> LD_state = <span class="number">0</span>;  <span class="comment">//记录LD各位状态</span></span><br><span class="line"><span class="type">uint16_t</span> LD_state_before = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">HAL_GPIO_WritePin(LD1_GPIO_Port,GPIO_PIN_All,GPIO_PIN_SET);</span><br><span class="line">HAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_SET);</span><br><span class="line">HAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_lightLD</span><span class="params">(<span class="type">uint8_t</span> LDnum)</span>&#123;</span><br><span class="line"></span><br><span class="line">LD_state |= (LD1_Pin &lt;&lt; LDnum); <span class="comment">//其他位不变，需要改变的位变为1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_closeLD</span><span class="params">(<span class="type">uint8_t</span> LDnum)</span>&#123; </span><br><span class="line"></span><br><span class="line">LD_state &amp;= ~(LD1_Pin &lt;&lt; LDnum); <span class="comment">//其他位不变，需改变的位变为0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Call_ChangeLD</span><span class="params">(<span class="type">void</span>(*fc)(<span class="type">uint8_t</span>),<span class="type">uint8_t</span> LDnum)</span>&#123;</span><br><span class="line"></span><br><span class="line">LDnum -= <span class="number">1</span>;</span><br><span class="line">fc(LDnum);</span><br><span class="line"><span class="keyword">if</span>(LD_state_before != LD_state)&#123;</span><br><span class="line">HAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_SET);</span><br><span class="line">HAL_GPIO_WritePin(LD1_GPIO_Port,GPIO_PIN_All,GPIO_PIN_SET);</span><br><span class="line">HAL_GPIO_WritePin(LD1_GPIO_Port,LD_state,GPIO_PIN_RESET);</span><br><span class="line">HAL_GPIO_WritePin(LD_load_GPIO_Port,LD_load_Pin,GPIO_PIN_RESET);</span><br><span class="line">LD_state_before = LD_state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Fuc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Read_Show_index(<span class="number">0</span>)) &#123;</span><br><span class="line">Call_ChangeLD(LED_closeLD,<span class="number">1</span>);</span><br><span class="line">Call_ChangeLD(LED_lightLD,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Call_ChangeLD(LED_closeLD,<span class="number">2</span>);</span><br><span class="line">Call_ChangeLD(LED_lightLD,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Read_Show_index(<span class="number">1</span>))&#123;</span><br><span class="line">Call_ChangeLD(LED_lightLD,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> Call_ChangeLD(LED_closeLD,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串口重定向与数据处理"><a class="markdownIt-Anchor" href="#串口重定向与数据处理"></a> 串口重定向与数据处理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMDNUM 6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TF1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TF2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PF1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PF2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">returnF1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">returnF2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> rx_DataBuffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> tx_DataBuffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> cmd[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> tx_len = <span class="number">0</span>;  <span class="comment">// 当前缓冲区数据长度</span></span><br><span class="line"><span class="type">uint8_t</span> tx_busy = <span class="number">0</span>;  <span class="comment">// 发送状态标志</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> rx_handle = <span class="number">0</span>; <span class="comment">//处理接收数据标志</span></span><br><span class="line"><span class="type">uint8_t</span> rx_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span>* cmd_str;</span><br><span class="line">    <span class="type">void</span> (*fc)();</span><br><span class="line">&#125;cmdinfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cmdinfo cmdlist[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;TF1&quot;</span>,TF1&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;TF2&quot;</span>,TF2&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;PF1&quot;</span>,PF1&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;PF2&quot;</span>,PF2&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;F1&quot;</span>,returnF1&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;F2&quot;</span>,returnF2&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TheUART_start</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    HAL_UARTEx_ReceiveToIdle_DMA(&amp;huart1,(<span class="type">uint8_t</span>*)rx_DataBuffer,<span class="number">0x0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TheUART_dma_transmit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果 DMA 还在忙，则不启动新的传输</span></span><br><span class="line">    <span class="keyword">if</span> (tx_busy) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    tx_busy = <span class="number">1</span>;  <span class="comment">// 标记为发送中</span></span><br><span class="line">    HAL_UART_Transmit_DMA(&amp;huart1,(<span class="type">uint8_t</span>*)tx_DataBuffer,tx_len<span class="number">-1</span>);<span class="comment">//-1为了防止傻逼烂桥杯的验证程序不通过</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保缓冲区不会溢出</span></span><br><span class="line">    <span class="keyword">if</span> (tx_len &lt; BUFFER_SIZE - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tx_DataBuffer[tx_len++] = (<span class="type">uint8_t</span>)ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果遇到换行符，或者缓冲区接近满，就启动 DMA 发送</span></span><br><span class="line">    <span class="comment">// 注意咯，如果缓冲区没满的情况下，只有检测到/n才会触发DMA的发送。所以在缓</span></span><br><span class="line">    <span class="comment">// 冲区没满的情况下，如果你想要发送字符串&quot;abc&quot;，printf(&quot;abc&quot;)是没用的，</span></span><br><span class="line">    <span class="comment">// printf(&quot;abc\n&quot;)才有用哦。</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span> || tx_len &gt;= BUFFER_SIZE - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TheUART_dma_transmit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TheUART_HandleRxdata</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rx_handle == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(cmd,rx_DataBuffer);</span><br><span class="line">        cmd[rx_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!Read_Show_index(<span class="number">1</span>))&#123;</span><br><span class="line">            other();</span><br><span class="line">            rx_len = <span class="number">0</span>;</span><br><span class="line">            rx_handle = <span class="number">0</span>;</span><br><span class="line">            TheUART_start();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; CMDNUM;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)cmd,(<span class="type">const</span> <span class="type">char</span>*)cmdlist[i].cmd_str) == <span class="number">0</span>)&#123;</span><br><span class="line">                cmdlist[i].fc();</span><br><span class="line">                rx_len = <span class="number">0</span>;</span><br><span class="line">                rx_handle = <span class="number">0</span>;</span><br><span class="line">                TheUART_start();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        other();</span><br><span class="line">        rx_len = <span class="number">0</span>;</span><br><span class="line">        rx_handle = <span class="number">0</span>;</span><br><span class="line">        TheUART_start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TF1</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TF2</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PF1</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PF2</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">returnF1</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">returnF2</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">other</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_TxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(huart-&gt;Instance == USART1)  <span class="comment">// 确保是目标串口</span></span><br><span class="line">    &#123;</span><br><span class="line">        tx_len = <span class="number">0</span>;  <span class="comment">// 清空缓冲区</span></span><br><span class="line">        tx_busy = <span class="number">0</span>; <span class="comment">// 标记为可用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UARTEx_RxEventCallback</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint16_t</span> Size)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(huart-&gt;Instance == USART1)&#123;</span><br><span class="line">        rx_len = Size;</span><br><span class="line">        rx_handle = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="adc使用定时器trgo信号触发adc转换"><a class="markdownIt-Anchor" href="#adc使用定时器trgo信号触发adc转换"></a> ADC：使用定时器TRGO信号触发ADC转换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> ADC_Data = .<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADCFuc_Init</span><span class="params">(ADC_HandleTypeDef *hadc)</span>&#123;</span><br><span class="line">    HAL_ADCEx_Calibration_Start(hadc,ADC_SINGLE_ENDED);<span class="comment">//校准</span></span><br><span class="line">    HAL_ADC_Start_IT(hadc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">ADCFuc_ReturnResult</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">double</span> result = ADC_Data;</span><br><span class="line">    result = (result / <span class="number">4095.0</span>) * <span class="number">3.3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中断-------------------------------------------------------------//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_ADC_ConvCpltCallback</span><span class="params">(ADC_HandleTypeDef *hadc)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hadc-&gt;Instance == ADC2)&#123;</span><br><span class="line">        ADC_Data = HAL_ADC_GetValue(&amp;hadc2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="at24c02"><a class="markdownIt-Anchor" href="#at24c02"></a> at24c02</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;i2c_hal.h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMAND_W   0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMAND_R   0xA1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">at24c02_Init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    I2CInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief at24c02写数据</span></span><br><span class="line"><span class="comment">/// @param address 要写入的地址</span></span><br><span class="line"><span class="comment">/// @param data 要写入的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">at24c02_Write</span><span class="params">(<span class="type">uint8_t</span> address,<span class="type">uint8_t</span> data)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    I2CStart();</span><br><span class="line"></span><br><span class="line">    I2CSendByte(COMMAND_W);</span><br><span class="line">    I2CWaitAck();</span><br><span class="line"></span><br><span class="line">    I2CSendByte(address);</span><br><span class="line">    I2CWaitAck();</span><br><span class="line"></span><br><span class="line">    I2CSendByte(data);</span><br><span class="line">    I2CWaitAck(); </span><br><span class="line"></span><br><span class="line">    I2CStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief at24c02读数据</span></span><br><span class="line"><span class="comment">/// @param address 要读数据的地址</span></span><br><span class="line"><span class="comment">/// @return 读出的数据</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">at24c02_Read</span><span class="params">(<span class="type">uint8_t</span> address)</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> data = <span class="number">0</span>;</span><br><span class="line">    I2CStart();</span><br><span class="line"></span><br><span class="line">    I2CSendByte(COMMAND_W);</span><br><span class="line">    I2CWaitAck();</span><br><span class="line"></span><br><span class="line">    I2CSendByte(address);</span><br><span class="line">    I2CWaitAck();</span><br><span class="line"></span><br><span class="line">    I2CStart();<span class="comment">//不释放总线的情况下重启通信，发送读命令。</span></span><br><span class="line"></span><br><span class="line">    I2CSendByte(COMMAND_R);</span><br><span class="line">    I2CWaitAck();</span><br><span class="line"></span><br><span class="line">    data = I2CReceiveByte();</span><br><span class="line">    I2CSendNotAck();<span class="comment">//通知从机不再发送数据</span></span><br><span class="line"></span><br><span class="line">    I2CStop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="韩信在干嘛韩信在偷塔能做到吗哇他出了一个名刀司命猫雷"><a class="markdownIt-Anchor" href="#韩信在干嘛韩信在偷塔能做到吗哇他出了一个名刀司命猫雷"></a> 韩信在干嘛？韩信在偷塔！能做到吗？哇他出了一个名刀·司命！猫雷！</h2><p>挂一张梦老师保佑！<br /><img src="https://tiebapic.baidu.com/forum/w%3D580%3B/sign=770517cb7fdbb6fd255be52e391faa18/8326cffc1e178a829fdedc90b003738da977e824.jpg?tbpicau=2025-04-12-05_1fd40d1758be922db3d2562ec3e230c3" alt="" /></p>]]></content>
    
    
    <summary type="html">自用。</summary>
    
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="程序架构" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="蓝桥杯" scheme="https://blog.godmao.top/Tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>hexo主题Klise-enhanced使用文档</title>
    <link href="https://blog.godmao.top/posts/20333/"/>
    <id>https://blog.godmao.top/posts/20333/</id>
    <published>2025-04-06T07:09:50.000Z</published>
    <updated>2025-04-06T09:00:52.000Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h2><p>本主题是根据dewjonh的hexo主题<a href="https://github.com/dewjohn/hexo-theme-Klise">Klise</a>改的，我非常喜欢这款主题，但是由于此主题原作者好像不再维护，对hexo的现版本（2024）的适配不太好，于是便自己修修补补用着🙂但是由于我没有太多的精力分配在前端上，所以有些代码可能有些不专业，希望各位大佬见谅并指正。当然如果有任何bug请尽管issue，我会尽力修复！</p><h2 id="主题概览"><a class="markdownIt-Anchor" href="#主题概览"></a> 主题概览</h2><p><img src="Snipaste_2025-04-06_15-26-39.png" alt="" /></p><p><img src="Snipaste_2025-04-06_15-27-19.png" alt="" /></p><p><img src="Snipaste_2025-04-06_15-27-54.png" alt="" /></p><p>你可以查看<a href="https://im.godmao.top/">demo</a>或<a href="https://im.godmao.top/">我的博客</a>来阅览主题效果。</p><h2 id="相较于原版有何改动"><a class="markdownIt-Anchor" href="#相较于原版有何改动"></a> 相较于原版有何改动</h2><ul><li>😢把scss全编译为css了，只有一个main.css文件，包含了所有的渲染样式…不过不用担心我注释了嘻嘻🤓</li><li>将原主题的深色模式进一步适配，并修改了一些元素的显示风格。</li></ul><h2 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h2><h3 id="首先"><a class="markdownIt-Anchor" href="#首先"></a> 首先，</h3><p>你需要下载一个字数统计插件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p>如果不想要下载或无法下载成功，你也可以放弃字数统计功能。前往主题文件夹下的<code>layout\post.ejs</code>删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字数: &lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(page.content) %&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">预计阅读时间: &lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(page.content) %&gt;min&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>两行。</p><h3 id="然后"><a class="markdownIt-Anchor" href="#然后"></a> 然后，</h3><p>安装主题文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/g0dmao/hexo-theme-Klise-enhanced.git</span><br></pre></td></tr></table></figure><p>将主题根目录的<code>_config.hexo-theme-Klise-enhanced.yml</code>移动到博客根目录。你可以打开该文件进行主题的一些配置。</p><p>在博客配置文件<code>_config.yml</code>中启用主题。</p><h3 id="最后"><a class="markdownIt-Anchor" href="#最后"></a> 最后，</h3><p>enjoy！</p><h2 id="个性化部分"><a class="markdownIt-Anchor" href="#个性化部分"></a> 个性化部分</h2><h3 id="自定义背景"><a class="markdownIt-Anchor" href="#自定义背景"></a> 自定义背景</h3><p>打开主题文件夹下的<code>source\css\main.css</code>在头部修改，可以自定义明暗模式下不同的背景，已做好注释。</p><h3 id="当网页失去焦点时标签页标题的显示文字"><a class="markdownIt-Anchor" href="#当网页失去焦点时标签页标题的显示文字"></a> 当网页失去焦点时标签页标题的显示文字</h3><p>打开主题文件夹下的<code>layout\layout.ejs</code> 修改document.title即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">visibilityState</span> == <span class="string">&#x27;hidden&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      normal_title = <span class="variable language_">document</span>.<span class="property">title</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;点一下&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  &#125; <span class="keyword">else</span> <span class="variable language_">document</span>.<span class="property">title</span> = normal_title;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="可选"><a class="markdownIt-Anchor" href="#可选"></a> 可选</h3><p>你可以安装如下插件获得更好的浏览体验。</p><h4 id="hexo-renderer-markdown-it-plus"><a class="markdownIt-Anchor" href="#hexo-renderer-markdown-it-plus"></a> hexo-renderer-markdown-it-plus</h4><p>不使用自带的md渲染器。使用markdown-it渲染器，丰富的插件提供更好的md浏览体验。</p><h4 id="hexo-tips"><a class="markdownIt-Anchor" href="#hexo-tips"></a> hexo-tips</h4><p>在文章中生成各种提示卡片，此主题已做好适配。</p><h4 id="hexo-blog-encrypt"><a class="markdownIt-Anchor" href="#hexo-blog-encrypt"></a> hexo-blog-encrypt</h4><p>文章加密插件。</p><h2 id="可能的问题"><a class="markdownIt-Anchor" href="#可能的问题"></a> 可能的问题</h2><h3 id="tags-categories页面显示不正确"><a class="markdownIt-Anchor" href="#tags-categories页面显示不正确"></a> tags、categories页面显示不正确</h3><p>首先检查页面的路径设置是否正确。若正确则试着在相应页面的<code>index.md</code> 里添加type和layout标签：<br /><img src="Snipaste_2025-04-06_16-18-33.png" alt="" /><br />tags页面 type、layout 为tags。<br />categories页面 type、layout 为 categories。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="web前端" scheme="https://blog.godmao.top/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="网页" scheme="https://blog.godmao.top/Tags/%E7%BD%91%E9%A1%B5/"/>
    
    <category term="hexo主题" scheme="https://blog.godmao.top/Tags/hexo%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>从c底层到嵌入式驱动开发的学习参考路线</title>
    <link href="https://blog.godmao.top/posts/25619/"/>
    <id>https://blog.godmao.top/posts/25619/</id>
    <published>2025-04-05T15:21:06.000Z</published>
    <updated>2025-04-05T15:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><p>以下是专为 <strong>嵌入式Linux驱动开发工程师</strong> 设计的 <strong>学习路线</strong>，整合了目标、重点、时间分配、书籍推荐和实战建议，力求清晰高效。由<code>deepseekR1</code>生成。</p><hr /><h3 id="一-学习路线总图"><a class="markdownIt-Anchor" href="#一-学习路线总图"></a> <strong>一、学习路线总图</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  A[C语言+硬件] --&gt; B[操作系统+驱动基础] --&gt; C[驱动专项+内核机制] --&gt; D[实战深化]</span><br></pre></td></tr></table></figure><hr /><h3 id="二-分阶段详解"><a class="markdownIt-Anchor" href="#二-分阶段详解"></a> <strong>二、分阶段详解</strong></h3><h4 id="阶段1c语言与硬件交互1-2个月"><a class="markdownIt-Anchor" href="#阶段1c语言与硬件交互1-2个月"></a> <strong>阶段1：C语言与硬件交互（1-2个月）</strong></h4><p><strong>目标</strong>：</p><ul><li>掌握C语言底层操作能力，理解程序如何直接控制硬件。</li></ul><p><strong>核心内容</strong>：</p><table><thead><tr><th><strong>知识点</strong></th><th><strong>必要程度</strong></th><th><strong>深入程度</strong></th><th><strong>推荐书籍/资源</strong></th></tr></thead><tbody><tr><td>指针与内存管理</td><td>★★★★★</td><td>理解内存布局</td><td>《C程序设计语言》（K&amp;R）</td></tr><tr><td>结构体与位操作</td><td>★★★★☆</td><td>能操作寄存器</td><td>《嵌入式C语言自我修养》</td></tr><tr><td>汇编基础</td><td>★★★☆☆</td><td>阅读简单汇编</td><td>《ARM Cortex-M权威指南》</td></tr><tr><td>编译流程（GCC）</td><td>★★★★☆</td><td>熟悉预处理-链接</td><td>CSAPP第3章</td></tr><tr><td>硬件交互（GPIO）</td><td>★★★★☆</td><td>裸机程序开发</td><td>STM32官方手册</td></tr></tbody></table><p><strong>实践项目</strong>：</p><ol><li>用STM32直接操作寄存器点亮LED（无需库函数）。</li><li>用C实现内存池分配器（模拟<code>malloc/free</code>）。</li></ol><p><strong>工具</strong>：</p><ul><li><strong>STM32CubeIDE</strong>：调试裸机程序。</li><li><strong>objdump</strong>：反汇编查看代码生成。</li></ul><p><strong>对Linux的用处</strong>：</p><ul><li>理解驱动中 <strong>寄存器映射</strong>（如<code>ioremap</code>）。</li><li>诊断 <strong>内存越界</strong> 和 <strong>硬件访问错误</strong>。</li></ul><hr /><h4 id="阶段2操作系统核心驱动基础2-3个月"><a class="markdownIt-Anchor" href="#阶段2操作系统核心驱动基础2-3个月"></a> <strong>阶段2：操作系统核心+驱动基础（2-3个月）</strong></h4><p><strong>目标</strong>：</p><ul><li>理解操作系统核心机制，入门Linux驱动开发。</li></ul><p><strong>核心内容</strong>：</p><table><thead><tr><th><strong>知识点</strong></th><th><strong>必要程度</strong></th><th><strong>深入程度</strong></th><th><strong>推荐书籍/资源</strong></th></tr></thead><tbody><tr><td>进程与线程</td><td>★★★☆☆</td><td>理解上下文切换</td><td>《操作系统导论》（OSTEP）</td></tr><tr><td>虚拟内存</td><td>★★★★☆</td><td>页表工作原理</td><td>《深入理解计算机系统》第9章</td></tr><tr><td>中断与异常</td><td>★★★★☆</td><td>中断处理流程</td><td>《Linux设备驱动程序》（LDD3）</td></tr><tr><td>内核模块开发</td><td>★★★★★</td><td>字符设备驱动</td><td>LDD3第3章</td></tr><tr><td>设备树（DT）</td><td>★★★★☆</td><td>解析硬件配置</td><td>内核文档《Device Tree Usage》</td></tr></tbody></table><p><strong>实践项目</strong>：</p><ol><li>编写虚拟字符设备驱动（实现<code>read</code>/<code>write</code>）。</li><li>为LED驱动添加设备树支持（<code>.dts</code>文件配置）。</li></ol><p><strong>工具</strong>：</p><ul><li><strong>QEMU</strong>：模拟ARM设备运行Linux。</li><li><strong>dmesg</strong>：查看内核日志。</li></ul><p><strong>对Linux的用处</strong>：</p><ul><li>掌握驱动开发框架（<code>file_operations</code>）。</li><li>理解 <strong>设备树</strong> 如何解耦硬件配置。</li></ul><hr /><h4 id="阶段3驱动专项内核机制3-6个月"><a class="markdownIt-Anchor" href="#阶段3驱动专项内核机制3-6个月"></a> <strong>阶段3：驱动专项+内核机制（3-6个月）</strong></h4><p><strong>目标</strong>：</p><ul><li>精通主流驱动开发技术，深入内核核心机制。</li></ul><p><strong>核心内容</strong>：</p><table><thead><tr><th><strong>知识点</strong></th><th><strong>必要程度</strong></th><th><strong>深入程度</strong></th><th><strong>推荐书籍/资源</strong></th></tr></thead><tbody><tr><td>GPIO/I2C/SPI驱动</td><td>★★★★★</td><td>完整驱动开发</td><td>《精通Linux设备驱动程序开发》</td></tr><tr><td>中断处理</td><td>★★★★★</td><td>顶半部/底半部</td><td>内核源码<code>drivers/irqchip</code></td></tr><tr><td>内核同步机制</td><td>★★★★☆</td><td>自旋锁/RCU</td><td>《Linux内核设计与实现》第5章</td></tr><tr><td>DMA与内存管理</td><td>★★★☆☆</td><td>缓存一致性</td><td>内核文档《DMA-API-HOWTO》</td></tr><tr><td>电源管理</td><td>★★★☆☆</td><td>suspend/resume</td><td>内核文档《Power Management》</td></tr></tbody></table><p><strong>实践项目</strong>：</p><ol><li>为树莓派开发I2C传感器驱动（如BMP280）。</li><li>实现带中断的按键驱动（<code>request_irq</code>）。</li></ol><p><strong>工具</strong>：</p><ul><li><strong>逻辑分析仪</strong>：抓取SPI/I2C时序。</li><li><strong>perf</strong>：分析驱动性能瓶颈。</li></ul><p><strong>对Linux的用处</strong>：</p><ul><li>掌握真实硬件驱动开发流程。</li><li>理解内核 <strong>并发控制</strong> 和 <strong>中断优化</strong>。</li></ul><hr /><h4 id="阶段4实战深化持续学习"><a class="markdownIt-Anchor" href="#阶段4实战深化持续学习"></a> <strong>阶段4：实战深化（持续学习）</strong></h4><p><strong>目标</strong>：</p><ul><li>参与真实项目，解决复杂问题。</li></ul><p><strong>核心内容</strong>：</p><table><thead><tr><th><strong>知识点</strong></th><th><strong>必要程度</strong></th><th><strong>深入程度</strong></th><th><strong>推荐资源</strong></th></tr></thead><tbody><tr><td>内核子系统</td><td>★★★★☆</td><td>输入/IIO子系统</td><td>内核源码<code>drivers/input</code></td></tr><tr><td>调试与调优</td><td>★★★★☆</td><td>ftrace/kgdb</td><td>内核文档《ftrace使用指南》</td></tr><tr><td>社区贡献</td><td>★★★☆☆</td><td>提交内核补丁</td><td>LKML（Linux内核邮件列表）</td></tr></tbody></table><p><strong>实践项目</strong>：</p><ol><li>为开源驱动修复Bug（如内核Bugzilla中的简单问题）。</li><li>优化驱动性能（减少中断延迟或内存占用）。</li></ol><p><strong>工具</strong>：</p><ul><li><strong>git</strong>：管理内核代码修改。</li><li><strong><a href="http://checkpatch.pl">checkpatch.pl</a></strong>：检查代码规范。</li></ul><p><strong>对Linux的用处</strong>：</p><ul><li>积累真实项目经验，提升工程能力。</li><li>理解Linux内核社区的协作方式。</li></ul><hr /><h3 id="三-时间分配建议"><a class="markdownIt-Anchor" href="#三-时间分配建议"></a> <strong>三、时间分配建议</strong></h3><table><thead><tr><th><strong>阶段</strong></th><th><strong>建议时长</strong></th><th><strong>核心目标</strong></th><th><strong>时间占比</strong></th></tr></thead><tbody><tr><td>C语言与硬件交互</td><td>1-2个月</td><td>裸机操作寄存器</td><td>15%</td></tr><tr><td>操作系统+驱动基础</td><td>2-3个月</td><td>字符设备驱动+设备树</td><td>30%</td></tr><tr><td>驱动专项+内核机制</td><td>3-6个月</td><td>GPIO/I2C/中断驱动开发</td><td>40%</td></tr><tr><td>实战深化</td><td>持续</td><td>项目经验+社区贡献</td><td>15%</td></tr></tbody></table><hr /><h3 id="四-驱动开发工程师核心能力"><a class="markdownIt-Anchor" href="#四-驱动开发工程师核心能力"></a> <strong>四、驱动开发工程师核心能力</strong></h3><ol><li><p><strong>硬件能力</strong>：</p><ul><li>阅读芯片手册（如时钟配置、寄存器定义）。</li><li>使用示波器调试I2C/SPI通信问题。</li></ul></li><li><p><strong>内核能力</strong>：</p><ul><li>编写符合内核编码规范（<code>checkpatch.pl</code>）的代码。</li><li>理解设备模型（总线/设备/驱动）。</li></ul></li><li><p><strong>调试能力</strong>：</p><ul><li>分析内核Oops和Panic日志。</li><li>使用<code>trace-cmd</code>跟踪函数调用链。</li></ul></li></ol><hr /><h3 id="五-学习建议与避坑"><a class="markdownIt-Anchor" href="#五-学习建议与避坑"></a> <strong>五、学习建议与避坑</strong></h3><ol><li><p><strong>必做</strong>：</p><ul><li>每天阅读内核驱动源码（如<code>drivers/gpio</code>）。</li><li>用真实硬件（树莓派/BeagleBone）替代仿真。</li></ul></li><li><p><strong>避免</strong>：</p><ul><li>沉迷自制操作系统内核（除非目标为内核研发）。</li><li>过早研究编译器后端优化（如LLVM Pass）。</li></ul></li><li><p><strong>捷径</strong>：</p><ul><li>直接参考内核中类似驱动的实现（如<code>drivers/i2c/busses/i2c-bcm2835.c</code>）。</li><li>参与开源社区（从文档改进开始）。</li></ul></li></ol><hr /><h3 id="六-驱动开发面试常见问题"><a class="markdownIt-Anchor" href="#六-驱动开发面试常见问题"></a> <strong>六、驱动开发面试常见问题</strong></h3><ul><li><p><strong>基础问题</strong>：</p><ul><li>解释<code>platform_driver</code>和<code>platform_device</code>的作用。</li><li>自旋锁为什么不能在睡眠场景使用？</li></ul></li><li><p><strong>实战问题</strong>：</p><ul><li>如何为一个新硬件编写设备树节点？</li><li>驱动中出现<code>Unable to handle kernel paging request</code>如何调试？</li></ul></li></ul><hr /><p>按此路线，<strong>12-18个月</strong> 可达到嵌入式Linux驱动工程师的入职要求。<strong>记住：驱动开发的本质是“用软件精确描述硬件行为”</strong>，保持对硬件的敏感度是关键！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;details&gt;
&lt;summary&gt;版权信息&lt;/summary&gt;
&lt;p&gt;:::warning&lt;/p&gt;
&lt;p&gt;本文章为博主原创文章。遵循 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans&quot;&gt;C</summary>
      
    
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="学习路线" scheme="https://blog.godmao.top/Tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Kelly McGonigal, Ph.D.《自控力》第四章阅读感悟</title>
    <link href="https://blog.godmao.top/posts/57146/"/>
    <id>https://blog.godmao.top/posts/57146/</id>
    <published>2025-04-04T03:32:41.000Z</published>
    <updated>2025-06-08T14:35:07.512Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="兄弟别搞，想看联系我。" data-whm="这个文章不能被校验, 不过你还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="5727f1ec7f0853418860903bb258ecdd883295eea2159e5f3b7952d887892b91">472f0d2124ee617a2f29ff331422d5d3c786bf02d6cb05b48659c7bd0efc234c66e4d05e5e352805b8be7fb548f5db1dc6ce19185f33969b60366e77544d242a7255fc093dceae1ef56b7b3616ab395661ed8126f2f2fd808d82d019625b83d11f79d38d81df10d287dcdf9fbb8d79e9c8d83e586475eedb6cb5e2397406cac88ae3b2cc9c06ebeb2d6383b47460e609f2bae318cd0ffc55aaf5b0edf4a6aa84257abc17b8e353a8c50ec02ce524c75dd8fd48193c96d88f35deaf59ce7aa8583b27b3382985ab21e165cf8330fb6f3aff3853b770500467baa6164296eed6f6c3f47059ea705b9701e83e91d7cce5759144f378b39afd02db8ac2a522ea8e071062cfe4bc1ad2dead654556198e87e1e09d939f7bc401f2ad0c7ea918cd99b9a76f378b206110669bbc55c30f9c23716a07baefa5d95a2345a5b9f803d5bfe68480cce34f61af3252c532e63c9c36cad7136a11c82cf344cdf68cc5ebbbc6f1c6f78a6a4aa2b5c4d9255c337eea8aa4df6fe45f5bc28201c1e9b119dd29dab3c7a3ed2eed624a34b3eb9917873736c58be8c3e9049965da96eee5879ec5ff01c13cbe3d63d0ea9b97f70f290d5cc50ca8c97816293c9fb8e1f39a07106859e1d594915c6d4160d3dbc0bbb4e38a78727a8ad526267eb9e3cec4bce8d3ecdbb654a940182778d95dafaba8f181fc6017186c373789adf1c14f8e012bdaacd1907fa1a94ca8e1e630c5f87d6534f46e0f314aecdbab95b0af72314d5a160e938e70a3a897086a18839a8f19864aac7492b1782c6cb7bf8637559efacab6d01ea67417ac0d1de277a3a2bb8690c527d7935fd332d8558465342e3b159a363cbd4f43cedd227ed55d6869467f7ed5dbe8c7fc91d95e1bcf426fa99022784bbad3b01298b3091946e9b3f5a4b5dba6914e72000fa3927bb7e5fbcc0493d48af555921a133b9781f972b6d1dbdf49a709a2880913ff899cf2cc7c89811961b7cabbe14f622638c67241b58e7b857cfac4cf0c811ab413da50a94b0a28c7b94d2b08bf3f23e8a0b4c938c6517dee77e8481277df97c970b11c493c7104ce8986957481b7b9ea9aacf3a14e2a479cc5193d0aa91099d0f3e087b1c25af3fa6a961870d04635d04647aa806ba10db4504c5c0f35a55a9e78fb0119dd90916a41721ae32f2bb18454e932d6ec1888e78dd9d5cfc8f8b895ea0ab79874f2587d6c1d61b3b5bf979ad77cef456b4281be80a4e92f1b582a7216f87cab9d8d7c26dcf9858f110d48bf4bf57e7327712a0ad03c4ab6e6a2fa8a3cbcf103e5a81b33a8a7f48e172b86c40172f9310f77c3901c4a8c24e108430e358de3523d7c35471dcb784e54504916a8b3db771fe70be124b321555099941b72ac95f1790339a127e17803b554a7e51b633c27cf30fd670553f6a8e01f1f7e39f86c864fbc43ada10a7b2221383c89c089191b73120cc747365824cfd7c5a0d19f1c8878c53f462f983ececd05a294b0dffc92ff4d94d5ea6e24361ec594cbf96a50329a1a4dcf03dfa3701a030e8c7792d42b95aaabda743cab3f7bf22b50b9ca40828d01f1e7ebbc6a8784fe31e5ceeaca9e8626294214b1fe29577f852153f5c98badaeea8d14f43723c4bcb8d3b7c129cc546b2e0a3f2320316fa29002c2736747fa5d943c327eb839e0cc34806c926b85ba88fa561a36262caef0f7371fdeb3e25767d8e331a64adb8a7022bf030b2d90bef1dcb30e90b0fbdab8a3a9b573ba43e9c0545803ab81bebaffcc26279df6d5e132967a9c0e05f0232f91c8c644e2e7216fb38c4dbaa741c1057d88c7dd9464d4d0451bc53deca9641406b3b9796db99628e00130bf575a125bf62750dd2d89e33e8202da72ded708ad6ed89bf23a45bf4480d7d6463791185f9d196def854136db1501367f9bc124a41968d80f9e99ec68373550df21b41521d36673779d3d414a36f4b657083a7a0ed1e9099e1a0675280545c9d33328207a8f0c4efadbea5a6dcdbf6179eb31f281e64dc9ae2fd4995c1dcd30551819d985e923c8efdc16f82bf508130370f5e152bfb0d4b954d3f9d00ba4df793c7264fcad272e032c944f00d4b346d27f17c5b39f4bd847ff7b155ca31a10063159e49b854aa47c288942abf4442003a1b48f1d0c08ea348e601d878bfcb1ddd6fa495b3c5e255e25d2bebf85211dc496cc8baa16c1d0f0ebad9ebec0fbc6e3e115e71d8ae7a89f04719f770f1aab77d1b282ee16f3b29b24ecba9053422370fd91c784c7a689c01b1d88ddb7a22521a8311294985b289402c6cb3ab21bf8bfc00cbff456c584f33a4c50f0cce07219ba3f811bf91c1756edb3de6f0fc054cef525c2a3c2213c2c5f8f8cc991cc82293f2b84e68ac890101142953d7835ef19fb2781b1dbdd3b0383223705d953f48f57ab44867b06dd15c330a468f19b47d467692109ba33c360097f0888b43cff2a99da4c9c09769c45667eba5dbc4daf75fc2e55cb5171fdc48a41028c6bd37d02e91f9d081be489e53e6b6d7194aa427caf49231537bb82373e5ed009a7aa04abaeac7fe9adc7f44c7d2eb950de3bd609a7d8d9a75fd86e68700696daf557589af4ec94a0c0677a7d567b03a9cc7b5a0d9578c96129c0d3e3fa17339d8cfdce3864a50a570cbd7e36dc53f536d13be6595bf3febffff2d3e722fc8d36b54f798a344a0b4f64c908307a54166e69f2755d5808b04c64f9fc4478d6a622bd7e19ba2bd7735b048b350008d5eca715c50cfdb21c5dc0f0f31d67a1f2bb1010113a7c44108d6a2da4311ac9bc2714433208051743cbde6ead516f3552d82efb528b845c99b672b346f5fb86ec2490a6fb39d8b5c20a5b84f0ff72553406092a4db85538703ed5fa4c42078d1da82e8cd65715990dcd46b33e9082003037654915e7bba72cad2e06c2981526713a4756c5bf2fbd2ed6ac3dc65953a35c0662b0e503ea774371e5b1f70c4c70fe09ee9704ea745df98568bbd5022bfe368d12cf7f5700c6a158a96682a2538f2fadca192adcdc15f58ff6103c9a5c81ac5763e5ea3d6a6c237c8dd70dd41eca5e3049345784dc5effebe8e575373ce54fe0597e38378ce49b0bc5ac1ad1fb3224560a4e069b6cc92766708c4e6b008d7c738f9d3290652ec6fa9236f4af6cb3b16084d07751f5b0b37106848f430b6bbb1b4592e5e17c41a266086148b2c88eebdfce956493b6ce55f955dac4f77e444219279cca474a827aff8d29908f0331cd91430d713faa08be672407a9c9c10a218abd70389220bf1de74a02e29a610424d203d20cacc99f82ea82f70647e0b1526c69d0f7ab78e6a5b1735743a5467417435c91219221fa0fb818fc29c7bad232e568e7f051d237b637ba389825525f71c329c80b631d945d3124bc6eb01c0dfbbfc4c103c188841e8ae4522558e7b556b4c5b4bb95953ae9b8c354e599a666ad1953e0429e309a6aca294fa2c65bf38263750084e9b4beb81b982ee77be236f1b3be80f6d768fdf2acc4d692b068eaf5070eb7aaffeaa28dcdd369bf8070bb66ccf762d68de642b3a7d194dce99ef934a9860d5b245eafbca53974075d2f3e4f13de936920c5b7073840d0755f89ae974423401edfc0ff87ef4b08873823490d33cf82c9ca15116b459cc5e88be8144916d40f5ef3c27f47c68d62e9c217f90c49e001da7bc93c8e4d966ecde37986716ec87d28ee26a702acc2bf43e057fbde4f21a1bf97c831f2521b3b0a1836d68efa76eb93c894be1a2e2d2cf175cbee4c90cdd35eb9ee97aa17d1fb6b4bede4aa9ef58ca16730dd8ba760d7a38534438235687418917cd3f4cb783298ba4d23d008f42edbae4e45b0c2b424e4fb999178fc9cb4c4d805500e07fea6ba2ec9ea2237ec51cbca8f7f9f04cef69832e98bc1f46ef53db47a1ec720215ef53c7f3df7898cd9170ce424bdae2c4a810baf6dd77d37e50f2ed3a616abd2b6236086086fe15c387e39290393c90baf589ccee0842d81abe16cf404edbd94b13133ce3c11c635dbe248d581512b3c8e244123ce56056755e9153dd260967effdbc13210494e260905ec6dc51f8016018ad15eaec1d7ae49a3920fae390a2f1388b448f4262737dc941447dceb6f8777429d8cea3a3cc691a4ec1edd3e7246aa7a3f345397482b79973a0026a3314a3e38c0a1ee5323e12c8d6eab25641e848adca2a1c65f96a63a521675195d2aef6a9324c08a0ee1ea16e42b5574313e53420129112904af9c9ac70b68e50e3b671ed441cbd49f9abf2105ce89c3e790bc9e6b5d144876b12cfc4d318c55d26a616835c7058dcc1a416723cf41cf64c82b5f8482c57bb735556251947b2d507b63486262e41c93f7d954ef1aaafb47085d8726459554ed9c7abf2f26fdf0dfa680105cacffc954a560a7bfdfcbc20c76fa53cc5f47f6d419a8ff3a66a56e1bf67ae8f39104ca88e080c101b3f5204db9e624b4136070b3c0500855a3987fb9cdefba772ba5e84fa38256102d5e895649b7d234de434a771b6e208edcee6732d0a98571afbbff1d0228484b2927f4176c9339eb946c915d16f5ab10917fbed0afd4d93c5468a59bef1208860cda3239026bf3d04d4028f5a1c1f84cbfc8360eb8a914836234b2ad0ff51e23d0f892b665f2dc1c48805d87af371be44e82c0b265a7bb239092b09a4ba415cc4448d861e8d11e9318a1ef4fe4948301a6afabf33ec628422edd1747263cb0e170f3d71e8e2494a61f677703205ff6d064d414cdb3bacdd1f862215b605aa6b4971ea62d3001e063c5fbcb4f153158864d68092dae58d9d30c810b78cd465c51b1048f2d6b6e45ea79b38653607535c877cb8fc6c493cfba18ad5feae17ab006ff130acead71f9bada903a3e2ce62de500f46828e1ab51e2235408c70ccc1c81370d800178368ff149b00a7496f164d07256396a872e5fe34107b3b35fedb48d8a46d5ea4cc1b4d972975c7639904c4bace33e09a7364e9ed961054362b66de41d7ce06e48e011e150a1ffd97cea78161728a711334312b49077375a2930db759723a7784ffcec561b4ad6c50270fe8ef248ad800ff34a9ece5e874d73821feb888e7a31abbc364c8eb04ea43d0bc686149b52f590cb1b80bd8385aa5d4d10f79008236aa2be77470ebff10609bc08856c03c0e10798966a45102f406b5808f9405a4e6b000d13f107f064143ef3a0099ef92f70e3152560e82a9184530bbf18f8bc7486ece8e93a3449af4ddd0b38983066afecf1f74ae6efe92005be525e7f0e287816729e0ff4e04ec44898a4b051f79718bd9f359735338059085b4812f9a6394bcc5c8e805cbcf5806a3e1bf66de36c9054864d02bb618fee8e4db3e51aaf00a170b554a89b41a4057b7e0c3071913ae2355b4e32d4f3effc6998a595e34d4b91e90a405e4642984f77c9dd4108ad5a27deb7f54a58087f02c96f313405d42ea72d50608e6dff0552424f17c22dd2745d9ab28dea10daa4da92ece00a33becd0916fb93833257704e21f80cafa192dfc493e1d47b189700b41097768b10eb1022b70aefaeadbef3fbb6fc8593a7c542e943010141901f7f08ca45dce43e49a266b8fbf61e737df16177d3fcfb462160e7ced413a68bbed1a535f86b2fa348cad0997301005cff1209e69dc1a5f417fd523695af4566e0db1ee2ce5569e98234719780e46eeba24e4b9c22d4e11921a45b28f955f80d8a46e2fdbd222193a0a3705005a44c27b2bd6557134109fceaa312e9b6f4fd997ff9629b345f2350a39c53dba0863954d5362d599609be5d4ab52950a45c035f0db53b979b2e69fff9f08b7de25754f424cb0e223f6ceb0207a5500164174c7a27f7c3699fe4e12718bc50e421840cbbe435c6377e0d61793ebcb212b918e147855cddd8fb011fea054355125a8fd5e095b810b2dddf5ae3af9e177d5bc1baeea02352844904b3e649088af0d109d51243eea36deaf32a7d55bd9f2bd3ab693060ddef06594e5bd2f53e02d5d48b893de2fafa1d556cc74b002767e5d2a23dbc17235dfdafc356ddbff76efda37e37a6ca4242a510a4868dcf0249b250cf3b06c290491218ffccf6c9e22fcd3980e136a893bd7435b4f1e3417885cc159c9342d05b70c3faef2cb8ec184460475827d6fcd65e04d8d1d39089b30d20a21ba6ab94af34bd4ffe896f66fe2aa07a7974edd1a3a5c93836ebd220234bb3d4d8fe3c067d4480e9eb438e551f15f4f179ec4ffaad1ab76337c73896ca980ed0c535e396088660a7724954cd76d4a8ee1c393204e5d6f123902200966d2178241acf4812208fbddc1b81d4b72ea99cdc8a649003f19369e1f8450561cc1655e6383c3eb903e96c06753244dbe2b919506f7402ad7ecedd9ee6c052a20d6522c785518480e213fcedcca77e59a1133a70382b6d9caba0310d90022a9eef24cac0f00d55a3c0483d588fc8791f810d56be7ca3f429481df8f1922d335934a3a8036f37a5e8e9e7cbac137faf329d93725d44006321795e0b7fef0c90143b84ecbd934316a258c04f9aeb33443c585dc40de13408e573db134c41920e72484631f5f46f2a760bfa363676df7505e2aa025af3855d6c71c6b0602072e064fd113ab76d1b93b4b2e7ff0125001c65887dff849dddf1ef2825deec1f42bfff2684ef1d26778929ac65a0e8698a97463db733e24c6690ceeea45cb54ba42b98944da0c5c21adfbe87645bc35e964675be76f1289004de93260416c68d457ac8fc7288ddcf1ebedcddf78ab787ad572eb25d203c9e3191c85bce4438cbf940b15c1c7f23ebba39325f7c40f915271aa82caaf24bcf575707ab7a9b2f586ca559df663b3437ae9322231f29525b1b5e1cee115100e868a2bc7adce9f6720402b9ea46ce623f4fa377ad7f170126c0247cf51b19ba7dcfaf6b0ed06248271c1a2a18a45efbffbb1981951a42142f737ea8d94a59139f75577fe12426d56fb772da873d3ea26fdbff44ea0648ad52dc26d972688123812faef0db1612dac7c3f9014ec7a4c9fab50ee17a82625fbebc52c76e9d3c354872cb1749cb33de1880e90e7723386bc70a3ee33424c6b2f567b71216d09fb624182d02403696cee74b37c8f42469e7e92a302559b4811e682cc7e65c1cb2d53eb353c2f1443ec33d0766cb18fab0c8ef758db2161b4773386029ff6b445eb157c1a9e879e3670d316d2a9972b58035e00cd084064f56d3b5ddbb0cd4e0ed1884f3670443550c09b10510e0016ed58b431af6e073173532ad1376a905ea20a0c7860726940fffba7d448a3cd15b44305c6216f59ece83bb15c04f1c10c578b6dae0b565798f60791a163392108224a20a67c14e690d98174a03b8f845d6b137e1c2d78140598138e5f7c0eda3a3c100d2ff7736ad6287a25f86fe0cb484071b555fc159300162f9231c4e8bf4a89126b5bcaaf2584cd5f3454398719c79dd62db6c12dc073fa293b416dc74abc51b8c3877427d5d957ee8f82364d6007f9b8cbf2e29aa124d6df5ef6f5f5591ca79d505d5840753a3deb1e64299e22dcdef5e4528ff343fccc3887b75138836052a44725f30b056c6ad47c0ae1d2f755fe5173356c143f92f57bf6df94230ff1c49591ffb3646fee1ddd2da044405bd6af2aae1ff024bde0c2e642ac73201c35e6ce0e3b48d42284fe854625c15aab52354e6404156ac5c50b18eda1f33cd8a24060797446d49e37d3d3de1ba897967d9e6d2898e6f1edfaa91d13b620242b17b8d2473d98b06398451af16081db15685535b165cc9c9bae8802af0efddfc85c016ef5c39df2be2c736951811125602ff5821a34f61212c5c981c11421e28d25dc6a6f84a9d20dd8738926eca7bc8539a55776c08cd65c4f43999796f54b3200ea533a9564470ac4e75813ee833448b5ae220c86461b1d18803da75c01938e9c2db8260bbdf697e77d95d0c3c99632c5e42458769c29aebbdf3e6f1b98dad24d4a16fa644a38f19036bbcc47cf975b45ec36899633db338c68c4f3d16009b50e7026caaa640e890674bf0e0cdb6f11b64cebb71f5c4cb86f3ad279f6bd3502ce4e6108be052ef802305062709274b72b5f989e91bff4eab737d9a293511b160290994f02955d6314531ce5cda55b4e455ec2ec3cfeb4009188d90878eb855bbbc833117ec74ae2c0127a01d88874fe60b9deb258bd309b94e8a02222b18d24cef5e95105d768eae6db3031da9efb14fcd0dd884981f3aba496246800bd20d36b9505cb82ad4c2c0ec2638f75bb91fb2a78cb4c08f2fefa96e2a927a6b4ec125f28bf7b68c38dff65239d4de4914eec8920083bf5faa5db552dc76810bdd260fb178a9c5186d0daeaad53e13998b1b13f0cda9ff41684128a3ec683b47569b11d0261c2441863c45934282a31a815c7f9d18f24b5e1dabd7b7fdb7c4d968737875b0a0ef35460aee35cb8dcd62fbd2e5ace838ae52d055cae5cb2ceddd4430fc968ff0312d4e6074742172ec7bccfb66a0cdf89dedcb85ea7a3d27c05c0d9b469ee044fb32b880ad79ad5ed3566bce97075ba083ed030ceeb10967bfc29b0f44f5f1283a1b957f4faa5fe73dca968bf019d1f80b3bd4ef7540e1d9f6431bd31c762beb501a04509ebd4c68aae1e64854785dea6422e9422f8ffd796e0c31d040364bd203dcc96f031151bc03304b3a110f9ac19923ff86c79aec1c251690fc3fa63239353414b9cbd0060c1136cf072ec0af3fd9d573fc7219d11f974c2beb932d5b624dece4e5ad60c803e7bd5c7961f08d6b147d22451f902c8f0d7c9d7d44be8623325003b26fe55c5af412bfde571ccfd8fbb9640e128b37367af6f329b87aa7d1320bd668e9f2b613329e05376ae7a26510566a7a8ec7d4a79384dc2d1d9b1eaf3bdea3cee3a37e465793eea46aefe08a8ab03ce7910d737f67cc2db5007b44e49e35f29de37d06feb11fa888cd27f158ecf44f68b87618d5b326769821e33dc11ca331631c79287bd6cf7c00ac82da7fd567b4f37a99680a609aba71692b88224af97697443fe86e4acbb8632d53548396cb72829fcdd41563861299fe4a82621cee73343979419f793be3c42bf2f8e79310f793b399f4c13fdb6e8d676479d8d1ce3bfba0888373c9c6615f1afa33976497e5b6250e67317f0dc0c13c0e908e418e23784c51f32ed5c7c5e559f88bc396326357bb2220dfc83c1b29790ca8d3d06a2da9afcba789371682c583b0a8d573263a61c5f8cdfe5eef5cca304861aadcd06fa918ee6c745608dd4c5f300ed90b7c2ba5bdc532593df9c6e12f42bfd66177eed1818380338d8bc90d9873ad354fbeadac79dee1e855f6e4fd36e1ed5a8bc536a52fe7f48cdc71715d7b78eb52fc96a93900e4f50f5a004946b48a02dd25d5d403f99eaea1886be1e4b77740d32d50738ea8fb86a022c3f72736698addd757a689e79e61ed078e45aa4794621503c5f61e74a7211a7f58f61dc36b13faab46216a8724db4db1ed5a7d957e4620c323d83357056b92e48795e00c4a956b361873cda9e07ec3643c79ad8c347e934b931be0c1f1fa6ecb4a24efaf70585fdd09422575ad7d87e2058be88ca474102e83620f62462bb64badd473b387daf072ecb42d8a61c076ed2db37f94110153f5df0185292e6d7d93113de4c98417edd0e726ddae48c9a24b11b4e71041d8d63ff987fc4b828221f4eb1d5898c6a61eb4d17e2a1c03b7b1d31d28a98eeaa80f78b491df8d127dd84770252f0512a4b1251966a0571861e6c0b51a783ece22cd074f3de620c05fac5cd01bb776d1121fb33e912fa0a0cd6249873381121b1bf26fd0c9eb2efc5a05c548c02b6d8f73b10213e0e37791e5010f0ab15f5cf282cfdffe51ae6820420045f0f557ad4ad2cffb666e2fabb205912b5fc239d28b4d346ddb17204bc24e6ea500d227d5663f91f228d0630433ea2406c9aac0e999002130c0d133aa601608ebbdc6768072f289919665245a90d485baa9a4ac870e581bb4f57bc5e5e95f4d976debadc2afa54cdff43d7ab93eba9e7b98eab580d168be268f035f2a8f615fa2372e1ff5e4f548f4b5194d0c43e1e0b9928f1c2712cb50f72717d58656dca4899f09899fe69ba7b85828ac578c32e293757498525f91e72dd684005f7a398b42f7a1a45f84b238373b63b8e9bb42ca208646ad78807ad62c86a6c8060b0d7d87aa44cd8bcaa10606a29ecc5bd9d8bada064993892a5cd48fb56502a1e79b5e38d2b4aeeea11ecd78de86d6f53b307d4022bafd9d202aaae3c5f4d21582671bf12e1d86a695d68c07a44d1bcfec2cbe3b77ad18357c0255ac89354c9781e52d3c703524fa0ed7b83f61facfaee1a9a1019b7727034ccc94640e1e6a2a06e37820d3f558f34fc7972d7daa88d90905d737967d4c47d079c8de67fb689f9a872c211d48c9186931052167ff870dade6a5b69c09a0c07d4dc01ff430437d35cabda45d43a51a3e2917be03451bc5af331e1e115e3b0d4be33cd92652cd0b273e52d2bd1c29f1b97f7e6baabf84d6b8e5fc167f2dd432f63de6d3295d07d0b63f30b4a1018c1d491a3729ceac09d68e9b91efe95ec92c304994181a4f0903710a04f31e174bf14d45a6525c1ba09e480ec72dfff7355dffe0e8dd35e0333dc8744987277a6b502e85e7fc537651a4910783e4885388f0faaca1a20dd3a0b425e287603768efa373aebd3e86ffbcfb339abe4762cb4011f740472c453ade3ddad32dd7544dffeb28a4339e649adac5d3012396cd4ecb3c4384553d76c8dcb5bb4eaf5d26c6561ad5d99db016d1302295f86feec7038f9f6a5eb42ce6e01bb4717930deba2f48d6c0706918f813c058c1a81b6efc45b6c305f5eba6c13b0a029a94301a9e76075399ce9d6643ea2eb75a421a9607b690f0ae21f53ed10fb6b2f048ec3c06fe44d306109c457d1e7be3ec39ccae1d5b9cfe0c4a7b5f203019e72043a980af2ca9e695d72fb8c5a285040c7b385075b3601d47782f3f32e6e47c7655bade10b3db8b3ef1739d07c9926ef26b33d1711574ba350990dbbf1d9a9dce5d0f95bebcc6e8ecf6885afcf062a4fffe8fbd9ef1053a50092a8177c500b880b39c06d055f0cc2765a9c1b0f95ce066948b6755762cfe57d8e9971eb387fd6055e78ad3a7b9ef04856f2a1e2c791367897615fc11bb91e36e90a5a92ba0abbef2e5ed4dd94f3b57595c46e20e85338a8ee59b8f5abeba3ded7375b4ff1f74a6f3c8c9bd86f587e277898fb226116c7fcab3eb6236c4cb26de10fbb215333bdc3a42406df9f6216a975c044a9eef7e02437fd9d2074711f7eb55884a889e565d3ed6e8a0e3825038108e22e20c87448e91d01a77c7ecc726569ac1b76ba103f2af25536645a72e8b3bbbdcb2824d957d048577a8cdab0dc56d7793d57d4148de9e77c8dad41f1a8b3298d8987e579165ff7e2eae5ec9ef189cf116a110397396b657df30967b0019d6ab3628758026b66fee41449300609a8fb58533242e3c0beb4f42b119d5d6b862187a640c9cb07e38dfcf38287ada23277f55929cb1ad99861cd8d0376801e900c1cc340dddcdbd70b459da3723303b2b01bb71a52a3c5f6b5b7252d0c1fe98f33235f06c45e73fb3d6f9acc1f7fb0dddf8953fb58053e41f444d29a5c9a5f17355f883f6ff55cf762ab73db064a2d2471153b4ac66b297fa4148ed771327b13ac8d1eeda3c1725101690d98b2c28414fcf166c2c1c2576934429f7a5ea548f3d70a03ea555d31dbc41f12b54e331e8ee94a970afea184c0a2da95767d669e5ae2d080bf9505de03802836bbb37a2478a37436956b9f8f4126ba54bfb47c0d10b83bf80748aeb53175916bd351e6b6e1c1852789e74c450991028ab5892b2948572858dfc74e0c17f04050106731ec2290a5c9214ad896f421e91104ebea35247550e0ca6808e3ca9e0cd1b17a7519564b454ee945b2f28169246c9b201dc87eff4f0a10c1b6ef585decfb4ca2562dda112daf5ab02cf4bb8ea876ecba4c29968a652d7298c8f59d24d2780b9cd198553389cc14ef8678ea1d3ddb4596c331583a85a5d87c768db1cb0cd9925218be87ad048b330506151dfe424646b976f1b377225698bfa5c4df40825de30069eb9abda59fe20aea49a044ad1f4e482f623f4437f73231d716391210c9da1539dc708ffaf6d6e42dc82ceb11706c3097cedd40cca38817911b7eb530a0859b9aa83166d29444cb4dbafaa09e60c312f6c81050c474c0d5e928a4a2cd34df5a874756487fd5c7f81a38d5633e43e621fb511349fee5381c969d47f8b5fc0cda95ad76c1a2ca3a1bd11c4622f788b50d90e116b7fde60f8489ff94d26e03cf6ccbacae1183e9217be62acb1ca2a6bab41ee919efdd1d16e8385125fde156bcce56e29c1b72d39006e501f11be6540a083ad6763c1475391e43fd4e63fc4fb25c5671b10054a58e0fcc4cd22e13dd2a0933c344d7c4e96cff2b6f315e1ddc209c65970a553a8eb03d8fb615f40e5957acfdf74ccb5f61472d540d14a475e2f99c951015906100d1decd3dfe257e146f698f636a83d092350ba8c6e95037169b67bb1d552776f3ace089a45c5d902a838b0e9833e059e67b57ff0cee2bff6ef27d7990402a34129129f1700673c8febf7fa3af027a15da4e305ad42ddcbf60744c47decffd173609bd8a890eb869c256fdf7692ae5d827a9d4e885098434a47d543611b13c0c61a013aad0f6e0b249e043e718fe8e86b251487491d43dcbb3ee6ecbce865dbe3a424e2ea9233edb7fc93699d4be553770674e6bc8bc25a356ca3441d57cf5634fe9e8345b58f2e748a3ec9cc62f5d37660c90a3b9e01b80e5a6105aef6374d1356cc74ba4abd3a718ce5b866d455fc2eec34bd13bcebc1f13d9c919108f1a2e7d8e473a587a673979beecdf0fadf9c3d7f608c276ef1ef374eb7c11598fd2d9446d992580d1e068bb14f660a0d7a4e9498088a9f0437e81cd7d2423ebf8ccd9c9e9ccc13e50fed3876eeea165f11304898221fb15a11878f331cbb26e0bced4d970909282cfc98e26666e287f3fbee379f747e4d25d772c5a17df00eb07164907523531d2f746d630da0747d87994d4028324fcc36f927d183e8a65200cafb8b2b83ea968ecc608287feeb315444ad59984b3f268bfb85a06e457d91fab27bbb169680a1e55a8bb6ac3a53ca5c9d472a8746085dd0335723d6f9084ef85db9f2e0bf19e826bfc8025d8be8ec1a63e720c9e4520b9f89f75385927a788c446c746de508e553a965cd4e5479c6888ad76937e9359b41002df517ee275d569827508e3f4be47e80dfd14d7688d654f124a033246251643d6c455d2cbf78cf31f1afcdaabcd8f612e0bcc9a2ab5e0d8d77f5f3ba66351550b00acd9c036d7f88101bf7c260babd7311af2df8d481a355a58e0eb1116c4647b1ddc592c7f762e038b502331710a6309c3dc661251166151d3999f82eddfb6009d5427ca37b4ab532fd8d305902a4008ac47f6a3992beecc91d04efb97dbc2e7965bd09e2329554e4c42951415eda7f4495810162e00b2ae29cf163eb655ecd44512c5cf9424518850a1c665f16ba443661138703d0961d2e91cb7c2c5cdec252139971c07f41bd5125d4c5ab37266c1d81effaf8a7f9256cc237df54ab8f25a8a2b59947eda2aefb4a03fe737d863353c0d8a60f93b560fb5d497a23fdad0fe0c9aae2c50cf770a5a7d20121e9e0ca6176691aa20754897c00cf513ac7d8e3efc307d232b7187380e751fdea9b6d490cc0aa196b5c30a0fcbd3f0ccf176c291f15c2d859be93afcf0f45a0bee392fee646285b2b3cbf128fd098e715e9076a2c2457e4a6e39513e9cf7e1ce755cf26b71c44a89e26a79285359e49ec6f17d688248d299014dc9e3a70f9735b0cdc6f3fa00cfdd65b9aa816514452c1980d80cac72daae72a32e423653e6304c0528fce4dd8864ce27f1c360ff325036432f6a53efb198e9b7e0792811f1794462cf89dee7ec62d1ccf370dc6fce1ee69e72308775b6c063a6d0434c3e88ead087eb3b75e7cc6faee06d2490c6e7d1afa1af861c90b268c8d3aa43b70cdae6de35fe597885c9a880d8c71870a3fa4cef4450cec9b59b17f387e1fc0d463161e6d1c88790621d4a9aad1a975b337129ca53fe35326fa1b4293c42f8edc8ec4a242cf135098a560fbba3561b4631d47b84704eaac05d05e082a375c25097d1516a4717e35703e4daa2e07f233781c917e3aa19651163629ed08f33c0a1f489f3c6a7aa6888ba14293f206181c401034ed98304fa71f172fcd16c5df82fb54476c77ed6889efbc51f8680354db8d7ffbec89cb63cb3c05e1adadcaa8808a6e96487d4b14407b989e555e7ccd0b22059b6285033a5d2f8663ec6729d540fa44236eb64fb47bf994e7c2d046033e73f899027cc1d10a6de76fc621ec830ae13d5cf5275627a6e9c02069e425b70b74dd70260bc53b8403405e07727f50e256eb77d04c2f422b4bd839cc6575ce9c51433848ff9d7c580dfdd90786ca098b4f617976997c7f107629c1b36e6e78a8aaf5a4b3344c2aa05821af83b5878d335372bfc4b20679a80d21f11e6f7178427ea32dc8f88a482bc6d1356063cf2a4d420b4c51234d9a6a29d7de9ee9c9b9e8a15ac281bb6ac454acc24e1f42ac3ce603102b30644b41c99cde8c148552ad1b445862a3281cb3b9cd4e6c7b9ad37faf481da4a81872b5b876b8a8e4ba124be1ee46de499fe33d5a8f4603bec42895dc10402b35e6fc37e3f56b1f66849ffe6149210eb7107122f3b60399c1cd3b1320b653eed6f9c0c0b44179f4b96aa41e4ef969f612f86c4b06cf9f8362610861026ee3bd5f474fef107e511d4131d6e5645d9952dda20db135e8f809dae77ea8d209b14d92ea325c7c9d56fb5c7948ebed20409ab386a27d591996283fd3a220ede0153fd52ae6257a795e6abc032dfb559ab47a2116c4e4f3e9700b93584c1f3f707ff9771787a73b5c74c7a2331c453cd85ddf448962d00ccccc098770e4ceeb5e9062ffe4789bf7f838e1ea028ae81fe67f67db73890ff6396a90cc751e4c598244e11068c79e7affda453bb0dc5cbf21eedf59498f61a7a674b498d426f72d5993f9dd1914ee6f7347cb258651ee4a5d1167cfd55172e544efcc0cb49885de90498108af15643c08fd97a362292b414443b113e3d696c80202eb7dfd2dc4c9f9946df94404988b1c0f7642cca9e4a9a19150522f957bf0ab361663c115824f36446ed96e36158545e29bab7ad1502ad9f67faff7c730b325d97c72489bcca497a7e6f84f532a159f80ab4e3b7673b8743d4950765523d768b54ae7e563111e8361fc5577eefa2b986ab65d833b9a26381b8980d2f6af6234bf0934c518acc2d8a20d48489f09e5d5a034d7e3a2c92834b7c5c3303aef5e229037e9fa1667d83e1ab44e2e43af0ef81c5a87e409ead842b78ee33721ca7cd93fb7608bc22333cfbb3e64abc0ab12c6985f8a2d5144f294661a19ab17fbca35624658555b22615ff25a9230e15d38dd61e7cb5ebe0900b05687d9a871ecde17860d29ad2bca19ab3bf8e0c05280dfb58c1fd471dcfe3bfe1cb1a4296c1557358b6b7813f988536cac239375e3a591af9846a631c7e0153f62c685c8d3ca1165f50701090f94df6e0b6c7efc46034c6ad7057e17efc7240f65f0a9686952a47a315b528f6bb92cc34e61b0dc5e1f5340a40ccc305992d7eb9be1efaa2f1234f4309061f31fe4d378a80252cb2214944ef4a5c293d9d57a3d04f8b56cbc177be3cf43618859b37ed044efb40006476fc9063963ed84b8dec968956ea4ee3638b7a4ab0e4afd5d45d4e9950ca03b2a8589c3f21eb57b72c6960eb6c04a0754cc06bd74a2dc05fc67fd0b576ba725a2560fc87409516f96e30c996aa997ed87753dc747e273c42dcdd8ad768de2bfd2104564d27f7a549a36c55885c4dce6dabae2ef883bf586f9eac80ee82f4f2eb63ecb6b10a6fea76ef014ff68ad97211015e7679e9c9615331f91e686883c42c90dd3ed35bed8ad1abf39b6859797e4a2194c55e03a928e2ecb240041e5f88c86a98d81d047e52ccf489579da31f280fd41e9feac02ead682de2d2a64fd89280724124b95daa0a795cc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">文章已加密</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">???</summary>
    
    
    
    <category term="阅读" scheme="https://blog.godmao.top/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="阅读感悟" scheme="https://blog.godmao.top/Tags/%E9%98%85%E8%AF%BB%E6%84%9F%E6%82%9F/"/>
    
    <category term="自控力" scheme="https://blog.godmao.top/Tags/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>三行代码实现按键的长短按检测</title>
    <link href="https://blog.godmao.top/posts/862/"/>
    <id>https://blog.godmao.top/posts/862/</id>
    <published>2025-03-22T04:38:43.000Z</published>
    <updated>2025-03-28T15:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="话不多说直接上代码"><a class="markdownIt-Anchor" href="#话不多说直接上代码"></a> 话不多说直接上代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uchar cont,trg;    <span class="comment">//triger触发 continue连续</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyScan</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">uchar ReadData =  PINB^<span class="number">0xff</span>;</span><br><span class="line">trg = ReadData &amp; (ReadData^cont);</span><br><span class="line">cont = ReadData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就完事了，灰常的amzing啊。</p><h2 id="尝试理解"><a class="markdownIt-Anchor" href="#尝试理解"></a> 尝试理解</h2><p>首先我们要理解<code>PINB</code>，这里的<code>PINB</code>指的是我们的单片机GPIOB的所有Pin的端口数据，而每个端口的数据（高/低——1/0）对应1个bit位。例如某单片机有八个端口只有端口0为高，其余皆为低，则PINB=0000 0001。在STM32Hal库中，我们可以这样实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">KeyBit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> keybit = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">//读取B1的电平状态并把他左移到bit0位</span></span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B1_GPIO_Port,B1_Pin) &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B2_GPIO_Port,B2_Pin) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B3_GPIO_Port,B3_Pin) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B4_GPIO_Port,B4_Pin) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> keybit; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取反"><a class="markdownIt-Anchor" href="#取反"></a> 取反</h3><p>第一行代码就相当于是取反操作，使没有按键按下时data始终为0x00。</p><p>注意，不一定就是异或0xff，按照上面的hal库方法，你的PINB变量实际上只有四位有效位，为了让没有按键按下时data为0x00，我们异或0x0f即可，或者将keybit初始化为0xf0然后异或0xff；而有时GPIO输入接了下拉，没有输入的情况本来就是0，这时就不需要再取反。反正就是要让它没有按键按下时等于0x00。</p><details><summary>点击即看异或真值表</summary><p>与0异或不变，与1异或取反</p><table><thead><tr><th>A</th><th>B</th><th>A ⊕ B</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></details><h3 id="单击按下"><a class="markdownIt-Anchor" href="#单击按下"></a> 单击按下</h3><p>第一次PB0按下的情况<br />端口数据原本为0xfe，ReadData读端口并且取反，变为 0x01 （第一行）。<br />因为这是第一次按下，所以Cont是上次的值，应为为0。与0异或不改变原有值，那么第二行执行的实际是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Trg</span> = <span class="number">0</span>x01 &amp; (<span class="number">0</span>x01^<span class="number">0</span>x00) = <span class="number">0</span>x01  </span><br></pre></td></tr></table></figure><p>将cont赋值</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cont</span> <span class="operator">=</span> ReadData <span class="operator">=</span> <span class="number">0</span>x01</span><br></pre></td></tr></table></figure><p>结果就是：</p><ul><li>ReadData ＝ 0x01</li><li>Trg ＝ 0x01</li><li>Cont ＝ 0x01</li></ul><h3 id="按下后还没有完全松开引申到长按"><a class="markdownIt-Anchor" href="#按下后还没有完全松开引申到长按"></a> 按下后还没有完全松开（引申到长按）</h3><p>此时程序依然在执行。</p><ul><li>第一行：不变，依然为0x01。</li><li>第二行：操作为——把检测到的按下按钮对应的bit为给置0了，让Trg等于0了</li><li>第三行：不变，依然为0x01。</li></ul><p>我们可以看到唯一变了的地方就是Trg被置0了。</p><h3 id="完全松开"><a class="markdownIt-Anchor" href="#完全松开"></a> 完全松开</h3><p>很好理解，肯定全为0x00了。</p><h3 id="笔者的思考"><a class="markdownIt-Anchor" href="#笔者的思考"></a> 笔者的思考</h3><p>该代码的核心思路我认为是用三种不同的数据内容代表不同的三种情况（未按下、单按、长按）按照这种思路，我们甚至还可以扩展。</p><p><code>ReadData</code>存储原始的端口电平数据，不能改变。后续的两个数据都会基于这个原始数据。<br /><code>Trg</code> 用于按键触发。<code>ReadData</code>中有bit位有上升沿时，Trg会记录这个上升沿：只有bit从0变为1，Trg才会置1。按下判断的条件是：<code>Trg</code>、<code>Cont</code>均为1。<br /><code>Cont</code> 用于长按。长按的判断条件是：<code>Trg</code>为0的情况下<code>Cont</code>依然为1。</p><p>这样的思路让我联想到了3-8译码器的巧妙设计，通过3个值的输入，可以得到8个值的输出，用3个值就可以为8个不同的情况进行处理。</p><h2 id="在stm32中使用"><a class="markdownIt-Anchor" href="#在stm32中使用"></a> 在STM32中使用</h2><p>附上我的使用方法，我使用的是<a href="http://im.godmao.top/posts/39448/">时间片轮询架构</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B1 0x01</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B2 0x02</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3 0x04</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B4 0x08</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">KeyBit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint8_t</span> keybit = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取B1的电平状态并把他左移到bit0位</span></span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B1_GPIO_Port,B1_Pin) &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B2_GPIO_Port,B2_Pin) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B3_GPIO_Port,B3_Pin) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    keybit |= HAL_GPIO_ReadPin(B4_GPIO_Port,B4_Pin) &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keybit;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyFuc</span><span class="params">(<span class="type">void</span>)</span>&#123;<span class="comment">//按键逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> i = <span class="number">0</span>;                           <span class="comment">//长按时间计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心代码：三行代码完成按键单、长按检测</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ReadData = KeyBit() ^ <span class="number">0x0f</span>;       <span class="comment">// 取反：在没有按键按下的情况下，其始终为0x00</span></span><br><span class="line"></span><br><span class="line">    Trg = ReadData &amp; (ReadData ^ Cont);             <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    Cont = ReadData;                                <span class="comment">// 3                        </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Trg &amp;&amp; Cont)&#123;<span class="comment">//单击逻辑      </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(Trg)&#123;                            </span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> B4: Key4_Fuc();<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> B3: Key3_Fuc();<span class="keyword">break</span>;          </span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> B2: Key2_Fuc();<span class="keyword">break</span>;          </span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> B1: Key1_Fuc();<span class="keyword">break</span>;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Cont &amp;&amp; <span class="number">0</span> == Trg) i++;<span class="comment">//以下为长按逻辑</span></span><br><span class="line">    <span class="keyword">else</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i &gt;= <span class="number">20</span>)&#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(Cont)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> B3: Key3_Fuc_Preesed();<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关于消抖问题"><a class="markdownIt-Anchor" href="#关于消抖问题"></a> 关于消抖问题</h2><p><s>不知道为什么，按理来说是需要消抖的，但是实际跑起来的时候没有消抖也非常稳，，，可能是我的按键检测任务执行间隔比较长？</s></p><hr /><p>2025.03.28 补充修改：如果使用时间片轮询调度，理论上如果按键扫描任务执行间隔时间较长，是不用消抖的。这就解释了为什么我的程序没有消抖也那么稳！例如，假设你设置的时间片调度间隔是 100ms，如果按键每次扫描时是 100ms 执行一次，假设按键抖动的周期是 10ms，那么每次扫描时按键就已经稳定了。这样，按键的物理状态变化就不太可能被误判为多个状态变化，因为时间间隔本身已经足够长。当然代价是 <strong>会牺牲按键响应速度，以及无法应用快速连按的按键逻辑</strong></p><hr /><p>关于消抖我还没有实际上机跑过，但是也写一下，Deepseek写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBOUNCE_TIME 1 <span class="comment">//消抖时间参数，根据时间片的时间来设定</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    KEY_STATE_IDLE,<span class="comment">//空闲</span></span><br><span class="line">    KEY_STATE_PRESSED,<span class="comment">//按下</span></span><br><span class="line">    KEY_STATE_RELEASED<span class="comment">//松开</span></span><br><span class="line">&#125; KeyState;</span><br><span class="line"></span><br><span class="line">KeyState key_state = KEY_STATE_IDLE;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> debounce_timer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyScan</span><span class="params">()</span> &#123;</span><br><span class="line">    uchar ReadData = PINB ^ <span class="number">0xff</span>;</span><br><span class="line">    uchar new_trg = ReadData &amp; (ReadData ^ cont);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (key_state) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEY_STATE_IDLE:</span><br><span class="line">            <span class="keyword">if</span> (new_trg != <span class="number">0</span>) &#123; <span class="comment">// 检测到按键变化</span></span><br><span class="line">                key_state = KEY_STATE_PRESSED;</span><br><span class="line">                debounce_timer = DEBOUNCE_TIME;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> KEY_STATE_PRESSED:</span><br><span class="line">            <span class="keyword">if</span> (debounce_timer &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                debounce_timer --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ReadData == (PINB ^ <span class="number">0xff</span>)) &#123; <span class="comment">// 确认按键状态</span></span><br><span class="line">                    trg = new_trg;</span><br><span class="line">                    cont = ReadData;</span><br><span class="line">    <span class="keyword">if</span>(trg &amp;&amp; cont)&#123;</span><br><span class="line"><span class="comment">/*写单击逻辑*/</span></span><br><span class="line">    &#125;</span><br><span class="line">                    key_state = KEY_STATE_RELEASED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    key_state = KEY_STATE_IDLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> KEY_STATE_RELEASED:</span><br><span class="line">            <span class="keyword">if</span> (new_trg == <span class="number">0</span>) &#123; <span class="comment">// 等待按键释放</span></span><br><span class="line">                key_state = KEY_STATE_IDLE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">三行代码即可实现按键的长短按检测。</summary>
    
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="程序架构" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="程序架构" scheme="https://blog.godmao.top/Tags/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84/"/>
    
    <category term="按键检测" scheme="https://blog.godmao.top/Tags/%E6%8C%89%E9%94%AE%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式模块化设计中的数据共享优化方案</title>
    <link href="https://blog.godmao.top/posts/58440/"/>
    <id>https://blog.godmao.top/posts/58440/</id>
    <published>2025-03-22T04:33:52.000Z</published>
    <updated>2025-03-22T07:24:56.000Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="问题的提出"><a class="markdownIt-Anchor" href="#问题的提出"></a> 问题的提出</h2><p>在嵌入式项目中，模块化每个功能有利于管理和理清开发思路，但是，当我们需要将模块联动起来的时候，需要一些必要的变量以实现两个模块之间的互相配合，最常见的方法是使用全局变量，但这样做使模块间耦合性<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>大大提高了。</p><h2 id="有什么更好的方案吗"><a class="markdownIt-Anchor" href="#有什么更好的方案吗"></a> 有什么更好的方案吗</h2><p>有的兄弟有的。只不过要牺牲一些效率（需要通过接口访问）。我们可以为共享变量建立一个专门的.c/.h文件，例如<code>SharedData.c/.h</code>。<br />这个文件集中管理模块间的共享变量。这样做结构清晰，每个模块<strong>只依赖 <code>SharedData.h</code>，而不是彼此依赖</strong>\ <br />同时我们通过两种方法使需要访问变量的模块成功读取或修改变量：</p><ul><li>结构体封装+指针传递</li><li>通过函数提供读取和修改的接口</li></ul><h2 id="结构体封装指针传递"><a class="markdownIt-Anchor" href="#结构体封装指针传递"></a> 结构体封装+指针传递</h2><p>:::recommend</p><ul><li>共享变量较多时非常好用。</li><li><strong>隐藏全局变量</strong>，外部模块无法直接访问共享数据而是通过指针，安全性高。</li><li>更好扩展。</li><li>方便，无需为每个变量都写函数接口以提供修改与读取。</li><li><strong>访问速度快</strong>。</li></ul><p>:::</p><h3 id="h文件"><a class="markdownIt-Anchor" href="#h文件"></a> .h文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_DATA_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> sensor_value;</span><br><span class="line">    <span class="type">int</span> motor_speed;</span><br><span class="line">&#125; SharedData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只提供获取指针的接口，而不是直接暴露变量</span></span><br><span class="line">SharedData* <span class="title function_">get_shared_data</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="c文件"><a class="markdownIt-Anchor" href="#c文件"></a> .c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shared_data.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> SharedData system_data = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// 只在本文件可见</span></span><br><span class="line"></span><br><span class="line">SharedData* <span class="title function_">get_shared_data</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;system_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在其他模块中使用"><a class="markdownIt-Anchor" href="#在其他模块中使用"></a> 在其他模块中使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shared_data.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">moduleA_update</span><span class="params">()</span> &#123;</span><br><span class="line">    SharedData *data = get_shared_data();</span><br><span class="line">    data-&gt;sensor_value += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:::warning</p><p>不推荐将<strong>接收共享变量的指针的变量</strong>定义为全局变量。尽管这样会方便一些。<strong>指针可能被多个模块修改</strong>，导致指向无效地址（增加 bug 风险）。推荐在每个函数内部通过接口访问变量。如果一定要这样做，请一定避免空指针（记住初始化指针）</p><p>:::</p><p>使用全局指针示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> SharedData *data;  <span class="comment">// 仅限当前文件访问</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">moduleA_init</span><span class="params">()</span> &#123;</span><br><span class="line">    data = get_shared_data();<span class="comment">//避免空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过函数提供读取和修改的接口"><a class="markdownIt-Anchor" href="#通过函数提供读取和修改的接口"></a> 通过函数提供读取和修改的接口</h2><p>:::recommend</p><ul><li><strong>灵活访问变量。你可以严格控制对数据的访问，如只读、避免非法值写入等；同时也可以自定义访问方法，如按位读取。非常的好用。</strong></li><li>可扩展性强。</li></ul><p>:::</p><p>:::error</p><ul><li>代码冗长，调用花销稍大。</li><li>变量太多时需要为每个变量都写接口，太麻烦。所以才要和上面的方法联合起来使用，只为必要的变量编写接口，其余通过第一种方法访问。</li></ul><p>:::</p><h3 id="h文件-2"><a class="markdownIt-Anchor" href="#h文件-2"></a> .h文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_DATA_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setSensorValue</span><span class="params">(<span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getSensorValue</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setMotorSpeed</span><span class="params">(<span class="type">int</span> speed)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getMotorSpeed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="c文件-2"><a class="markdownIt-Anchor" href="#c文件-2"></a> .c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shared_data.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sensor_value = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> motor_speed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setSensorValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span>) &#123;  <span class="comment">// 限制非法值</span></span><br><span class="line">        sensor_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getSensorValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sensor_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setMotorSpeed</span><span class="params">(<span class="type">int</span> speed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (speed &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        motor_speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMotorSpeed</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> motor_speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="在其他模块中使用-2"><a class="markdownIt-Anchor" href="#在其他模块中使用-2"></a> 在其他模块中使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shared_data.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">moduleA_update</span><span class="params">()</span> &#123;</span><br><span class="line">    setSensorValue(getSensorValue() + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="联合起来"><a class="markdownIt-Anchor" href="#联合起来"></a> 联合起来</h2><p>将两种方式联合起来使用——大部分变量，我们使用指针接口访问即可；如果有些变量需要一些个性化要求，我们为这些变量编写定制的接口就好。</p><h2 id="挖坑"><a class="markdownIt-Anchor" href="#挖坑"></a> 挖坑</h2><p>降低耦合性的方法还有使用单例模式，以及RTOS中的消息/事件机制。后续研究。</p><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>代码耦合性（Coupling）是指模块或组件之间的依赖程度。如果代码耦合性很高，模块之间会紧密依赖，导致代码难以维护、扩展和测试。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">避免模块间公共变量导致耦合性提高。</summary>
    
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="程序架构" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="程序架构" scheme="https://blog.godmao.top/Tags/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84/"/>
    
    <category term="降低耦合" scheme="https://blog.godmao.top/Tags/%E9%99%8D%E4%BD%8E%E8%80%A6%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>串口重定向的非阻塞方法</title>
    <link href="https://blog.godmao.top/posts/18285/"/>
    <id>https://blog.godmao.top/posts/18285/</id>
    <published>2025-03-17T14:10:17.000Z</published>
    <updated>2025-03-17T15:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="常用方式"><a class="markdownIt-Anchor" href="#常用方式"></a> 常用方式</h2><p>有时我们需要串口打印信息到上位机，最便捷的方法是重定向 <code>printf()</code>，网上的常用方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span>&#123;    </span><br><span class="line">HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> ch;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *f)</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="type">uint8_t</span> ch = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">HAL_UART_Receive(&amp;huart1, &amp;ch, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> ch;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="这样做的缺点"><a class="markdownIt-Anchor" href="#这样做的缺点"></a> 这样做的缺点</h3><ul><li>这是 <strong>阻塞模式</strong>，每次 <code>printf()</code> 都要等待数据发送完毕，影响 CPU 执行效率。</li><li>如果数据较多，会降低实时性，阻塞主循环。</li></ul><h2 id="使用非阻塞的方式灵活运用dma"><a class="markdownIt-Anchor" href="#使用非阻塞的方式灵活运用dma"></a> 使用非阻塞的方式：灵活运用DMA</h2><p>我们使用DMA非阻塞发送。具体步骤如下：</p><h3 id="1-定义缓冲区"><a class="markdownIt-Anchor" href="#1-定义缓冲区"></a> 1. 定义缓冲区。</h3><p>根据fputc()的特性（这里先按下不表），使用 DMA 发送时，<code>printf()</code> 需要先把数据存到 <strong>一个缓冲区</strong>，然后一次性使用 DMA 发送出去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TX_BUFFER_SIZE 256  <span class="comment">// 发送缓冲区大小</span></span></span><br><span class="line"><span class="type">uint8_t</span> uart_tx_buffer[TX_BUFFER_SIZE];  <span class="comment">// 串口发送缓冲区</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint16_t</span> tx_len = <span class="number">0</span>;  <span class="comment">// 当前缓冲区数据长度</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint8_t</span> tx_busy = <span class="number">0</span>;  <span class="comment">// 发送状态标志</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-重定向-fputc使用缓冲区"><a class="markdownIt-Anchor" href="#2-重定向-fputc使用缓冲区"></a> 2. 重定向 <code>fputc()</code>，使用缓冲区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保缓冲区不会溢出</span></span><br><span class="line">    <span class="keyword">if</span> (tx_len &lt; TX_BUFFER_SIZE - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        uart_tx_buffer[tx_len++] = (<span class="type">uint8_t</span>)ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果遇到换行符，或者缓冲区接近满，就启动 DMA 发送</span></span><br><span class="line">    <span class="comment">// 注意咯，如果缓冲区没满的情况下，只有检测到/n才会触发DMA的发送。所以在缓</span></span><br><span class="line">    <span class="comment">// 冲区没满的情况下，如果你想要发送字符串&quot;abc&quot;，printf(&quot;abc&quot;)是没用的，</span></span><br><span class="line">    <span class="comment">// printf(&quot;abc\n&quot;)才有用哦。</span></span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span> || tx_len &gt;= TX_BUFFER_SIZE - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        uart_dma_transmit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-定义dma-发送函数"><a class="markdownIt-Anchor" href="#3-定义dma-发送函数"></a> 3. 定义DMA 发送函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_dma_transmit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果 DMA 还在忙，则不启动新的传输</span></span><br><span class="line">    <span class="keyword">if</span> (tx_busy) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    tx_busy = <span class="number">1</span>;  <span class="comment">// 标记为发送中</span></span><br><span class="line">    HAL_UART_Transmit_DMA(&amp;huart1, uart_tx_buffer, tx_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-dma-传输完成回调"><a class="markdownIt-Anchor" href="#4-dma-传输完成回调"></a> 4. DMA 传输完成回调</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_TxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (huart-&gt;Instance == USART1)  <span class="comment">// 确保是目标串口</span></span><br><span class="line">    &#123;</span><br><span class="line">        tx_len = <span class="number">0</span>;  <span class="comment">// 清空缓冲区</span></span><br><span class="line">        tx_busy = <span class="number">0</span>; <span class="comment">// 标记为可用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="一些疑惑的解答"><a class="markdownIt-Anchor" href="#一些疑惑的解答"></a> 一些疑惑的解答</h2><p>Q: 茂神茂神，你的说的非阻塞方式的确很不错，但是还是太吃操作了，我就不能直接在 <code>fputc()</code>里写 <code>HAL_UART_Transmit_DMA</code>吗？<br /><br />A: 可以的兄弟可以的。<code>fputc()</code> 是发送一个字符对吧，理论上我们只需要把DMA传输的字节数改为1就行了对吧？nonono，首先DMA是非阻塞的对吧，也就是激活了它，他就只管发，不管你完没完成，你都可以再次激活它，如果像你这样做，当发送字符流时大概率是这种情况：</p><blockquote><p><code>fputc()</code>打电话给DMA的秘书说我要发这个字符，然后他就认为我已经给DMA说了叫它发送这个字符啦，所以这个字符就发出去啦，剩下就不关我的事啦。结果DMA秘书看到DMA此时还在忙于上次发送，于是判断DMA为<code>HAL_BUSY</code>没有办法把字符交给DMA。这个字符信息就丢失了。。。。</p></blockquote>]]></content>
    
    
    <summary type="html">关于串口重定向的非阻塞方法的介绍。</summary>
    
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="程序架构" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="STM32" scheme="https://blog.godmao.top/Tags/STM32/"/>
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="程序架构" scheme="https://blog.godmao.top/Tags/%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84/"/>
    
    <category term="串口" scheme="https://blog.godmao.top/Tags/%E4%B8%B2%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>CubeMX配置功能系列：iic</title>
    <link href="https://blog.godmao.top/posts/58129/"/>
    <id>https://blog.godmao.top/posts/58129/</id>
    <published>2025-03-12T06:42:40.000Z</published>
    <updated>2025-03-12T13:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章为博主原创文章。遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h2><p>由于前面已经详细介绍了iic通信协议（详见<a href="https://im.godmao.top/posts/55329/">通信协议：iic [ g0dMa0’s Blog ]</a>），这里主要就硬件iic在cubemx中的配置作介绍。</p><h2 id="通道设置"><a class="markdownIt-Anchor" href="#通道设置"></a> 通道设置</h2><p><img src="Snipaste_2025-03-12_14-59-01.png" alt="" /><br />哈哈没想到吧，iic通道不止支持iic协议，孩子。<br />SMBus-系统管理总线，是iic的扩展。利用系统管理总线，设备可提供制造商信息，告诉系统它的型号/部件号，保存暂停事件的状态，报告不同类型的错误，接收控制参数，和返回它的状态。SMBus为系统和电源管理相关的任务提供控制总线。<br />SMBus 为系统和电源管理这样的任务提供了一条控制总线，使用 SMBus 的系统，设备之间发送和接收消息都是通过 SMBus，而不是使用单独的控制线，这样可以节省设备的管脚数。\ <br />所以它与iic的区别很明显了，一个是该总线上连接设备自身可以控制总线(I2C，速率较高)，想干嘛就干嘛；另一个是设备之间可以通过它来传送信息，但是速率比较慢，比如用在检测各元件状态并更新硬件设置引脚等，同时廉价是它的优点。<br /><br /><strong>SMBus-Alert</strong>是一个带中断线的可选信号，用于那些希望扩展他们的控制能力而牺牲一个引脚的设备。SMBALERT和SCL和SDA信号一样，是一种线与信号。SMBALERT通常和SMBus广播呼叫地址一起使用。与SMBus有关的消息为2字节。<strong>单一的从设备可以通过SMBALERT发信号给主机表示它希望进行通信</strong>，这可通过设置I2C_CR1寄存器上的ALERT位实现。主机处理该中断并通过提醒响应地址ARA(Alert Response Address，地址值为0001100x)访问所有SMBALERT设备。只有那些将SMBALERT拉低的设备能应答ARA。此状态是由 I2C_SR1寄存器中的SMBALERT状态标记来标识的。主机执行一个修改过的接收字节操作。由从发送设备提供的7位设备地址被放在字节的7个最高位上，第八个位可以是0或1。如果多个设备把SMBALERT拉低，最高优先级设备(最小的地址)将在地址传输期间通过标准仲裁赢得通信权。在确认从地址后，此设备不得再拉低它的SMBALERT，如果当信息传输完成后，主机仍看到SMBALERT低，就知道需要再次读ARA。没有执行SMBALERT信号的主机可以定期访问ARA。有关SMBus提醒模式的更多详细资料，请参考2.0版的SMBus规范。<strong>说白了还是通信，只不过是从机与从机的通信</strong> <br />我先忽略系统管理总线协议。专注于iic。</p><h2 id="主模式设置"><a class="markdownIt-Anchor" href="#主模式设置"></a> 主模式设置</h2><p><img src="Snipaste_2025-03-12_17-56-13.png" alt="" /></p><h3 id="custom-timing"><a class="markdownIt-Anchor" href="#custom-timing"></a> Custom Timing</h3><p>这个牛逼了，iiC通信依赖于特定的时序参数，如时钟频率、高低电平时间等。STM32CubeMX通常提供预定义的时序配置，适用于常见场景。但在某些情况下，预定义配置可能无法满足需求，这时就需要手动调整时序参数。</p><p>通过“Custom Timing”，你可以根据具体需求调整以下参数：</p><ol><li><strong>SCL时钟频率</strong>：设置SCL时钟的频率。</li><li><strong>SCL高低电平时间</strong>：分别设置SCL高电平和低电平的持续时间。</li><li><strong>数据建立和保持时间</strong>：设置数据在时钟边沿前后的稳定时间。</li><li><strong>起始和停止条件时间</strong>：设置起始和停止条件的持续时间。</li></ol><h4 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h4><ul><li><strong>非标准I2C设备</strong>：某些设备可能需要特定的时序。</li><li><strong>优化性能</strong>：在高噪声环境中，调整时序可以提高通信稳定性。</li><li><strong>调试</strong>：在调试时，手动调整时序有助于排查问题。</li></ul><h4 id="配置步骤"><a class="markdownIt-Anchor" href="#配置步骤"></a> 配置步骤</h4><ol><li>在CubeMX中启用I2C外设。</li><li>选择“Custom Timing”选项。</li><li>手动输入所需的时序参数。</li><li>生成代码并验证配置。</li></ol><h4 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h4><ul><li>确保时序参数符合I2C规范和设备要求。</li><li>错误的配置可能导致通信失败或损坏设备。<br />通过“Custom Timing”，你可以更灵活地配置I2C通信，满足特定需求。</li></ul><h4 id="看完以后发现我还是不会用啊"><a class="markdownIt-Anchor" href="#看完以后发现我还是不会用啊"></a> 看完以后发现我还是不会用啊，，，，，</h4><h3 id="timing"><a class="markdownIt-Anchor" href="#timing"></a> Timing</h3><p>这个是和上面那个一起用的，我猜是把Timing这个设定值写入某个寄存器里，然后这个寄存器的不同位控制着不同的时序参数，如高低电平时间什么的。没有深究。因为估计也不会用自定义时序。<br /><img src="Snipaste_2025-03-12_18-39-27.png" alt="" /><br />自定义时序enable 后的界面如上图所示。</p><h3 id="risetimefalltimecoefficient-of-digital-filter"><a class="markdownIt-Anchor" href="#risetimefalltimecoefficient-of-digital-filter"></a> RiseTime/FallTime/Coefficient of Digital Filter</h3><p>控制iic上升沿/下降沿的时间，iic对于上下降沿的时间是有要求的。<br />数字滤波器系数。不启用设置为0，启用则可设置为1-15，表示1-15个iic外设时钟。<br />这三个参数要遵循一套非常复杂的时序计算方法的，也和对应的外设有关系，在设置前也要阅读相关的外设资料。此处暂且不展开。</p><h3 id="analog-filter"><a class="markdownIt-Anchor" href="#analog-filter"></a> Analog Filter</h3><p>模拟滤波器。</p><h2 id="从模式设置"><a class="markdownIt-Anchor" href="#从模式设置"></a> 从模式设置</h2><h3 id="clock-no-stretch-mode"><a class="markdownIt-Anchor" href="#clock-no-stretch-mode"></a> Clock No Stretch Mode</h3><p><strong>IIC时钟拉伸(Clock stretching)</strong>：<br />有时候低速从机可能由于上一个请求还没处理完，无法继续接收主机的后续请求，<strong>即主机的数据传输速率超过了从机的处理能力</strong>。这种情况下，从机可以进行时钟拉伸来要求主机暂停传输数据 。通常时钟都是由主机提供的，从机只是在SDA上读数据或者发数据。<br />时钟拉伸则是从机在主机释放SCL后，将SCL主动拉低并保持，此时要求主机停止在SCL上产生脉冲以及在SDA上发送数据，直到从机释放SCL（SCL为高电平）。之后主机便可以继续正常的数据传输了。可见时钟拉伸实际上是利用了时钟同步的机制，只是时钟由从机产生。 如果系统中存在这种低速从机并且从机实现了时钟拉伸，主机必须能够处理这种情况，<strong>实际上大部分从机设备中不包含SCL驱动器的，因此无法拉伸时钟。</strong></p><h3 id="primary-address-length-selection"><a class="markdownIt-Anchor" href="#primary-address-length-selection"></a> Primary Address Length selection</h3><p>从设备地址长度 置从设备的地址是7bit还是10bit。大部分为7bit。</p><h3 id="general-call-address"><a class="markdownIt-Anchor" href="#general-call-address"></a> General call address</h3><p><strong>通用广播地址是为了寻址总线上所有设备。</strong> 如果一个设备不需要使用广播功能，可以不响应广播。如果设备需要使用广播功能，则它在检测到广播地址后发送响应，并作为从机接收读取总线上发送的数据。主机不知道总线上有多少从机发送响应。<strong>总线上所有可以响应广播的从机读取广播地址后的第二个及后面的字节。</strong> 不能处理这些广播数据的从机通过不发送响应的方式忽略它。同样地，<strong>如果有一个或一个以上的从机发送响应，则主机就检测不到总线上其它没有响应的设备。</strong> 广播消息的含义总是定义在第二个字节。<br /><img src="65d333b522f92fae6584d6d5cccc4de9.jpeg" alt="" /></p><details><summary>以下内容需要的时候再看</summary><p>有两种可能情况：</p><ul><li><p>最低位“B”为0</p></li><li><p>最低位“B”为1</p></li><li><p>“B”为0，第二个字节包括以下定义：<br />0000 0110（06h）：复位并通过硬件写内容到从机的可编程部分。所有可以响应此类广播的从机，收到此两字节后，进行复位并进入它们地址的可编程部分。注意确保设备在加电后不会将SDA或SCL拉低，因为这些低电平会阻塞总线；<br />0000 0100（04h）：通过硬件写内容到从机的可编程部分，作用类似（06h），但设备不会复位；<br />0000 0000（00h）：这个不应该作为第二个字节用。<br />编程时序参考相应设备的DATASHEET。\</p></li><li><p>“B”为1，两字节广播定义为“硬件广播”。主机在编程后，可以发送既定的从机地址到总线上，构成两字节序列的“硬件广播”。主机可能并不知道总线上从机的地址，它只能通过硬件广播的方式，将自身地址通知给系统。<br />硬件广播的第二个字节的前七位包括主机的地址。总线上的智能设备如微控制器，读取此地址并接收主机发送的其它信息。如果主机也可以作为从机使用，则以上读取的主机地址实际上也就是（切换主从模式后的）从机地址。在系统中，一种可能是系统复位后设备由主机发送模式切换到从机接收模式，这时由系统主机先告诉硬件主机数据应送往的从机地址，这样当硬件主机发送数据时就可以直接向指定从机（地址）发送数据了。<br />如下所示：</p></li></ul></details><p><img src="e76a7cecc118d861220014786be3e39b.jpeg" alt="" /></p><h3 id="dual-address-acknowledged"><a class="markdownIt-Anchor" href="#dual-address-acknowledged"></a> Dual Address Acknowledged</h3><p>双地址确认。允许从机响应两个不同的地址。有啥用？？？？</p><h3 id="primary-slave-address"><a class="markdownIt-Anchor" href="#primary-slave-address"></a> Primary slave address</h3><p>从设备初始地址。不用填。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li>⭐⭐⭐<a href="https://blog.csdn.net/sternlycore/article/details/85759475">I2C详解（二）_i2c general call-CSDN博客</a>遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议</li><li><a href="https://blog.csdn.net/yangguoyu8023/article/details/71440688">IIC设备驱动程序（六）————SMBus协议-CSDN博客</a></li><li><a href="https://shequ.stmicroelectronics.cn/thread-571931-1-1.html">【STM32F030开发日志/评测/笔记】+（1）STM32F0处理器I2C时间配… - STM32团队 ST意法半导体中文论坛</a></li><li>⭐⭐⭐<a href="https://blog.csdn.net/as480133937/article/details/105259075">【STM32】HAL库 STM32CubeMX教程十二—IIC(读取AT24C02 )_hal iic-CSDN博客</a></li></ul>]]></content>
    
    
    <summary type="html">硬件iic在cubemx中的配置。</summary>
    
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="CubeMX配置功能" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/CubeMX%E9%85%8D%E7%BD%AE%E5%8A%9F%E8%83%BD/"/>
    
    
    <category term="STM32" scheme="https://blog.godmao.top/Tags/STM32/"/>
    
    <category term="CubeMX" scheme="https://blog.godmao.top/Tags/CubeMX/"/>
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="iic" scheme="https://blog.godmao.top/Tags/iic/"/>
    
  </entry>
  
  <entry>
    <title>通信协议：iic</title>
    <link href="https://blog.godmao.top/posts/55329/"/>
    <id>https://blog.godmao.top/posts/55329/</id>
    <published>2025-03-10T14:06:55.000Z</published>
    <updated>2025-03-14T12:54:30.000Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h2><p>iic作为当今嵌入式应用中最常见的串行通信协议之一<span class="spoiler">我愿将其与UART和SPI并称三幻神</span>，是对于嵌入式开发者是最基本的要求，因为老是会忘记iic协议的一些细节，故作记录。</p><h2 id="iic简介"><a class="markdownIt-Anchor" href="#iic简介"></a> iic简介</h2><p><strong>IIC(Inter－Integrated Circuit)总线</strong>是一种由NXP（原PHILIPS）公司开发的两线式串行总线，用于连接微控制器及其外围设备。<strong>是一种半双工同步的低速通信协议</strong>。多用于主控制器和从器件间的主从通信，在小数据量场合使用，传输距离短，任意时刻只能有一个主机等特性。<br /><br />IC使用两根信号线进行通信：一根时钟线SCL，一根数据线SDA。IIC将SCL处于高时SDA拉低的动作作为开始信号，SCL处于高时SDA拉高的动作作为结束信号；传输数据时，SDA在SCL低电平时改变数据，在SCL高电平时保持数据，每个SCL脉冲的高电平传递1位数据。</p><h2 id="主要特性"><a class="markdownIt-Anchor" href="#主要特性"></a> 主要特性</h2><ul><li>IC用2根信号线通信：串行数据线 SDA、串行时钟线 SCL；</li><li>IIC总线上所有器件的SDA、SCL引脚输出驱动都为<strong>开漏(OD) 结构</strong>，通过外接上拉电阻实现总线上所有节点SDA、SCL信号的线与逻辑关系；</li><li>总线上的所有设备通过软件寻址且具有唯一的地址（7位或10位）。7位“从机专用地址码”，其高4位为由生产厂家制定的设备类型地址，低3位为器件引脚定义地址（由使用者定义）；10位地址不常见；</li><li>任何时刻都只存在简单的主从关系，按数据传输的方向，主机可以是主发送器或主接收器；</li><li>支持多主机。在总线上存在多个主机时，通过冲突检测和仲裁机制防止多个主机同时发起数据传输时存在的冲突；</li><li>IIC总线上所有器件都具有“自动应答”功能，保证数据传输的正确性； <strong>主机和从机的区别在于对SCL的发送权，只有主机才能发送SCL</strong>；</li><li>IIC总线允许挂载最多的设备数量取决于总线上最大电容值，一般为400pf（Hs模式100pf）</li></ul><p>支持的传输速率：</p><table><thead><tr><th>模式</th><th>速度</th></tr></thead><tbody><tr><td>标准模式（Standard Mode）</td><td>100kb/s</td></tr><tr><td>快速模式（Fast Mode）</td><td>400kb/s</td></tr><tr><td>增强快速模式（Fast Mode Plus）</td><td>1Mb/s</td></tr><tr><td>高速模式（High Speed Mode）</td><td>3.4Mb/s</td></tr><tr><td>极速模式（Ultra-FastMode）</td><td>5Mb/s</td></tr></tbody></table><h2 id="硬件结构"><a class="markdownIt-Anchor" href="#硬件结构"></a> 硬件结构</h2><h3 id="总线结构"><a class="markdownIt-Anchor" href="#总线结构"></a> 总线结构</h3><p>IIC使用两根信号线进行通信，要求两根线都使用 <strong>开漏输出接上拉电阻</strong> 的配置，以此实现总线上所有节点SDA、SCL信号的<strong>线与</strong>逻辑关系。<br />Rp电阻的取值有一定的要求，太小会导致灌入电流过大，使’低’数据不稳定，甚至损坏端口；太大会导致信号上升缓慢，使得数据传输出错。在不同应用场景及供电电压下有不同的取值要求。<br /><img src="79b9189018381624841758e3ade6e477.png" alt="" /></p><h3 id="仲裁机制"><a class="markdownIt-Anchor" href="#仲裁机制"></a> 仲裁机制</h3><h4 id="开漏输出"><a class="markdownIt-Anchor" href="#开漏输出"></a> 开漏输出</h4><p>开漏输出回顾：当输入为高电平时，三级管导通，输出为低电平。输入为低电平，输出不确定，在这种情况下，如果使用强上拉，则可以输出高电平。开漏输出是实现”线与“的一种方案。</p><h4 id="线与"><a class="markdownIt-Anchor" href="#线与"></a> 线与</h4><p>多个开漏输出连接在一起时，只要有一个输入为低电平，那么总体表现为低电平（处于低电平的那个io口把vdd流向Vout的电流引走了）。<br /><img src="Snipaste_2025-03-11_20-01-18.png" alt="" /></p><p>“线与“使得总线上不会出现数据冲突，实现了总线的仲裁控制。总线的控制权会交给最后一个输出低电平的设备，其它设备（输出高）通过检测总线上的电平状态（状态低），对比与自己输出状态不一致，则自动退出对总线的控制请求，从而防止了总线上的数据冲突。</p><h2 id="时序逻辑"><a class="markdownIt-Anchor" href="#时序逻辑"></a> 🌟时序逻辑</h2><h3 id="数据有效性"><a class="markdownIt-Anchor" href="#数据有效性"></a> 数据有效性</h3><p>scl为高电平期间，为数据采集期，所以sda上的数据此时一定要保持稳定哦~<br /><img src="6c89c55012485f151df1a9fb48843d3f.jpeg" alt="" /></p><h3 id="开始与结束信号"><a class="markdownIt-Anchor" href="#开始与结束信号"></a> 开始与结束信号</h3><p>有设备想要sda总线控制权时，会主动把sda拉低。平时sda为高。</p><ul><li><strong>开始信号（START/S）：</strong> <strong>SCL为高时</strong>，SDA从高到低的跳变产生开始信号 。</li><li><strong>结束信号（STOP/P）  ：</strong> <strong>SCL为高时</strong>，SDA从低到高的跳变产生结束信号。</li><li><strong>重复开始信号（ReSTART/Sr）：</strong> 在结束时不给出STOP信号，而以一个时钟周期内再次给出开始信号作为替代。<br /><img src="f749a6ab4f928522a99db173fd504647.png" alt="" /></li></ul><h3 id="传输格式字节格式"><a class="markdownIt-Anchor" href="#传输格式字节格式"></a> 传输格式（字节格式）</h3><p>SDA数据线上的每个字节<strong>必须是8位</strong>，对于每次传输的<strong>字节数没有限制</strong>。每个字节（8位）数据传送完后紧跟着应答信号（ACK，第9位）。数据的先后顺序为：<strong>高位在前</strong> 。<br /><img src="d3bbca378362c28829cee243a8497ef7.png" alt="" /></p><h3 id="ack信号"><a class="markdownIt-Anchor" href="#ack信号"></a> ACK信号</h3><p>协议规定数据传输过程必须包含应答（ACK）。接收器通过应答告知发送的字节已被成功接收，之后发送器可以进行下一个字节的传输。所以主机产生数据传输过程用了9个时钟。发送器在应答时钟周期内释放对SDA总线的控制，这样 <strong>接收器</strong> 可以通过将SDA线拉低告知发送器：数据已被成功接收。(谁接收，谁发送应答信号)<span class="spoiler">发送端对接收端说：我他妈要给你发数据了，收到货他妈回复一下0</span><br />应答信号分为两种：</p><ol><li>当第9位(应答位)为 <strong>低电平</strong> 时，为 <strong>ACK</strong>  （Acknowledge）   信号</li><li>当第9位(应答位)为 <strong>高电平</strong> 时，为 <strong>NACK</strong>（Not Acknowledge）信号</li></ol><p>主机发送数据，从机接收时，ACK信号由从机发出。当在SCL第9位时钟高电平信号期间，如果SDA仍然保持高电平，则主机可以直接产生STOP条件终止以后的传输或者继续ReSTART开始一个新的传输 <span class="spoiler">此时主机发现事情不对，我他妈辛辛苦苦给你发的货你连句回应都没有，主机可以选择不发了，或者继续用爱发电发发发 大声发！来财，来~我是憋佬仔</span><br /><br />从机发送数据，主机读取数据时，ACK信号由主机给出。主机响应ACK表示还需要再接收数据，而当主机接收完想要的数据后，通过发送NACK告诉从机读取数据结束、释放总线。随后主机发送STOP命令，将总线释放，结束读操作。<span class="spoiler">从机这个fw，纯添狗级别的、麦当劳级别的、ATM级别的。主机叫一直叫从机爆金币，从机真就一直爆，榨干从机了就直接把他甩了他妈的</span></p><h3 id="7bit完整传输示意图"><a class="markdownIt-Anchor" href="#7bit完整传输示意图"></a> 7bit完整传输示意图</h3><p><img src="f313f22e0c7bc962ff6e9e5afc2bbc95.png" alt="" /></p><p>没错前7位是地址，发完地址发送读/写命令，然后发送端交出sda控制权，等待接收端的应答信号。如果从机没有给出ACK应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由master来决定如何处理（STOP或ReSTART）。</p><h3 id="从机发主机收的情况"><a class="markdownIt-Anchor" href="#从机发主机收的情况"></a> 从机发，主机收的情况</h3><p>主机对向从机读取数据时，方式同发送数据有所不同，要多一次通信过程。<br />主机需要先向从机发送一次信号，告诉从机”我要读取数据“，然后<strong>重开一次通信</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，等待从机主动返回数据。<br /><img src="Snipaste_2025-03-11_20-50-32.png" alt="" /></p><h3 id="10bit传输"><a class="markdownIt-Anchor" href="#10bit传输"></a> 10bit传输</h3><p>随着IIC设备日益增多，7位的从机地址逐渐不能满足使用，于是从机地址从7位扩充到了10位。7位和10位地址的设备可以共存于同一个I2C总线系统互不冲突，展现了良好的兼容性。<br />10-bit 地址的IIC设备需要 2-Byte 来传输从设备地址信息，所以采用了这样的设计：第一个字节为 11110 + 地址高两位(第10、9bit) + 读写控制位，第二个字节为从设备地址低8位，除此之外与7-bit设备相同。（因为 “1111 0xx” 为 IIC 中特地保留的16个特殊指令地址中的一个，所以7-bit设备不会响应该首字节的呼叫，只有10-bit设备会响应，从而实现良好兼容。<span class="spoiler">好样的，iic👍👍👍为你骄傲</span>）<br />直接贴图了<br />写<br /><img src="5569e1d0e47921103fe2d9d5b8ce83f9.jpeg" alt="" /><br />读<br /><img src="dee04bba6b887b740ab122eac9bc37bf.jpeg" alt="" /><br />注意第一帧都是write哦。</p><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ul><li>⭐⭐⭐<a href="https://blog.csdn.net/qq_39829913/article/details/104718185">基础通信协议之 IIC (I2C) 详细讲解_i2c通信的详细讲解-CSDN博客</a>遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议</li><li><a href="https://www.cnblogs.com/yuanqiangfei/p/15781416.html">二十、I2C总线仲裁机制 - 轻轻的吻 - 博客园</a></li><li><a href="https://zhuanlan.zhihu.com/p/638360051">GPIO推挽与开漏输出的“线与“特性 - 知乎</a></li></ul><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>重复启动信号（Repeated Start）是一种特殊的操作，<strong>它允许在不释放总线的情况下从写模式切换到读模式</strong>。这种方式可以避免总线被其他设备占用，或者防止主设备发送 STOP 信号后，其他设备试图接管总线。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">本篇讲解了iic通信协议。</summary>
    
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="通信协议" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="iic" scheme="https://blog.godmao.top/Tags/iic/"/>
    
    <category term="通信协议" scheme="https://blog.godmao.top/Tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>CubeMX配置功能系列：ADC（下）</title>
    <link href="https://blog.godmao.top/posts/55933/"/>
    <id>https://blog.godmao.top/posts/55933/</id>
    <published>2025-03-09T12:01:13.000Z</published>
    <updated>2025-03-12T06:50:28.000Z</updated>
    
    <content type="html"><![CDATA[<details><summary>版权信息</summary><p>:::warning</p><p>本文章遵循 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh-hans">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>:::</p></details><hr /><h2 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h2><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#1-%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F">1. 输入模式</a><ul><li><a href="#11-%E5%8D%95%E7%AB%AF%E8%BE%93%E5%85%A5">1.1. 单端输入</a></li><li><a href="#12-%E5%B7%AE%E5%88%86%E8%BE%93%E5%85%A5">1.2. 差分输入</a></li></ul></li><li><a href="#2-%E7%BB%A7%E7%BB%AD%E7%9C%8Bconfig%E9%83%A8%E5%88%86">2. 继续看config部分</a><ul><li><a href="#21-%E9%80%9A%E7%94%A8%E8%AE%BE%E7%BD%AE%E9%83%A8%E5%88%86">2.1. 通用设置部分：</a></li><li><a href="#22-adc-%E8%AE%BE%E7%BD%AE%E9%83%A8%E5%88%86">2.2. ADC 设置部分：</a><ul><li><a href="#221-clockpre">2.2.1. ClockPre…</a></li><li><a href="#222-resolusion">2.2.2. Resolusion</a></li><li><a href="#223-data-ali">2.2.3. Data Ali…</a></li><li><a href="#224-gain-com">2.2.4. Gain Com…</a></li><li><a href="#225-scan-conversion-mode">2.2.5. Scan Conversion Mode</a></li><li><a href="#226-end-of-conversion-selection">2.2.6. End Of Conversion Selection</a></li><li><a href="#227-low-powerautowait">2.2.7. Low Power Auto Wait</a></li><li><a href="#228-continuous-conversion-mode">2.2.8. Continuous Conversion Mode</a></li><li><a href="#229-discontinuous-conversion-mode">2.2.9. Discontinuous Conversion Mode</a></li><li><a href="#2210-dma-continuous-requests">2.2.10. DMA Continuous Requests</a></li><li><a href="#2211-overrun-behaviour">2.2.11. Overrun behaviour</a></li><li><a href="#2212-conversion-data-managerment-modeh7">2.2.12. Conversion Data Managerment Mode（H7）</a></li></ul></li><li><a href="#23-%E8%A7%84%E5%88%99%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%BC%8F">2.3. 规则转换模式</a><ul><li><a href="#231-enable-regular-conversions">2.3.1. Enable Regular Conversions</a></li><li><a href="#232-enable-regular-oversamping%E4%B8%8D%E5%B8%B8%E7%94%A8">2.3.2. Enable Regular Oversamping（不常用）</a></li><li><a href="#233-oversamping-right-shift%E4%B8%8D%E5%B8%B8%E7%94%A8">2.3.3. Oversamping Right Shift（不常用）</a></li><li><a href="#234-number-of-conversion">2.3.4. Number Of Conversion</a></li><li><a href="#235-external-trigger-conversion-soure%E8%A7%A6%E5%8F%91%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%A4%96%E9%83%A8%E6%9D%A5%E6%BA%90">2.3.5. External Trigger Conversion Soure（触发转换的外部来源）</a></li><li><a href="#236-external-trigger-conversion-edge%E8%A7%A6%E5%8F%91%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%A4%96%E9%83%A8%E6%B2%BF">2.3.6. External Trigger Conversion Edge（触发转换的外部沿）</a></li><li><a href="#237-rank">2.3.7. Rank</a></li><li><a href="#238-offset-number">2.3.8. Offset Number</a></li></ul></li><li><a href="#24-%E7%84%B6%E5%90%8E%E6%98%AF%E6%B3%A8%E5%85%A5%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%BC%8F">2.4. 然后是注入转换模式</a><ul><li><a href="#241-%E8%A7%84%E5%88%99%E9%80%9A%E9%81%93">2.4.1. 规则通道：</a></li><li><a href="#242-%E6%B3%A8%E5%85%A5%E9%80%9A%E9%81%93">2.4.2. 注入通道：</a></li></ul></li><li><a href="#25-%E6%9C%80%E5%90%8E%E6%98%AF%E5%8F%AF%E7%88%B1%E7%9A%84%E7%9C%8B%E9%97%A8%E5%B0%8F%E7%8B%97">2.5. 最后是可爱的看门小狗🥰~</a></li></ul></li><li><a href="#3-%E5%8F%82%E8%80%83%E5%87%BD%E6%95%B0">3. 参考函数</a></li><li><a href="#4-%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2">4. 参考博客</a></li></ul><h2 id="1-输入模式"><a class="markdownIt-Anchor" href="#1-输入模式"></a> 1. 输入模式</h2><p>我们打开cubemx的配置，配置通道时有如下选择：分别是差分输入和单端输入。<br /><img src="Snipaste_2025-03-09_19-30-43.png" alt="" /></p><h3 id="11-单端输入"><a class="markdownIt-Anchor" href="#11-单端输入"></a> 1.1. 单端输入</h3><p>单端输入方式优点就是简单，缺点是如果VIN受到干扰，由于GND电位始终是0V，所以最终采样值也会随着干扰而变化。采样值=VIN（叠加干扰值 ）- 0V</p><p>如图所示，单端输入只有一个输入引脚ADCIN，使用公共地GND作为电路的返回端，ADC的采样值=ADCIN电压-GND的电压(0V)。这种输入方式优点就是简单，缺点是如果vin受到干扰，由于GND电位始终是0V，所以最终ADC的采样值也会随着干扰而变化。<br /><img src="8c60645887a08582fd0cd8f9cba6b8da.png" alt="" /></p><h3 id="12-差分输入"><a class="markdownIt-Anchor" href="#12-差分输入"></a> 1.2. 差分输入</h3><p>差分受到的干扰是差不多的，输入的共模干扰，在输入时会被减掉，从而降低了干扰，缺点就是接线复杂一些。</p><p>差分信号 优点：易分辨小信号、抗干扰EMS强；缺点:双线</p><p>而差分输入比单端输入多了一根线，最终的ADC采样值=(ADCIN电压)-(ADCIN-电压)，由于通常这两根差分线会布在一起，所以他们受到的干扰是差不多的，输入共模干扰，在输入ADC时会被减掉，从而降低了干扰，缺点就是接线复杂一些。而且需要VIN+和VIN-两路反相的输入信号。</p><p>差分输入的是将两个输入端的差值作为信号，这样可以免去一些误差，比如你输入一个1V的信号可电源有偏差实际输入要大0.1.就可以用差分输入1V和2V一减就把两端共有的那0.1误差剪掉了。单端输入无法去除这类误差。</p><p><img src="Snipaste_2025-03-09_19-43-28.png" alt="" /></p><h2 id="2-继续看config部分"><a class="markdownIt-Anchor" href="#2-继续看config部分"></a> 2. 继续看config部分</h2><p><img src="Snipaste_2025-03-09_19-45-21.png" alt="" /><br /><img src="Snipaste_2025-03-09_19-45-32.png" alt="" /></p><h3 id="21-通用设置部分"><a class="markdownIt-Anchor" href="#21-通用设置部分"></a> 2.1. 通用设置部分：</h3><ul><li>当只启用1个ADC时，只能选择<strong>独立模式</strong>，如果使用双ADC并要求同步的话，则会有更多选择。双重ADC同步模式，两个ADC同时采集一个或多个通道，可以提高采样率。这个双ADC同步模式的选择先不作记录了！</li></ul><h3 id="22-adc-设置部分"><a class="markdownIt-Anchor" href="#22-adc-设置部分"></a> 2.2. ADC 设置部分：</h3><h4 id="221-clockpre"><a class="markdownIt-Anchor" href="#221-clockpre"></a> 2.2.1. ClockPre…</h4><p>时钟预分频，双时钟域架构。目的是让ADC达到稳定的工作频率<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>（异步时钟模式（Asynchronous clock mode，基于PLL2P时钟）同步时钟模式（Synchronous clock mode，基于AHB时钟）有些型号的单片机则是直接从时钟树专门分出了一个ADC时钟频率配置。<br /><img src="Snipaste_2025-03-09_20-30-53.png" alt="" /></p><h4 id="222-resolusion"><a class="markdownIt-Anchor" href="#222-resolusion"></a> 2.2.2. Resolusion</h4><p>分辨率。不再赘诉。请见上篇</p><h4 id="223-data-ali"><a class="markdownIt-Anchor" href="#223-data-ali"></a> 2.2.3. Data Ali…</h4><p>数据对齐。不再赘诉。请见上篇</p><h4 id="224-gain-com"><a class="markdownIt-Anchor" href="#224-gain-com"></a> 2.2.4. Gain Com…</h4><p>增益补偿：对所有转换后的数据进行增益补偿。每次转换后，数据根据增益补偿对采样后的数据进行变换。</p><h4 id="225-scan-conversion-mode"><a class="markdownIt-Anchor" href="#225-scan-conversion-mode"></a> 2.2.5. Scan Conversion Mode</h4><p>扫描模式。不再赘诉。请见上篇</p><h4 id="226-end-of-conversion-selection"><a class="markdownIt-Anchor" href="#226-end-of-conversion-selection"></a> 2.2.6. End Of Conversion Selection</h4><p>转换结束标志选择：指定转换结束后是否产生EOS中断或单次转换结束事件标志（EOC）。有End of single conversion（EOC） 与 End of sequence of conversion（EOS）两种选择。这两个事件会触发中断与DMA。<br /><br />在多通道转换过程中，如果选择了End of sequence of conversion，会在一组数据转换完成后发出EOS标志，如下图所示。如果不选，则不会置位该标志。<br /><img src="Snipaste_2025-03-09_20-42-09.png" alt="" /><br />选择EOS目的是等所有通道转换完毕后，产生中断后将全部数据取出来，或者使用DMA将全部数据取出来。</p><h4 id="227-low-power-auto-wait"><a class="markdownIt-Anchor" href="#227-low-power-auto-wait"></a> 2.2.7. Low Power Auto Wait</h4><p>低功耗自动延迟等待模式，可选参数为 ENABLE 和 DISABLE，当使能时，仅当一组内所有之前的数据已处理完毕时，才开始新的转换，适用于低频应用。<strong>该模式仅用于 ADC 的轮询模式，不可用于 DMA 以及中断。</strong></p><h4 id="228-continuous-conversion-mode"><a class="markdownIt-Anchor" href="#228-continuous-conversion-mode"></a> 2.2.8. Continuous Conversion Mode</h4><p>是否启用连续转换。不再赘诉。请见上篇 <strong>若想使用ADC+DMA的话，必须先使能连续转换模式</strong>。</p><h4 id="229-discontinuous-conversion-mode"><a class="markdownIt-Anchor" href="#229-discontinuous-conversion-mode"></a> 2.2.9. Discontinuous Conversion Mode</h4><p>间断模式，再赘诉一下。这里的不连续含义是指每次触发进行一个子组的转换，跟Continuous Conversion Mode的连续含义不一样。例如使能了该配置，该参数的下方就立马出现Number Of Discontinuous Conversions，如果它设为2，且ADC1使能了通道1，2，5，7，10，11的话，那么第一次触发ADC1采样时，就会采样通道1与通道2的值，再一次触发ADC1采样的话，就会采样通道5与通道7值，如此类推。值得注意的是，Continuous Conversion Mode与Discontinuous Conversion Mode不能同时使能，两者不能共存。</p><h4 id="2210-dma-continuous-requests"><a class="markdownIt-Anchor" href="#2210-dma-continuous-requests"></a> 2.2.10. DMA Continuous Requests</h4><p>DMA连续请求：指定 DMA 请求是否以一次性模式执行(当达到转换次数时，DMA 传输停止)或在连续模式下(DMA 传输无限制，无论转换的数量)。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><ul><li>不使能：在这种模式下，每次有新的转换数据可用时，ADC都会生成一个DMA传输请求，一旦DMA到达最后一个DMA传输，即使转换已经再次开始，ADC也会停止生成DMA请求，适合转换固定数量数据的情况。</li><li>使能：在这种模式下，每当数据寄存器中有新的转换数据可用时，即使DMA已经到达最后一次DMA传输，ADC也会生成DMA传输请求。这允许在循环模式下配置DMA来处理连续的模拟输入数据流。</li></ul><h4 id="2211-overrun-behaviour"><a class="markdownIt-Anchor" href="#2211-overrun-behaviour"></a> 2.2.11. Overrun behaviour</h4><p>溢出处理：用于配置ADC转换数据未及时读取，造成溢出时的处理。</p><ul><li>Overrun data preserved:保留旧数据，丢弃和丢失新的转换。</li><li>Overrun data overwritten:数据寄存器被最后一次转换的结果覆盖，之前未读的数据丢失<br /><img src="Snipaste_2025-03-09_21-17-16.png" alt="" /></li></ul><h4 id="2212-conversion-data-managerment-modeh7"><a class="markdownIt-Anchor" href="#2212-conversion-data-managerment-modeh7"></a> 2.2.12. Conversion Data Managerment Mode（H7）</h4><p>转换数据管理模式。不使用DMA的话，不使用DFSDM数字滤波器做后期处理的话，选择Regular Conversion data stored in DR register only即可。其实就是选择存放转换完成的模拟量数据的地方而已。</p><h3 id="23-规则转换模式"><a class="markdownIt-Anchor" href="#23-规则转换模式"></a> 2.3. 规则转换模式</h3><h4 id="231-enable-regular-conversions"><a class="markdownIt-Anchor" href="#231-enable-regular-conversions"></a> 2.3.1. Enable Regular Conversions</h4><p>使能规则转换。使能它才能采集各个通道上的模拟量。</p><h4 id="232-enable-regular-oversamping不常用"><a class="markdownIt-Anchor" href="#232-enable-regular-oversamping不常用"></a> 2.3.2. Enable Regular Oversamping（不常用）</h4><p>使能规则过采样。<br /><img src="Snipaste_2025-03-10_14-20-12.png" alt="" /></p><h4 id="233-oversamping-right-shift不常用"><a class="markdownIt-Anchor" href="#233-oversamping-right-shift不常用"></a> 2.3.3. Oversamping Right Shift（不常用）</h4><p>过采样右移。<strong>过采样器能将累加的采样值进行右移</strong>。有什么用？比如过采样设置15，那么将采集16个值进行累加。接着配置右移动4位的话，相当于将刚才的累加值除以16，得到平均值。不需要在程序里求平均了。当然，如果大家喜欢在程序里求平均值也是可以的。</p><h4 id="234-number-of-conversion"><a class="markdownIt-Anchor" href="#234-number-of-conversion"></a> 2.3.4. Number Of Conversion</h4><p>转换通道数。根据ADC配置的通道数来选择。有多少转换通道就设置几。</p><h4 id="235-external-trigger-conversion-soure触发转换的外部来源"><a class="markdownIt-Anchor" href="#235-external-trigger-conversion-soure触发转换的外部来源"></a> 2.3.5. External Trigger Conversion Soure（触发转换的外部来源）</h4><p>选择触发转换的来源：</p><ul><li>Regular Conversion launched by software （软件触发）</li><li>Timer 1 Capture Compare 1 event （定时器1捕获比较事件1）</li><li>… （各种定时器触发来源）<br />一般使用软件触发就行。</li></ul><h4 id="236-external-trigger-conversion-edge触发转换的外部沿"><a class="markdownIt-Anchor" href="#236-external-trigger-conversion-edge触发转换的外部沿"></a> 2.3.6. External Trigger Conversion Edge（触发转换的外部沿）</h4><p>选择定时器触发时，需要进一步选择触发的沿。选择软件触发时，该项为None。<br />Trigger detection on the rising edge（上升沿）<br />Trigger detection on the falling edge（下降沿）<br />Trigger detection on the rising and falling edge（上升与下降沿）</p><h4 id="237-rank"><a class="markdownIt-Anchor" href="#237-rank"></a> 2.3.7. Rank</h4><p><img src="Snipaste_2025-03-10_14-29-51.png" alt="" /></p><ul><li>Channel：选择采样的通道。</li><li>Sampling Time：采样时间。配置多少个时钟周期，建议采样时间尽量长一点，以获得较高的准确度。总的转换时间=采样时间+逐次逼近时间（TSAR）。<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><br />逐次逼近参考时间：请查阅相关数据手册。<br />这是一个参考：<br /><img src="Snipaste_2025-03-10_14-31-52.png" alt="" /></li></ul><h4 id="238-offset-number"><a class="markdownIt-Anchor" href="#238-offset-number"></a> 2.3.8. Offset Number</h4><p>偏移序号？？不懂。</p><h3 id="24-然后是注入转换模式"><a class="markdownIt-Anchor" href="#24-然后是注入转换模式"></a> 2.4. 然后是注入转换模式</h3><p>我们看到，在选择了ADC的相关通道引脚之后，在模拟至数字转换器中有两个通道：注入通道与规则通道。规则通道至多16个，注入通道至多4个。</p><h4 id="241-规则通道"><a class="markdownIt-Anchor" href="#241-规则通道"></a> 2.4.1. 规则通道：</h4><p>规则通道相当于你正常运行的程序，看它的名字就可以知道，很规矩，就是正常执行程序。</p><h4 id="242-注入通道"><a class="markdownIt-Anchor" href="#242-注入通道"></a> 2.4.2. 注入通道：</h4><p>注入通道可以打断规则通道，听它的名字就知道不安分，如果在规则通道转换过程中，有注入通道进行转换，那么就要先转换完注入通道，等注入通道转换完成后，再回到规则通道的转换流程。类似于中断。<br /><img src="Snipaste_2025-03-10_14-43-22.png" alt="" /></p><h3 id="25-最后是可爱的看门小狗~"><a class="markdownIt-Anchor" href="#25-最后是可爱的看门小狗~"></a> 2.5. 最后是可爱的看门小狗🥰~</h3><p>当被ADC转换的模拟电压值低于低阈值或高于高阈值时，便会产生中断。阈值的高低值由ADC_LTR和ADC_HTR配置。<br />可以防止读取到的电压值超量程或者低于量程，也可以监控CPU温度，防止温度过高，反正是用处多多。</p><h2 id="3-参考函数"><a class="markdownIt-Anchor" href="#3-参考函数"></a> 3. 参考函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启ADC 3种模式 ( 轮询模式 中断模式 DMA模式 )</span></span><br><span class="line">HAL_ADC_Start(&amp;hadcx);       <span class="comment">//轮询模式开启ADC</span></span><br><span class="line">HAL_ADC_Start_IT(&amp;hadcx);       <span class="comment">//中断轮询模式开启ADC</span></span><br><span class="line">HAL_ADC_Start_DMA(&amp;hadcx);       <span class="comment">//DMA模式开启ADC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭ADC 3种模式 ( 轮询模式 中断模式 DMA模式 )</span></span><br><span class="line">HAL_ADC_Stop();</span><br><span class="line">HAL_ADC_Stop_IT();</span><br><span class="line">HAL_ADC_Stop_DMA();</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADC校准函数 ：F4系列不支持</span></span><br><span class="line">HAL_ADCEx_Calibration_Start(&amp;hadcx);      </span><br><span class="line"></span><br><span class="line"><span class="comment">//读取ADC转换值</span></span><br><span class="line">HAL_ADC_GetValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待转换结束函数.第一个参数为哪个ADC,第二个参数为最大等待时间</span></span><br><span class="line">HAL_ADC_PollForConversion(&amp;hadc1, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADC中断回调函数</span></span><br><span class="line">HAL_ADC_ConvCpltCallback();</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换完成后回调，DMA模式下DMA传输完成后调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//规则通道及看门狗配置</span></span><br><span class="line">HAL_ADC_ConfigChannel(); <span class="comment">//配置规则组通道</span></span><br><span class="line">HAL_ADC_AnalogWDGConfig();</span><br></pre></td></tr></table></figure><h2 id="4-参考博客"><a class="markdownIt-Anchor" href="#4-参考博客"></a> 4. 参考博客</h2><p>有星星的是我觉得写的很好的博客。</p><ul><li>⭐⭐⭐<a href="https://blog.csdn.net/wallace89/article/details/117048846">STM32H743-梳理ADC模数转换器在CubeMX上的配置_overrun behaviour-CSDN博客</a>遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议</li><li>⭐⭐⭐<a href="https://blog.csdn.net/demonneverhunts/article/details/135155881">STM32CubeIde ADC配置详解_end of conversion selection-CSDN博客</a>遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议</li><li>⭐⭐⭐<a href="https://blog.csdn.net/as480133937/article/details/99627062">【STM32】HAL库 STM32CubeMX教程九—ADC_cubemx adc-CSDN博客</a></li><li><a href="https://blog.csdn.net/chenhuanqiangnihao/article/details/122086308">ADC的单端输入、伪差分输入、差分输入区别？_差分adc-CSDN博客</a></li></ul><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>ADC的工作频率需要查阅相关数据手册,工作频率太高会导致转换无法完成。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>在连续模式下，DMA 必须配置为循环模式。否则，当达到 DMA 缓冲区最大指针时将触发溢出。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>时间可以用ADC时钟周期来衡量。例如12bitADC的逐次逼近时间为12.5个ADC时钟周期 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">本篇介绍了STM32 ADC的相关配置。</summary>
    
    
    
    <category term="嵌入式" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="CubeMX配置功能" scheme="https://blog.godmao.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/CubeMX%E9%85%8D%E7%BD%AE%E5%8A%9F%E8%83%BD/"/>
    
    
    <category term="STM32" scheme="https://blog.godmao.top/Tags/STM32/"/>
    
    <category term="CubeMX" scheme="https://blog.godmao.top/Tags/CubeMX/"/>
    
    <category term="ADC" scheme="https://blog.godmao.top/Tags/ADC/"/>
    
    <category term="嵌入式" scheme="https://blog.godmao.top/Tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
</feed>
